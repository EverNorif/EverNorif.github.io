<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动手学深度学习(1)-预备知识</title>
    <link href="/2023/08/18/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-1-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/08/18/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-1-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="线性代数补充">线性代数补充</h1><h2 id="向量点积-dot-product">向量点积 Dot Product</h2><p>给定两个向量，它们之间的点积（dotproduct）是对应位置元素相乘并相加：</p><p><span class="math display">\[\overrightarrow{a} \cdot \overrightarrow{b} = \sum_{i=1}^{n}a_ib_i =a_1b_1 + a_2b_2 + ...+a_nb_n\]</span></p><p>对应Pytorch中的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b = torch.arange(<span class="hljs-number">5</span>), torch.arange(<span class="hljs-number">5</span>)<br><br>result = torch.dot(a, b)<br></code></pre></td></tr></table></figure><h2 id="矩阵-向量积-matrix-vector-product">矩阵-向量积 Matrix-VectorProduct</h2><p>给定一个<span class="math inline">\(m \times n\)</span>的矩阵<spanclass="math inline">\(A\)</span>和一个<spanclass="math inline">\(n\)</span>维向量<spanclass="math inline">\(x\)</span>，矩阵和向量的乘积有如下计算方式：</p><p><span class="math display">\[Ax =\begin{bmatrix}a_1^T \\a_2^T \\... \\a_m^T \\\end{bmatrix} x=\begin{bmatrix}a_1^T x \\a_2^T x \\... \\a_m^T x \\\end{bmatrix}\]</span></p><p>矩阵向量积<span class="math inline">\(Ax\)</span>是一个长度为<spanclass="math inline">\(m\)</span>的列向量，其中第<spanclass="math inline">\(i\)</span>个元素是向量点积<spanclass="math inline">\(a_i^Tx\)</span>。</p><p>我们可以把一个矩阵<span class="math inline">\(A \in R^{m \timesn}\)</span>乘法看作一个从<span class="math inline">\(R^n\)</span>到<spanclass="math inline">\(R^m\)</span>向量的转换。这些转换是非常有用的，例如可以用方阵的乘法来表示旋转。</p><h2 id="矩阵乘法-matrix-matrix-multiplication">矩阵乘法 Matrix-MatrixMultiplication</h2><p>矩阵乘法即遵循前给行，后给列的计算方式，是矩阵-向量积的扩展。</p><p>注意，矩阵乘法不应该与Hadamard积混淆。Hadamard积（Hadamardproduct）表示的是矩阵按照对应位置元素进行相乘，数学符号为<spanclass="math inline">\(\odot\)</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a = torch.arange(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 矩阵乘法</span><br>a @ a.T<br>a.matmul(a.T)<br><br><span class="hljs-comment"># 按元素相乘 Hadamard积</span><br>a * a<br>a.mul(a)<br></code></pre></td></tr></table></figure><h2 id="范数">范数</h2><p>简单地说，向量的范数是用来衡量一个向量有多大的。向量的范数并不局限于某一种计算方式，只要一个函数<spanclass="math inline">\(f\)</span>能够将向量映射到标量，并且满足如下性质，那么我们就可以称这个函数是向量的范数。</p><p><span class="math display">\[\begin{aligned}&amp;1.[缩放] \ f(\alpha x) = |\alpha|f(x) \\&amp;2.[三角不等式]\  f(x+y) \le f(x) + f(y) \\&amp;3.[非负]\  f(x) \ge 0\\&amp;4.范数最小为0，当且仅当向量全由0组成\end{aligned}\]</span></p><p>自然有很多函数都能够满足这些要求，在这些函数或者称为范数中，有一些常用的特殊范数，包括<spanclass="math inline">\(L_2\)</span>范数、<spanclass="math inline">\(L_1\)</span>范数、<spanclass="math inline">\(L_p\)</span>范数等。</p><p><span class="math display">\[\begin{aligned}&amp;L_1范数: ||x||_1 = \sum_{i=1}^n |x_i|\\&amp;L_2范数: ||x||_2 = ||x|| = \sqrt{\sum_{i=1}^{n}x_i^2} \\&amp;L_p范数: ||x||_p = (\sum_{i=1}^n |x_i|^p)^{1-p}\\\end{aligned}\]</span></p><p>在Pytorch中，这些范数可以通过下面的方式进行计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">data = torch.tensor([<span class="hljs-number">3.0</span>, -<span class="hljs-number">4.0</span>])<br><br><span class="hljs-comment"># L2范数</span><br>torch.norm(data)<br><span class="hljs-comment"># L1范数</span><br>torch.<span class="hljs-built_in">abs</span>(data).<span class="hljs-built_in">sum</span>()<br></code></pre></td></tr></table></figure><p>类似于向量的<span class="math inline">\(L_2\)</span>范数，矩阵<spanclass="math inline">\(X \in R^{m \timesn}\)</span>的Frobenius范数是矩阵元素平方和的平方根：</p><p><span class="math display">\[||X||_F = \sqrt{\sum_{i=1}^{m}\sum_{j=1}^{n}x_{ij}^{2}}\]</span></p><h1 id="导数计算">导数计算</h1><h2 id="函数推广">函数推广</h2><p>我们最熟悉的函数应该是<span class="math inline">\(y =f(x)\)</span>的格式，这里的函数<spanclass="math inline">\(f(x)\)</span>接受一个标量<spanclass="math inline">\(x\)</span>，输出另一个标量<spanclass="math inline">\(y\)</span>。在线性代数里面我们引入了向量，矩阵等，于是函数也可以对应推广到标量、向量和矩阵版本。针对函数的类型和输入的类型，可以分为下面几类。</p><blockquote><p>理解核心在于牢牢把握<spanclass="math inline">\(f\)</span>的输出是一个标量，这样就可以清楚不同类型函数+不同类型输入的计算逻辑以及形状。</p></blockquote><h3 id="标量function">标量function</h3><p>标量function称为实值标量函数，输出是一个标量，也是最基本的函数，使用符号<spanclass="math inline">\(f\)</span>表示。</p><p>input可以是一个标量，例如：</p><p><span class="math display">\[f(x) = ax+b\]</span></p><p>input可以是一个向量，例如：</p><p><span class="math display">\[设\mathbf{x} = [x_1, x_2, x_3]^T \\f(\mathbf{x}) = ax_1 + bx_2 + cx_3\]</span></p><p>input可以是一个矩阵，例如：</p><p><span class="math display">\[设 \mathbf{X}_{3 \times 2} = (x_{ij})_{i=1,j=1}^{3,2} \\f(\mathbf{X}) = a_1x_{11} + a_2x_{12} + a_3x_{13} + a_4x_{21} +a_5x_{22} + a_6x_{23}\]</span></p><h3 id="向量function">向量function</h3><p>向量function称为实向量函数，输出是一个向量，使用符号<spanclass="math inline">\(\mathbf{f}\)</span>表示，例如有：</p><p><span class="math display">\[\mathbf{f}_{3\times 1} =\begin{bmatrix}f_1\\f_2\\f_3\end{bmatrix}\]</span></p><p>input可以是一个标量，例如：</p><p><span class="math display">\[\mathbf{f}_{3\times 1}(x) =\begin{bmatrix}f_1(x)\\f_2(x)\\f_3(x)\end{bmatrix} =\begin{bmatrix}a_1x+b_1\\a_2x+b_2\\a_3x+b_3\end{bmatrix}\]</span></p><p>input可以是一个向量，例如：</p><p><span class="math display">\[设\mathbf{x} = [x_1, x_2, x_3]^T \\\mathbf{f}_{3\times 1}(\mathbf{x}) =\begin{bmatrix}f_1(\mathbf{x})\\f_2(\mathbf{x})\\f_3(\mathbf{x})\end{bmatrix} =\begin{bmatrix}a_1x_1+b_1x_2+c_1x_3\\a_2x_1+b_2x_2+c_2x_3\\a_3x_1+b_3x_2+c_3x_3\\\end{bmatrix}\]</span></p><p>input可以是一个矩阵，例如：</p><p><span class="math display">\[设 \mathbf{X}_{3 \times 2} = (x_{ij})_{i=1,j=1}^{3,2} \\\mathbf{f}_{3\times 1}(\mathbf{X}) =\begin{bmatrix}f_1(\mathbf{X})\\f_2(\mathbf{X})\\f_3(\mathbf{X})\end{bmatrix} =\begin{bmatrix}a_1x_{11} + a_2x_{12} + a_3x_{13} + a_4x_{21} + a_5x_{22} + a_6x_{23} \\b_1x_{11} + b_2x_{12} + b_3x_{13} + b_4x_{21} + b_5x_{22} + b_6x_{23} \\c_1x_{11} + c_2x_{12} + c_3x_{13} + c_4x_{21} + c_5x_{22} + c_6x_{23} \\\end{bmatrix}\]</span></p><h3 id="矩阵function">矩阵function</h3><p>矩阵function称为实矩阵函数，输出是一个矩阵，使用符号<spanclass="math inline">\(\mathbf{F}\)</span>表示，例如有：</p><p><span class="math display">\[\mathbf{F}_{3\times 2} =\begin{bmatrix}f_{11} &amp; f_{12} \\f_{21} &amp; f_{22} \\f_{31} &amp; f_{32} \\\end{bmatrix} \\\]</span></p><p>input可以是一个标量，例如：</p><p><span class="math display">\[\mathbf{F}_{3\times 2}(x) =\begin{bmatrix}f_{11}(x) &amp; f_{12}(x) \\f_{21}(x) &amp; f_{22}(x) \\f_{31}(x) &amp; f_{32}(x) \\\end{bmatrix} \\\]</span></p><p>input可以是一个向量，例如：</p><p><span class="math display">\[设\mathbf{x} = [x_1, x_2, x_3]^T \\\mathbf{F}_{3\times 2}(\mathbf{x}) =\begin{bmatrix}f_{11}(\mathbf{x}) &amp; f_{12}(\mathbf{x}) \\f_{21}(\mathbf{x}) &amp; f_{22}(\mathbf{x}) \\f_{31}(\mathbf{x}) &amp; f_{32}(\mathbf{x}) \\\end{bmatrix} \\\]</span></p><p>input可以是一个矩阵，例如：</p><p><span class="math display">\[设 \mathbf{X}_{3 \times 2} = (x_{ij})_{i=1,j=1}^{3,2} \\\mathbf{F}_{3\times 2}(\mathbf{X}) =\begin{bmatrix}f_{11}(\mathbf{X}) &amp; f_{12}(\mathbf{X}) \\f_{21}(\mathbf{X}) &amp; f_{22}(\mathbf{X}) \\f_{31}(\mathbf{X}) &amp; f_{32}(\mathbf{X}) \\\end{bmatrix} \\\]</span></p><p>总结来说可以得到如下的表格：</p><table><thead><tr class="header"><th>function</th><th>标量input</th><th>向量input</th><th>矩阵input</th></tr></thead><tbody><tr class="odd"><td>实值标量函数</td><td><span class="math inline">\(f(x)\)</span></td><td><span class="math inline">\(f(\mathbf{x})\)</span></td><td><span class="math inline">\(f(\mathbf{X})\)</span></td></tr><tr class="even"><td>实向量函数</td><td><span class="math inline">\(\mathbf{f}(x)\)</span></td><td><span class="math inline">\(\mathbf{f}(\mathbf{x})\)</span></td><td><span class="math inline">\(\mathbf{f}(\mathbf{X})\)</span></td></tr><tr class="odd"><td>实矩阵函数</td><td><span class="math inline">\(\mathbf{F}(x)\)</span></td><td><span class="math inline">\(\mathbf{F}(\mathbf{x})\)</span></td><td><span class="math inline">\(\mathbf{F}(\mathbf{X})\)</span></td></tr></tbody></table><h2 id="矩阵求导以及相关布局">矩阵求导以及相关布局</h2><p>矩阵求导的本质实际上就是function中的每个<spanclass="math inline">\(f\)</span>分别对input中的每个元素逐个求偏导，只不过写成了向量、矩阵形式而已。例如考虑实值标量函数，input为向量，即<spanclass="math inline">\(f(\mathbf{x}_{n\times 1})\)</span>，则有：</p><p><span class="math display">\[\frac{\partial f(\mathbf{x})}{\partial \mathbf{x}_{n\times 1}} =\begin{bmatrix}\frac{\partial f}{\partial x_1} \\\frac{\partial f}{\partial x_2} \\... \\\frac{\partial f}{\partial x_n}\end{bmatrix} \\\]</span></p><p>上面我们将结果写成了列向量的形式，当然也可以写成行向量的形式，行列向量的形式互为转置。</p><p><span class="math display">\[\frac{\partial f(\mathbf{x})}{\partial \mathbf{x}_{n\times 1}} =[\frac{\partial f}{\partial x_1}\frac{\partial f}{\partial x_2}...\frac{\partial f}{\partial x_n}]\]</span></p><p>再考虑向量function，同时input也是向量，即<spanclass="math inline">\(\mathbf{f}_{m\times1}(\mathbf{x}_{n\times1})\)</span>，其中function中有<spanclass="math inline">\(m\)</span>个<spanclass="math inline">\(f\)</span>，input中有<spanclass="math inline">\(n\)</span>个元素。进行求导就可以产生<spanclass="math inline">\(m\times n\)</span>个结果。这<spanclass="math inline">\(m \timesn\)</span>个结果如何排列，是写成行向量还是列向量，则对应矩阵求导结果的相关布局。</p><p>布局分为分子布局和分母布局。</p><p>分子布局指的是分子<code>f</code>是列向量形式，分母<code>x</code>是行向量形式：</p><p><span class="math display">\[\frac{\partial \mathbf{f}_{m\times 1}}{\partial \mathbf{x}_{n \times 1}}=\begin{bmatrix}\frac{\partial f_1}{\partial \mathbf{x}_{n \times 1}} \\\frac{\partial f_2}{\partial \mathbf{x}_{n \times 1}} \\... \\\frac{\partial f_m}{\partial \mathbf{x}_{n \times 1}} \\\end{bmatrix}=\begin{bmatrix}\frac{\partial f_1}{\partial x_{1}}&amp; \frac{\partial f_1}{\partial x_{2}}&amp; ...&amp; \frac{\partial f_1}{\partial x_{n}}\\\frac{\partial f_2}{\partial x_{1}}&amp; \frac{\partial f_2}{\partial x_{2}}&amp; ...&amp; \frac{\partial f_2}{\partial x_{n}}\\... \\\frac{\partial f_m}{\partial x_{1}}&amp; \frac{\partial f_m}{\partial x_{2}}&amp; ...&amp; \frac{\partial f_m}{\partial x_{n}}\\\end{bmatrix} \\\]</span></p><p>分母布局指的是分母<code>x</code>是列向量形式，分子<code>f</code>是行向量形式：</p><p><span class="math display">\[\frac{\partial \mathbf{f}_{m\times 1}}{\partial \mathbf{x}_{n \times 1}}=\begin{bmatrix}\frac{\partial \mathbf{f}_{m \times 1}}{\partial x_1} \\\frac{\partial \mathbf{f}_{m \times 1}}{\partial x_2} \\... \\\frac{\partial \mathbf{f}_{m \times 1}}{\partial x_n} \\\end{bmatrix}=\begin{bmatrix}\frac{\partial f_{1}}{\partial x_1}&amp; \frac{\partial f_{2}}{\partial x_1}&amp; ..&amp; \frac{\partial f_{m}}{\partial x_1}\\\frac{\partial f_{1}}{\partial x_2}&amp; \frac{\partial f_{2}}{\partial x_2}&amp; ..&amp; \frac{\partial f_{m}}{\partial x_n}\\... \\\frac{\partial f_{1}}{\partial x_1}&amp; \frac{\partial f_{2}}{\partial x_2}&amp; ..&amp; \frac{\partial f_{m}}{\partial x_n}\\\end{bmatrix} \\\]</span></p><p>使用哪种布局并没有严格的要求，只需要前后统一即可。不过无论使用何种布局，<spanclass="math inline">\(\mathbf{f}_{m\times1}(\mathbf{x}_{n\times1})\)</span>的导数都是一个二维矩阵，而对于更高维度的矩阵函数，或者输入是矩阵，同样也可以这样分析。此时假设矩阵input的维度为<spanclass="math inline">\((a,b)\)</span>，那么input中的<spanclass="math inline">\(n\)</span>个元素就可以从第一个维度便利，看作是<spanclass="math inline">\(a\)</span>个向量，然后依次进行分析，进行推广。</p><p>假设此时我们使用分子布局，对于矩阵求导结果的维度则有如下结论：</p><table><thead><tr class="header"><th>function</th><th>dim</th><th>标量input</th><th>向量input</th><th>矩阵input</th></tr></thead><tbody><tr class="odd"><td>dim</td><td></td><td><span class="math inline">\(x(1,)\)</span></td><td><span class="math inline">\(\mathbf{x}(n,1)\)</span></td><td><span class="math inline">\(\mathbf{X}(n,k)\)</span></td></tr><tr class="even"><td>标量function</td><td><span class="math inline">\(y(1,)\)</span></td><td><span class="math inline">\(\partial y/\partial x(1,)\)</span></td><td><span class="math inline">\(\partial y/\partial\mathbf{x}(1,n)\)</span></td><td><span class="math inline">\(\partial y/\partial \mathbf{X}(k,n)\)</span></td></tr><tr class="odd"><td>向量function</td><td><span class="math inline">\(\mathbf{y}(m,1)\)</span></td><td><span class="math inline">\(\partial \mathbf{y}/\partialx(m,1)\)</span></td><td><span class="math inline">\(\partial \mathbf{y}/\partial\mathbf{x}(m,n)\)</span></td><td><span class="math inline">\(\partial \mathbf{y}/\partial\mathbf{X}(m, k, n)\)</span></td></tr><tr class="even"><td>矩阵function</td><td><span class="math inline">\(\mathbf{Y}(m,l)\)</span></td><td><span class="math inline">\(\partial \mathbf{Y}/\partial x(m,l)\)</span></td><td><span class="math inline">\(\partial \mathbf{Y}/\partial\mathbf{x}(m, l, n)\)</span></td><td><span class="math inline">\(\partial \mathbf{Y}/\partial\mathbf{X}(m, l, k, n)\)</span></td></tr></tbody></table><p>这里需要注意的是，如果后续没有特别说明，本人笔记中矩阵求导结果默认都使用分子布局，即分子<code>f</code>为列向量形式，分母<code>x</code>为行向量形式。</p><h1 id="自动求导">自动求导</h1><p>机器学习中非常常用的优化算法是梯度下降法，它的实现关键在于梯度的计算。其中，也会涉及到矩阵求导。下面主要介绍如何进行矩阵导数的计算。</p><p>首先回顾标量函数，我们有标量链式法则：</p><p><span class="math display">\[y=f(u),u=g(x),则 \frac{\partial y}{\partial x} = \frac{\partialy}{\partial u} \frac{\partial u}{\partial x}\]</span></p><p>链式法则同样可以推广到向量和矩阵，不过特别需要注意各个阶段的形状：</p><p><span class="math display">\[\begin{aligned}\frac{\partial y}{\partial \mathbf{x}} &amp;= \frac{\partial y}{\partialu} \frac{\partial u}{\partial \mathbf{x}} \\(1,n)&amp;=(1,)(1,n) \\\frac{\partial y}{\partial \mathbf{x}} &amp;= \frac{\partial y}{\partial\mathbf{u}} \frac{\partial \mathbf{u}}{\partial \mathbf{x}} \\(1,n)&amp;=(1,k)(k,n) \\\frac{\partial \mathbf{y}}{\partial \mathbf{x}} &amp;= \frac{\partial\mathbf{y}}{\partial \mathbf{u}} \frac{\partial \mathbf{u}}{\partial\mathbf{x}} \\(m,n)&amp;=(m,k)(k,n) \\\end{aligned}\]</span></p><p>有了推广的链式法则，理论上我们可以进行任何函数的求导。但是神经网络通常具有非常深度的结构，手动进行链式法则求导是比较困难的，因此需要借助自动求导。</p><p>自动求导指的是计算一个函数在指定值上的导数，自动求导与符号求导和数值求导不同，符号求导指的是计算出导数的表达式，然后带入特定值直接计算导数值；数值求导指的是利用导数的定义，使用特定值附近差值的极限来计算导数值。</p><p>自动求导的思想实际上就是链式法则。对于导数<spanclass="math inline">\(\partial y / \partial x\)</span>，有：</p><p><span class="math display">\[\frac{\partial y}{\partial x} = \frac{\partial y}{\partial u_n}\frac{\partial u_n}{\partial u_{n-1}} ... \frac{\partial u_2}{\partialu_1}\frac{\partial u_1}{\partial x}\]</span></p><p>通过这个式子，我们可以计算在指定值上的导数。计算方式有两种，分别对应自动求导的两种模式，正向累积和反向累积（其中反向累积就是大名鼎鼎的反向传播BackPropagation，反向传播是用来计算梯度的一种方式）</p><p><span class="math display">\[\begin{aligned}正向累积: \frac{\partial y}{\partial x} = \frac{\partial y}{\partialu_n} (\frac{\partial u_n}{\partial u_{n-1}}( ... (\frac{\partialu_2}{\partial u_1}\frac{\partial u_1}{\partial x})))\\反向累积:\frac{\partial y}{\partial x} = (((\frac{\partial y}{\partialu_n} \frac{\partial u_n}{\partial u_{n-1}}) ... )\frac{\partialu_2}{\partial u_1})\frac{\partial u_1}{\partial x})\\\end{aligned}\]</span></p><p>之后，我们再引入计算图的概念。简单来说，计算图就是将一个计算分解成多步操作，形成一个类似无环图的结构。考虑如下计算图的构造，整个计算图自底向上执行的过程实际上就是计算过程：</p><img src="/2023/08/18/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-1-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E5%9B%BE.png" class="" title="计算图"><p>这里我们主要介绍反向累积的计算过程。可以发现，如果结合链式法则，实际上计算图中的每个非叶子节点就是一步计算，可以对应到链式法则中的一次导数计算。</p><img src="/2023/08/18/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-1-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/%E5%8F%8D%E5%90%91%E7%B4%AF%E7%A7%AF.png" class="" title="反向累积"><p>那么为了计算整个导数，我们可以反向执行计算图。即从上到下依次计算各个节点的导数值。举例来说，为了计算<spanclass="math inline">\(\partial z / \partial b =2b\)</span>，我们需要知道b的值，即该节点计算过程中的中间结果。</p><p>于是整个反向累积的过程实际上分为两个过程：</p><ul><li>正向过程：自底向上的原式计算过程，需要存储中间结果</li><li>反向过程：自顶向下的导数计算过程，利用存储的中间结果进行导数计算</li></ul><p>如果假设操作子数目为n的话，反向累积的是时间复杂度为<spanclass="math inline">\(O(n)\)</span>，通常可以认为正向和反向的代价类似；空间复杂度为<spanclass="math inline">\(O(n)\)</span>，因为需要存储正向过程中的所有中间结果。</p><p>在Pytroch中，即利用类似的原理完成自动求导。首先进行数据准备。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br>x = torch.arange(<span class="hljs-number">4.0</span>) <span class="hljs-comment"># tensor([0., 1., 2., 3.])</span><br><span class="hljs-comment"># 如果要存储梯度，那么需要开启选项</span><br>x.requires_grad_(<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 也可以在初始化的时候给定该选项 </span><br><span class="hljs-comment"># 等价于x = torch.arange(4.0,requires_grad=True)</span><br>x.grad <span class="hljs-comment">#默认值是None</span><br></code></pre></td></tr></table></figure><p>假设我们现在计算<spanclass="math inline">\(\mathbf{x}\)</span>的点积，即：</p><p><span class="math display">\[y = \mathbf{x} \cdot \mathbf{x} =[x_1^2, x_2^2 ,x_3^2, x_4^2]\]</span></p><p>我们可以手动进行符号求导，即</p><p><span class="math display">\[\frac{\partial y}{\partial \mathbf{x}} = [2x_1, 2x_2, 2x_3,2x_4]\]</span></p><p>在Pytroch中，可以通过下面的方式自动计算梯度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先构造算式</span><br>y = torch.dot(x, x)<br><br><span class="hljs-comment"># 之后调用反向传播来计算y关于每个分量的梯度</span><br><span class="hljs-comment"># 注意和符号求导的区别，这里会直接计算出具体的值</span><br>y.backward()<br>x.grad <span class="hljs-comment"># tensor([0., 2., 4., 6.])</span><br></code></pre></td></tr></table></figure><p>我们也可以将<spanclass="math inline">\(\mathbf{x}\)</span>的值带入上面进行的手动求导结果中，可以发现确实是相同的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x.grad == <span class="hljs-number">2</span> * x  <span class="hljs-comment"># tensor([True, True, True, True])</span><br></code></pre></td></tr></table></figure><p>同样我们可以计算其他算式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在默认情况下，PyTorch会累积梯度，我们需要清除之前的值</span><br>x.grad.zero_()  <span class="hljs-comment">#如果没有这一步结果就会加累上之前的梯度值，变为[1,5,9,13]</span><br>y = x.<span class="hljs-built_in">sum</span>()<br>y.backward()<br>x.grad  <span class="hljs-comment"># tensor([1., 1., 1., 1.])</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x.grad.zero_()<br>y = x * x  <span class="hljs-comment">#哈达玛积，对应元素相乘</span><br>y.<span class="hljs-built_in">sum</span>().backward()  <span class="hljs-comment">#等价于y.backword(torch.ones(len(x)))</span><br>x.grad  <span class="hljs-comment"># tensor([0., 2., 4., 6.])</span><br></code></pre></td></tr></table></figure><p>注意这里需要首先对<spanclass="math inline">\(y\)</span>进行sum，之后再进行反向传播。这样做是因为<strong>在深度学习当中通常考虑的都是标量Loss，因此计算的是标量对向量或矩阵的导数</strong>。我们通常不会去计算向量或者矩阵函数的导数，因为这样的Loss维度膨胀会非常快。</p><p>并且即使构建函数的计算图需要用过Python控制流，仍然可以计算得到的变量的梯度。这也是隐式构造的优势，因为它会存储梯度计算的计算图，再次计算时执行反向过程就可以。</p><p>同时Pytroch还支持将某些计算移动到计算图之外，即不计算这部分的梯度。这种方式可以用于将神经网络的一些参数进行固定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 后可用于用于将神经网络的一些参数固定住</span><br>x.grad.zero_()<br>y = x * x<br>u = y.detach() <span class="hljs-comment"># 把y当作常数</span><br>z = u * x<br><br>z.<span class="hljs-built_in">sum</span>().backward()<br>x.grad == x * x  <span class="hljs-comment"># 如果没有y.detach() 此处应该是x.grad = 3 * x * x</span><br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/263777564">矩阵求导--本质篇</a></li><li><ahref="http://zh.d2l.ai/chapter_preliminaries/autograd.html">动手学深度学习-预备知识-自动微分</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>动手学深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数的本质</title>
    <link href="/2023/08/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <url>/2023/08/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="向量">向量</h1><p>向量可以看作是一个有方向的箭头，或者一个列表，其中用数字填充。但是实质上，我们关心的是向量的两种运算，分别是向量加法和向量数乘。可以说，向量加法和向量数乘贯穿线性代数始终。<span class="math display">\[向量加法:\overrightarrow{A} + \overrightarrow{B}\\向量数乘:\lambda\overrightarrow{A}\]</span>在坐标系中描述一个向量依赖于坐标系所选择的基向量，这样向量坐标则表示了我们如何根据这组基向量，通过缩放和相加（向量数乘和向量加法）来得到对应向量。</p><p>一组向量的所有可能的线性组合，被称为这组向量所张成的空间。张成的空间的实际含义是，如果给定一组基向量，仅通过向量数乘和向量加法进行计算，能够得到的向量的集合是什么。</p><p>如果一组向量是线性相关的，则说明其中至少存在一个向量对这组向量所能张成的空间（维度）是没有贡献的，即我们可以移除其中一个向量而不减少张成的空间。否则这组向量则是线性无关的。</p><p>一组向量线性无关的严格定义如下，下面的式子当前仅当 a = b = c = 0的时候成立： <span class="math display">\[a\overrightarrow{v} + b\overrightarrow{w} +c\overrightarrow{u} = 0\]</span></p><h1 id="矩阵与线性变换">矩阵与线性变换</h1><p>首先考虑线性变换。变换本质上是函数的另一种说法，它接收一个输入input，得到一个输出output。在线性代数的情况下，我们考虑的是接收一个向量，并且输出另一个向量的变换。</p><p>考虑向量是空间中的一个箭头，变换则将向量的位置从初始位置改变到后来的位置。而空间中充满了向量，<strong>变换则可以看作是操纵空间的一种手段。线性变换则是变换中的一种特殊情况</strong>，直观地说，线性变换在变换前后，原点保持固定，并且保持网格线平行且等距分布。</p><p>那么我们该如何用数值来描述一个线性变换呢，具体的来说，我们需要完成下面过程的数值描述：<span class="math display">\[\begin{bmatrix}x_{in}\\y_{in}\end{bmatrix}\rightarrow？？？\rightarrow\begin{bmatrix}x_{out}\\y_{out}\end{bmatrix}\]</span>实际上，我们只需要记录基向量变换后的位置，就可以描述其他所有向量的变换。一个向量A 是基向量 {X...}的一个线性组合，在发生线性变换之后，基向量变成了变换后的基向量 {X1...}，而变换后的向量 A1 仍然是变换后基向量 {X1...} 的相同的线性组合。</p><p>我们记录了基向量变换后的位置，就能够通过对应的计算得到任意向量在经过相同变换后对应的位置。</p><img src="/2023/08/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%9F%A9%E9%98%B5.png" class=""><p>这也就是说，<strong>一个线性变换可以通过一组数字来确定，这组数字就是基向量在变换之后的坐标</strong>。如果我们将这些坐标以列向量的形式纵向进行排列，则可以得到一个矩阵的形式。这样一个矩阵就可以用来描述一个线性变换。而对比函数的写法，我们将这个变换放在左边，将输入放在右边，得到的就是矩阵乘法。通过一次矩阵乘法，我们可以将输入的变换前向量的坐标转换为变换后向量的坐标。</p><img src="/2023/08/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20221231100110368.png" class=""><p>总结来说，线性变换是操作空间的一种手段。它保持网格线平行且等距分布，并且保持原点不动。而这种变换只需要几个数字就能够描述清楚，这些数字就是变换后基向量的坐标，以这些坐标为列的矩阵为我们提供了一种描述线性变换的语言。<strong>而矩阵向量乘法就是计算线性变换作用于给定向量的一种途径。每当我们看到一个矩阵的时候，都可以将它解读为对空间的一种变换</strong>。</p><p>而两个矩阵的乘积就可以看作是两个线性变换的相继作用。这里需要注意作用的发生顺序是从右往左的。如果在这个含义下理解矩阵乘积，那么很多性质都能够直接得到。</p><p>首先，矩阵乘法不满足交换律，即AB和BA是不同的。如果我们将矩阵看作是线性变换的作用，这是显而易见的，AB表示对空间先作用B变换再作用A变换，而BA表示对空间先作用A变换再作用B变换，二者并不相同。此外，矩阵乘法满足结合律，即(AB)C =A(BC)。实际上这两者都是ABC，即对空间按照顺序进行C、B、A变换。</p><h1 id="行列式">行列式</h1><p>我们将矩阵看作是对空间进行线性变换，即压缩或者拉伸。一个很好的衡量方式是，测量变换究竟对空间有多少拉伸或者挤压，或者说测量空间被改变的比例，这就是行列式的意义。在二维空间中，则对应面积被改变了多少；在三维空间中，则对应体积被改变了多少。</p><p>如果行列式的值为负，则表示空间的定向被改变了。在二维空间中，感觉上就像是将平面翻转了。在三维空间中，则是从满足右手定则变为不满足。</p><p>如果行列式为0，则表示对应的线性变换将整个空间进行了降维，例如将二维的平面压缩为一条直线或者一个点。因此，只需要检测一个矩阵的行列式是否为0，就可以判断该矩阵代表的线性变换是否将空间压缩到一个更小的维度上。而如果行列式的值为0，也代表了这个矩阵的列必然线性相关。这是因为对应的变换进行了降维，对应的基向量中必然存在向量对维度没有贡献，则线性相关。</p><h1 id="线性方程组">线性方程组</h1><p>线性方程组的形式与矩阵乘法的形式非常类似，我们可以将线性方程组表示为矩阵乘法的形式。</p><img src="/2023/08/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20221231104502443.png" class=""><p>如果考虑矩阵与线性变换的对应关系，我们实际上是在考虑这样一个问题：矩阵A表示一个线性变换，我们需要求解一个向量x，使得它在进行变换后与v重合。</p><p>矩阵A表示一个线性变换，那么就可能出现降维的情况，即按照A的行列式是否为0进行划分。</p><ul><li>如果A的行列式不为0，则有且只有一个x在变换之后能够与v重合</li><li>如果A的行列式为0，则表示变换进行了降维，如果v在原来的维度空间中，那么就无解，而如果v恰好在降维后的空间中，则存在解</li></ul><p>如果A的行列式不为0，我们可以通过逆变换来找到对应的x。<strong>这个逆变换也是一个变换，实际上就对应了A的逆矩阵。</strong>逆矩阵有如下的性质：<span class="math display">\[A^{-1}A = E\]</span>其中这个E表示单位矩阵。实际上它也可以对应一个线性变换，恒等变换。它表示什么也不做。考虑它的含义，我们首先进行A变换，然后进行A的逆变换，实际效果也等同于什么都不做。</p><p>一旦我们找到了A的逆，我们就可以用于求解上面的线性方程组。而<strong>如果A的行列式为0，则A不存在逆变换。因为一个变换是无法增加维度的</strong>。</p><p>对于一个矩阵，对应一个线性变换，会有一个新的术语来描述，秩。<strong>秩代表了进行变换后空间的维度。</strong>如果进行变换后变成了一条直线，则秩为1；如果进行变换后变成了一个平面，则秩为2。一个矩阵对应的秩不能超过它本身代表的基向量的维度，即矩阵的列数。因为变换只能降维而不能升维。而如果<strong>矩阵代表的变换没有进行维度压缩，即行列式不为0，则我们称它是满秩的。</strong></p><p>一个矩阵代表的变换形成的空间，我们称其为列空间。<strong>列空间的含义实际上就是以矩阵的所有列作为基向量，它能够张成的空间</strong>。矩阵的列告诉我们变换后基向量的位置，这些变换后的基向量张成的空间就是所有可能的变换结果。<strong>因此，更精确的秩的定义是列空间的维数</strong>。</p><p>零向量一定会被包含在列空间中，因为线性变换必须保证原点位置不变。对于一个满秩变换来说，唯一能够在变换后落在原点上的就是原点本身。但是对一个非满秩的变换来说，它将空间压缩到一个更低的维度上，<strong>也就是说有一系列向量在变换后成为零向量。这些向量的集合被称为矩阵的零空间或者核。</strong>对线性方程组来说，零空间就是Ax =0的所有可能的解的集合，只有当A的行列式为0时，这个矩阵才有非零解。</p><blockquote><p>上面的讨论的线性变换基本上都是方阵，而对于非方阵来说，我们同样可以将其看作一个线性变换。它的输入和输出处在不同的维度空间当中，完成的是跨维度的变换。如果一个非方阵是<spanclass="math inline">\(a\timesb\)</span>的，表示一个从b维空间到a维空间的线性变换。</p><p>例如输入是二维空间中的一条直线，而输出是三维空间中的一个面，则该变换对应的矩阵应该是一个3 <span class="math inline">\(\times\)</span> 2的矩阵，它表示列空间有两个基向量，但是这两个基向量都存在于三维空间中。不过这个矩阵仍然是满秩的，因为列空间的维度与输入空间的维度相同，列空间是一个面，维度是2，输入空间是二维空间，维度也是2。</p></blockquote><h1 id="点积">点积</h1><p>两个向量之间的点积得到的是一个标量。点积（dotproduct）的标准计算方法如下，即对应位置上的值相乘再全部相加。 <spanclass="math display">\[\overrightarrow{a} \cdot \overrightarrow{b} = \sum_{i=1}^{n}a_ib_i =a_1b_1 + a_2b_2 + ...+a_nb_n\]</span>点积的几何解释则是一个向量向另一个向量上投影，然后计算投影和另一个向量长度的乘积：<span class="math display">\[\overrightarrow{a} \cdot \overrightarrow{b} =\left \| \overrightarrow{a} \right \| \times\left \| \overrightarrow{b} \right \|\times\cos{\theta}\]</span>我们首先考虑从多维空间到一维空间（数轴）的线性变换。在这里，直观地来说，线性变换需要满足：如果你有一系列等距分布于一条直线上的点，应用线性变换之后，这些点会等距分布于输出空间中，也就是数轴上。这类变换对应的矩阵会是一个1<span class="math inline">\(\times\)</span> n的矩阵，n表示输入空间的维度，输入空间的每个基向量在进行变换后都对应数轴上的一个数。利用矩阵进行坐标转换计算（矩阵乘法），每个n维输入空间的向量都会对应到数轴上的一个数。</p><p>实际上，这类特殊的矩阵乘法就与点积类似。因此，一个n维向量和一个1<span class="math inline">\(\times\)</span> n的矩阵就有了联系（躺下和立起）。在任何时候，如果看到了一个线性变换，它的输入空间是n维空间，输出空间是一维的空间，无论它是如何定义的，在n维空间中会存在一个向量v与之相关。在这个意义下，进行变换和与向量v做点积是相同的，变换的方法就是向v上投影。</p><blockquote><p>这种对偶性可以描述为：</p><ul><li>一个向量的对偶是由它定义的线性变换</li><li>一个从多维空间到一维空间的线性变换的对偶是多维空间中的某个特定向量</li></ul></blockquote><h1 id="叉积">叉积</h1><p>如果我们有两个向量v和w，那么它们的叉积得到的结果也是一个向量，这个向量的大小是v和w对应得到的平行四边形的面积，而方向满足右手定则，从前扫向后面，即如果是v<span class="math inline">\(\times\)</span>w，则是从v方向扫向w的方向。</p><p>平行四边形的面积可以通过行列式来计算。在前面我们提到行列式表示一个变换对空间的改变程度。如果计算v<span class="math inline">\(\times\)</span>w，我们可以将第一个向量作为矩阵的第一列，将第二个向量作为矩阵的第二列，然后计算行列式。行列式的符号表示定向发生改变，也能够对应到叉积的符号。</p><img src="/2023/08/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20221231114445882.png" class=""><p>而如果是三维向量的叉积计算，也能够通过行列式来进行：</p><img src="/2023/08/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20221231114813185.png" class=""><h1 id="基变换">基变换</h1><p>如果我们在一个坐标系中表示一个向量，我们可以得到对应的坐标，它表示我们如何通过基向量经过缩放和相加得到对应的向量。这组基向量实际上可以看作是封装于坐标系中的隐含假设。基向量的不同导致坐标的不同。在标准坐标系中，基向量是向量i和j，但是同样可以存在另一个坐标系，它的基向量是其他的向量。</p><p>在不同坐标系中进行转化，通常需要经过基变换的过程。我们可以通过线性变换来完成这一过程。假设现在有两个坐标系，一个是标准坐标系，另一个是新坐标系，它们的基向量并不相同。</p><p>新坐标系中的基向量可以在标准坐标系中进行表示，从而得到一个矩阵。它所代表的变换就能够将标准坐标系转换为新坐标系。</p><p>考虑一个相同的变换，它完成的几何含义是相同的，但是在不同坐标系中对应的矩阵表示一般不同。通常情况下我们习惯于使用标准坐标系，下面的过程完成的是我们如何借助标准坐标系来对新坐标系中的向量变化进行计算。即新坐标系中的向量<spanclass="math inline">\(v\)</span>，经过一个变换，得到新向量<spanclass="math inline">\(v^{&#39;}\)</span></p><img src="/2023/08/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20221231121801023.png" class=""><p>首先我们需要将新坐标系中的向量<spanclass="math inline">\(v\)</span>转换为标准坐标系中的表示，这需要我们知道新坐标系中的基向量在标准坐标系中的表示，基向量构成的矩阵记为A。这样Av就是以标准坐标系的语言来描述向量<spanclass="math inline">\(v\)</span>。之后在标准坐标系中描述变换M，得到在标准坐标系中经过变换后的向量为MA<spanclass="math inline">\(v\)</span>。之后还需要将标准坐标系转换为新坐标系，因此需要实行A的逆变换，所以整个过程就是下面的式子：<span class="math display">\[A^{-1}MA\overrightarrow{v} =\overrightarrow{v^{&#39;}}\]</span> 总结来说，表达式<spanclass="math inline">\(A^{-1}MA\)</span>暗示着一种数学上的转移作用。中间的矩阵M代表一种你所见的变换，而外侧的两个矩阵代表着转移作用，也就是视角上的转化。矩阵乘积仍然代表着同一个变换，只不过是从其他视角来看待的。</p><h1 id="特征向量与特征值">特征向量与特征值</h1><p>考虑空间中的某个线性变换，它可以使用一个矩阵来表示。我们关注它对一个向量的作用，并考虑这个向量张成的空间，即一条直线。在变换的前后，大部分向量都会离开它所张成的空间。<strong>而某些特殊的向量在变换前后仍然处在它所张成的空间，意味着矩阵对它的作用仅仅是拉伸或者压缩而已，相当于一个标量。这类特殊的向量就是矩阵的特征向量，而拉伸或者压缩的比例则是对应的特征值</strong>。</p><p>特征向量满足如下性质，其中的<spanclass="math inline">\(\lambda\)</span>就是对应的特征值： <spanclass="math display">\[A\overrightarrow{v} = \lambda\\overrightarrow{v}\]</span>我们可以通过将矩阵的列看作变换后的基向量来理解线性变换。但是理解线性变换的关键往往应该较少依赖于特定的坐标系，更好的方法是求出它的特征向量和特征值。</p><p>特征向量的计算可以从上面的性质出发： <span class="math display">\[\begin{aligned}A\overrightarrow{v} &amp;= \lambda\\overrightarrow{v}\\(A - \lambda E) \overrightarrow{v} &amp;= 0\end{aligned}\]</span> 这样我们需要求解这个新矩阵，使得它与向量<spanclass="math inline">\(v\)</span>的乘积为0。如果向量<spanclass="math inline">\(v\)</span>为零向量，这个等式恒成立，对我们来说并没有太大意义，我们需要的是一个非零解<spanclass="math inline">\(v\)</span>。从前面秩的相关说明中我们可以知道，<strong>当且仅当这个新矩阵代表的变换将空间压缩到更低的维度时，才会存在一个非零向量使得上式成立</strong>。即对应新矩阵的行列式为0。当然根据计算结果，特征向量可能不存在，也可能存在多个。<span class="math display">\[det(A - \lambda E) = 0\]</span>如果对于一个变换M，我们能够找到对应的特征向量，并且这些特征向量能够构成一组基向量，那么我们就可以考虑下面的性质：<span class="math display">\[A^{-1}MA = B\]</span>其中A是特征向量在标准坐标系下的表示，B是一个对角矩阵，对角线上的元素分别为对应的特征值。前面我们说到，一个形如<spanclass="math inline">\(A^{-1}MA\)</span>的变换实际上是一种转移作用，它表示在以特征向量为基向量的坐标系下观察变换M。这里的B也是在新坐标系下观察得到的结果。又考虑到特征向量的性质，这种变换只会拉伸或者收缩特征向量，因此得到的是一个对角矩阵。<strong>这组向量既是特征向量，也是基向量，我们称这组向量为特征基</strong>。</p><h1 id="抽象向量空间">抽象向量空间</h1><p>函数是一种同样具有向量性质的东西。从某种意义上来看，函数实际上只是另一种向量。我们说在考虑向量的时候，我们的核心关注点在于向量的加法和数乘，而函数也能满足相应的性质：<span class="math display">\[(f + g)(x) = f(x) + g(x)\\(\lambda f)(x) = \lambda f(x)\]</span>因此，之前我们以箭头或者是列表考虑的向量所得到的所有概念，应该都能够被推广到函数当中来。举例来说，函数的变换接收一个函数，输出一个新的函数，一个常见的例子就是导数。</p><p>线性的严格定义是抽象的，它需要满足可加性和成比例性，一种常见的描述方法是“线性变换保持向量加法运算和数乘运算”。普适意味着抽象，抽象带来了普适。因此我们完全可以将其应用到函数上。考虑导数的话，求导实际上也是一个线性运算。如果用矩阵来描述求导，考虑多项式，可以有如下的结果：</p><img src="/2023/08/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20221231133912174.png" class=""><img src="/2023/08/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20221231133949869.png" class=""><p>这里求导算子对应的矩阵实际上可以通过对基函数进行求导得来。我们依次对所有的基函数进行求导，得到的结果作为列向量，就构成了对应的矩阵。</p><p>乍一看，函数求导和矩阵运算毫无关联，但是实际上它们非常接近。实际上，我们前面提到的很多概念，在函数中都有直接的类比。</p><table><thead><tr class="header"><th>线性代数中的概念</th><th>应用于函数时的别名</th></tr></thead><tbody><tr class="odd"><td>线性变换</td><td>线性算子</td></tr><tr class="even"><td>点积</td><td>内积</td></tr><tr class="odd"><td>特征向量</td><td>特征函数</td></tr><tr class="even"><td>...</td><td>...</td></tr></tbody></table><p>如果我们重新考虑什么是向量，实际上，只要你处理的对象集具有合理的数乘和相加概念，都能够被看成向量，前面提到的相关概念应该都能适用。</p><p>在进行理论研究时我们的考虑通常是抽象的，但是抽象的理论应该具有普适性。而为了让这些抽象的理论能够应用到具体的某个对象上，则需要某种媒介，这里的媒介就是公理。在向量的角度来看，就是向量加法和数乘的规则：</p><ol type="1"><li>向量加法满足结合律</li><li>向量加法满足交换律</li><li>向量加法的单位元存在</li><li>每个向量的加法逆元均存在</li><li>标量乘法与标量的域乘法相容</li><li>标量乘法的单位元存在</li><li>标量乘法对向量加法满足分配律</li><li>标量乘法对域加法满足分配律</li></ol><p>在线性代数的现代理论中，如果要让所有已经建立好的理论和概念适用于一个向量空间，那么它必须满足八条公理。向量的形式本身并不重要，它可以是任何东西，只需要向量相加和数乘的概念遵守以上规则即可。</p><h1 id="参考资料">参考资料</h1><ol type="1"><li><ahref="https://www.bilibili.com/video/av44855426/?vd_source=f05227407dcf2e1cd95d954a632cec91">【线性代数的本质】合集-转载于3Blue1Brown官方双语</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>数学基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>数学</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch快速入门</title>
    <link href="/2023/08/16/Pytorch%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2023/08/16/Pytorch%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="quick-start">Quick Start</h1><p>首先通过一个模型训练的案例来对Pytorch进行快速使用。需要提前import的模块如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> torchvision.transforms <span class="hljs-keyword">import</span> ToTensor<br></code></pre></td></tr></table></figure><h2 id="数据准备">数据准备</h2><p>数据是模型训练的基础。在Pytorch中有两个数据相关的抽象，分别是<code>torch.utils.data.DataLoader</code>和<code>torch.utils.data.Dataset</code>。其中Dataset管理了训练数据和标签，提供相关方式来获取每个数据以及对应的Label；DataLoader对Dataset进行包装，将原始数据进行组织，并对Dataset进行迭代取值，相关迭代方法可以配置。</p><blockquote><p>torchversion是视觉领域的相关库。Pytorch还提供了其他特定领域的相关库，包括torchtext、torchaudio。这些相关库中提供了一些相关测试数据。</p></blockquote><p>这里使用torchversion中提供的<ahref="https://github.com/zalandoresearch/fashion-mnist">FashionMNIST</a>数据集来进行演示。下面的代码会将FashionMNIST数据集下载到<code>./data</code>目录下，并返回对应的Dataset。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Download training data from open datasets.</span><br>training_data = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">True</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor(),<br>)<br><br><span class="hljs-comment"># Download test data from open datasets.</span><br>test_data = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">False</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor(),<br>)<br></code></pre></td></tr></table></figure><p>之后将Dataset包装成DataLoader，供后续训练使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">64</span><br><br><span class="hljs-comment"># Create data loaders.</span><br>train_dataloader = DataLoader(training_data, batch_size=batch_size)<br>test_dataloader = DataLoader(test_data, batch_size=batch_size)<br><br><span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> test_dataloader:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Shape of X [N, C, H, W]: <span class="hljs-subst">&#123;X.shape&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Shape of y: <span class="hljs-subst">&#123;y.shape&#125;</span> <span class="hljs-subst">&#123;y.dtype&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="模型搭建">模型搭建</h2><p>准备好数据之后，需要进行模型的搭建。Pytorch中模型的关键类是<code>nn.Module</code>。通过继承该类，在<code>__init__</code>中定义不同层次的网络，并在<code>forward</code>方法中定义前向传播的过程，我们可以定义出不同类型的模型。</p><p>Pytorch支持多种类型的设备，包括cpu，cuda（gpu），<ahref="https://pytorch.org/docs/stable/notes/mps.html">mps</a>等。在使用的时候，Model和Data都需要使用<code>to()</code>方法加载到对应device上。</p><blockquote><p>需要注意的是，mps支持Mac M系列的芯片。而在Intelchip的Mac上也会检测出mps可用，但是在Intel Chip Mac上使用mpsdevice可能会存在一些问题。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Get cpu, gpu or mps device for training.</span><br>device = (<br>    <span class="hljs-string">&quot;cuda&quot;</span><br>    <span class="hljs-keyword">if</span> torch.cuda.is_available()<br>    <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;mps&quot;</span><br>    <span class="hljs-keyword">if</span> torch.backends.mps.is_available()<br>    <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span><br>)<br><span class="hljs-comment"># device = &quot;cpu&quot; # open it to use cpu if you are using mac intel chip</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Using <span class="hljs-subst">&#123;device&#125;</span> device&quot;</span>)<br><br><span class="hljs-comment"># Define model</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NeuralNetwork</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.flatten = nn.Flatten()<br>        self.linear_relu_stack = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">28</span>*<span class="hljs-number">28</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.flatten(x)<br>        logits = self.linear_relu_stack(x)<br>        <span class="hljs-keyword">return</span> logits<br><br>model = NeuralNetwork().to(device)<br><span class="hljs-built_in">print</span>(model)<br></code></pre></td></tr></table></figure><h2 id="模型训练">模型训练</h2><p>模型训练的过程实际上就是一个迭代的过程，在每次循环当中，我们使用损失函数LossFunction和优化器Optimizer，利用梯度下算法来迭代更新模型参数，最终使得模型达到最优或者相对最优的水平。</p><p>在案例中，我们使用了交叉熵损失函数以及SGD优化器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">loss_fn = nn.CrossEntropyLoss()<br>optimizer = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">1e-3</span>)<br></code></pre></td></tr></table></figure><p>下面的train方法表示的是一个epoch的训练流程，一个epoch表示对训练集中的所有数据都处理一遍。在一个epoch中，我们首先利用DataLoader以batch的方式从训练集中加载数据，对于每个batch的数据，让其经过模型计算之后，通过损失函数计算Loss，再执行backward，利用Optimizer更新模型参数。在训练过程中，我们可以记录训练进度，模型损失等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">dataloader, model, loss_fn, optimizer</span>):<br>    size = <span class="hljs-built_in">len</span>(dataloader.dataset)<br>    model.train()<br>    <span class="hljs-keyword">for</span> batch, (X, y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dataloader):<br>        X, y = X.to(device), y.to(device)<br><br>        <span class="hljs-comment"># Compute prediction error</span><br>        pred = model(X)<br>        loss = loss_fn(pred, y)<br><br>        <span class="hljs-comment"># Backpropagation</span><br>        loss.backward()<br>        optimizer.step()<br>        optimizer.zero_grad()<br><br>        <span class="hljs-keyword">if</span> batch % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            loss, current = loss.item(), (batch + <span class="hljs-number">1</span>) * <span class="hljs-built_in">len</span>(X)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;loss: <span class="hljs-subst">&#123;loss:&gt;7f&#125;</span>  [<span class="hljs-subst">&#123;current:&gt;5d&#125;</span>/<span class="hljs-subst">&#123;size:&gt;5d&#125;</span>]&quot;</span>)<br></code></pre></td></tr></table></figure><p>下面的test方法表示的也是一个epoch的测试。与train方法不同的，test方法不需要对模型参数进行更新，只需要计算实际的loss即可。因此这里设置<code>torch.no_grad()</code>来关闭梯度更新。在训练过程中进行测试的目的是判断模型是否仍然在学习。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">dataloader, model, loss_fn</span>):<br>    size = <span class="hljs-built_in">len</span>(dataloader.dataset)<br>    num_batches = <span class="hljs-built_in">len</span>(dataloader)<br>    model.<span class="hljs-built_in">eval</span>()<br>    test_loss, correct = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> dataloader:<br>            X, y = X.to(device), y.to(device)<br>            pred = model(X)<br>            test_loss += loss_fn(pred, y).item()<br>            correct += (pred.argmax(<span class="hljs-number">1</span>) == y).<span class="hljs-built_in">type</span>(torch.<span class="hljs-built_in">float</span>).<span class="hljs-built_in">sum</span>().item()<br>    test_loss /= num_batches<br>    correct /= size<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test Error: \n Accuracy: <span class="hljs-subst">&#123;(<span class="hljs-number">100</span>*correct):&gt;<span class="hljs-number">0.1</span>f&#125;</span>%, Avg loss: <span class="hljs-subst">&#123;test_loss:&gt;8f&#125;</span> \n&quot;</span>)<br></code></pre></td></tr></table></figure><p>有了单个epoch的训练和测试方法之后，实际的训练和测试就是循环执行单个epoch的流程，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">epochs = <span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;t+<span class="hljs-number">1</span>&#125;</span>\n-------------------------------&quot;</span>)<br>    train(train_dataloader, model, loss_fn, optimizer)<br>    test(test_dataloader, model, loss_fn)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done!&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="模型保存和加载">模型保存和加载</h2><p>模型训练完毕之后，可以将其保存成相关文件，包括模型保存和模型参数保存。这里我们选择将训练好的模型的相关参数进行保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.save(model.state_dict(), <span class="hljs-string">&quot;model.pth&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Saved PyTorch Model State to model.pth&quot;</span>)<br></code></pre></td></tr></table></figure><p>Pytorch中也提供方法从相应文件中加载出对应模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model = NeuralNetwork().to(device)<br>model.load_state_dict(torch.load(<span class="hljs-string">&quot;model.pth&quot;</span>))<br></code></pre></td></tr></table></figure><p>加载好模型之后，就可以直接使用了，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">classes = [<br>    <span class="hljs-string">&quot;T-shirt/top&quot;</span>,<br>    <span class="hljs-string">&quot;Trouser&quot;</span>,<br>    <span class="hljs-string">&quot;Pullover&quot;</span>,<br>    <span class="hljs-string">&quot;Dress&quot;</span>,<br>    <span class="hljs-string">&quot;Coat&quot;</span>,<br>    <span class="hljs-string">&quot;Sandal&quot;</span>,<br>    <span class="hljs-string">&quot;Shirt&quot;</span>,<br>    <span class="hljs-string">&quot;Sneaker&quot;</span>,<br>    <span class="hljs-string">&quot;Bag&quot;</span>,<br>    <span class="hljs-string">&quot;Ankle boot&quot;</span>,<br>]<br><br>model.<span class="hljs-built_in">eval</span>()<br>x, y = test_data[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], test_data[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><span class="hljs-keyword">with</span> torch.no_grad():<br>    x = x.to(device)<br>    pred = model(x)<br>    predicted, actual = classes[pred[<span class="hljs-number">0</span>].argmax(<span class="hljs-number">0</span>)], classes[y]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Predicted: &quot;<span class="hljs-subst">&#123;predicted&#125;</span>&quot;, Actual: &quot;<span class="hljs-subst">&#123;actual&#125;</span>&quot;&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>通过快速入门案例，我们可以大致总结出一个完整的模型训练和测试流程：</p><ol type="1"><li>准备数据集，利用DataLoader来加载数据集</li><li>搭建模型</li><li>构建损失函数，定义优化器</li><li>设置训练网络的一些参数，例如epoch、batch size、learning rate等</li><li>开始训练，在训练过程中记录测试结果</li><li>训练完成之后评估训练效果</li><li>将训练好的模型进行保存</li><li>加载已经保存好的模型进行使用</li></ol><h1 id="tensor">Tensor</h1><p>Tensor是Pytorch中最基本的数据结构，<strong>在Pytroch中，模型的输入，输出以及模型参数都是使用Tensor来表示的</strong>。Tensor与Numpy中的ndarray非常类似，它们具有即为相似的API。不过Tensor可以借助GPU或者其他硬件来进行计算加速，而ndarray只能运行在CPU上；同时Tensor还对自动微分进行了优化，使其更加适合机器学习的场景。</p><p>Tensor的许多操作都可以与Numpy中的ndarray进行类比，有关Numpy可以查看本人的<ahref="https://evernorif.github.io/2023/08/04/Numpy%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/">Numpy基础笔记</a>。在Tensor中同样有向量化、广播机制等，与Numpy中的含义相同。</p><p>下面对Tensor的一些相关操作进行简单举例，主要是为了和Numpy中的API建立联系。更多的Tensor相关操作可以参考官方文档<ahref="https://pytorch.org/docs/stable/torch.html">Torch.Tensors|PytorchDocumentation</a>。</p><h2 id="相关概念">相关概念</h2><p>Tensor又被称为张量，其中一维，二维张量有特殊的名称：</p><ul><li>标量：单个数值</li><li>向量：标量值组成的列表，一维张量</li><li>矩阵：二维列表，二维张量</li><li>张量：更高维度的列表</li></ul><p>其中，维度（dimension）这个概念在不同上下文时往往会有不同的含义。</p><p>对于向量或者某个轴来说，向量或轴的维度表示的是向量或轴的长度，即向量或轴的元素数量。</p><p>对于张量来说，张量的维度表示的是张量具有的轴数。在这个意义上，张量的某个轴的维数指的是这个轴的长度。</p><h2 id="tensor的创建">Tensor的创建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Tensor可以直接从数据创建,数据类型自动推断</span><br>x_data = torch.tensor(data)<br><br><span class="hljs-comment"># 从numpy.ndarray创建</span><br>np_array = np.array(data)<br>x_np = torch.from_numpy(np_array)<br><br><span class="hljs-comment"># 从其他tensor创建，具有相同的shape</span><br>x_ones = torch.ones_like(x_data) <br>x_rand = torch.rand_like(x_data, dtype=torch.<span class="hljs-built_in">float</span>)<br><br><span class="hljs-comment"># 指定shape创建，默认dtype为float</span><br>shape = (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>rand_tensor = torch.rand(shape)  <span class="hljs-comment"># rand</span><br>randn_tensor = torch.randn(shape)  <span class="hljs-comment"># rand正态分布</span><br>ones_tensor = torch.ones(shape)  <span class="hljs-comment"># 全1矩阵</span><br>zeros_tensor = torch.zeros(shape)  <span class="hljs-comment"># 全0矩阵</span><br><br><span class="hljs-comment"># 常用创建方法</span><br>range_tensor = torch.arange(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>实际上，在Pytorch中，device为CPU的Tensors可以和numpy上的ndarray共享内存，两者的值变化会相互影响。可以通过Tensor的<code>.numpy()</code>和<code>torch.from_numpy(ndarray)</code>来构建这种关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># tensor to ndarray</span><br>t = torch.ones(<span class="hljs-number">5</span>)<br>n = t.numpy()<br> <br><span class="hljs-comment"># ndarray to tensor</span><br>n = np.ones(<span class="hljs-number">5</span>)<br>t = torch.from_numpy(n)<br></code></pre></td></tr></table></figure><h2 id="tensor的基本属性">Tensor的基本属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.rand(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-comment"># shape</span><br>tensor.shape  <br><span class="hljs-comment"># or tensor.size</span><br><span class="hljs-comment"># dtype</span><br>tensor.dtype<br><span class="hljs-comment"># device(cpu/gpu/mps/...)</span><br>tensor.device<br><br><span class="hljs-comment"># num of element</span><br>tensor.numel()<br></code></pre></td></tr></table></figure><p>通过Tensor的<code>.to()</code>方法，可以将Tensor转移到对应设备上，以使用相应硬件的加速能力，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># move tensor to the GPU if available</span><br><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>    tensor = tensor.to(<span class="hljs-string">&quot;cuda&quot;</span>)<br><span class="hljs-comment"># move tensor to the MPS if available</span><br><span class="hljs-keyword">elif</span> torch.backends.mps.is_available():<br>    tensor = tensor.to(<span class="hljs-string">&quot;mps&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="tensor的索引切片">Tensor的索引、切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 与Numpy类似</span><br>tensor = torch.ones(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)<br>tensor[<span class="hljs-number">0</span>]  <span class="hljs-comment"># first row</span><br>tensor[:, <span class="hljs-number">0</span>]  <span class="hljs-comment"># first column</span><br>tensor[..., -<span class="hljs-number">1</span>]  <span class="hljs-comment"># last column</span><br><br>tensor = torch.arange(<span class="hljs-number">10</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment"># 支持Mask矩阵</span><br>tensor[tensor % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># tensor([0, 2, 4, 6, 8])</span><br><br><span class="hljs-comment"># 支持Index矩阵</span><br>i = torch.tensor([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])<br>j = torch.tensor([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>tensor[i, j]  <span class="hljs-comment"># tensor([0, 1, 7, 8, 9])</span><br></code></pre></td></tr></table></figure><h2 id="tensor的数学计算方法">Tensor的数学计算方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># + - * / ** @</span><br><br><span class="hljs-comment"># 矩阵乘法的三种方式 y1,y2,y3值相同</span><br>y1 = tensor @ tensor.T<br>y2 = tensor.matmul(tensor.T)<br>y3 = torch.rand_like(y1)<br>torch.matmul(tensor, tensor.T, out=y3)<br><br><span class="hljs-comment"># 矩阵按元素相乘的三种方式 z1,z2,z3值相同</span><br>z1 = tensor * tensor<br>z2 = tensor.mul(tensor)<br>z3 = torch.rand_like(tensor)<br>torch.mul(tensor, tensor, out=z3)<br><br><span class="hljs-comment"># 单元素Tensor与Python数值的转换: item()</span><br>sum_tensor = tensor.<span class="hljs-built_in">sum</span>()<br>sum_value = sum_tensor.item()<br><span class="hljs-comment"># 或者Python内置函数</span><br>sum_value = <span class="hljs-built_in">int</span>(sum_tensor)<br><br><span class="hljs-comment"># 向量点积(对应元素相乘再相加)</span><br>tensor = torch.arange(<span class="hljs-number">6</span>)<br>a = torch.dot(tensor, tensor)<br></code></pre></td></tr></table></figure><p>Pytorch中的方法通常都是返回一个新的对象，不过也提供对原对象修改的方法，即执行原地操作。这些方法大都在对应方法名后增加了一个下划线<code>_</code>。当然在Pytorch中不推荐这种使用方式，因为会导致梯度丢失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>tensor.add_(<span class="hljs-number">5</span>)  <span class="hljs-comment"># tensor += 5</span><br></code></pre></td></tr></table></figure><p>对于聚合函数来说，我们同样可以指定沿着哪个轴进行聚合，这个轴在最终结果中会消失。不过可以通过指定<code>keepdims</code>属性为True，来保持维度，进行非降维聚合，此时该轴对应的元素数量下降为1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.arange(<span class="hljs-number">8</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(tensor.shape)  <span class="hljs-comment"># torch.Size([2, 4])</span><br><br><span class="hljs-built_in">print</span>(tensor.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>).shape)  <span class="hljs-comment"># torch.Size([4])</span><br><span class="hljs-built_in">print</span>(tensor.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>).shape)  <span class="hljs-comment"># torch.Size([2])</span><br><br><br><span class="hljs-comment"># keepdims=True</span><br><span class="hljs-built_in">print</span>(tensor.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>, keepdims=<span class="hljs-literal">True</span>).shape)  <span class="hljs-comment"># torch.Size([1, 4])</span><br><span class="hljs-built_in">print</span>(tensor.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>).shape)  <span class="hljs-comment"># torch.Size([2, 1])</span><br></code></pre></td></tr></table></figure><h2 id="tensor的shape变换">Tensor的Shape变换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 类比 numpy concatenate, 矩阵堆叠</span><br>tensor = torch.arange(<span class="hljs-number">8</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(tensor.shape)  <span class="hljs-comment"># torch.Size([2, 4])</span><br>t0 = torch.cat([tensor, tensor, tensor], dim=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(t0.shape)  <span class="hljs-comment"># torch.Size([6, 4])</span><br>t1 = torch.cat([tensor, tensor, tensor], dim=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(t1.shape)  <span class="hljs-comment"># torch.Size([2, 12])</span><br><br><span class="hljs-comment"># 沿着新维度进行矩阵堆叠，需要满足所有tensor具有相同的shape</span><br><span class="hljs-comment"># 会新增维度，新增到指定的dim对应的维度</span><br>tensor = torch.arange(<span class="hljs-number">9</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(tensor.shape)  <span class="hljs-comment"># torch.Size([3, 3])</span><br>t0 = torch.stack([tensor, tensor], dim=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(t0.shape)  <span class="hljs-comment"># torch.Size([2, 3, 3])</span><br>t1 = torch.stack([tensor, tensor], dim=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(t1.shape)  <span class="hljs-comment"># torch.Size([3, 2, 3])</span><br>t2 = torch.stack([tensor, tensor], dim=<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(t2.shape)  <span class="hljs-comment"># torch.Size([3, 3, 2])</span><br></code></pre></td></tr></table></figure><h1 id="dataset与dataloader">Dataset与DataLoader</h1><p>一个良好的架构特点是低耦合，在Pytorch中，也希望能够将数据处理代码和模型训练代码分离。Dataset和DataLoader就是用来解决这种问题的。在Pytorch中，Dataset存储样本数据feature以及对应的标签label；DataLoader则将Dataset包装成一个可迭代对象，使得我们能够更加轻松地访问样本。</p><p>除此之外，Pytorch还提供了许多预定义好的示例数据集，包括 <ahref="https://pytorch.org/vision/stable/datasets.html">ImageDatasets</a>，<ahref="https://pytorch.org/text/stable/datasets.html">Text Datasets</a>和 <a href="https://pytorch.org/audio/stable/datasets.html">AudioDatasets</a>。在Pytorch中，这些数据集都以Dataset的子类形式提供，通过相关API我们可以直接拿到对应数据集的Dataset对象。例如在QuickStart中，我们就是直接使用了Pytroch自带的API获取了Fashion-MNIST数据集。</p><h2 id="dataset">Dataset</h2><p>Pytorch允许用户自定义Dataset类。自定义Dataset需要继承<code>torch.utils.data.Dataset</code>，并且实现其中的<code>__init__</code>，<code>__len__</code>和<code>__getitem__</code>方法。这三个方法实际上就是在定义如何读取数据，数据集的大小以及通过<code>[index]</code>如何获取数据。</p><ul><li>在<code>__init__</code>方法中定义后续可能需要的所有变量和方法；</li><li>在<code>__len__</code>方法中返回数据集的大小；</li><li>在<code>__getitem__</code>方法中返回数据集中第index条记录，包括feature和label</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> torchvision.io <span class="hljs-keyword">import</span> read_image<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomImageDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, annotations_file, img_dir, transform=<span class="hljs-literal">None</span>, target_transform=<span class="hljs-literal">None</span></span>):<br>        self.img_labels = pd.read_csv(annotations_file)<br>        self.img_dir = img_dir<br>        self.transform = transform<br>        self.target_transform = target_transform<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.img_labels)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, <span class="hljs-number">0</span>])<br>        image = read_image(img_path)<br>        label = self.img_labels.iloc[idx, <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> self.transform:<br>            image = self.transform(image)<br>        <span class="hljs-keyword">if</span> self.target_transform:<br>            label = self.target_transform(label)<br>        <span class="hljs-keyword">return</span> image, label<br></code></pre></td></tr></table></figure><p>这里的示例代码处理的是这样的场景，用于训练的图片数据存储在<code>img_dir</code>中，对应的label则存放在<code>annotataions_file</code>中，每行表示一条数据记录，并且格式为<code>image_file_name, label</code>。</p><h2 id="dataloader">DataLoader</h2><p>利用Dataset进行数据访问，我们只能通过下标进行，并且每次只能获取一个feature和label。在训练模型时，我们通常对传递样本的方式有所要求，例如希望以minibatch的形式传递，希望在不同时期对传递数据进行shuffle以减少过拟合等。</p><p>而DataLoader对Dataset进行了一层包装，它是一个可迭代对象，通过简单的API为我们抽象了这种数据处理的复杂性。利用DataLoader，我们可以很简单地完成batch，shuffle等的指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br>train_dataloader = DataLoader(training_data, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)<br>test_dataloader = DataLoader(test_data, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>DataLoader可以根据需要对数据集进行迭代，每次迭代返回的是一批train_features和train_labels。如果额外指定了shuffle为true，则每次返回的数据各不相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 迭代访问dataloader</span><br><span class="hljs-comment"># train_features,train_labels都是batch批量的数据</span><br>train_features, train_labels = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(train_dataloader))<br></code></pre></td></tr></table></figure><h1 id="transforms">Transforms</h1><p>我们前面提到Pytorch中模型训练输入输出和参数都是Tensor的数据类型，但是很多时候原始的训练数据集并不是Tensor的格式，例如QuickStart中训练数据就是以图片的形式出现的。Transforms指的就是将各式各样的原始数据类型转换成Tensor的格式，使其能够适合训练。</p><p>例如，在<ahref="https://pytorch.org/vision/stable/transforms.html">torchvision.transforms</a>中提供了对于图像类数据来说常用的转换方式。</p><h1 id="model">Model</h1><p>一个Model是由多个模块module构成的，每个模块会对数据进行相应的计算处理。<code>torch.nn</code>namespace向用户提供构建Model所需的支持。在Pytorch中，所有的Module都是<code>nn.Module</code>的子类。我们可以调用一些现有的基本Module进行组合，形成自定义的Model。</p><p>自定义Model需要实现一个Model类，继承<code>nn.Module</code>，并实现其中的<code>__init__</code>和<code>forward()</code>方法。</p><ul><li>在<code>__init__</code>方法中定义在Model中可能用到的模块</li><li>在<code>forward(self, x)</code>方法中定义数据经过Model的前向传播流程。其中的参数<code>x</code>表示单个feature，即Dataset中的某个feature</li></ul><p>回顾Quick Start中定义的Model，我们定义了如下的Model结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NeuralNetwork</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.flatten = nn.Flatten()<br>        self.linear_relu_stack = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">28</span>*<span class="hljs-number">28</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.flatten(x)<br>        logits = self.linear_relu_stack(x)<br>        <span class="hljs-keyword">return</span> logits<br></code></pre></td></tr></table></figure><p>我们可以从模型对于某个feature的一次处理来理解代码。从前向传播forward方法出发，在这种情况下，x就是一个由<code>28*28</code>的图片转化而来的<code>(28, 28)</code>的Tensor。在前向传播中，首先通过一个Flatten层将Tensor拍平为<code>(784)</code>，之后经过一个线性层Linear降低维度为<code>(512)</code>，之后依次经过ReLU、线性层、ReLU、线性层，此时Tensor的shape已经降低为<code>(10)</code>了。最后返回这个Tensor。</p><p>对于上面出现的一些基本模块，这里不再进行介绍，不过需要提一下<code>nn.Sequential()</code>方法，这个方法可以将多个Module按照顺序组织在一起，返回一个新的Module。</p><h1 id="autograd">AutoGrad</h1><p>在训练神经网络的过程中，最常用的算法是梯度下降，该算法通过计算参数相对于损失函数的梯度值来进行参数的更新。这个过程中最为复杂的一步就是梯度的计算，Pytorch通过内置的<code>torch.autpgrad</code>梯度计算引擎来计算梯度，它支持任何计算图的梯度自动计算。（反向传播是一种计算梯度的方式）</p><p>Tensor自身具有一个<code>requires_grad</code>属性，表示是否需要计算它的梯度。我们可以在创建的时候指定该属性，也可以通过<code>x.requires_grad_(True)</code>来设置。在训练过程中，我们调用模型损失（标量）的<code>backward</code>方法，pytorch就会自动进行梯度计算，此时可以通过<code>.grad</code>属性来查看对应的梯度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">loss.backward()<br><span class="hljs-built_in">print</span>(w.grad)<br><span class="hljs-built_in">print</span>(b.grad)<br></code></pre></td></tr></table></figure><p>在有些时候，我们不希望Pytorch计算梯度，只希望网络进行前向传播，那么此时可以使用<code>torch.no_grad()</code>with作用域进行包裹，这样Pytorch就不会进行梯度的计算了。或者使用某个Tensor的<code>.detach()</code>版本。这样的Tensor也不会被计算梯度。</p><blockquote><p>不计算梯度的原因可能是我们希望冻结参数，又或者是希望加速计算。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> torch.no_grad():<br>  <span class="hljs-comment"># ...</span><br>  <br>z = torch.matmul(x, w)+b<br>z_det = z.detach()<br></code></pre></td></tr></table></figure><h1 id="model-save-and-load">Model Save and Load</h1><p>模型的保存和加载分为两种方式。第一种方式是仅保存模型的参数权重，在加载的时候需要先创建出具有相同结构的Model实例，然后再将对应参数加载到模型当中；第二种情况是直接将整个模型进行保存，包括Model的结构和参数，在使用的时候也是直接加载即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方式一: save model params</span><br><span class="hljs-comment"># save</span><br>torch.save(model_save.state_dict, <span class="hljs-string">&quot;xxx.pth&quot;</span>)<br><span class="hljs-comment"># load</span><br>model_load = xxx <span class="hljs-comment"># model define 注意model使用的device要和保存的时候一致</span><br>model_load.load_state_dict(torch.load(<span class="hljs-string">&quot;xxx.pth&quot;</span>))<br><br><span class="hljs-comment"># 方式二: save model</span><br><span class="hljs-comment"># save</span><br>torch.save(model_save, <span class="hljs-string">&quot;xxx.pth&quot;</span>)<br><span class="hljs-comment"># load</span><br>model_load = torch.load(<span class="hljs-string">&quot;xxx.pth&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://pytorch.org/tutorials/beginner/basics/intro.html">Introductionto Pytorch|Pytorch Documentation</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slidev:从Markdown生成PPT</title>
    <link href="/2023/08/15/Slidev-%E4%BB%8EMarkdown%E7%94%9F%E6%88%90PPT/"/>
    <url>/2023/08/15/Slidev-%E4%BB%8EMarkdown%E7%94%9F%E6%88%90PPT/</url>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p><ahref="https://sli.dev/">slidev</a>是一款为开发者提供的PPT工具，它允许我们通过编写Markdown来快速生成PPT。结合一定的CSS语法以及社区主题，slidev也能够完成非常精美的PPT。更重要的是程序员对Markdown更为熟悉，同时使得后续的复用变得非常简单。</p><blockquote><p>还有类似的工具例如<ahref="https://revealjs.com/markdown/">Reveal.JS</a>，利用<ahref="https://github.com/MSzturc/obsidian-advanced-slides">AdvancedSlide</a>插件结合Obsidian也是一种常见的解决方案。</p></blockquote><p>slidev提供多种安装方式，这里推荐全局安装，之后在任意目录下都可以直接使用<code>slidev</code>命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -g @slidev/cli<br></code></pre></td></tr></table></figure><p>安装完成之后，我们可以快速编写一个<code>slidev-slide.md</code>，然后通过<code>slidev</code>命令就可以进行PPT的生成。该命令基于对应的md文件在本地启动一个server，默认通过访问<code>http://localhost:3030</code>可以在浏览器中进行PPT的访问。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">slidev slidev-slide.md<br></code></pre></td></tr></table></figure><p>虽然slidev是基于Markdown的，但是它的语法规则与标准的Markdown渲染规则还是略有差异，因此在使用slidev的时候，在对应的Markdown编辑器中建议开启源码模式。</p><h1 id="tips">Tips</h1><p>slidev的官方文档地址为：<a href="https://cn.sli.dev/guide/">GettingStarted|sli.dev</a>。该文档已经非常详细了，日常使用都可以参考该文档。这里仅记录本人在使用过程中的一些小tips，以供快速fix。</p><h2 id="css修改">CSS修改</h2><p>slidev对于markdown的转换有一套默认的风格，但是由于Markdown天然支持html，因此我们可以按照想要的方式对内容进行样式设计。可以参考<ahref="https://cn.sli.dev/custom/config-windicss.html">配置WindiCSS|slidev</a>。通过这种方式，我们可以很方便地进行样式改变。下面举一些例子。</p><p>一个最简单的操作，我们可以为一段文本指定背景颜色，指定边框等。只需要利用<code>&lt;div&gt;</code>标签将对应文本块进行包裹，然后在<code>class</code>中指定对应的style，这里的风格指定可以参考WindiCSS提供的相关工具<ahref="https://windicss.org/utilities/">Utilites</a>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bg-gray-500/50 border-5&quot;</span>&gt;</span></span><br>some text...<br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>slidev中的代码块，在展示模式下，如果其中的内容过多，超出高度的时候，默认行为是隐藏。此时我们可以通过CSS修改来解决该问题，主要需要指定代码块元素的高度以及overflow的行为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;h-40 overflow-scroll&quot;</span>&gt;</span></span><br><span class="hljs-code">```html</span><br><span class="hljs-code">too long code in here...</span><br><span class="hljs-code">```</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在Monaco编辑模式下，可以通过指定高度来解决隐藏问题：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">```html&#123;monaco&#125; &#123;height:100px&#125;</span><br><span class="hljs-code">too long code in here...</span><br><span class="hljs-code">```</span><br></code></pre></td></tr></table></figure><p>还有一个较为常用的是网格grid布局，可以用于在一张PPT中排列多个需要展示的元素。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid grid-cols-4 gap-5 pt-4 -mb6&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="export导出">export导出</h2><p>slidev支持将网页版的PPT导出为pdf格式，此时需要使用<code>slidev export</code>命令。当然在使用之前需要先安装<code>playwright-chromium</code>。对于全局安装的用户来说，这里使用<code>-D</code>安装后可能还是无法使用export。此时可以尝试使用<code>-g</code>进行全局安装。</p><p>export默认导出的逻辑是每一张PPT对应一页PDF，如果有动画效果的话，那么可以使用<code>--with-clicks</code>参数，此时多个步骤的PPT会转化为多页PDF，每一页对应一次点击。</p><h2 id="icon图标">icon图标</h2><p>slidev中直接支持开源图标集的访问，只需要指定<code>&lt;&#123;collection-name&#125;-&#123;icon-name&#125; /&gt;</code>即可。图标库可以参考<ahref="https://icones.js.org/">icones</a>和<ahref="https://icon-sets.iconify.design/">icon-sets.iconify</a>。</p><blockquote><p>不过其中部分icon会显示notfound，这点目前还不清楚是什么原因导致的。</p></blockquote><h2 id="左右布局">左右布局</h2><p>slidev提供了一个<code>two-cols</code> layout来完成左右布局：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br><span class="hljs-section">layout: two-cols</span><br><span class="hljs-section">---</span><br><span class="hljs-section">## 左右布局</span><br><br><span class="hljs-section">### Left</span><br><br>This shows on the left<br><br>左边内容<br><br>::right::<br><br><span class="hljs-section">##  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span></span><br><br><span class="hljs-section">###  Right</span><br><br>This shows on the right<br><br>右边内容<br></code></pre></td></tr></table></figure><h1 id="acadamic-theme">Acadamic Theme</h1><p>slidev支持主题theme的快速替换，在社区中有许多高质量的主题可供我们使用。本节主要介绍一个简洁的学术主题acadamic，地址为<ahref="https://github.com/alexanderdavide/slidev-theme-academic/tree/master">slidev-theme-academic</a></p><p>可以在顶层的<code>front-matter</code>中直接指定：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br><span class="hljs-section">theme: academic</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>一个slidev theme的使用主要是看它提供的各种layout如何使用。acadamictheme提供了如下layout可供使用，下面逐一介绍。</p><ol type="1"><li>cover 封面页</li><li>table-of-contents 目录页</li><li>index 列表页</li><li>figure 单图片页面</li><li>figure-side 单侧图片页面</li><li>center 文字居中页面</li></ol><h2 id="cover">cover</h2><p>cover页面的<code>front-matter</code>中重要属性如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>layout: cover<br>class: text-white<br>coverAuthor: EverNorif # 作者名称<br>coverAuthorUrl: https://evernorif.github.io/about/ # 作者跳转链接<br>coverBackgroundUrl: background.jpg # 背景图片，存放在public目录下<br>coverBackgroundSource: unsplash # 右下角参考图片名称<br>coverBackgroundSourceUrl: xxx # 点击参考图片跳转链接<br><span class="hljs-section">title: hello world with academic in slidev  # 整个PPT的名称，会出现在标签栏中</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h2 id="table-of-contents">table-of-contents</h2><ul><li><p>目录页面，在formatter中指定layout为<code>table-of-contents</code></p></li><li><p>会自动检测所有标题，包含封面和结束页面；也会自动检测页面之间的层级关系</p></li></ul><h2 id="index">index</h2><p>列表页面index的<code>front-matter</code>如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>layout: index<br>indexEntries:<br><span class="hljs-bullet">-</span> &#123; title: &quot;GitHub&quot;, uri: &quot;https://github.com/&quot; &#125;<br><span class="hljs-bullet">-</span> &#123; title: &quot;Custom Uri&quot;, uri: 5 &#125;<br><span class="hljs-section">indexRedirectType: external</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>列表页面通过formatter中属性来指定<code>indexEntries</code>展示的列表，以及对应的链接。在该页面中可以进行其他内容的书写，最终的列表会添加到页面的最后方。</p><p>默认情况下这里的<code>uri</code>只能提供数字，表示要跳转到第几张PPT。此时<code>title</code>将会失效，会被自动解析为对应页面的标题。此时点击跳转是在内部跳转，不会新开一个页面。</p><p>如果指定了<code>indexRedirectType</code>为<code>external</code>，那么就可以提供外部链接，且此时<code>title</code>会与我们指定的保持一致。并且即使是写的内部链接跳转，名称也是以提供的为准。不过此时点击跳转会新开一个tab页面。</p><h2 id="figure">figure</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>layout: figure<br>figureCaption: Curated cover image for Slidev<br>figureFootnoteNumber: 1<br><span class="hljs-section">figureUrl: https://source.unsplash.com/collection/94734566/1920x1080</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>figure页面通常用来展示一张大图，通常也可以搭配脚注使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Footnotes</span> <span class="hljs-attr">separator</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Footnote</span> <span class="hljs-attr">:number</span>=<span class="hljs-string">1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://unsplash.com/collections/94734566/slidev&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;noreferrer&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>From Anthony Fu&#x27;s unsplash<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Footnote</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Footnotes</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="figure-side">figure-side</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>layout: figure-side<br>figureCaption: use local image in pubilc folder<br>figureFootnoteNumber: 2<br><span class="hljs-section">figureUrl: background.jpg</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>figure-side页面用来在单侧展示一张图片。注意左边的内容会挤占图片的空间，图片会随着空间进行动态调整，可能出现图片被完全挤开的情况。因此需要注意代码块的宽度。当然同样可以搭配脚注使用。</p><h2 id="center">center</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>layout: center<br><span class="hljs-section">class: &quot;text-center&quot;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>center页面用于将所有的内容都进行居中显示。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
      <category>生产力</category>
      
    </categories>
    
    
    <tags>
      
      <tag>slidev</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas基础笔记</title>
    <link href="/2023/08/07/Pandas%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/08/07/Pandas%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="pandas基础笔记">Pandas基础笔记</h1><p>Pandas是数据分析中最受欢迎的Python Package之一，它的官方文档为<ahref="https://pandas.pydata.org/docs/">PandasDocumentation</a>。Pandas主要用于表格数据（行列格式）的数据操作，同时它提供从多种数据源读取数据的能力，以及丰富的数据操作功能，包括数据聚合、数据分析和数据清洗等。Pandas也可以与其他数据科学相关的Package进行良好的配合，包括numpy、scikit-learn、matplotlib、seaborn、plotly等。</p><p>可以通过pip或者conda来进行pandas的安装，使用install命令即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install pandas<br>conda install pandas<br></code></pre></td></tr></table></figure><p>我们在代码中通常以pd的形式引入Pandaspackage，后面也都遵循这种约定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h2 id="数据读取">数据读取</h2><p>Pandas主要面对的是有行列的表结构，并且使用DataFrameClass来进行表征，表的每一列又对应一个Class，为Series。因此学习Pandas的核心就在于学习DataFrame以及Series的操作。（主要是DataFrame）</p><p>DataFrame包含行和列，每一列有自己的列名，每一行也会有一个index，这个index可以由系统自动生成，此时index为从0自增的自然数，也可以由用户指定某一列为index。</p><blockquote><p>Pandas中的index：在Pandas中，index主要可以提供如下功能</p><ul><li>更方便的数据查询</li><li>使用index可以获得性能提升<ul><li>如果index是唯一的，pandas会使用哈希表优化，查询性能为O(1)</li><li>如果index不是唯一的，但是有序，Pandas会使用二分查找算法，查询性能为O(logN)</li><li>如果index是完全随机的，那么每次查询都要扫描全表，查询性能为O(N)</li></ul></li><li>自动的数据对齐功能<ul><li>如果将两个Series进行操作，index相同的可以进行相互操作，不相同则为空（NaN，None之类的）</li></ul></li><li>更多更强大的数据结构支持<ul><li>CategoricalIndex：基于分类数据的index，提升性能</li><li>MultiIndex：多维索引，用于groupby多维聚合后结果等</li><li>DatetimeIndex：时间类型索引，强大的日期和时间的方法支持</li></ul></li></ul></blockquote><p>Pandas支持从多种格式的数据进行读取，并生成表结构，常用的数据来源有csv、txt、excel、json、mysql数据库等，它们分别可以用不同的api来进行读取：</p><table><thead><tr class="header"><th>数据类型</th><th>说明</th><th>读取方法</th></tr></thead><tbody><tr class="odd"><td>csv、tsv、txt</td><td>用逗号或tab分隔的纯文本文件</td><td>pd.read_csv</td></tr><tr class="even"><td>excel</td><td>xls或者xlsx文件(支持sheet的选择)</td><td>pd.read_excel</td></tr><tr class="odd"><td>json</td><td>json文件，每一列数据按照index：value分开存储</td><td>pd.read_json</td></tr><tr class="even"><td>mysql</td><td>关系型数据库表</td><td>pd.read_sql</td></tr></tbody></table><p>其中最为常用的是<code>pd.read_csv</code>，它支持下面一些常用的参数：</p><ul><li><p><code>filepath_or_buffer</code>：支持csv、tsv、txt等文件路径，这个文件路径也可以是一个URL链接，链接对应内容为以指定字符分隔的文本</p></li><li><p><code>header</code>：指定以哪一行作为header，为None表示没有header。默认使用第1行</p></li><li><p><code>index_col</code>：指定以哪一列作为index列，默认为自增index。可以传入数字（从0开始），也可以传入列名</p></li><li><p><code>sep='\t',</code>：指定分隔符</p></li><li><p><code>names</code>：接受一个字符串数组，用于自定义列名</p></li><li><p><code>usecols</code>：接受一个字符串数组，表示仅读取指定列到内存当中</p></li></ul><p>如果要读取数据库中的表，那么需要先建立连接，在read方法中提供连接参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>conn = pymysql.connect(<br>   host=<span class="hljs-string">&#x27;xxx.x.x.x&#x27;</span>,<br>   user=<span class="hljs-string">&#x27;xxx&#x27;</span>,<br>   passward=<span class="hljs-string">&#x27;xxx&#x27;</span>,<br>   database=<span class="hljs-string">&#x27;xxx&#x27;</span>,<br>   charset=<span class="hljs-string">&#x27;xxx&#x27;</span>) <span class="hljs-comment"># 数据库配置</span><br><br>mysql_page = pd.read_sql(<br>   <span class="hljs-string">&quot;select * from xxx表名&quot;</span>, <span class="hljs-comment"># 这是SQL语句</span><br>   con = conn<br>)<br></code></pre></td></tr></table></figure><p>除了从文件中读取数据，我们还可以从列表或者字典中创建Series或者DataFrame。</p><p>对于Series来说，我们可以从列表或者字典中创建Series对象。如果传入的是列表，那么index就是默认的自增index；如果传入的是字典dict，那么其中的key就变为index。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从list中创建, 通过name指定列名</span><br>li = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>series = pd.Series(li, name=<span class="hljs-string">&#x27;col&#x27;</span>)<br><br><span class="hljs-comment"># 从dict中创建</span><br><span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&#x27;index0&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;index1&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;index2&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;index3&#x27;</span>:<span class="hljs-number">4</span>&#125;<br>series = pd.Series(<span class="hljs-built_in">dict</span>, name=<span class="hljs-string">&#x27;col&#x27;</span>)<br><br><span class="hljs-comment"># 查询Series</span><br>series[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 返回原生数据类型</span><br>series[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]  <span class="hljs-comment"># 返回Series</span><br></code></pre></td></tr></table></figure><p>对于DataFrame来说，我们可以从字典中创建Series对象，其中每一个Key对象是一个列表，此时字典的每个Key表示一列，列表中的每个value就是对应一行的值。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从dict中创建，通过index=[...]指定index</span><br><span class="hljs-built_in">dict</span> = &#123;<br>    <span class="hljs-string">&#x27;col1&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],<br>    <span class="hljs-string">&#x27;col2&#x27;</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br>&#125;<br>df = pd.DataFrame(<span class="hljs-built_in">dict</span>, index=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])  <br></code></pre></td></tr></table></figure></p><h2 id="数据保存">数据保存</h2><p>Pandas同样允许将DataFrame对象输出成各种格式的文件，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># output to csv</span><br>df.to_csv(<span class="hljs-string">&quot;test_out.csv&quot;</span>, index=<span class="hljs-literal">False</span>)<br><br><span class="hljs-comment"># output to json</span><br>df.to_json(<span class="hljs-string">&quot;test_out.json&quot;</span>)<br><br><span class="hljs-comment"># output to text, 需要手动指定分隔符</span><br>df.to_csv(<span class="hljs-string">&#x27;test_out.txt&#x27;</span>, header=df.columns, index=<span class="hljs-literal">False</span>, sep=<span class="hljs-string">&#x27; &#x27;</span>)<br><br><span class="hljs-comment"># output to excel</span><br>df.to_excel(<span class="hljs-string">&quot;test_out.xlsx&quot;</span>, index=<span class="hljs-literal">False</span>)<br><br></code></pre></td></tr></table></figure><h2 id="基础数据操作">基础数据操作</h2><h3 id="信息查询">信息查询</h3><p>在通过read方法得到了DataFrame对象之后，可以通过一些简单的方法来初步查看该数据的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">df.head()  <span class="hljs-comment"># 查看前5行</span><br><br>df.tail(n=<span class="hljs-number">10</span>)  <span class="hljs-comment"># 查看后10行</span><br><br>df.shape  <span class="hljs-comment"># 查看行列数目，几行几列，先行后列。注意index列不计算在shape中</span><br><br>df.index  <span class="hljs-comment"># 显示index名</span><br><br>df.columns  <span class="hljs-comment"># 显示列名</span><br><br>df.info()  <span class="hljs-comment"># 显示概述，包括每列的名词、非空值、类型以及占用空间等</span><br><br>df.describe()  <span class="hljs-comment"># 显示所有数字列的统计摘要，包括平均值、最大最小值、标准差、分位数等</span><br>df.describe().T  <span class="hljs-comment"># df.describe()得到的结果也是一个DataFrame，可以使用T来查看转置效果</span><br></code></pre></td></tr></table></figure><h3 id="行列查询">行列查询</h3><p>在DataFarme中，对行列查询是基本操作。</p><p>下面是查询行的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询行需要通过index来完成</span><br>df.loc[index] <span class="hljs-comment"># 返回一行，index是对应索引值</span><br><br>df.loc[[index1,index2, ...]] <span class="hljs-comment"># 返回多行</span><br><br>df.loc[index1:index3] <span class="hljs-comment"># 使用切片，此方式包含末尾元素</span><br><br>df.iloc[] <span class="hljs-comment"># 传入的是数字位置（第几个）其余用法与.loc相同</span><br></code></pre></td></tr></table></figure><p>下面是查询列的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询列需要通过列名来完成</span><br>df[column]  <span class="hljs-comment"># 返回一列，column是对应列名</span><br>df.column  <span class="hljs-comment"># 直接用.来调用</span><br><br>df[[column1, column2, ...]]  <span class="hljs-comment"># 返回多列，中间列表是多列对应的名称</span><br></code></pre></td></tr></table></figure><p>下面是行列同时查询的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># .loc可以同时指定行和列，通过逗号隔开，前面是行范围，后面是列范围</span><br><span class="hljs-comment"># 行列范围的指定和上面单独指定行列是相同的，包括单个label值，列表，切片等</span><br>df.loc[index, column]<br>df.loc[index, [column1, column2, ...]]<br>df.loc[[index1, index2, ...], column]<br>df.loc[[index1, index2, ...], [column1, column2, ...]]<br></code></pre></td></tr></table></figure><p>并且在查询的时候，我们可以结合判断条件来尽心过滤和筛选。实际上条件表达式会返回一个由布尔值组成的Serise，长度正好是整个DataFrame的长度。在返回结果的时候，类似于传递了一个Mark，只有当Series对应位置上是True的时候，该行才会返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 条件表达式的使用:df[条件表达式]</span><br><span class="hljs-comment"># 单条件查询</span><br>df[df[<span class="hljs-string">&#x27;age&#x27;</span>] &gt;= <span class="hljs-number">18</span>]<br><br><span class="hljs-comment"># 多条件查询，每个条件都使用()&amp;()进行连接</span><br>df[(df[<span class="hljs-string">&#x27;age&#x27;</span>] &gt;= <span class="hljs-number">18</span>) &amp; (df[<span class="hljs-string">&#x27;unit&#x27;</span>] == <span class="hljs-string">&#x27;catchu&#x27;</span>)]<br><br><span class="hljs-comment"># 由于条件表达式是对行的选取规则，因此也可以用在.loc中</span><br>df.loc[df[<span class="hljs-string">&#x27;age&#x27;</span>]==<span class="hljs-number">18</span>]<br><br><span class="hljs-comment"># 字符串列的使用方式</span><br>df[df[<span class="hljs-string">&#x27;name&#x27;</span>].<span class="hljs-built_in">str</span>.startswith(<span class="hljs-string">&#x27;k&#x27;</span>)]<br></code></pre></td></tr></table></figure><p>这里需要注意的是，如果某一列Series中存放的是字符串类型的数据，我们是无法直接调用字符串某个确切的字符串对应的方法的，而是需要先获取Series的str属性，然后在属性上调用函数。<code>Series.str</code>不是python的原生字符串，而是自己的一套方法，不过大部分和原生str很相似，可以参考<ahref="https://pandas.pydata.org/docs/reference/series.html#string-handling">SeriesString hadnling｜pandas</a>。</p><h3 id="新增或修改数据列">新增或修改数据列</h3><p>在Pandas中可以使用直接修改，<code>df.apply</code>等方式来新增或修改数据。</p><p>直接修改指的是利用<code>.loc</code>方法进行定位，然后直接指定对应的value：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[index, column] = xxx <span class="hljs-comment"># 修改某行某列的值 xxx = one value</span><br><br>df.loc[:, column] = xxx <span class="hljs-comment"># 修改某列的值 xxx = one series</span><br><br>df.loc[index, :] = xxx <span class="hljs-comment"># 修改某行的值 xxx = one series</span><br><br><span class="hljs-comment"># 同样可以用来新增数据</span><br>df.loc[:, new_column] = xxx  <span class="hljs-comment"># 新增一列 xxx = one series</span><br></code></pre></td></tr></table></figure><p><code>df.apply</code>方法的返回值是一个Series，它的含义是沿着DataFrame的某一个轴执行函数，相当于每次传入了一个Series，然后得到一个value。最终所有的value组成一个Serise。</p><ul><li>axis=0：沿着横轴方向，每次传入一列给函数，最终得到的Series是横向的</li><li>axis=1：沿着竖轴方向，每次转入一行给函数，最终得到的Series是竖向的</li></ul><blockquote><p>可以理解为axis表示最终得到的结果与哪个轴相同，axis=0表示最终得到的Series与x轴相同，即得到的Series是横向的。</p><p>这样理解的话，axis=0表示水平轴，axis=1表示垂直轴，与numpy中有所区别，建议实际使用过程中直接尝试不同的axis查看对应的效果，毕竟只有两个选项。</p></blockquote><p>利用apply方法可以新增一列或者一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 新增一行</span><br>df.loc[<span class="hljs-number">0</span>, :] = df.apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">len</span>(x), axis=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 新增一列</span><br>df.loc[:, <span class="hljs-string">&#x27;age+1&#x27;</span>] = df.apply(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;age&#x27;</span>] + <span class="hljs-number">1</span>, axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="列名index处理">列名/index处理</h3><p>列名处理指的是我们可以修改DataFrame的列名，一共有两种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接通过修改属性来修改列名，此方式需要给出所有的列名</span><br>df.column = [xxx,xxx,xxx,...]  <br><br><span class="hljs-comment"># 通过提供dict来修改列名，指定旧列名以及目标新列名</span><br>df.rename(columns = &#123;old_col: new_col&#125;, inplace=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>index处理指的是我们可以修改DataFrame的Index：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 重新设定index</span><br>df.set_index(<span class="hljs-string">&#x27;指定列&#x27;</span>,inplace=<span class="hljs-literal">False</span>, drop=<span class="hljs-literal">False</span>)  <br><br><span class="hljs-comment"># - inplace：表示是否要替换原有索引（对应单索引和复合索引）</span><br><span class="hljs-comment"># - drop：表示是否要丢弃这一列索引数据，如果为False表示将索引仍然保留作为表格内容</span><br><br><span class="hljs-comment"># 还原索引，重新变为默认的整型索引</span><br>df.reset_index()<br></code></pre></td></tr></table></figure><h3 id="缺失值处理">缺失值处理</h3><p>在处理缺失值之前，首先需要检测缺失值。Pandas提供了<code>isnull()</code>和<code>notnull()</code>等方法来判断空值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以下方法均返回一个DataFrame，其中每个单元格的Value是一个布尔值，代表当前单元格是否为空。注意isnull和isna，notnull和notna完全相同。</span><br>df.isnull() <br>df.isna()<br>df.notnull()<br>df.notna()<br></code></pre></td></tr></table></figure><p>一种处理缺失值的方式是直接丢弃缺失值，Pandas中提供<code>dropna</code>方法来删除缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.dropna(axis=<span class="hljs-number">0</span>|<span class="hljs-number">1</span>, how=<span class="hljs-built_in">any</span>|<span class="hljs-built_in">all</span>, inplace=<span class="hljs-literal">True</span>|<span class="hljs-literal">False</span>, subset=[xxx])<br></code></pre></td></tr></table></figure><ul><li><code>axis</code>：删除行还是列，可选值为0或1<ul><li>等于0或者index表示按行删除，默认为0</li><li>等于1或者columns表示按列删除</li></ul></li><li><code>how</code>：可选值为any或all<ul><li>any：出现空值就删除</li><li>all：所有都是空值才删除</li></ul></li><li><code>inplace</code>：布尔值，是否修改当前df<ul><li>True：修改当前df</li><li>False：返回新的df</li></ul></li><li><code>subset</code>：表示接受空值判断的子集columns</li></ul><p>另外一种处理缺失值的方式是进行填充，Pandas中提供<code>fillna</code>方法来填充缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.fillna(value=xxx, method=xxx, axis=<span class="hljs-number">0</span>|<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>|<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li><code>value</code>：用于填充的值，可以是单个值，或者字典（key是列名，value是值），如果是填充字典的情况，则表示检测key那一列，如果是空，就替换为value。这样使得我们能够对不同列采取不同的填充措施。</li><li><code>method</code>：填充方法，可选值为backfill、ffill、bfill<ul><li>ffill：使用前一个不为空的值进行填充</li><li>backfill/bfill：使用后一个不为空的值进行填充</li></ul></li><li><code>axis</code>：按行填充还是列填充，同dropna</li><li><code>inplace</code>：是否修改当前df，同dropna</li></ul><h3 id="重复值处理">重复值处理</h3><p>Pandas中提供drop_duplicates方法来进行去重，此方法可以接收列名，表示按照哪一列或者哪几列进行去重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df.drop_duplicates()  <span class="hljs-comment"># 按照所有列去重</span><br>df.drop_duplicates(<span class="hljs-string">&#x27;name&#x27;</span>)  <span class="hljs-comment"># 按照name列去重</span><br>df.drop_duplicates([<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>])  <span class="hljs-comment"># 按照name和age列去重</span><br></code></pre></td></tr></table></figure><h3 id="数据排序">数据排序</h3><p>Pandas同样支持数据的排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对于Series来说，排序方法为</span><br>Series.sort_values(ascending=<span class="hljs-literal">True</span>, inplace=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># - ascending：默认为True升序排序，为False降序排序</span><br><span class="hljs-comment"># - inplace：是否修改原始Series</span><br><br><span class="hljs-comment"># 对于DataFrame来说，排序方法为</span><br>DataFrame.sort_values(by,ascending=<span class="hljs-literal">True</span>,inplace=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># - by：排序的基准，可以提供单个列名或者列名数组</span><br><span class="hljs-comment"># - ascending：bool或者List，升序还是降序，如果是List则对应by的多列</span><br><span class="hljs-comment"># - inplace：是否修改原始DataFrame</span><br></code></pre></td></tr></table></figure><h3 id="数据统计">数据统计</h3><p>常见的数据统计方法有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">.mean()  <span class="hljs-comment"># 平均值</span><br>.<span class="hljs-built_in">max</span>()  <span class="hljs-comment"># 最大值</span><br>.<span class="hljs-built_in">min</span>()  <span class="hljs-comment"># 最小值</span><br>.<span class="hljs-built_in">sum</span>()  <span class="hljs-comment"># 求和</span><br>.unique() <span class="hljs-comment"># 可以查看一列中有哪些值</span><br>.nunique() <span class="hljs-comment"># 返回某一列的不重复值的个数</span><br>.value_counts()  <span class="hljs-comment"># 可以查看有哪些值并进行计数</span><br>df.cov()  <span class="hljs-comment"># 协方差矩阵</span><br>df.corr()  <span class="hljs-comment"># 相关系数矩阵</span><br>df[<span class="hljs-string">&#x27;xxx&#x27;</span>].corr(df[<span class="hljs-string">&#x27;yyy&#x27;</span>])  <span class="hljs-comment"># 单独查看两列的相关系数</span><br></code></pre></td></tr></table></figure><h2 id="高级数据操作">高级数据操作</h2><h3 id="merge">Merge</h3><p>Pandas中的Merge，相当于Sql中的join，方法签名如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">pd.merge(left,right,on=<span class="hljs-literal">None</span>,left_on=<span class="hljs-literal">None</span>,right_on=<span class="hljs-literal">None</span>,left_index=<span class="hljs-literal">False</span>,right_index=<span class="hljs-literal">False</span>,suffixes=(<span class="hljs-string">&#x27;_x&#x27;</span>,<span class="hljs-string">&#x27;_y&#x27;</span>),copy=<span class="hljs-literal">True</span>,indicator=<span class="hljs-literal">False</span>,validate=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li><code>left,right</code>：需要进行join的左表和右表</li><li><code>how</code>：join类型，有left、right、outer、inner，与sql中的连接定义一致</li><li><code>on</code>：进行join的key，left和right都需要有这个key</li><li><code>left_on</code>：left的df或series的key</li><li><code>right_on</code>：right的df或series的key</li><li><code>left_index,right_index</code>：使用index而不是普通的column做join</li><li><code>suffixes</code>：两个元素的后缀，如果列有重名，自动添加后缀</li></ul><h3 id="concat">Concat</h3><p>Pandas中的concat用于合并相同格式的数据，可以完成上下拼接或者左右拼接，给DataFrame添加行或者列。合并时按照索引或者列名进行对齐，方法签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat(objs,axis=<span class="hljs-number">0</span>,join=<span class="hljs-string">&#x27;outer&#x27;</span>,ignore_index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li><code>objs</code>：接收一个列表，其中的元素可以是DataFrame，Series或两者混合</li><li><code>axis</code>：默认0代表按行合并，1表示按列合并</li><li><code>join</code>：合并的时候索引的对齐方式，默认为outer，也可以是inner</li><li><code>ignore_index</code>：是否忽略掉原来的数据索引</li></ul><h3 id="groupby">GroupBy</h3><p>Pandas中的<code>groupby</code>方法可以做到先对数据进行分组，然后在每个分组上应用聚合函数或者转换函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">groupby(<span class="hljs-string">&#x27;columns&#x27;</span>)  <span class="hljs-comment"># 原来的columns变成索引，以此看其他列</span><br><br>groupby([<span class="hljs-string">&#x27;columns1&#x27;</span>,<span class="hljs-string">&#x27;colunms2&#x27;</span>,...])  <span class="hljs-comment"># 形成多级索引（分层索引）</span><br><span class="hljs-comment"># as_index=False：指定不要形成多级索引</span><br><br><span class="hljs-comment"># 如果需要同时查看多种数据统计，可以使用.agg方法</span><br><span class="hljs-comment"># import numpy as np</span><br>df.groupby(<span class="hljs-string">&#x27;unit&#x27;</span>).agg([np.<span class="hljs-built_in">sum</span>, np.count_nonzero])<br><span class="hljs-comment"># 也可以传dict作为参数，指定对特定列执行特定的操作</span><br>df.groupby(<span class="hljs-string">&#x27;unit&#x27;</span>).agg(&#123;<span class="hljs-string">&#x27;age&#x27;</span>:np.mean,<span class="hljs-string">&#x27;name&#x27;</span>:np.count_nonzero&#125;)<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://www.datacamp.com/tutorial/pandas">pandastutorial|datacamp</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Conda相关操作记录</title>
    <link href="/2023/08/05/Conda%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/08/05/Conda%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="conda虚拟环境">Conda虚拟环境</h1><ol type="1"><li>Conda虚拟环境的基本管理</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># conda 虚拟环境列表</span><br>conda <span class="hljs-built_in">env</span> list<br><br><span class="hljs-comment"># 创建虚拟环境</span><br>conda create -n &lt;env_name&gt; python=x.x<br><br><span class="hljs-comment"># 激活虚拟环境</span><br>conda activate &lt;env_name&gt;<br><br><span class="hljs-comment"># 退出虚拟环境</span><br>deactivate<br><br><span class="hljs-comment"># 删除虚拟环境</span><br>conda remove -n &lt;env_name&gt; --all<br></code></pre></td></tr></table></figure><p>各个虚拟环境之间是隔离的，体现在文件夹中，每个环境都被存放在<code>$ANACONDA_PATH/envs/&lt;env_name&gt;</code>目录下。</p><ol start="2" type="1"><li>关闭Conda base环境自动激活</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 设置auto_activate_base参数为false</span><br>conda config --<span class="hljs-built_in">set</span> auto_activate_base <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># 需要激活base环境时</span><br>conda activate base<br><br><span class="hljs-comment"># 如果想要恢复自动激活base环境</span><br>conda config --<span class="hljs-built_in">set</span> auto_activate_base <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h1 id="jupyter配置">jupyter配置</h1><ol type="1"><li>jupyter支持Conda虚拟环境</li></ol><p>默认情况下打开jupyternotebook是无法检测到Conda中的虚拟环境，需要进行如下配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 首先在base环境下安装nb_conda_kernels </span><br>conda install nb_conda_kernels <br><br><br><span class="hljs-comment"># 之后其他虚拟环境需要安装ipykernel才能显示在juypter的检测环境中</span><br>conda install ipykernel<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>jupyter支持代码提示和补全</li></ol><p>默认情况下，通过浏览器打开jupyternotebook是没有代码提示与自动补全功能的，可以参考xxx，通过安装相关插件来增加对应功能。</p><p>当然也可以通过在Pycharm中使用jupyter来解决。利用Pycharm打开<code>.ipynb</code>文件，其中会自带代码提示和补全的支持。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://blog.51cto.com/u_15127622/4594568">anaconda取消每次默认启动base环境_mob604756fa6ad7的技术博客</a></li><li><ahref="https://blog.csdn.net/u014264373/article/details/119390267">如何在Jupyter Notebook 中切换/使用 conda 虚拟环境？_jupyter notebook condaenv_Tina姐的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Conda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Numpy基础笔记</title>
    <link href="/2023/08/04/Numpy%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/08/04/Numpy%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p><ahref="https://numpy.org/doc/stable/index.html">Numpy</a>是一个功能强大的Python第三方pacakge，它为我们提供了一个非常强大的数据结构，n维数组，即<code>numpy.ndarray</code>。它是几乎所有Python数据科学工具包的基础。</p><p>Numpy底层使用C语言编写，因此相比与原生Python，它具有非常快的速度。同时，Numpy使用向量化Vectorization技术来减少代码中显式出现循环的次数，使得代码具有更好的可读性，更适合用于描述复杂的数学方程。可以说，Numpy就是PythonData science中多维数组的事实标准。</p><p>numpy的安装非常简单，直接使用pip或者conda进行即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install numpy<br>conda install numpy<br></code></pre></td></tr></table></figure><p>在代码中进行引入的时候，通常会将numpy引入为<code>np</code>，后续我们也都遵循这个约定。同时后面在进行描述的时候，可能会涉及到数组、矩阵等表述，在大多数语境下，这两者指的是同一个东西，都是<code>ndarray</code>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><blockquote><p>如果只是为了学习相关编程语言，那么可以使用一个在线Code网站<ahref="https://replit.com/">replit</a>，它允许我们直接通过浏览器来实时运行代码。</p></blockquote><h1 id="核心概念">核心概念</h1><p>n维数组<code>np.ndarray</code>是Numpy中的核心和基础，学习Numpy最重要的就是学习这个类以及相关方法的使用。不过在此之前，有必要先了解Numpy中的几个核心概念，包括shape、axis、vectorization和broadcasting，理解这些概念有利于更好地把握numpy的运行机制。</p><h2 id="shape">Shape</h2><p>对于n维数组来说，它的形状shape是非常重要的一个属性，我们可以通过<code>.shape</code>来查看数组的形状，也可以使用<code>.reshape()</code>方法来改变数组的形状。在使用ndarray的过程中，shape是一个非常基本的，也是我们应该非常关注的一个属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">table = np.arange(<span class="hljs-number">24</span>).reshape((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-comment"># table.shape</span><br>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment"># table输出如下:</span><br>array([[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],<br>        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],<br>        [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]],<br><br>       [[<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],<br>        [<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],<br>        [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>]]])<br></code></pre></td></tr></table></figure><p>对于二维数组来说，shape可以告诉我们这个数组有几行几列，但是对于更高维度的情况，就比较难直观地理解shape的含义。我们可以从数组嵌套的角度来理解shape，计算shape的过程就是一个逐层去除嵌套的过程。例如上面的table是一个三维的数组，它的shape为<code>(2, 3, 4)</code>。结合它的输出，第一个2表示去掉第一层<code>[]</code>，我们可以得到两个元素；第二个3表示对于上面的每个元素，再次解除嵌套去掉<code>[]</code>，可以得到三个元素；以此类推。</p><p>而<code>reshape</code>方法则是上面这个过程的逆过程。对于一个需要进行reshape的矩阵，我们首先可以将其进行flatten，即拍平成一个一维矩阵，之后按照shape进行逐层的分配，最终得到期望的形状。</p><h2 id="axis">Axis</h2><p>与shape紧密相关的概念是axis轴，或者可以理解为维度。对于一个矩阵来说，我们希望知道它的shape，同时也希望了解哪些数据位于哪些轴上。在numpy的数组中，轴从0开始进行索引，依次递增。从最外层<code>[]</code>开始是axis=0轴，逐步进入内部轴的索引也依次增加。例如对于二维数组来说，垂直轴为0轴，水平轴为1轴。</p><p>axis与shape也有对应关系。如果一个数组维度为<code>n</code>，那么它的axis最高就是<code>n-1</code>，同时它的shape也就是一个含有<code>n</code>个数字的tuple。实际上我们可以将shape理解为在描述每个axis上具有多少个元素。例如上面例子中的三维数组table，shape为<code>(2, 3, 4)</code>，则代表在axis=0上有2个元素，在axis=1上有3个元素，在axis=2上有4个元素。这里的元素指的不是最小单位数字，而是可能由多个数字构成的，具有类似结构的组合。</p><p>在Numpy中，有许多方法会根据是否指定axis来改变对应的行为。以<code>.max()</code>方法为例，有如下测试结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">table = np.arange(<span class="hljs-number">24</span>).reshape((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-comment"># shape: (2, 3, 4)</span><br><span class="hljs-comment"># axis:  (0, 1, 2)</span><br><span class="hljs-comment"># table output: </span><br>array([[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],<br>        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],<br>        [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]],<br><br>       [[<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],<br>        [<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],<br>        [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>]]])<br><br><span class="hljs-comment"># table.max() </span><br><span class="hljs-number">23</span><br><br><span class="hljs-comment"># table.max(axis=0)</span><br><span class="hljs-comment"># shape: (3, 4)</span><br>array([[<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],<br>       [<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],<br>       [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>]])<br><br><span class="hljs-comment"># table.max(axis=1)</span><br><span class="hljs-comment"># shape: (2, 4)</span><br>array([[ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],<br>       [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>]])<br><br><span class="hljs-comment"># table.max(axis=2)</span><br><span class="hljs-comment"># shape: (2, 3)</span><br>array([[ <span class="hljs-number">3</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>],<br>       [<span class="hljs-number">15</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>]])<br></code></pre></td></tr></table></figure><p>可以看到，如果没有指定axis，那么numpy默认将所有的最小单元纳入考虑，相当于将整个数组拍平之后进行函数计算。而如果指定了axis，那么在计算过程中会沿着对应轴走，每次传入在该轴对应维度下的一个元素。<strong>对于聚合函数来说，沿着哪个轴走，最终得到的arrayshape就会消除掉哪一个维度</strong>（轴对应的维度），这点也可以在最终结果的shape中发现。此时可以将单个数字看作特殊的零维矩阵。</p><p>事实上，Numpy的许多函数都是这样运行的：如果没有指定轴，那么它们会对整个数据集执行操作。否则，它们以轴方式执行操作。</p><h2 id="vectorization">Vectorization</h2><p>Vectorization，又称矢量化，它指的是<strong>对数组中的每个元素以相同的方式执行相同的操作</strong>。该操作与for循环执行得到的结果相同，但是在代码中不需要出现for关键字，以此提高可读性。矢量化计算是Numpy能够做到干净，可读性的关键。虽然向量化并不会提高甚至有可能降低执行性能，但是相比于它带来的巨大可读性，这些性能损耗是可以接受的。</p><p>Numpy自身提供的方法大都能够进行矢量化，但是有些时候我们会使用到其他Package的方法，如果也想矢量化，那么需要使用<ahref="https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html">np.vectorize()</a>方法来获得该方法的矢量化版本。例如我们需要使用阶乘函数，即<code>math.factorial</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> factorial<br><br>a = np.arange(<span class="hljs-number">10</span>).reshape((<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>))<br>factorial(a)<br></code></pre></td></tr></table></figure><p>直接使用会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">TypeError: only <span class="hljs-built_in">integer</span> scalar arrays can be converted to a scalar index<br></code></pre></td></tr></table></figure><p>此时需要先创建阶乘函数的向量化版本，之后才能正常使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> factorial<br><br>factorial_vectorization = np.vectorize(factorial)<br>a = np.arange(<span class="hljs-number">10</span>).reshape((<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>))<br>factorial_vectorization(a)<br></code></pre></td></tr></table></figure><h2 id="broadcasting">Broadcasting</h2><p>Broadcasting，也称为广播，它是扩展两个不同形状的数组并弄清楚如何在它们之间执行矢量化计算的过程。</p><p>通常两个数组之间能够进行计算，是因为它们的维度能够相互匹配。例如对于数组加法，如果要进行数组之间的加法，这两个数组必须具有相同的shape。但是在numpy中，有时候两个数组的shape并不相同，但是它们仍然能够完成计算，这就是Broadcasting在发挥作用。</p><p>Broadcasting有一个核心规则：<strong>如果数组的维度匹配或者其中一个数组的大小为1，则数组可以相互广播</strong>。如果数组沿轴的大小匹配，则将逐个元素对元素进行操作，类似于内置Python 函数 zip() 的工作方式。如果其中一个数组在轴上的大小为1，则该值将沿该轴进行广播，即重复多次，以匹配另一个数组中沿该轴的元素数量。</p><p>以下面的例子来进行说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">3</span>).reshape((<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))<br><span class="hljs-comment"># a output:</span><br>array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]])<br><br>b = np.arange(<span class="hljs-number">3</span>).reshape((<span class="hljs-number">3</span>,<span class="hljs-number">1</span>))<br><span class="hljs-comment"># b output:</span><br>array([[<span class="hljs-number">0</span>],<br>       [<span class="hljs-number">1</span>],<br>       [<span class="hljs-number">2</span>]])<br><br>c = a + b<br><span class="hljs-comment"># c.shape: (3, 3)</span><br><span class="hljs-comment"># c = a+b: output</span><br>array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>       [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>       [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])<br><span class="hljs-comment"># progress:</span><br><span class="hljs-comment"># broadcasting of a</span><br>[<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>]<br><br><span class="hljs-comment"># broadcasting of b</span><br>[<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<br>]<br></code></pre></td></tr></table></figure><p>在上面的例子中，数组a的shape为<code>(1, 3)</code>，数组b的shape为<code>(3, 1)</code>，这两个数组进行加法运算，需要维度的匹配。经过观察可以发现，a和b可以进行广播，并且最终匹配的shape是<code>(3, 3)</code>。而广播实际上就是一个沿着某一个轴重复的过程。例如这里的数组a需要广播到<code>(3, 3)</code>，因此它需要沿着axis=0轴进行元素重复；数组b需要广播到<code>(3, 3)</code>，它需要沿着axis=1轴进行元素重复。两个数组都广播到相同shape之后，就可以按照位置对应进行加法计算了。</p><p>不过需要注意只有在某个轴上大小为1时才能进行Broadcasting，否则会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ValueError: operands could not be broadcast together with shapes ...<br></code></pre></td></tr></table></figure><h1 id="基础操作">基础操作</h1><h2 id="ndarray创建">ndarray创建</h2><h3 id="np.array">np.array</h3><p>在之前的操作中我们使用<code>np.arange</code>来创建过数组，得到的是一个从0到指定值的递增序列。同样我们可以通过<code>np.array()</code>来从python序列类型中创建ndarray，注意其中提供的list嵌套形状就是最终矩阵的shape，而元素类型会由numpy自动推断，当然也可以通过<code>dtype</code>属性进行手动指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<br>    [<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>],<br>    [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>])<br><br>a.ndim  <span class="hljs-comment"># 2</span><br><br>a.shape  <span class="hljs-comment"># (2, 4)</span><br><br>a.size  <span class="hljs-comment"># 8</span><br><br>a.dtype  <span class="hljs-comment"># dtype(&#x27;int64&#x27;)</span><br><br>a.dtype.name  <span class="hljs-comment"># &#x27;int64&#x27;</span><br></code></pre></td></tr></table></figure><p>ndarray的常用属性如下：</p><ul><li><code>ndim</code>：数组的维度，也是shapetuple的元素个数，也是轴的个数</li><li><code>shape</code>：数组的形状</li><li><code>size</code>：数组所有元素的个数，是shapetuple中所有值的乘积</li><li><code>dtype</code>：数组中元素的类型</li></ul><p>在ndarray中，所有的元素都需要具有相同的类型，常用的类型有下面这些，完成的支持类型列表可以参考<ahref="https://numpy.org/devdocs/user/basics.types.html">Data Types|NumpyDocumentation</a>。</p><table><thead><tr class="header"><th>C type</th><th>numpy type</th></tr></thead><tbody><tr class="odd"><td>bool</td><td>np.bool_</td></tr><tr class="even"><td>int</td><td>np.intc</td></tr><tr class="odd"><td>long</td><td>np.int_</td></tr><tr class="even"><td>float</td><td>np.single</td></tr><tr class="odd"><td>double</td><td>np.double</td></tr></tbody></table><blockquote><p>在Numpy中使用字符串多少有点奇怪，但是Numpy确实也能够支持。不过因为这种用法确实非常少见，这里不进行更加细致的描述</p></blockquote><h3 id="other-method">other method</h3><p>下面列出了一些其他常用的特殊数组创建方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># zeros: 全零矩阵</span><br>np.zeros((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>))<br>array([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],<br>       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])<br><br><span class="hljs-comment"># ones: 全一矩阵</span><br>np.ones((<span class="hljs-number">3</span>, <span class="hljs-number">2</span>))<br>array([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>       [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>       [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])<br><span class="hljs-comment"># arange: 通过range构造序列再生成矩阵</span><br><span class="hljs-comment"># 生成的矩阵都是1维的，可以通过reshape进行变换</span><br>np.arange(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment"># reshape最后一个值为-1表示自动计算</span><br>np.arange(<span class="hljs-number">10</span>).reshape((<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># empyt: 随机矩阵</span><br>np.empty((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><br><span class="hljs-comment"># linspace: 在范围内均匀生成指定元素个数</span><br><span class="hljs-comment"># 解决在arrage中无法通过step精确控制矩阵元素个数的问题</span><br>np.linspace(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">7</span>)<br><br><span class="hljs-comment"># random: 返回[0, 1)之间的随机值</span><br><span class="hljs-comment"># 生成一维矩阵</span><br>np.random.random(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># randn: 按照标准正态分布随机</span><br><span class="hljs-comment"># 生成一维矩阵</span><br>np.random.randn(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h2 id="数学计算">数学计算</h2><p>由于Numpy支持向量化，因此利用Numpy来进行数学计算变得非常直观：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>])<br>b = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># 以下方法均返回一个新的对象，而非在原对象上修改</span><br><br><span class="hljs-comment"># 矩阵加法</span><br>a + b<br><span class="hljs-comment"># 矩阵减法</span><br>a - b<br><span class="hljs-comment"># 矩阵点乘（对应位置相乘）</span><br>a * b<br><span class="hljs-comment"># 矩阵乘法: @ 或者.dot()</span><br>a.reshape((<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)) @ b.reshape((<span class="hljs-number">1</span>, <span class="hljs-number">4</span>))<br>a.reshape((<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)).dot(b.reshape((<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)))<br><span class="hljs-comment"># 逐元素操作</span><br>a ** <span class="hljs-number">2</span><br><span class="hljs-comment"># 矩阵转置: 转置后的矩阵shape是原来的逆序</span><br>a.T<br>a.transpose()<br></code></pre></td></tr></table></figure><p>Numpy中还提供了许多通用的方法，这些方法同样支持向量化，允许直接接受一个ndarray作为输入，然后对其中的元素依次进行对应操作。更多方法可以参考官方文档<ahref="https://numpy.org/doc/stable/user/quickstart.html#functions-and-methods-overview">Functionsand Methods Overview|Numpy Documentation</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>])<br><br>np.exp(a)  <span class="hljs-comment"># e的乘方</span><br>np.sqrt(a)  <span class="hljs-comment"># 开根号</span><br>np.ceil(a)  <span class="hljs-comment"># 向上取整</span><br>np.floor(a)  <span class="hljs-comment"># 向下取整</span><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>Numpy中还有许多聚合函数，例如<code>.sum()</code>,<code>.max()</code>, <code>.mean()</code>和<code>.std()</code>等等，这些聚合函数基本都有两种运行模式，在不指定axis的情况下考虑整个矩阵，在指定axis的情况下沿着对应axis进行聚合计算。</p><h2 id="index与mark">Index与Mark</h2><h3 id="基础索引">基础索引</h3><p>在ndarray中进行取值，方法与python原生的list类似，利用<code>[]</code>完成，并且支持通过单个索引位置或者切片进行取值。不过ndarray更加灵活，它在任意一个维度上都支持索引或者切片操作。并且利用索引进行取值之后，我们也可以通过直接赋值来修改矩阵中对应的value。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">120</span>).reshape((<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>))<br>a[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>a[:,<span class="hljs-number">3</span>, <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>在Numpy中还提供了<code>...</code>表达式，它可以用来简化连续的多个<code>:</code>，例如有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># assume x has 5 axes</span><br><br>x[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ...] <span class="hljs-keyword">is</span> equivalent to x[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, :, :, :]<br><br>x[..., <span class="hljs-number">3</span>] <span class="hljs-keyword">is</span> equivalent to x[:, :, :, :, <span class="hljs-number">3</span>] <br><br>x[<span class="hljs-number">4</span>, ..., <span class="hljs-number">5</span>, :] <span class="hljs-keyword">is</span> equivalent to x[<span class="hljs-number">4</span>, :, :, <span class="hljs-number">5</span>, :]<br></code></pre></td></tr></table></figure><p>Numpy中提供一个<code>np.nonzero()</code>方法来查找数组中不为零的元素的下标，利用这个方法可以进行快速的过滤和查找。对于一个n维的数组，该方法会返回n个一维数组。这些一维数组具有相同的长度，利用类似zip的方法可以获取到每个不为零元素的下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>).reshape((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>np.nonzero(a)<br><br><span class="hljs-comment"># np.nonzero(a) output:</span><br>(array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]), array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]), array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]))<br></code></pre></td></tr></table></figure><h3 id="mark矩阵">Mark矩阵</h3><p>此外，ndarray还允许我们通过<strong>Mark矩阵</strong>来进行取值。Mark矩阵是一个和原矩阵具有相同shape的矩阵，元素类型为布尔类型。利用Mark矩阵取值的过程就是判断Mark矩阵对应位置上是否为True，为True就加入最终的结果。利用Mark矩阵进行取值，最终得到的结果是一个一维矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可以通过条件表达式来得到一个由布尔值构成的矩阵</span><br>a = np.arange(<span class="hljs-number">20</span>).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">5</span>))<br><br>mark = a % <span class="hljs-number">3</span> == <span class="hljs-number">0</span><br><span class="hljs-comment"># mark output:</span><br>array([[ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>],<br>       [<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>],<br>       [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>],<br>       [ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>]])<br><br>a[mark]<br><span class="hljs-comment"># a[mark] output:</span><br>array([ <span class="hljs-number">0</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>])<br></code></pre></td></tr></table></figure><p>我们可以通过条件表达式来得到一个由布尔值构成的矩阵，多个条件可以使用<code>&amp;</code>和<code>|</code>来进行多条件连接，注意不能使用<code>and</code>和<code>or</code>，原因是这些内置的操作符没有实现向量化。</p><h3 id="index矩阵">Index矩阵</h3><p>更进一步，Numpy允许使用<strong>index矩阵</strong>来进行索引，区别于Mark矩阵中的值都是布尔值，这个index矩阵由下标索引组成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>)**<span class="hljs-number">2</span><br><br>index = np.array([<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>],<br>    [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>],<br>])<br><br><span class="hljs-comment"># index矩阵</span><br>a[index]<br>array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">9</span>],<br>       [ <span class="hljs-number">4</span>, <span class="hljs-number">16</span>]])<br></code></pre></td></tr></table></figure><p>index矩阵完成的操作非常容易理解，实际上就是讲index中各个位置上的元素替换为被查询矩阵对应下标的元素，被查询的维度是矩阵的第一维度。以上面的举例来看，<code>a[index]</code>的计算实际上就是下面的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># index</span><br>array([[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>],<br>       [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>]])<br><span class="hljs-comment"># a[index]</span><br>array([[a[<span class="hljs-number">1</span>], a[<span class="hljs-number">3</span>]],<br>       [a[<span class="hljs-number">2</span>], a[<span class="hljs-number">4</span>]]])<br><span class="hljs-comment"># 即为</span><br>array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">9</span>],<br>       [ <span class="hljs-number">4</span>, <span class="hljs-number">16</span>]])<br></code></pre></td></tr></table></figure><p>我们还可以在矩阵的不同维度上使用index矩阵，不过要求多个index矩阵之间的shape相同。在不同维度上应用index矩阵与上面的单个index矩阵具有相同的原理，不同维度上index矩阵的值结合起来就是最终定位对应元素的依据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment"># a output</span><br>array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],<br>       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],<br>       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])<br><br><span class="hljs-comment"># two index matrix</span><br>i = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],  <span class="hljs-comment"># indices for the first dim of `a`</span><br>              [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]])<br>j = np.array([[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>],  <span class="hljs-comment"># indices for the second dim</span><br>              [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])<br><br><span class="hljs-comment"># a[i, j]</span><br><span class="hljs-comment"># array([[a[0, 2], a[1, 1]],</span><br><span class="hljs-comment">#        [a[1, 3], a[2, 3]]])</span><br>a[i, j]<br>array([[ <span class="hljs-number">2</span>,  <span class="hljs-number">5</span>],<br>       [ <span class="hljs-number">7</span>, <span class="hljs-number">11</span>]])<br><br><span class="hljs-comment"># a[i, 2] support vectorization</span><br><span class="hljs-comment"># array([[a[0, 2], a[1, 2]],</span><br><span class="hljs-comment">#        [a[1, 2], a[2, 2]]])</span><br>a[i, <span class="hljs-number">2</span>]<br>array([[ <span class="hljs-number">2</span>,  <span class="hljs-number">6</span>],<br>       [ <span class="hljs-number">6</span>, <span class="hljs-number">10</span>]])<br><br><span class="hljs-comment"># a[:, j] support silce</span><br>a[:, j]<br>array([[[ <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>], [ <span class="hljs-number">3</span>,  <span class="hljs-number">3</span>]],<br><br>       [[ <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>],<br>        [ <span class="hljs-number">7</span>,  <span class="hljs-number">7</span>]],<br><br>       [[<span class="hljs-number">10</span>,  <span class="hljs-number">9</span>],<br>        [<span class="hljs-number">11</span>, <span class="hljs-number">11</span>]]])<br></code></pre></td></tr></table></figure><h2 id="shape变换">Shape变换</h2><h3 id="reshape">reshape</h3><p>我们可以利用Numpy中提供的方法来操作单个矩阵的shape。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">60</span>).reshape((<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># 矩阵展平，返回一维矩阵</span><br>a.flatten()  <span class="hljs-comment"># 返回一个新矩阵</span><br>a.ravel()  <span class="hljs-comment"># 返回原矩阵的一个视图view</span><br><br><span class="hljs-comment"># 修改矩阵的shape</span><br>a.reshape((<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))  <span class="hljs-comment"># 返回新矩阵</span><br>a.resize((<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))  <span class="hljs-comment"># 直接修改原矩阵</span><br></code></pre></td></tr></table></figure><h3 id="新增维度">新增维度</h3><p>有时候我们可能需要为矩阵新增一个维度，表现在shape上就是在某个轴上多出一个1，此时我们可以使用numpy中提供的关键字<code>np.newaxis</code>。实际上这个关键字就是None的别名，不过具有更好的可读性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>)<br>a[np.newaxis, :].shape  <span class="hljs-comment"># (1, 6)</span><br><br>np.newaxis <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>或者可以使用numpy提供的<code>expand_dims</code>方法，通过axis指定需要在哪个轴上新增维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>)  <span class="hljs-comment"># a shape: (6,)</span><br><br>b = np.expand_dims(a, axis=<span class="hljs-number">0</span>)<br>b.shape  <span class="hljs-comment"># (1, 6)</span><br></code></pre></td></tr></table></figure><h3 id="矩阵堆叠">矩阵堆叠</h3><p>numpy中还提供多个矩阵拼接的方法，或者称为矩阵堆叠。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>    [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>])<br>b = np.array([<br>    [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>    [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br>])<br><br><span class="hljs-comment"># vstack</span><br>np.vstack((a, b))<br>array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>],<br>       [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>       [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])<br><br><span class="hljs-comment"># hstack</span><br>np.hstack((a, b))<br>array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])<br></code></pre></td></tr></table></figure><p>对于二维矩阵来说，<code>vstack</code>表示垂直(vertical)堆叠；<code>hstack</code>表示水平(horizontal)堆叠。对于维度更高的矩阵来说，<code>vstack</code>表示沿axis=0堆叠；<code>hstack</code>表示沿axis=1堆叠。<strong>沿着哪个轴进行堆叠，对应维度的shape会增加</strong>，其他维度的shape不发生改变。因此在堆叠的时候，其他维度的shape需要相同才能够堆叠。</p><p>除了<code>vstack</code>和<code>hstack</code>之外，numpy中还有一个更加灵活的方法<code>concatenate</code>，它允许接受axis参数指定沿着哪个轴进行堆叠。如果提供axis为None，则直接拍平再进行操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">np.concatenate((a, b), axis=<span class="hljs-number">0</span>)<br>np.concatenate((a, b), axis=<span class="hljs-number">1</span>)<br>np.concatenate((a, b), axis=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><h3 id="矩阵分割">矩阵分割</h3><p>除了矩阵堆叠，还可以进行矩阵分割split，有类似的方法<code>hsplit</code>、<code>vsplit</code>和<code>array_split</code>。<code>hsplit</code>表示水平切割，或者说沿axis=1切割；<code>vsplit</code>表示垂直切割，或者说沿axis=0切割；<code>array_split</code>允许接受axis参数，指定沿着哪个轴进行切割；如果提供axis为Node，则直接拍平再进行操作。以上方法都接收一个目标切割数<code>indices_or_sections</code>，注意该目标数需要与对应的维度shape具有整除关系，这样才能正常切割。不过<code>array_split</code>并不受这个限制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># hsplit</span><br>np.hsplit(a, <span class="hljs-number">5</span>)<br>[array([[ <span class="hljs-number">0</span>],<br>        [ <span class="hljs-number">5</span>],<br>        [<span class="hljs-number">10</span>]]),<br> array([[ <span class="hljs-number">1</span>],<br>        [ <span class="hljs-number">6</span>],<br>        [<span class="hljs-number">11</span>]]),<br> array([[ <span class="hljs-number">2</span>],<br>        [ <span class="hljs-number">7</span>],<br>        [<span class="hljs-number">12</span>]]),<br> array([[ <span class="hljs-number">3</span>],<br>        [ <span class="hljs-number">8</span>],<br>        [<span class="hljs-number">13</span>]]),<br> array([[ <span class="hljs-number">4</span>],<br>        [ <span class="hljs-number">9</span>],<br>        [<span class="hljs-number">14</span>]])]<br><br><span class="hljs-comment"># vsplit</span><br>np.vsplit(a, <span class="hljs-number">3</span>)<br>[array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]),<br> array([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]]),<br> array([[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]])]<br><br><span class="hljs-comment"># array_split</span><br><span class="hljs-comment"># 下面两个表达式分别对应上面的两个方法</span><br>np.array_split(a, <span class="hljs-number">5</span>, axis=<span class="hljs-number">1</span>)<br>np.array_split(a, <span class="hljs-number">3</span>, axis=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># array_split indices_or_sections 不受整除限制</span><br><br>np.array_split(a, <span class="hljs-number">2</span>, axis=<span class="hljs-number">0</span>)<br>[array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],<br>        [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]]),<br> array([[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]])]<br></code></pre></td></tr></table></figure><h2 id="视图view与复制copy">视图View与复制Copy</h2><p>在使用numpy的过程中，通常会涉及到矩阵的复制等操作。对于ndarray来说，主要分为三种情况，分别是直接赋值<code>=</code>，使用视图<code>view()</code>以及使用复制<code>copy()</code>。</p><p>如果直接通过等号进行赋值，实际上并没有产生复制，新旧矩阵完全是相同的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br>b = a<br><span class="hljs-built_in">print</span>(b <span class="hljs-keyword">is</span> a)  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>ndarray提供视图<code>.view()</code>方法，通过view方法产生的矩阵是原矩阵的一个视图，它们共享相同的底层数据。可以修改视图矩阵的shape而不影响原矩阵，但是修改视图的数据，原矩阵的数据也会受到影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br>b = a.view()<br><span class="hljs-built_in">print</span>(b <span class="hljs-keyword">is</span> a)  <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(b.base <span class="hljs-keyword">is</span> a)  <span class="hljs-comment"># True</span><br><br>b = b.reshape((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))  <span class="hljs-comment"># b shape变成(2, 2)</span><br><span class="hljs-built_in">print</span>(a.shape)  <span class="hljs-comment"># a shape 保持不变</span><br><br>b[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] = <span class="hljs-number">10</span> <span class="hljs-comment"># 修改b中的元素</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">0</span>])  <span class="hljs-comment"># ouptut 10，a中的元素也相应改变</span><br></code></pre></td></tr></table></figure><p>ndarray同样提供复制方法<code>.copy()</code>。通过copy方法产生的矩阵是完完全全的复制，属于deepcopy，新旧矩阵之间不会有任何的相互影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">b = a.copy()<br></code></pre></td></tr></table></figure><h2 id="数据保存和读取">数据保存和读取</h2><p>numpy中也提供数据的读取和保存方法，可以将一个ndarray对象保存在文件当中，并在需要的时候可以从文件中进行读取。对应的存储文件有两种，后缀名分别是<code>.npy</code>和<code>.npz</code>。单个ndarray的保存对应npy文件，同时存储多个ndarray对应使用npz文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>)<br>b = np.arange(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># npy file</span><br>np.save(<span class="hljs-string">&quot;test-save-a&quot;</span>, a)<br>c = np.load(<span class="hljs-string">&quot;test-save-a.npy&quot;</span>)<br><br><span class="hljs-comment"># npz file</span><br>np.savez(<span class="hljs-string">&quot;test-save-a&quot;</span>, a, b)<br>d = np.load(<span class="hljs-string">&quot;test-save-a.npz&quot;</span>)<br>d[<span class="hljs-string">&#x27;arr_0&#x27;</span>] <span class="hljs-comment"># means a</span><br>d[<span class="hljs-string">&#x27;arr_1&#x27;</span>] <span class="hljs-comment"># means b</span><br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://realpython.com/numpy-tutorial/">NumpyTutorial|RealPython</a></li><li><a href="https://numpy.org/doc/stable/user/index.html">Numpy UserGuide|Numpy Documentation</a></li><li><a href="https://numpy.org/doc/stable/reference/index.html">NumpyAPI Reference|Numpy Documentation</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac Terminal美化记录</title>
    <link href="/2023/08/02/Mac-Terminal%E7%BE%8E%E5%8C%96%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/08/02/Mac-Terminal%E7%BE%8E%E5%8C%96%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="记录">记录</h1><h2 id="terminal">Terminal</h2><ol type="1"><li>选择Terminal的配色方案：<ahref="https://github.com/sindresorhus/terminal-snazzy">sindresorhus/terminal-snazzy:Elegant Terminal theme with bright colors</a></li><li>配置窗口的大小，在14寸MacBook Pro上本人合适的参数如下：</li></ol><table><thead><tr class="header"><th>配置项</th><th>配置值</th></tr></thead><tbody><tr class="odd"><td>字体</td><td>Monaco 14</td></tr><tr class="even"><td>窗口列数</td><td>90</td></tr><tr class="odd"><td>窗口行数</td><td>32</td></tr><tr class="even"><td>字符间距</td><td>1.05</td></tr><tr class="odd"><td>行间距</td><td>1.3</td></tr></tbody></table><h2 id="oh-my-zsh">oh-my-zsh</h2><p>详细过程可以参考<ahref="https://medium.com/@jackklpan/make-mac-terminal-app-beautiful-and-productive-213f24c0ef4f">MakeMac Terminal App Beautiful and Productive | by Jack Pan | Medium</a></p><ol type="1"><li>安装oh-my-zsh</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>安装相关插件，包括autojump、zsh-syntax-highlighting和zsh-autosuggestions，分别可以完成常用目录跳转，命令高亮以及历史命令推荐</li><li>修改主题配置文件<code>.oh-my-zsh/themes/robbyrussell.zsh-theme</code>，修改为下面的内容。相比于默认效果，下面的配置主要完成了全路径显示和用户显示</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">local</span> ret_status=<span class="hljs-string">&quot;%(?:%&#123;<span class="hljs-variable">$fg_bold</span>[green]%&#125;➜ :%&#123;<span class="hljs-variable">$fg_bold</span>[red]%&#125;➜ )&quot;</span><br>PROMPT=<span class="hljs-string">&#x27;$&#123;ret_status&#125; %&#123;$fg_bold[magenta]%&#125;%n %&#123;$fg[cyan]%&#125;%~%&#123;$reset_color%&#125; $(git_prompt_info)&#x27;</span><br><br>ZSH_THEME_GIT_PROMPT_PREFIX=<span class="hljs-string">&quot;%&#123;<span class="hljs-variable">$fg_bold</span>[blue]%&#125;git:(%&#123;<span class="hljs-variable">$fg</span>[red]%&#125;&quot;</span><br>ZSH_THEME_GIT_PROMPT_SUFFIX=<span class="hljs-string">&quot;%&#123;<span class="hljs-variable">$reset_color</span>%&#125; &quot;</span><br>ZSH_THEME_GIT_PROMPT_DIRTY=<span class="hljs-string">&quot;%&#123;<span class="hljs-variable">$fg</span>[blue]%&#125;) %&#123;<span class="hljs-variable">$fg</span>[yellow]%&#125;✗&quot;</span><br>ZSH_THEME_GIT_PROMPT_CLEAN=<span class="hljs-string">&quot;%&#123;<span class="hljs-variable">$fg</span>[blue]%&#125;)&quot;</span><br></code></pre></td></tr></table></figure><h2 id="iterm2">iTerm2</h2><ol type="1"><li>iTerm2是一款可以代替Mac原生Terminal的应用，能够完成的功能大体上与Terminal相同，同时还提供更多的功能（个人认为最强大的一个功能是通过<code>command</code>+点击在命令行中直接打开目录或者文件）</li><li>iTerm2的主题配置选择：<a href="https://draculatheme.com/">Dracula —Dark theme for 270+ apps</a></li><li>Vim的配色也可以选择Dracula</li></ol><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://juejin.cn/post/6850418116414046215">oh-my-zsh修改主题添加全路径显示- 掘金</a></li><li><a href="https://github.com/ohmyzsh/ohmyzsh/issues/5686">how toenable username and hostname in the default theme? · Issue #5686 ·ohmyzsh/ohmyzsh</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python单元测试之基本测试框架</title>
    <link href="/2023/08/02/Python%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/08/02/Python%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="unittest">unittest</h1><p>unittest是Python标准库中提供的一个单元测试框架，官方文档为：<ahref="https://docs.python.org/3/library/unittest.html">unittest-Unittestingframework</a>。使用unittest，我们主要需要学习测试用例的书写，以及一些相关的测试方法、断言方法等。</p><p>首先我们准备需要被测试的代码。首先在项目根目录下提供<code>src</code>和<code>tests</code>两个目录，在<code>src</code>目录中存放源代码，在<code>tests</code>中存放后续的测试代码。</p><p>这里的源代码模拟了一个计算的功能，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># My Calculator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">num1: <span class="hljs-built_in">int</span>, op: <span class="hljs-built_in">str</span>, num2: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;+&#x27;</span>:<br>        <span class="hljs-keyword">return</span> num1 + num2<br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;-&#x27;</span>:<br>        <span class="hljs-keyword">return</span> num1 - num2<br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;*&#x27;</span>:<br>        <span class="hljs-keyword">return</span> num1 * num2<br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;/&#x27;</span>:<br>        <span class="hljs-keyword">return</span> num1 / num2<br><br></code></pre></td></tr></table></figure><p>这里需要提示一下，一个较为规范的项目结构，应该在根目录下提供至少两个目录和一个入口文件。入口文件作为整个项目的入口，如果是package项目的话，则这个入口文件可能是<code>setup.py</code>。另外两个目录，其中一个目录存放源代码，并且所有的源代码都应该存放在这个目录下；另外一个目录名为<code>tests</code>，存放所有的单元测试。一般来说，这两个目录都声明为package的形式，即拥有一个<code>__init__.py</code>文件。</p><blockquote><p>当然由于Python社区的自由，目前也没有像Java中的Maven一样，有一个统一的项目结构和项目管理标准。以上只是其中一种推荐的项目结构。</p></blockquote><p>之后，我们需要建立一个测试类来继承unittest里面的<code>TestCase</code>类，继承这个类之后我们才是真正的使用unittest框架去写测试用例。继承之后，在类中书写测试方法，注意测试方法必须要以<code>test_</code>开头，同时我们存放测试类的<code>.py</code>文件也需要以<code>test_</code>开头，这样才能被unittest框架检测到。完成测试方法之后，可以选择在main方法中调用<code>unittest.main()</code>来运行测试用例，也可以使用命令行的方式进行运行。运行之后unittest就会自动检测测试方法并进行运行。</p><p>下面是示例测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># test_calculate</span><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">from</span> src.MyCalculator <span class="hljs-keyword">import</span> calculate<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMyCalculator</span>(unittest.TestCase):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add_method</span>(<span class="hljs-params">self</span>):<br>        res = calculate(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">2</span>)<br>        self.assertEqual(res, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_subtract_method</span>(<span class="hljs-params">self</span>):<br>        res = calculate(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>)<br>        self.assertEqual(res, <span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_zero_division</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">with</span> self.assertRaises(ZeroDivisionError):<br>            calculate(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><p>注意上面除零异常的测试，需要使用with语句进行包裹。我们可以运行main函数，会发现一共有3个测试案例运行了。当然也可以使用命令行的方式，在项目根目录下运行下面的命令，unittest就会检测项目中所有的测试案例并进行运行。注意测试案例的规范，即文件名和测试方法名均以<code>test_</code>开头。（一个较为规范的格式是测试类也以<code>Test</code>开头）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python -m unittest<br></code></pre></td></tr></table></figure><p>可以看到，利用unittest完成单元测试还是非常简单的，只需要按照如下的步骤：</p><ol type="1"><li>根据规范建立测试案例，包括测试源代码文件、测试类以及测试方法</li><li>在测试方法中进行逻辑测试，以及相应的assert断言</li><li>利用命令行或者main函数的方法进行测试</li></ol><p>当然除了断言方法外，unittest中还提供了一些较为常用的函数。例如下面的方法可以帮助我们在测试的前后都进行一些相关逻辑的处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">setUp</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 每条用例执行之前都会执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test case &#123;&#125; start ...&quot;</span>.<span class="hljs-built_in">format</span>(self))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tearDown</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 每条用例执行之后都会执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test case &#123;&#125; end ...&quot;</span>.<span class="hljs-built_in">format</span>(self))<br><br><span class="hljs-meta">@classmethod  </span><span class="hljs-comment"># 注意该装饰器必须使用</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>) -&gt; <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 整个测试用例类执行之前会执行一次</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test class &#123;&#125; start ...&quot;</span>.<span class="hljs-built_in">format</span>(cls))<br><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tearDownClass</span>(<span class="hljs-params">cls</span>) -&gt; <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 整个测试类执行之后会执行一次</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test class &#123;&#125; end ...&quot;</span>.<span class="hljs-built_in">format</span>(cls))<br></code></pre></td></tr></table></figure><h1 id="pytest">pytest</h1><h2 id="quick-start">quick start</h2><p>pytest是一个第三方Python单元测试框架，官方文档为：<ahref="https://docs.pytest.org/en/7.4.x/">pytest: helps you write betterprograms</a>。相比于unittest，pytest更加灵活简便，支持参数化，具有丰富的第三方插件，支持自定义扩展等。</p><p>在使用pytest之前需要进行安装，直接使用pip安装即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install -U pytest<br></code></pre></td></tr></table></figure><p>之后我们可以进行测试代码的书写，被测试的代码仍然是上面的<code>MyCalculator</code>。pytest的测试书写更为灵活，可以是函数级别的组织，也可以是类级别的组织。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> src.MyCalculator <span class="hljs-keyword">import</span> calculate<br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_sum_method</span>():<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">2</span> == calculate(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCalculate</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_multipy_method</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> <span class="hljs-number">8</span> == calculate(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_zero_division</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 可以通过match来assert指定的错误信息格式</span><br>        <span class="hljs-keyword">with</span> pytest.raises(ZeroDivisionError, <span class="hljs-keyword">match</span>=<span class="hljs-string">&#x27;division by zero&#x27;</span>):<br>            calculate(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">0</span>)<br>           <br></code></pre></td></tr></table></figure><p>利用pytest进行测试案例的书写同样需要遵循一定的<ahref="https://docs.pytest.org/en/7.4.x/explanation/goodpractices.html#test-discovery">规则</a>：</p><ul><li>测试文件以<code>test_</code>开头，或者<code>_test</code>结尾；</li><li>测试类以<code>Test</code>开头，并且不能带有init方法；</li><li>测试函数以<code>test_</code>开头；</li><li>断言使用基本的assert即可</li></ul><p>我们在项目根目录中直接通过命令行执行测试，直接输入下面的命令即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pytest<br></code></pre></td></tr></table></figure><p>pytest可以兼容检测到unittest中的测试案例。利用命令行运行的时候，可以发现使用unittest书写的测试案例也被运行到了。不过这是因为unittest的测试案例书写规范与pytest基本一致。需要注意的是，unittest中的<code>setUp</code>和<code>tearDown</code>方法在利用pytest运行的时候并没有生效。</p><h2 id="其他功能">其他功能</h2><p>上面是pytest的基本用法。除此之外，pytest还提供了许多额外的功能。</p><h3 id="fixture">fixture</h3><p>在一些时候，我们可能会有一堆测试方法，它们都依赖于某个数据来源。在unittest中，我们会将数据来源的处理放在setUp方法中，以此避免大量的重复代码。这种方式存在的问题是，随着测试类越来越大，实际的测试代码和setUp函数可能相隔越来越远，我们可能无法仅仅通过测试函数的内容来很快得知它的依赖。</p><p>pytest在一定程度上解决了这个问题，它利用fixture来显式地声明一个测试方法需要的依赖。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">example_data</span>():<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;xxx&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span><br>    &#125;<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_example_data</span>(<span class="hljs-params">example_data</span>):<br>    <span class="hljs-keyword">assert</span> example_data[<span class="hljs-string">&#x27;name&#x27;</span>] == <span class="hljs-string">&#x27;xxx&#x27;</span><br>    <span class="hljs-keyword">assert</span> example_data[<span class="hljs-string">&#x27;age&#x27;</span>] == <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>这里的<code>example_data</code>就像使用<code>fixture</code>创建了一个全局变量，在IDE中点击函数参数中的example_data，也会直接跳转到fixture的定义处。事实上fixture也是能够被import的，一个好的实践是将所有的fixture都管理在一个module中，让测试函数按需导入即可。</p><h3 id="参数化">参数化</h3><p>pytest提供测试参数化的功能，简单来说就是我们可以通过参数化的方法来以多种输入情况运行结构类似的测试。而如果不使用参数化，要达到同样的效果可能需要写非常多结构类似的代码。而通过pytest提供的参数化，我们只需要书写一遍测试结构，然后提供多种测试参数。通过pytest命令行运行之后，每个参数会对应实例化出一个测试案例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;input_num&quot;</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_greater_than_one</span>(<span class="hljs-params">input_num</span>):<br>    <span class="hljs-keyword">assert</span> input_num &gt; <span class="hljs-number">1</span><br><br><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;input_num, is_odd&quot;</span>, [(<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-literal">True</span></span>), (<span class="hljs-params"><span class="hljs-number">2</span>, <span class="hljs-literal">False</span></span>), (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-literal">True</span></span>), (<span class="hljs-params"><span class="hljs-number">4</span>, <span class="hljs-literal">False</span></span>)]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_is_odd_num</span>(<span class="hljs-params">input_num, is_odd</span>):<br>    <span class="hljs-keyword">assert</span> (input_num % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) == is_odd<br></code></pre></td></tr></table></figure><h3 id="第三方插件">第三方插件</h3><p>pytest还具有丰富的第三方插件，这些插件为提供了丰富的功能。这里简单介绍一些第三方插件。</p><ul><li><code>pytest-randomly</code>：强制测试代码按照随机的顺序运行</li><li><code>pytest-cov</code>：集成了coverage来计算代码覆盖率，直接通过<code>pytest --cov</code>来测试代码覆盖率</li><li><code>pytest-djano</code>：提供Django的测试框架</li></ul><h1 id="coverage">coverage</h1><p>通过unittest或者pytest等单元测试框架，我们可以书写各式各样的单元测试，但是如何判断我们的单元测试是否足够呢？一个非常基础的评价指标是行覆盖率，它表达的是单元测试执行到的代码行数占总行数的比例。</p><p>我们可以通过coverage这个package来帮助计算单元测试的覆盖率。coverage属于第三方库，需要额外安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install coverage<br></code></pre></td></tr></table></figure><p>在之前<code>unittest</code>中，我们使用<code>python -m unittest</code>来运行测试案例，现在使用<code>coverage</code>来运行测试案例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 根据框架不同选择使用不同的测试module</span><br><span class="hljs-comment"># 不同module测试能够检测到的测试案例也不同</span><br>coverage run -m unittest<br>coverage run -m pytest<br></code></pre></td></tr></table></figure><p>测试完成之后，会在当前目录下生成一个<code>.coverage</code>的文件，其中就记录了测试结果。可以通过下面的命令查看结果，命令会在shell中以表格形式展示出覆盖率结果，包括每个文件的代码总行数，miss行数，覆盖率等。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">coverage report<br>coverage report -m <span class="hljs-comment"># 查看miss的是哪些行，给出line number</span><br></code></pre></td></tr></table></figure><p>当然表格形式的结果看起来还是比较费劲的，coverage同样支持以html形式展示覆盖率结果。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">coverage html<br></code></pre></td></tr></table></figure><p>上面的命令会在当前目录下生成一个名为<code>htmlcov</code>的文件夹，之后我们可以通过下面的命令在本机运行一个httpserver，之后通过浏览器访问<code>http://0.0.0.0:8000/</code>，就可以以更加直观地方式查看覆盖率结果。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python -m http.server --directory htmlcov/<br></code></pre></td></tr></table></figure><p>有的时候，我们的一些代码确实可能无法通过测试代码覆盖到，那么就可以通过增加注释来让coverage在计算覆盖率的时候不统计这些代码。这个特殊的注释是<code># pragma: no cover</code>。如果该注释放在函数定义的那一行，则整个函数在统计覆盖率的时候都会被忽略；如果该注释放在函数中实际逻辑的某一行，则这一行在统计覆盖率的时候会被忽略。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://realpython.com/pytest-python-testing/">EffectivePython Testing With Pytest|Real Python</a></li><li><ahref="https://www.cnblogs.com/gmjianchi/p/12930691.html">pytest测试用例编写----预期的异常测试ExpectingExceptions</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>UnitTest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes学习笔记(4)-安全认证与DashBoard使用</title>
    <link href="/2023/08/01/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E4%B8%8EDashBoard%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/01/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E4%B8%8EDashBoard%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="安全认证">安全认证</h1><h2 id="简介">简介</h2><p>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。Kubernetes通过对各种使用它服务的客户端进行认证和鉴权，以此来保证集群的安全性。</p><p>在Kubernetes集群中，客户端通常分为两类：</p><ul><li><code>User Account</code>：一般是独立于Kubernetes之外的其他服务管理的用户账号。</li><li><code>Service Account</code>：Kubernetes管理的账号，用于为Pod中的服务进程在访问Kubernetes时提供身份标识。</li></ul><p>在Kubernetes中，ApiServer是访问及管理资源对象的唯一入口。任何一个请求访问ApiServer，都要经过下面三个流程：</p><ul><li>Authentication（认证）：身份鉴别，只有正确的账号才能够通过认证</li><li>Authorization（鉴权）：判断用户是否有权限对访问的资源执行特定的动作</li><li>AdmissionControl（准入控制）：用于补充授权机制以实现更加精细的访问控制功能</li></ul><h2 id="认证管理">认证管理</h2><p>Kubernetes集群安全的关键点在于如何识别并认证客户端身份，它提供了三种客户端身份认证方式：</p><ul><li>HTTP Base认证：通过用户名+密码的方式认证</li><li>HTTP Token认证：通过一个Token来识别合法用户</li><li>HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式</li></ul><p>Kubernetes允许同时配置多种认证方式，只要其中任意一个方式认证通过即可。</p><h2 id="鉴权管理">鉴权管理</h2><p>认证管理用于明确用户的身份，接下来的鉴权管理则用于判断某个用户是否有某种权限。</p><p>每个发送到ApiServer的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误。</p><p>Api Server目前支持以下几种授权策略：</p><ul><li><code>AlwaysDeny</code>：表示拒绝所有请求，一般用于测试</li><li><code>AlwaysAllow</code>：允许接收所有请求，相当于集群不需要授权流程（Kubernetes默认的策略）</li><li><code>ABAC</code>：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li><li><code>Webhook</code>：通过调用外部REST服务对用户进行授权</li><li><code>Node</code>：是一种专用模式，用于对kubelet发出的请求进行访问控制</li><li><code>RBAC</code>：基于Role的访问控制（kubeadm安装方式下的默认选项）</li></ul><p>在RBAC(Role-Based Access Control)中会涉及如下概念：</p><ul><li>用户：包括User、Groups、ServiceAccount</li><li>Role：代表着一组定义在资源上的可操作动作的集合，简单来说就是某种权限</li><li>绑定Binding：将定义好的Role跟用户绑定在一起，即授予用户某种权限</li></ul><p>在Kubernete中存在与RBAC相关的顶级Resource对象，都可以通过yaml配置文件进行资源的创建和修改：</p><ul><li>Role、ClusterRole：用于指定一组权限</li><li>RoleBinding、ClusterRoleBinding：用于将角色（权限）赋予给对象</li></ul><p>资源的定义提高了可复用性，例如一些同类用户具有相同的权限，此时在进行权限赋予的时候就可以直接复用同一个RoleResource。</p><h2 id="准入控制">准入控制</h2><p>来自客户端的请求在通过了前面的认证和授权之后，还需要经过准入控制处理，ApiServer才会进行处理。准入控制是一个可配置的控制器列表，可以通过在ApiServer上通过命令行设置选择执行哪些准入控制器。</p><p>只有当所有的准入控制器都检查通过之后，ApiServer才会执行该请求，否则返回拒绝。当前可配置的AdmissionControl准入控制如下：</p><ul><li><code>AlwaysAdmit</code>：允许所有请求</li><li><code>AlwaysDeny</code>：禁止所有请求，一般用于测试</li><li><code>AlwaysPullImages</code>：在启动容器之前总去下载镜像</li><li><code>DenyExecOnPrivileged</code>：它会拦截所有想在PrivilegedContainer上执行命令的请求</li><li><code>ImagePolicyWebhook</code>：该插件将允许后端的一个Webhook程序来完成AdmissionController的功能</li><li><code>Service Account</code>：使用ServiceAccount实现了自动化</li><li><code>SecurityContextDeny</code>：这个插件将使用SecurityContext的Pod中的定义全部失效</li><li><code>ResourceQuota</code>：用于资源配额管理目的，观察所有请求，确保在namespace上的配额不会超标</li><li><code>LimitRanger</code>：用于资源限制管理，作用于namespace上，确保对Pod进行资源限制</li><li><code>InitialResources</code>：为未设置资源请求与限制的Pod，根据其镜像的历史资源的使用情况进行设置</li><li><code>NamespaceLifecycle</code>：如果尝试在一个不存在的namespace中创建资源对象，则该创建请求将被拒绝。当删除一个namespace时，系统将会删除该namespace中所有对象</li><li><code>DefaultStorageClass</code>：为了实现共享存储的动态供应，为未指定StorageClass或PV的PVC尝试匹配默认的StorageClass，尽可能减少用户在申请PVC时所需了解的后端存储细节</li><li><code>DefaultTolerationSeconds</code>：这个插件为那些没有设置forgivenesstolerations并具有notready:NoExecute和unreachable:NoExecute两种taints的Pod设置默认的“容忍”时间，为5min</li><li><code>PodSecurityPolicy</code>：这个插件用于在创建或修改Pod时决定是否根据Pod的securitycontext和可用的PodSecurityPolicy对Pod的安全策略进行控制</li></ul><h1 id="dashboard">DashBoard</h1><p>命令行工具kubectl提供了几乎所有操作Kubernetes集群的功能，但是操作门槛还是有些高。因此，为了提供更丰富的用户体验，Kubernetes还开发了一个基于Web的DashBoard，用户可以使用Dashboard来部署容器化的应用，监控应用的状态，执行故障排查以及管理Kubernetes中各种资源等。官方DashBoard的项目地址为<ahref="https://github.com/kubernetes/dashboard">kubernetes/dashboard:General-purpose web UI for Kubernetesclusters</a>。下面简单介绍这个DashBoard的使用方式。</p><p>首先需要从官网下载配置文件<code>recommended.yaml</code>，这里面描述了DashBoard运行所需的资源。实际上DashBoard整体也是一个运行在Kubernetes集群中的服务，需要各种Resource的支持。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml<br></code></pre></td></tr></table></figure><p>得到配置文件之后，我们需要进行一些修改。主要修改的是其中名为kubernetes-dashboard的Service，修改内容为增加下面具有注释的两行。因为默认情况下该Service的type为ClusterIP，无法在集群外访问，因此这里需要将其改为NodePort，同时完成端口映射。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span>  <span class="hljs-comment"># change to NodePort</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">443</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8443</span><br>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30009</span>  <span class="hljs-comment"># expose nodePort</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">kubernetes-dashboard</span><br></code></pre></td></tr></table></figure><p>之后，可以运行apply命令生成相关资源。可以发现所有资源都位于<code>kubernetes-dashboard</code>名称空间下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f recommended.yaml<br></code></pre></td></tr></table></figure><p>此时我们已经可以访问<code>https://localhost:30009/</code>来进入DashBoard，不过此时它会提示我们输入Token。因此我们还需要创建相关User，获取Token。下面的步骤均参考官方文档：<ahref="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md">dashboard/docs/user/access-control/creating-sample-user.mdat master · kubernetes/dashboard</a>。</p><p>首先我们需要创建一个用户<code>admin-user</code>，并为其赋予相关的权限。这两个动作对应Kubernetes中的两个Resource，因此准备如下配置文件，这里命名为<code>admin-user.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-admin</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br></code></pre></td></tr></table></figure><p>之后利用apply命令创建资源，这样就可以创建出admin-user用户并且为其授予权限。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f admin-user.yaml<br></code></pre></td></tr></table></figure><p>然后利用下面的命令生成Token：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl create token admin-user -n kubernetes-dashboard<br></code></pre></td></tr></table></figure><p>该命令会在控制台上输出一长串字符串，即Token。访问<code>https://localhost:30009/</code>，在登录页面上输入获取的Token，即可登录成功。</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes学习笔记(3)-Service与数据存储</title>
    <link href="/2023/08/01/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Service%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <url>/2023/08/01/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Service%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="service">Service</h1><h2 id="介绍">介绍</h2><p>在Kubernetes中，Pod是应用程序的载体，我们可以通过Pod的ip来访问应用程序。但是Pod的ip地址不是固定的，这也就意味着不方便直接采用Pod的Ip对服务进行访问。</p><p>为了解决这个问题，Kubernetes提供了Service这种类型的Resource。Service会对提供同一个服务的多个Pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的Pod服务。</p><p>事实上，Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程。每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候，Kubernetes通过Api-Server向etcd写入创建的Service的信息，而kube-proxy会基于监听的机制来发现这种Service的变动，之后它会将最新的Service信息转换成对应的访问规则。</p><p>下面是Service的资源清单描述：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>  <span class="hljs-comment"># 资源类型</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>  <span class="hljs-comment"># 资源版本</span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service</span> <span class="hljs-comment"># 资源名称</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 命名空间</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 描述</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 标签选择器，用于确定当前service代理哪些pod</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-comment"># Service类型，指定service的访问方式</span><br>  <span class="hljs-attr">clusterIP:</span>  <span class="hljs-comment"># 虚拟服务的ip地址</span><br>  <span class="hljs-attr">sessionAffinity:</span> <span class="hljs-comment"># session亲和性，支持ClientIP、None两个选项</span><br>  <span class="hljs-attr">ports:</span> <span class="hljs-comment"># 端口信息</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span> <br>      <span class="hljs-attr">port:</span> <span class="hljs-number">3017</span>  <span class="hljs-comment"># service端口</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">5003</span> <span class="hljs-comment"># pod端口</span><br>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">31122</span> <span class="hljs-comment"># 主机端口</span><br></code></pre></td></tr></table></figure><p>其中type表示Service的类型，可选值有：</p><ul><li><code>ClusterIP</code>：默认类型。这种Service只能在集群内部，通过Kubernetes系统自动分配的虚拟IP访问</li><li><code>NodePort</code>：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务</li><li><code>LoadBalancer</code>：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持</li><li><code>ExternalName</code>：把集群外部的服务引入集群内部，直接使用</li></ul><h2 id="clusterip">ClusterIP</h2><p>一个ClusterIP类型的Service，对应配置文件示例如下，其中直接指定type为ClusterIP，并通过LabelSelector来决定代理Pod的范围。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-clusterip</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">xxx.xxx.xxx.xxx</span> <span class="hljs-comment"># service的ip地址，如果不写，默认会生成一个</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>  <span class="hljs-comment"># Service端口       </span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># pod端口</span><br></code></pre></td></tr></table></figure><p>Service配置文件中的Selector描述可以对应到一系列Pod，在Kubernetes中用Endpoint来描述这种对应关系。Endpoint是Kubernetes中的一个资源对象，存储在etcd中，用来记录一个Service对应的所有Pod的访问地址。这也就是说，Service和Pod之间的联系是通过Endpoints来实现的，一个Service由一组Pod组成，这些Pod通过Endpoints暴露出来。</p><p>默认情况下，对于Service的访问会转发到后面真实的Pod上，转发策略默认使用kube-proxy的策略，例如随机，轮询等。不过Kubernetes中也提供了基于客户端地址的会话保持模式，可以通过设置<code>spec.sessionAffinity:ClientIP</code>来开启。在这种模式下，来自同一个客户端发起的所有请求都会转发到固定的一个Pod上。</p><p>当然在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略。针对这种情况，Kubernetes提供了HeadLinessService，这类Service不会分配ClusterIP，如果想要访问Service，只能通过Service的域名进行查询。要创建一个HeadLinessService，只需要在配置文件中指定<code>spec.type</code>为ClusterIP，同时指定<code>spec.clusterIP</code>为None即可。</p><h2 id="nodeport">NodePort</h2><p>ClusterIP类型的Service只能在集群内部访问，如果希望将Service暴露给集群外部使用，则需要NodePort类型的Service。NodePort的工作原理实际上就是将service的端口映射到Node的一个端口上，然后就可以通过<code>NodeIp:NodePort</code>来访问Service了。</p><p>一个NodePort的配置文件示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-nodeport</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span> <span class="hljs-comment"># service类型</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30002</span> <span class="hljs-comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h2 id="loadbalancer">LoadBalancer</h2><p>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持。外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。</p><h2 id="externalname">ExternalName</h2><p>ExternalName类型的Service用于引入集群外部的服务，它通过<code>externalName</code>属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。</p><h1 id="数据存储">数据存储</h1><h2 id="介绍-1">介绍</h2><p>在Kubernetes中，容器的生命周期可能很短，会被频繁地创建和销毁。容器在被销毁时，保存在其中的数据也会被清除。Kubernetes引入Volume的概念来持久化保存容器中的数据。</p><p><code>Volume</code>是Pod中能够被多个容器访问的共享目录，它被定义在Pod上（在Pod的配置文件中声明），然后被一个Pod里的多个容器挂载到具体的文件目录下。Kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命容器不与Pod中单个容器的生命周期相关，当容器终止或者重启时，Volume中的数据也不会丢失。</p><p>kubernetes的Volume支持多种类型，比较常见的有下面几个：</p><ul><li>简单存储：EmptyDir、HostPath、NFS</li><li>高级存储：PV、PVC</li><li>配置存储：ConfigMap、Secret</li></ul><h2 id="基本存储">基本存储</h2><h3 id="emptydir">EmptyDir</h3><p>EmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录。EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为Kubernetes会自动分配一个目录，当Pod销毁时，EmptyDir中的数据也会被永久删除。 EmptyDir用途如下：</p><ul><li>临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留</li><li>一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</li></ul><p>例如下面的配置文件，在<code>Pod.spec.volumes</code>中声明了Volume，然后在Container的详细配置中进行对应挂载。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">volume-emptydir</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">volumeMounts:</span>  <span class="hljs-comment"># 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log/nginx</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;tail -f /logs/access.log&quot;</span>] <span class="hljs-comment"># 初始命令，动态读取指定文件中内容</span><br>    <span class="hljs-attr">volumeMounts:</span>  <span class="hljs-comment"># 将logs-volume 挂在到busybox容器中，对应的目录为 /logs</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/logs</span><br>  <span class="hljs-attr">volumes:</span> <span class="hljs-comment"># 声明volume， name为logs-volume，类型为emptyDir</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="hostpath">HostPath</h3><p>EmptyDir中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。HostPath就是将Node主机中一个实际目录挂载到Pod中，以供容器使用，这样设计可以保证即使Pod销毁，数据依旧可以存在于Node主机上。</p><p>HostPath的使用方式与EmptyDir基本相同，只需要在声明的时候指定相关配置即可，后续Container可以用来挂载。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># HostPath Example</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>    <span class="hljs-attr">hostPath:</span> <br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/root/logs</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span>  <span class="hljs-comment"># 目录存在就使用，不存在就先创建后使用</span><br></code></pre></td></tr></table></figure><p>其中type的可选值如下：</p><ul><li><code>DirectoryOrCreate</code>：目录存在就使用，不存在就先创建后使用</li><li><code>Directory</code>：目录必须存在</li><li><code>FileOrCreate</code>：文件存在就使用，不存在就先创建后使用</li><li><code>File</code>：文件必须存在</li><li><code>Socket</code>：unix套接字必须存在</li><li><code>CharDevice</code>：字符设备必须存在</li><li><code>BlockDevice</code>：块设备必须存在</li></ul><h3 id="nfs">NFS</h3><p>HostPath可以解决数据持久化的问题，但是一旦Node节点故障了，或者Pod转移到了别的节点，就又会出现问题。此时需要准备单独的网络存储系统，比较常用的有NFS、CIFS。在Volume中也可以直接配置NFS相关的存储系统。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># NFS Example</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>    <span class="hljs-attr">nfs:</span><br>      <span class="hljs-attr">server:</span> <span class="hljs-string">xxx.xxx.xxx.xxx</span> <span class="hljs-comment"># nfs服务器地址</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/root/data/nfs</span> <span class="hljs-comment"># 共享文件路径</span><br></code></pre></td></tr></table></figure><h2 id="高级存储">高级存储</h2><p>Kubernetes支持的存储系统有很多，每种存储系统可能有互不相同的配置，学习成本较高。而为了能够屏蔽底层存储实现的细节，方便用户使用，Kubernetes引入PV和PVC两种资源对象。</p><p><code>PV(Persistent Volume)</code>指持久化卷，是对底层的共享存储的一种抽象。一般情况下PV由Kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。</p><p><code>PVC(Persistent Volume Claim)</code>指持久卷声明，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向Kubernetes系统发出的一种资源需求申请。</p><p>PV和PVC是一一对应的，整个使用过程通常会经过下面一些阶段：</p><ul><li><p>资源供应：首先由管理员手动创建底层存储和PV</p></li><li><p>资源绑定：用户创建PVC，Kubernetes负责根据PVC的声明去寻找PV，并进行绑定。</p><ul><li>一旦找到，就将该PV与用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了PV一旦绑定到某个PVC上，就会被这个PVC独占，不能再与其他PVC进行绑定了</li><li>如果找不到，PVC则会无限期处于Pending状态，直到等到系统管理员创建了一个符合其要求的PV</li></ul></li><li><p>资源使用：用户可在Pod中像Volume一样使用PVC，将PVC挂载到容器内的某个路径进行使用。</p></li><li><p>资源释放：用户删除PVC来释放PV。当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。</p></li><li><p>资源回收：Kubernetes根据PV设置的回收策略进行资源的回收。对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用。</p></li></ul><h2 id="配置存储">配置存储</h2><h3 id="configmap">ConfigMap</h3><p>ConfigMap是一种比较特殊的存储卷，它的主要作用是存储配置信息。</p><p>ConfigMap也属于一种Resource，例如可以通过如下配置文件创建一个ConfigMap：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">configmap</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">info:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    username:admin</span><br><span class="hljs-string">    password:123456</span><br><span class="hljs-string"></span>  <span class="hljs-attr">myConfig:</span> <span class="hljs-string">test</span><br></code></pre></td></tr></table></figure><blockquote><p>注意这里的<code>｜</code>竖线。在yaml中竖线表示保留文本块中的换行符，因此这里的含义是向<code>data.info</code>传递了<code>username:admin\npassword:123456</code>。</p></blockquote><p>创建之后可以通过describe命令查看详情：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl describe cm configmap -n dev<br></code></pre></td></tr></table></figure><p>创建好了之后，就可以像正常使用Volume的步骤一样，使用ConfigMap。例如现在我们创建一个Pod，在其中挂载ConfigMap，对应的配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-configmap</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">volumeMounts:</span> <span class="hljs-comment"># 将configmap挂载到目录</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/configmap/config</span><br>  <span class="hljs-attr">volumes:</span> <span class="hljs-comment"># 引用configmap</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>    <span class="hljs-attr">configMap:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">configmap</span><br></code></pre></td></tr></table></figure><p>通过进入这个Pod，我们可以发现，ConfigMap对应目录到目录<code>/configmap/config</code>，并且在该目录下有两个文件<code>info, myConfig</code>，并且这两个文件的内容对应就是yaml配置文件中的值。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl <span class="hljs-built_in">exec</span> -it pod-configmap -n dev -- /bin/sh<br><br><span class="hljs-comment"># 以下为进入Pod后的命令执行情况</span><br><br><span class="hljs-comment"># ls    </span><br>bin   dev etc   lib32   media  proc  sbin  tmp<br>boot   docker-entrypoint.d home  lib64   mnt    root  srv   usr<br>configmap  docker-entrypoint.sh  lib   libx32  opt    run   sys   var<br><span class="hljs-comment"># cd configmap/config</span><br><span class="hljs-comment"># ls</span><br>info  myConfig<br><span class="hljs-comment"># cat info</span><br>username:admin<br>password:123456<br><span class="hljs-comment"># cat myConfig  </span><br><span class="hljs-built_in">test</span> <br></code></pre></td></tr></table></figure><p>实际上ConfigMap的核心就在于配置文件中的<code>data</code>字段。在data字段中允许我们以键值对的形式传入内容，并且每个键值对最终会对应到目录下的一个文件，其中Key是文件名称，Value是文件中的内容。并且如果我们更新ConfigMap的内容，Pod中的值也会动态更新。</p><h3 id="secret">Secret</h3><p>Secret与ConfigMap非常类似，它可以完成自动解码，主要用于存储敏感信息，例如密码、秘钥、证书等等。</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes学习笔记(2)-Pod与Pod Controller</title>
    <link href="/2023/07/31/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-Pod%E4%B8%8EPod-Controller/"/>
    <url>/2023/07/31/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-Pod%E4%B8%8EPod-Controller/</url>
    
    <content type="html"><![CDATA[<h1 id="pod">Pod</h1><h2 id="结构与定义">结构与定义</h2><p>在Kubernetes中，每个Pod都可以包含一个或者多个容器，这些容器可以分为两类：</p><ul><li><p>用户程序所在的容器，数量可多可少</p></li><li><p>Pause容器，这是每个Pod都会有的一个<strong>根容器</strong>，它的作用有两个，一方面可以以它为依据，评估整个Pod的健康状态；另一方面可以在根容器上设置Ip地址，其它容器都此Ip（PodIP），以实现Pod<strong>内部</strong>的网络通信</p></li></ul><p>在Kuberents中，每个Resource最终都可以对应一个yaml配置文件，不同的Resource对应的配置文件可选项不同。利用<code>kubectl explain</code>可以查看对应Resource的可配置项以及相关含义：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># kubectl explain 资源类型         查看某种资源可以配置的一级属性</span><br><span class="hljs-comment"># kubectl explain 资源类型.属性     查看属性的子属性</span><br>kubectl explain pod<br>kubectl explain pod.metadata<br></code></pre></td></tr></table></figure><p>每种Resource的可配置项众多，这里不全部列出，需要时可以使用<code>explain</code>命令进行查看。</p><p>在Kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：</p><ul><li><code>apiVersion &lt;string&gt;</code>：版本信息，由Kubernetes内部定义，版本号必须可以用<code>kubectl api-versions</code> 查询到</li><li><code>kind &lt;string&gt;</code>：Resource类型信息，由Kubernetes内部定义，Resource必须可以用<code>kubectl api-resources</code> 查询到</li><li><code>metadata &lt;Object&gt;</code>：元数据信息，主要是资源标识和说明，常用的有name、namespace、labels等</li><li><code>spec &lt;Object&gt;</code>：描述信息，这是配置中最重要的一部分，其中是对各种Resource配置的详细描述</li><li><code>status &lt;Object&gt;</code>：状态信息，里面的内容不需要定义，由Kubernetes自动生成</li></ul><p>在上面的属性中，spec详细信息是配置重点，具有如下的常见子属性:</p><ul><li><code>containers &lt;[]Object&gt;</code>：容器列表，用于定义容器的详细信息</li><li><code>nodeName &lt;String&gt;</code>：根据nodeName的值将pod调度到指定的Node节点上</li><li><code>nodeSelector &lt;map[]&gt;</code>：根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node上</li><li><code>hostNetwork &lt;boolean&gt;</code>：是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</li><li><code>volumes &lt;[]Object&gt;</code>：存储卷，用于定义Pod上面挂载的存储信息</li><li><code>restartPolicy &lt;string&gt;</code>：重启策略，表示Pod在遇到故障的时候的处理策略</li></ul><h2 id="pod-配置">Pod 配置</h2><h3 id="pod-基础配置">Pod 基础配置</h3><p>Pod中可以运行多个Container，Container的配置即为Pod的基础配置。通过<code>kubectl explain pod.spec.containers</code>查看相关信息，其中可配置项如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">KIND:</span>     <span class="hljs-string">Pod</span><br><span class="hljs-attr">VERSION:</span>  <span class="hljs-string">v1</span><br><span class="hljs-attr">RESOURCE:</span> <span class="hljs-string">containers</span> <span class="hljs-string">&lt;[]Object&gt;</span>   <span class="hljs-comment"># 数组，代表可以有多个容器</span><br><span class="hljs-attr">FIELDS:</span><br>   <span class="hljs-string">name</span>  <span class="hljs-string">&lt;string&gt;</span>     <span class="hljs-comment"># 容器名称</span><br>   <span class="hljs-string">image</span> <span class="hljs-string">&lt;string&gt;</span>     <span class="hljs-comment"># 容器需要的镜像地址 [image_name:version]</span><br>   <span class="hljs-string">imagePullPolicy</span>  <span class="hljs-string">&lt;string&gt;</span> <span class="hljs-comment"># 镜像拉取策略 </span><br>   <span class="hljs-string">command</span>  <span class="hljs-string">&lt;[]string&gt;</span> <span class="hljs-comment"># 容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br>   <span class="hljs-string">args</span>     <span class="hljs-string">&lt;[]string&gt;</span> <span class="hljs-comment"># 容器的启动命令需要的参数列表</span><br>   <span class="hljs-string">env</span>      <span class="hljs-string">&lt;[]Object&gt;</span> <span class="hljs-comment"># 容器环境变量的配置</span><br>   <span class="hljs-string">ports</span>    <span class="hljs-string">&lt;[]Object&gt;</span>     <span class="hljs-comment"># 容器需要暴露的端口号列表</span><br>   <span class="hljs-string">resources</span> <span class="hljs-string">&lt;Object&gt;</span>      <span class="hljs-comment"># 资源限制和资源请求的设置</span><br></code></pre></td></tr></table></figure><p><code>name</code>表示运行的container名称，可自定义；<code>image</code>表示container的镜像地址，通常由镜像名称和版本构成。</p><p><code>imagePullPolicy</code>用于设置镜像拉取策略，Kubernetes支持配置三种拉取策略：</p><ul><li>Always：总是从远程仓库拉取镜像（一直远程下载）</li><li>IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就本地本地没远程下载）</li><li>Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错（一直使用本地）</li></ul><p>镜像拉取策略的默认值与镜像tag有一定关系，如果镜像tag为具体版本号，那么默认策略是IfNotPresent，如果镜像tag是latest，那么默认策略是Always。</p><p><code>command</code>表示容器启动命令，<code>args</code>表示启动命令所需的参数。这两个参数主要对应的是DockerFile中的<code>ENTRYPOINT</code>，并且此处的配置要优先于DockerFile中的配置，具体有如下的规则：</p><ul><li>如果command和args均没有配置，那么用Dockerfile的配置；</li><li>如果command配置来，但args没有配置，那么Dockerfile默认的配置会被忽略，执行输入的command</li><li>如果command没配置，但args配置了，那么Dockerfile中配置的ENTRYPOINT的命令会被执行，并且使用当前args的参数</li><li>如果command和args都写配置了，那么Dockerfile的配置被忽略，执行command并追加上args参数</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># command example</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done;&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>env</code>用于在Pod的Container中设置环境变量。不过这种方式不是很推荐，推荐使用后续的ConfigMap来完成相关操作。</p><p><code>ports</code>用于指定容器需要暴露的端口设置，支持如下选项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">KIND:</span>     <span class="hljs-string">Pod</span><br><span class="hljs-attr">VERSION:</span>  <span class="hljs-string">v1</span><br><span class="hljs-attr">RESOURCE:</span> <span class="hljs-string">ports</span> <span class="hljs-string">&lt;[]Object&gt;</span><br><span class="hljs-attr">FIELDS:</span><br>   <span class="hljs-string">name</span>         <span class="hljs-string">&lt;string&gt;</span>  <span class="hljs-comment"># 端口名称，如果指定，必须保证name在pod中是唯一的</span><br>   <span class="hljs-string">containerPort&lt;integer&gt;</span> <span class="hljs-comment"># 容器要监听的端口(0&lt;x&lt;65536)</span><br>   <span class="hljs-string">hostPort</span>     <span class="hljs-string">&lt;integer&gt;</span> <span class="hljs-comment"># 容器要在主机上公开的端口，注意要避免端口冲突(一般省略) </span><br>   <span class="hljs-string">hostIP</span>       <span class="hljs-string">&lt;string&gt;</span>  <span class="hljs-comment"># 要将外部端口绑定到的主机IP(一般省略)</span><br>   <span class="hljs-string">protocol</span>     <span class="hljs-string">&lt;string&gt;</span>  <span class="hljs-comment"># 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”。</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># ports example</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span> <span class="hljs-comment"># 设置容器暴露的端口列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><p><code>resources</code>用于指定容器的资源限制和配额，其中包含两个子选项，分别是<code>limits</code>和<code>requests</code>。limits用于限制运行时容器的最大占用资源，当容器占用资源超过limits时会被终止，并进行重启；requests用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># resources example</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-comment"># 资源配额</span><br>      <span class="hljs-attr">limits:</span>  <span class="hljs-comment"># 限制资源（上限）</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-comment"># CPU限制，单位是core数</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;10Gi&quot;</span> <span class="hljs-comment"># 内存限制</span><br>      <span class="hljs-attr">requests:</span> <span class="hljs-comment"># 请求资源（下限）</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-comment"># CPU限制，单位是core数</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;10Mi&quot;</span>  <span class="hljs-comment"># 内存限制</span><br></code></pre></td></tr></table></figure><h3 id="pod-生命周期">Pod 生命周期</h3><h4 id="概述">概述</h4><p>Pod的生命周期包括Pod对象从创建到终止的全部流程，确切地说分为下面的阶段：</p><ol type="1"><li><p>pod创建过程</p></li><li><p>初始化容器（initcontainer）创建运行过程（这里的初始化容器是个名词）</p></li><li><p>运行主容器（main container）</p><ul><li><p>容器启动后钩子（post start）、容器终止前钩子（pre stop）</p></li><li><p>容器的存活性探测（liveness probe）、就绪性探测（readinessprobe）</p></li></ul></li><li><p>pod终止过程</p></li></ol><p>在整个生命周期中，Pod会出现5种状态，分别如下：</p><ul><li><code>挂起(Pending)</code>：ApiServer已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</li><li><code>运行中(Running)</code>：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成</li><li><code>成功(Succeeded)</code>：pod中的所有容器都已经成功终止并且不会被重启</li><li><code>失败(Failed)</code>：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</li><li><code>未知(Unknown)</code>：ApiServer无法正常获取到pod对象的状态信息，通常由网络通信失败所导致</li></ul><h4 id="创建和终止">创建和终止</h4><p>Pod的创建过程：</p><ol type="1"><li><p>用户通过kubectl或其他api客户端提交需要创建的pod信息给ApiServer</p></li><li><p>ApiServer开始生成pod对象的信息，并将信息存入etcd，然后返回确认信息至客户端</p></li><li><p>ApiServer开始反映etcd中的pod对象的变化，其它组件使用watch机制来跟踪检查ApiServer上的变动</p></li><li><p>Scheduler发现有新的pod对象要创建，开始为Pod分配主机并将结果信息更新至ApiServer</p></li><li><p>Node节点上的kubelet发现有pod调度过来，尝试调用docker启动容器，并将结果回送至ApiServer</p></li><li><p>ApiServer将接收到的pod状态信息存入etcd中</p></li></ol><p>Pod的终止过程：</p><ol type="1"><li>用户向ApiServer发送删除pod对象的命令</li><li>ApiServer中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead</li><li>将pod标记为terminating状态</li><li>kubelet在监控到pod对象转为terminating状态的同时启动pod关闭过程</li><li>Endpoint控制器监控到pod对象的关闭行为时，将其从所有匹配到此Endpoint的service资源的端点列表中移除</li><li>如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式启动执行</li><li>pod对象中的容器进程收到停止信号</li><li>宽限期结束后，若pod中还存在仍在运行的进程，那么pod对象会收到立即终止的信号</li><li>kubelet请求ApiServer将此pod资源的宽限期设置为0从而完成删除操作，此时pod对于用户已不可见</li></ol><h4 id="初始化容器">初始化容器</h4><p>初始化容器是在pod的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：</p><ol type="1"><li>初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么Kubernetes需要重启它直到成功完成</li><li>初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行</li></ol><p>初始化容器有很多的应用场景，下面列出的是最常见的几个：</p><ul><li>提供主容器镜像中不具备的工具程序或自定义代码</li><li>初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足</li></ul><p>初始化容器的配置可以在<code>spec.initContainers</code>中完成，它具有的配置项与<code>spec.Containers</code>基本相同。</p><h4 id="钩子函数">钩子函数</h4><p>钩子（hook）函数向用户提供生命周期对应时间点的控制方法。用户可以通过hook函数完成在生命周期的不同时间点执行不同的方法。</p><p>Kubernetes在主容器的启动之后和停止之前提供了两个钩子函数：</p><ul><li><code>post start</code>：容器创建之后执行，如果失败了会重启容器</li><li><code>pre stop</code>：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</li></ul><p>钩子处理器支持使用下面三种方式定义动作，配置在<code>spec.containers.lifecycle</code>选项当中。下面演示的是poststart阶段的配置，pre stop阶段有类似的配置选项。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># exec: 在容器内部执行一次命令</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">containers:</span><br><span class="hljs-attr">lifecycle:</span><br><span class="hljs-attr">postStart:</span><br>        <span class="hljs-attr">exec:</span><br>          <span class="hljs-attr">command:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">/tmp/healthy</span><br><br><span class="hljs-comment"># tcpSocket: 在容器内部尝试访问指定一个用户容器的端口</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">containers:</span><br><span class="hljs-attr">lifecycle:</span><br><span class="hljs-attr">postStart:</span><br><span class="hljs-attr">tcpSocket:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-comment"># httpGet: 在容器内部向某url发起http请求</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">containers:</span><br><span class="hljs-attr">lifecycle:</span><br><span class="hljs-attr">postStart:</span><br><span class="hljs-attr">httpGet:</span><br><span class="hljs-attr">path:</span> <span class="hljs-string">/xxx</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.5</span><span class="hljs-number">.3</span> <span class="hljs-comment"># 主机地址</span><br><span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span> <span class="hljs-comment"># 支持的协议 HTTP/HTTPS</span><br></code></pre></td></tr></table></figure><h4 id="容器探测">容器探测</h4><p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么Kubernetes就会把该问题实例"摘除"，不承担业务流量。Kubernetes提供了两种探针来实现容器探测，分别是：</p><ul><li><code>liveness probe</code>：存活性探针，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器</li><li><code>readiness probe</code>：就绪性探针，用于检测应用实例当前是否可以接收请求，如果不能，k8s不会转发流量，但是并不会处理(重启或杀死)这个容器</li></ul><p>这两种探针均支持三种方式，配置在<code>spec.containers.livenessProbe</code>或者<code>readinessProbe</code>中。三种方式与钩子函数中的三种方式基本相同：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># exec: 如果命令执行的退出码为0则认为正常，否则不正常</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">containers:</span><br><span class="hljs-attr">livenessProbe:</span><br><span class="hljs-attr">exec:</span><br><span class="hljs-attr">command:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">/tmp/healthy</span><br><br><span class="hljs-comment"># tcpSocket: 访问一个用户容器的端口，如果能够建立socket连接则认为正常，否则不正常</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">containers:</span><br><span class="hljs-attr">livenessProbe:</span><br><span class="hljs-attr">tcpSocket:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-comment"># httpGet: 如果返回的状态码在200和399之间则认为正常，否则不正常</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">containers:</span><br><span class="hljs-attr">livenessProbe:</span><br><span class="hljs-attr">httpGet:</span><br><span class="hljs-attr">path:</span> <span class="hljs-string">/xxx</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-attr">host:</span> <span class="hljs-string">xxx.xxx.xxx.xxx</span><br><span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span> <span class="hljs-comment"># HTTP/HTTPS</span><br></code></pre></td></tr></table></figure><h4 id="重启策略">重启策略</h4><p>对于出现问题的Pod，Kubernetes会对其进行重启，而重启是遵循一定的重启策略的。Pod的重启策略可以在<code>spec.restartPolicy</code>中进行配置，共有三种可选项，如下所示：</p><ul><li><code>Always</code> ：容器失效时，自动重启该容器，这也是默认值</li><li><code>OnFailure</code> ： 容器终止运行且退出码不为0时重启</li><li><code>Never</code> ： 不论状态为何，都不重启该容器</li></ul><p>重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长。</p><h3 id="pod-调度">Pod 调度</h3><p>在默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，我们可能想控制某些Pod到达某些节点上，Kubernetes也提供相应的方式来完成这种需求。Kubernetes提供了四种调度方式：</p><ul><li>自动调度：运行在哪个节点上完全由Scheduler经过一系列的算法计算得出</li><li>定向调度：NodeName、NodeSelector</li><li>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity</li><li>污点（容忍）调度：Taints、Toleration</li></ul><h4 id="定向调度">定向调度</h4><p>定向调度的含义是Pod声明自己期望被调度到Node。我们可以在Pod上声明需要被调度到的目标Node，或者目标Node列表（以NodeSelector的形式提供）。由于定向调度是强制性的，因此如果期望的目标Node不存在的话，Pod会运行失败。这种方式实际上是直接跳过了Scheduler的调度逻辑，直接向目标Node上进行调度。</p><p>期望Node可以通过NodeName或者NodeSelector来提供，配置项的位置为<code>spec.nodeName</code>或者<code>spec.nodeSelector</code>。其中NodeSelector是基于label-selector机制进行匹配的，通常会选择出一组具有对应Label的Node作为目标Node。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># nodeName</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">nodeName:</span> <span class="hljs-string">node1</span><br><br><span class="hljs-comment"># nodeSelector</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">nodeSelector:</span><br><span class="hljs-attr">nodeenv:</span> <span class="hljs-string">preprod</span>  <span class="hljs-comment"># 指定调度到具有nodeenv=preprod标签的节点上</span><br></code></pre></td></tr></table></figure><h4 id="亲和性调度">亲和性调度</h4><p>亲和性调度描述的是一种调度的倾向。与定向调度的强制性不同，亲和性调度会优先满足倾向条件，但是如果实在没有办法满足的话，Pod还是能够运行，这样使得调度更加灵活。</p><p>亲和性实际上描述的是是否将两个Pod部署得更加靠近，如果两个Pod之间交互频繁，那么就可以认为它们之间具有亲和性，因此就可以尽可能得将其部署在同一个Node上，减少网络传输带来的性能损耗。不过在进行应用的多副本部署的时候，反而要注意不应该将Pod都部署在同一个Node上，这样不利于提高服务的高可用性。</p><p>亲和性调度主要分为以下三种类型：</p><ul><li><code>nodeAffinity</code>：描述Node倾向于接受哪些Pod</li><li><code>podAffinity</code>：描述Pod倾向于和哪些已经被调度的Pod部署在一起</li><li><code>podAntiAffinity</code>：描述Pod倾向于不和哪些已经被调度的Pod部署在一起</li></ul><h4 id="污点和容忍">污点和容忍</h4><p>前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加污点(Traints)属性，来决定是否允许Pod调度过来。</p><p>在Node上如果添加了污点Traints，就表示这个Node会拒绝这类Node调度过来，甚至可以将已经存在的Pod进行驱逐。实际上，如果我们使用的是kubeadm来搭建的集群，默认就会给master节点添加一个污点标记,所以pod就不会调度到master节点上。</p><p>污点的格式为：<code>key=value:effect</code>,key和value是污点的标签，effect描述污点的作用，支持如下三个选项：</p><ul><li>PreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可调度</li><li>NoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但不会影响当前Node上已存在的Pod</li><li>NoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已存在的Pod驱离</li></ul><p>可以使用kubectl命令行来设置和去除污点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 设置污点</span><br>kubectl taint nodes node1 key=value:effect<br><br><span class="hljs-comment"># 去除污点[减号]</span><br>kubectl taint nodes node1 key:effect-<br><br><span class="hljs-comment"># 去除所有污点[减号]</span><br>kubectl taint nodes node1 key-<br></code></pre></td></tr></table></figure><p>容忍(Toleration)与污点的作用正好是相反的，污点的作用是让Node拒绝某些Pod；而容忍的作用是强制让这类Pod调度到Node上。容忍是针对与污点来说的，污点表示Node的拒绝策略，而容忍污点表示Pod忽略这种拒绝策略。容忍的相关配置在<code>spec.tolerations</code>中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">KIND:</span>     <span class="hljs-string">Pod</span><br><span class="hljs-attr">VERSION:</span>  <span class="hljs-string">v1</span><br><span class="hljs-attr">RESOURCE:</span> <span class="hljs-string">tolerations</span> <span class="hljs-string">&lt;[]Object&gt;</span><br><span class="hljs-attr">FIELDS:</span><br>   <span class="hljs-string">key</span>       <span class="hljs-comment"># 对应着要容忍的污点的键，空意味着匹配所有的键</span><br>   <span class="hljs-string">value</span>     <span class="hljs-comment"># 对应着要容忍的污点的值</span><br>   <span class="hljs-string">operator</span>  <span class="hljs-comment"># key-value的运算符，支持Equal和Exists（默认）</span><br>   <span class="hljs-string">effect</span>    <span class="hljs-comment"># 对应污点的effect，空意味着匹配所有影响</span><br>   <span class="hljs-string">tolerationSeconds</span>   <span class="hljs-comment"># 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间</span><br></code></pre></td></tr></table></figure><h1 id="pod-controller">Pod Controller</h1><h2 id="简介">简介</h2><p>Pod是Kubernetes的最小管理单元，在kubernetes中，按照pod的创建方式可以将其分为两类：</p><ul><li>自主式pod：Kubernetes直接创建出来的Pod，这种pod删除后就没有了，也不会重建</li><li>控制器创建的pod：kubernetes通过控制器创建的pod，这种pod删除了之后还会自动重建</li></ul><p>Pod控制器是管理pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器我们最终的期望状态就行，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。</p><p>在Kubernetes中，有很多类型的pod控制器，每种都有自己的适合的场景，常见的有下面这些：</p><ul><li><code>ReplicaSet</code>：保证副本数量一直维持在期望值，并支持pod数量扩缩容，镜像版本升级</li><li><code>Deployment</code>：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本</li><li><code>Horizontal Pod Autoscaler</code>：可以根据集群负载自动水平调整Pod的数量，实现削峰填谷</li><li><code>DaemonSet</code>：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务</li><li><code>Job</code>：创建出来的pod只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务</li><li><code>Cronjob</code>：它创建的Pod负责周期性任务控制，不需要持续后台运行</li></ul><h2 id="replicasetrs">ReplicaSet(RS)</h2><p>ReplicaSet的主要作用是保证一定数量的pod正常运行，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对pod数量的扩缩容和镜像版本的升降级。</p><p>ReplicaSet的资源清单描述如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment"># 标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">rs</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 副本数量，即需要创建出Pod的数量，默认为1</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># Expressions匹配规则</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">nginx-pod</span>]&#125;<br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本，其中的字段与Pod相关字段基本相同</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>如果需要临时执行<strong>扩缩容</strong>的话，直接修改对应的yaml配置文件即可，PodController会监测配置文件并确保系统的最终状态符合文件的描述。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 可以通过edit命令修改对应配置文件，该命令会唤起编辑器</span><br>kubectl edit rs &lt;rs-name&gt; -n &lt;namespace&gt;<br></code></pre></td></tr></table></figure><p>当然也可以直接使用scale命令进行扩缩容，直接在<code>--replicas=n</code>后面指定目标数量即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># scale扩缩容</span><br>kubectl scale rs &lt;rs-name&gt; --replicas=xx<br></code></pre></td></tr></table></figure><p>如果需要<strong>升级镜像</strong>的话，也可以通过编辑配置文件的命令来完成，或者通过<code>set image</code>命令来完成：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># set image更新镜像</span><br><span class="hljs-comment"># kubectl set image rs rs名称 容器=镜像版本 -n namespace</span><br>kubectl <span class="hljs-built_in">set</span> image rs &lt;rs-name&gt; &lt;container-name&gt;=&lt;image_name&gt;:&lt;version&gt;<br></code></pre></td></tr></table></figure><h2 id="deploymentdeploy">Deployment(Deploy)</h2><p>为了更好的解决服务编排的问题，Kubernetes在V1.2版本开始，引入了<code>Deployment</code>Pod控制器。这种控制器并不直接管理pod，而是通过管理ReplicaSet来简介管理Pod，因此Deployment比ReplicaSet功能更加强大。</p><p>除了支持ReplicaSet的所有功能之外，Deployment还支持发布的停止和继续，支持版本的滚动升级和回滚等。</p><p>Deployment的资源清单描述如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">deploy</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 副本数量</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 保留历史版本</span><br>  <span class="hljs-attr">paused:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 暂停部署，默认是false，决定创建了Deployment之后是暂停，还是直接创建Pod</span><br>  <span class="hljs-attr">progressDeadlineSeconds:</span> <span class="hljs-number">600</span> <span class="hljs-comment"># 部署超时时间（s），默认是600</span><br>  <span class="hljs-attr">strategy:</span> <span class="hljs-comment"># 镜像更新策略</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span> <span class="hljs-comment"># 滚动更新策略</span><br>    <span class="hljs-attr">rollingUpdate:</span> <span class="hljs-comment"># 滚动更新</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">30</span><span class="hljs-string">%</span> <span class="hljs-comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">30</span><span class="hljs-string">%</span> <span class="hljs-comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># Expressions匹配规则</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">nginx-pod</span>]&#125;<br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>Deployment的<strong>扩缩容</strong>操作与ReplicaSet相同，可以通过修改配置文件或者scale命令来完成。</p><p>在<strong>镜像更新</strong>方面，Deployment支持两种更新策略:<code>Recreate</code>和<code>RollingUpadte</code>,可以通过<code>strategy</code>指定策略类型,支持两个属性:默认滚动更新。</p><ul><li><code>Recreate</code>：在创建出新的Pod之前会先杀掉所有已存在的Pod</li><li><code>RollingUpdate</code>：杀死一部分，再启动一部分，在更新过程中，存在两个版本Pod</li></ul><p>Deployment还支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能。实际上，Deplyment会保存历史过程中的ReplicaSet，如果需要进行回退，可以直接重新调用原来的ReplicaSet。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl rollout： 版本升级相关功能，支持下面的选项：<br><br>- status显示当前升级状态<br>- <span class="hljs-built_in">history</span>   显示 升级历史记录<br>- pause    暂停版本升级过程<br>- resume   继续已经暂停的版本升级过程<br>- restart    重启版本升级过程<br>- undo 回滚到上一级版本（可以使用--to-revision回滚到指定版本）<br></code></pre></td></tr></table></figure><blockquote><p>补充：金丝雀发布</p><p>金丝雀发布指的是在发布过程中先让一部分Pod进行更新，此时在整个提供服务的Pod中，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。</p></blockquote><h2 id="horizontal-pod-autoscalerhpa">Horizontal PodAutoscaler(HPA)</h2><p>Horizontal PodAutoscaler(HPA)能够完成Pod数量的动态调整，即自动化扩缩容。</p><p>HPA可以获取每个Pod利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。其实HPA与之前的Deployment一样，也属于一种Kubernetes资源对象，它通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性地调整目标Pod的副本数。</p><h2 id="daemonsetds">DaemonSet(DS)</h2><p>DaemonSet类型的控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。</p><p>每当向集群中添加一个Node的时候，指定的Pod副本也会添加到该节点上；当节点从集群中移除时，Pod也会被垃圾回收。</p><h2 id="job">Job</h2><p>Job，主要用于负责批量处理短暂的，一次性的(每个任务仅运行一次就结束)任务。当Job创建的pod执行成功结束时，Job将记录成功结束的pod数量；当成功结束的pod达到指定的数量时，Job将完成执行</p><p>Job的资源描述如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">job</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">completions:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 指定job需要成功运行Pods的次数。默认值: 1</span><br>  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 指定job在任一时刻应该并发运行Pods的数量。默认值: 1</span><br>  <span class="hljs-attr">activeDeadlineSeconds:</span> <span class="hljs-number">30</span> <span class="hljs-comment"># 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。</span><br>  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">6</span> <span class="hljs-comment"># 指定job失败后进行重试的次数。默认是6</span><br>  <span class="hljs-attr">manualSelector:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否可以使用selector选择器选择pod，默认是false</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-comment"># ...</span><br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span><br>   <span class="hljs-comment"># ...</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span> <span class="hljs-comment"># 重启策略只能设置为Never或者OnFailure</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><h2 id="cronjobcj">CronJob(CJ)</h2><p>CronJob控制器以Job控制器资源为其管控对象，并借助它管理pod资源对象。Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以用作定时任务，控制其运行时间点和重复运行的方式。调度方式使用Linux中的cron格式描述，可以参考<ahref="https://phoenixnap.com/kb/set-up-cron-job-linux">How to Set Up aCron Job in Linux? {Schedule Tasks} | PhoenixNAP KB</a></p><p>CronJob的资源描述如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1beta1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">cronjob</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">schedule:</span> <span class="hljs-comment"># cron格式的作业调度运行时间点,用于控制任务在什么时间执行</span><br>  <span class="hljs-attr">concurrencyPolicy:</span> <span class="hljs-comment"># 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业</span><br>  <span class="hljs-attr">failedJobHistoryLimit:</span> <span class="hljs-comment"># 为失败的任务执行保留的历史记录数，默认为1</span><br>  <span class="hljs-attr">successfulJobHistoryLimit:</span> <span class="hljs-comment"># 为成功的任务执行保留的历史记录数，默认为3</span><br>  <span class="hljs-attr">startingDeadlineSeconds:</span> <span class="hljs-comment"># 启动作业错误的超时时长</span><br>  <span class="hljs-attr">jobTemplate:</span> <span class="hljs-comment"># job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义</span><br>   <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>其中并发执行策略有三种选项：</p><ul><li><code>Allow</code>：允许Jobs并发运行(默认)</li><li><code>Forbid</code>：禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行</li><li><code>Replace</code>：替换，取消当前正在运行的作业并用新作业替换它</li></ul>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes学习笔记(1)-简介与基本使用</title>
    <link href="/2023/07/29/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/07/29/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="kubernetes简介">Kubernetes简介</h1><h2 id="背景介绍">背景介绍</h2><p>应用程序的部署方式主要经历了三个时代。传统部署将应用程序部署在物理机上，这种方式实现简单，但是很难合理地分配计算资源，容易导致资源浪费以及程序之间相互影响。而后发展到虚拟化部署，即可以在一台物理机上运行多个虚拟机，每个虚拟机都是一个独立的环境，每个程序部署在一台虚拟机上，这种方式程序之间不会相互影响，但是增加了操作系统的虚拟，同样会浪费部分资源。部署方式继续发展，到容器化部署。容器化与虚拟化部署类似，但是容器之间共享操作系统，降低了资源的浪费。</p><p>在容器化部署的相关过程中，一个非常重要的课题就是容器编排。容器管理的相关问题统称为容器编排问题。例如当某个容器故障停机之后，如何让另外一个容器立刻启动去替补停机的容器；或者如何根据并发访问量的多少来动态地调整容器的数量。</p><p>以下许多软件来解决容器编排问题，而我们主要学习的是其中最受欢迎，使用最为广泛的Kubernetes。</p><ul><li><code>Swarm</code>：Docker自己的容器编排工具</li><li><code>Mesos</code>：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li><li><code>Kubernetes</code>：Google开源的的容器编排工具</li></ul><p>kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p><ul><li><strong>自我修复</strong>：一旦某一个容器崩溃，能够在1秒左右迅速启动新的容器</li><li><strong>弹性伸缩</strong>：可以根据需要，自动对集群中正在运行的容器数量进行调整</li><li><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</li><li><strong>负载均衡</strong>：如果一个服务启动了多个容器，能够自动实现请求的负载均衡</li><li><strong>版本回退</strong>：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li><li><strong>存储编排</strong>：可以根据容器自身的需求自动创建存储卷</li></ul><blockquote><p>Kubernetes的环境搭建，可以参考官方文档<ahref="https://kubernetes.io/docs/setup/">GettingStarted|Kubernetes</a>。</p><p>另外，如果在Mac或者Windows上安装过DockerDesktop，可以在设置中开启Kubernetes的支持，就可以在本地进行Kubernetes的使用，可以参考相关博客<ahref="https://blog.csdn.net/liumiaocn/article/details/110037640">Kubernetes基础:在MacOS上安装Kubernetes</a>。</p></blockquote><h2 id="组件与相关概念">组件与相关概念</h2><p>Kubernetes属于主从架构，集群中的角色分为<strong>控制节点Master</strong>以及<strong>工作节点Node</strong>，在不同的节点上会安装不同的组件。</p><p>Master节点是整个集群的控制平面，负责集群的管理与决策，其中包含如下组件：</p><ul><li><code>ApiServer</code>：资源操作的唯一入口，用于接收用户输入的命令，提供认证、授权、API注册和发现等机制</li><li><code>Scheduler</code>：负责集群资源调度，按照预定的调度策略将Pod调度到相应的Node节点上</li><li><code>ControllerManager</code>：负责维护集群的状态，例如程序部署安排、故障检测、自动扩展、滚动更新等</li><li><code>Etcd</code>：负责存储集群中各种资源对象的信息</li></ul><p>Node节点是集群的数据平面，负责为容器提供运行环境，用于实际运行容器，其中包含如下组件：</p><ul><li><code>Kubelet</code>：负责维护容器的生命周期，通过控制Docker，来创建、更新销毁容器。</li><li><code>KubeProxy</code>：负责提供集群内部的服务发现和负载均衡</li><li><code>Docker</code>：负责节点上容器的各种操作</li></ul><img src="/2023/07/29/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Kubernetes%E7%BB%84%E4%BB%B6.png" class="" title="Kubernetes 组件"><p>现在假设我们需要在Kubernetes上部署一个nginx服务，那么需要经过如下的步骤：</p><ol type="1"><li>首先启动Kubernetes环境，Master和Node将自身的信息注册到etcd数据库中</li><li>nginx服务到安装请求通过kubectl发送到Master节点上的ApiServer组件</li><li>ApiServer组件调用Scheduler组件来决定把这个服务安装到哪个Node节点上。这个过程需要从etcd中读取各个Node节点的信息，然后按照调度算法进行选择，并将选择结果告知ApiServer</li><li>ApiServer调用ControllerManager来调度Node节点安装nginx服务</li><li>Kubelet接收到指令之后，通知Docker，由Docker来启动一个nginx的Pod。这里的Pod是Kubernetes中的最小操作单元，Container容器必须运行在某个Pod当中</li><li>至此，一个nginx服务就运行成功了，如果外界需要访问该服务，则需要通过KubeProxy来令Pod产生可访问的代理，之后外界用户就可以访问集群中的nginx服务</li></ol><p>下面统一介绍Kubernetes中的相关概念：</p><ul><li><code>Master</code>：集群控制节点，每个集群至少需要一个Master节点来负责集群的管理和控制</li><li><code>Node</code>：工作负载节点，由Master分配容器到这些Node工作节点上，然后Node节点中的Docker负责容器的运行</li><li><code>Pod</code>：Kubernetes中的最小控制单元，容器都是运行在Pod中的。一个Pod中可以有一个或者多个容器</li><li><code>Controller</code>：控制器，可以通过控制器来实现对Pod的管理，例如启动Pod、停止Pod、伸缩Pod的数量等</li><li><code>Service</code>：Pod对外服务的统一入口，其中可以维护同一类的多个Pod</li><li><code>Label</code>：标签，用于对资源进行分类，同一类资源会拥有相同的标签</li><li><code>Namespace</code>：命名空间，用于隔离Pod的运行环境</li></ul><h1 id="资源管理">资源管理</h1><h2 id="介绍">介绍</h2><p>在Kubernetes中，所有内容都被抽象为资源，用户需要通过操作资源来管理Kubernetes。</p><p>Kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务。所谓的部署服务，其实就是在Kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。Kubernetes的最小管理单元是Pod而不是容器，所以只能将容器放在<code>Pod</code>中，而Kubernetes一般也不会直接管理Pod，而是通过<code>Pod控制器</code>来管理Pod的。Pod可以提供服务之后，就要考虑如何访问Pod中服务，Kubernetes提供了<code>Service</code>资源实现这个功能。当然，如果Pod中程序的数据需要持久化，Kubernetes还提供了各种<code>存储</code>系统。</p><p>学习Kubernetes的核心，就是学习如何对集群上的Pod、Pod控制器、Service、存储等各种资源进行操作。</p><h2 id="kubectl">kubectl</h2><p>Kubernetes提供了一个命令行工具kubectl，该命令行工具能够对集群本身进行管理，并且能够在集群上进行容器化应用的安装部署。kubectl命令的语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl [<span class="hljs-built_in">command</span>] [<span class="hljs-built_in">type</span>] [name] [params]<br></code></pre></td></tr></table></figure><ul><li><code>command</code>：指定需要对资源执行的操作，例如create、get、delete</li><li><code>type</code>：指定资源的类型，例如deployment、pod、service</li><li><code>name</code>：指定资源的名称，注意是大小写敏感的</li><li><code>params</code>：指定额外的可选参数</li></ul><p>下面是一些命令的举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看所有pod</span><br>kubectl get pod <br><br><span class="hljs-comment"># 查看某个pod</span><br>kubectl get pod pod_name<br><br><span class="hljs-comment"># 查看某个pod,以yaml格式展示结果</span><br>kubectl get pod pod_name -o yaml<br>kubectl get pod pod_name -o wide<br></code></pre></td></tr></table></figure><blockquote><p>Tips：在Node节点上运行kubectl</p><p>kubectl的运行是需要进行配置的，它的配置文件是$HOME/.kube，如果想要在node节点运行kubectl，需要将master上的.kube文件复制到node节点上，可以通过在master节点上执行scp命令来完成文件的复制。</p></blockquote><h3 id="资源类型">资源类型</h3><p>在Kubernetes中所有的内容都被抽象为resource，可以通过下面的命令查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl api-resources<br></code></pre></td></tr></table></figure><p>其中常用的resource类型有：</p><blockquote><p>不必过于在意resource名称的单复数，kubectl都能够支持</p></blockquote><ul><li>集群资源：属于集群组成的一部份</li></ul><table><thead><tr class="header"><th>resource名称</th><th>缩写</th></tr></thead><tbody><tr class="odd"><td>nodes</td><td>no</td></tr></tbody></table><ul><li>namespace：命名空间，用于隔离Pod</li></ul><table><thead><tr class="header"><th>resource名称</th><th>缩写</th></tr></thead><tbody><tr class="odd"><td>namespace</td><td>ns</td></tr></tbody></table><ul><li>pod：用于装载容器</li></ul><table><thead><tr class="header"><th>resource名称</th><th>缩写</th></tr></thead><tbody><tr class="odd"><td>pods</td><td>pd</td></tr></tbody></table><ul><li>pod controller：用于控制Pod资源</li></ul><table><thead><tr class="header"><th>resource名称</th><th>缩写</th></tr></thead><tbody><tr class="odd"><td>replicationcontrollers</td><td>rc</td></tr><tr class="even"><td>replicasets</td><td>rs</td></tr><tr class="odd"><td>deployments</td><td>deploy</td></tr><tr class="even"><td>daemonsets</td><td>ds</td></tr><tr class="odd"><td>jobs</td><td></td></tr><tr class="even"><td>cronjobs</td><td>cj</td></tr><tr class="odd"><td>horizontalpodautoscalers</td><td>hpa</td></tr><tr class="even"><td>statefulsets</td><td>sts</td></tr></tbody></table><ul><li>服务发现：Pod的统一对外服务接口</li></ul><table><thead><tr class="header"><th>resource名称</th><th>缩写</th></tr></thead><tbody><tr class="odd"><td>services</td><td>svc</td></tr><tr class="even"><td>ingress</td><td>ing</td></tr></tbody></table><ul><li>存储资源：支持存储相关功能</li></ul><table><thead><tr class="header"><th>resource名称</th><th>缩写</th></tr></thead><tbody><tr class="odd"><td>volumeattachements</td><td></td></tr><tr class="even"><td>persistentvolumes</td><td>pv</td></tr><tr class="odd"><td>persistentvolumeclaims</td><td>pvc</td></tr></tbody></table><ul><li>配置资源：支持配置相关功能</li></ul><table><thead><tr class="header"><th>resource名称</th><th>缩写</th></tr></thead><tbody><tr class="odd"><td>configmaps</td><td>cm</td></tr><tr class="even"><td>secrets</td><td></td></tr></tbody></table><h3 id="操作类型">操作类型</h3><p>Kubernetes允许对resource进行多种操作，可以通过<code>--help</code>来查看详细的操作命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>其中常用的操作类型有：</p><ul><li>基本命令：</li></ul><table><thead><tr class="header"><th>操作</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>create</td><td>创建资源</td></tr><tr class="even"><td>edit</td><td>编辑资源</td></tr><tr class="odd"><td>get</td><td>查看资源</td></tr><tr class="even"><td>patch</td><td>更新资源</td></tr><tr class="odd"><td>delete</td><td>删除资源</td></tr><tr class="even"><td>explain</td><td>展示资源详情</td></tr></tbody></table><ul><li>运行与调试：</li></ul><table><thead><tr class="header"><th>操作</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>run</td><td>在集群中运行指定的镜像</td></tr><tr class="even"><td>expose</td><td>暴露资源为Service</td></tr><tr class="odd"><td>describe</td><td>显示资源内部信息</td></tr><tr class="even"><td>logs</td><td>输出容器在Pod中的日志</td></tr><tr class="odd"><td>attach</td><td>进入运行中的容器</td></tr><tr class="even"><td>exec</td><td>执行容器中的某个命令</td></tr><tr class="odd"><td>cp</td><td>在Pod内外复制文件</td></tr><tr class="even"><td>rollout</td><td>管理资源的发布</td></tr><tr class="odd"><td>scale</td><td>对Pod的规模进行调整（扩缩容）</td></tr><tr class="even"><td>autoscale</td><td>自动调整Pod的数量</td></tr></tbody></table><ul><li>高级命令：</li></ul><table><thead><tr class="header"><th>操作</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>apply</td><td>通过文件对资源进行配置</td></tr><tr class="even"><td>label</td><td>更新资源上的标签</td></tr></tbody></table><ul><li>其他命令：</li></ul><table><thead><tr class="header"><th>操作</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>cluster-info</td><td>显示集群信息</td></tr><tr class="even"><td>version</td><td>显示版本信息，包括Server以及Client</td></tr></tbody></table><h2 id="管理方式">管理方式</h2><p>Kubernetes共有三种资源管理方式，分别是命令式对象管理、命令式对象配置以及声明式对象配置。</p><ul><li>命令式对象管理：指的是直接使用命令去操作Kubernetes资源</li><li>命令式对象配置：通过命令和配置文件去操作Kubernetes资源，命令包括create/patch</li><li>声明式对象配置：通过apply命令和配置文件操作Kubernetes资源，其中apply用于创建和更新资源，无法删除资源</li></ul><table><thead><tr class="header"><th style="text-align: left;">类型</th><th style="text-align: left;">操作对象</th><th style="text-align: left;">适用环境</th><th style="text-align: left;">优点</th><th style="text-align: left;">缺点</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">命令式对象管理</td><td style="text-align: left;">对象</td><td style="text-align: left;">测试</td><td style="text-align: left;">简单</td><td style="text-align: left;">只能操作活动对象，无法审计、跟踪</td></tr><tr class="even"><td style="text-align: left;">命令式对象配置</td><td style="text-align: left;">文件</td><td style="text-align: left;">开发</td><td style="text-align: left;">可以审计、跟踪</td><td style="text-align: left;">项目大时，配置文件多，操作麻烦</td></tr><tr class="odd"><td style="text-align: left;">声明式对象配置</td><td style="text-align: left;">目录</td><td style="text-align: left;">开发</td><td style="text-align: left;">支持目录操作</td><td style="text-align: left;">意外情况下难以调试</td></tr></tbody></table><h3 id="命令式对象管理">命令式对象管理</h3><p>命令式对象管理指的是直接使用命令去操作Kubernetes资源，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个namesapce</span><br>kubectl create namespace dev<br><br><span class="hljs-comment"># 查看namespace</span><br>kubectl get ns  <br><br><span class="hljs-comment"># 在dev namepsace下创建并运行一个nginx的pod</span><br>kubectl run pod --image=nginx:latest -n dev<br><br><span class="hljs-comment"># 查看pod</span><br>kubectl get pod -n dev<br><span class="hljs-comment"># 结果如下</span><br>NAME   READY   STATUS    RESTARTS   AGE<br>pod    1/1     Running   0          46s<br><br><span class="hljs-comment"># 删除指定pod</span><br>kubectl delete pod pod -n dev<br></code></pre></td></tr></table></figure><h3 id="命令式对象配置">命令式对象配置</h3><p>命令式对象配置就是使用命令配合配置文件一起来操作Kubernetes Resource。这种方式可以简单的认为是命令 +yaml配置文件（里面是命令需要的各种参数）</p><p>例如我们可以创建一个配置文件<code>nginx-pod.yaml</code>，这个配置文件基本描述了Pod运行的环境以及相关的属性，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dev</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginxpod</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-containers</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br></code></pre></td></tr></table></figure><p>该配置文件完成了两个资源的定义。首先定义了一个namespace，名称为<code>dev</code>。然后定义了一个pod，该pod的名称为<code>nginxpod</code>，运行在<code>dev</code>namespace中，同时在详细信息<code>spec</code>中指定了容器的名称以及对应的镜像。</p><p>之后执行create命令进行资源创建，提示创建了namespace dev 以及podnginxpod，可以通过相关get命令查看到创建出的资源。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl create -f nginx-pod.yaml<br><span class="hljs-comment"># namespace/dev created</span><br><span class="hljs-comment"># pod/nginxpod created</span><br></code></pre></td></tr></table></figure><p>同时也可以使用删除命令，同时删除这两个资源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl delete -f nginx-pod.yaml <br><span class="hljs-comment"># namespace &quot;dev&quot; deleted</span><br><span class="hljs-comment"># pod &quot;nginxpod&quot; deleted</span><br></code></pre></td></tr></table></figure><h3 id="声明式对象配置">声明式对象配置</h3><p>声明式对象配置跟命令式对象配置很相似，但是它只有一个命令apply。</p><p>同样使用上面的实例配置文件，首先第一次执行apply命令，发现创建了资源。之后我们可以继续执行，发现资源没有变动。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f nginx-pod.yaml     <br><span class="hljs-comment"># namespace/dev created</span><br><span class="hljs-comment"># pod/nginxpod created</span><br><br>kubectl apply -f nginx-pod.yaml<br><span class="hljs-comment"># namespace/dev unchanged</span><br><span class="hljs-comment"># pod/nginxpod unchanged</span><br></code></pre></td></tr></table></figure><p>实际上，声明式对象配置使用yaml配置文件来描述资源的最终状态，然后使用apply命令来将资源调整为描述的状态，如果没有该资源就进行创建，如果有修改就进行调整，没有变化就什么也不做。</p><p>使用apply操作资源，如果资源不存在，就创建，相当于 kubectlcreate；如果资源已存在，就更新，相当于 kubectl patch。</p><blockquote><p>推荐使用方式：</p><ul><li>创建/更新资源 使用声明式对象配置 kubectl apply -f xxx.yaml</li><li>删除资源 使用命令式对象配置 kubectl delete -f xxx.yaml</li><li>查询资源 使用命令式对象管理 kubectl get(describe) 资源名称</li></ul></blockquote><h1 id="getting-started">Getting Started</h1><p>接下来我们通过在Kubernetes集群中部署一个可供外界访问的nginx服务来初步学习Kubernetes的使用以及相关概念。</p><h2 id="namespace">Namespace</h2><p>namespace是Kubernetes系统中非常重要的resource，它的主要作用是实现多套环境的资源隔离或者多租户的资源隔离。</p><p>在默认情况下，Kubernetes集群中的所有Pod都是可以相互访问的，但是在实际中，我们可能不想让两个Pod之间进行相互访问，那么此时就可以将两个Pod划分到不同的namespace下。</p><p>Kubernetes通过namespace机制来划分逻辑上的组，方便对不同组的资源进行隔离和管理。同时通过Kubernetes的授权机制，可以将不同的namespace交给不同的租户来管理，实现多租户的资源隔离。此外，结合Kuberentes的资源配额机制，限定不同租户能够占用的资源，例如CPU使用量、内存使用量等，来实现租户可用资源的管理。</p><p>Kubernetes集群在启动之后，会默认创建如下的namespace：</p><ul><li><code>default</code>：所有未指定namespace的对象都会被分配在default命名空间</li><li><code>kube-node-lease</code>：用于维护集群节点之间的心跳信息</li><li><code>kube-public</code>：此命名空间下的resource可以被所有人访问，包括未认证用户</li><li><code>kube-system</code>：所有由Kubernetes系统创建的resource都处于这个命名空间</li></ul><p>在GettingStarted中，我们创建一个名为dev的namespace，可以使用之前提到的三种资源管理方式中的任意一种来进行。通过<code>kubectl get ns dev -o yaml</code>命令可以以yaml形式查看namespace的详细信息。</p><ul><li>如果需要使用yaml配置文件来创建，可以参考：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><h2 id="pod">Pod</h2><p>Pod是Kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。Kubernetes在集群启动之后，集群中的各个组件也都是以Pod方式运行的，例如可以通过<code>kubectl get pod -n kube-system</code>查看集群系统相关Pod。</p><p>我们可以通过<code>kubectl run</code>命令来指定在集群中运行Pod，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl run nginx --image=nginx:latest --port=80 --namespace dev <br><span class="hljs-comment"># 命令格式： kubectl run (pod名称) [参数] </span><br><span class="hljs-comment"># --image  指定Pod的镜像</span><br><span class="hljs-comment"># --port   指定端口</span><br><span class="hljs-comment"># --namespace  指定namespace</span><br></code></pre></td></tr></table></figure><p>同样也可以使用delete删除对应的pod。<code>kubectl delete pod nginx -n dev</code>。</p><blockquote><p>注意：在较老版本的kubectl中，run命令会生成deplyment来控制Pod，而在最新的kubectl中，run命令则是直接创建Pod。</p></blockquote><ul><li>参考yaml配置文件：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">pod</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><h2 id="deployment">Deployment</h2><p>在Kubernetes中，Pod是最小的控制单元，但是Kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于Pod的管理，确保Pod资源符合预期的状态，当Pod的资源出现故障时，会尝试进行重启或重建Pod。</p><p>Kubernetes中Pod控制器的种类有很多，在GettingStarted中我们先介绍其中的Deployment。</p><p>可以通过下面的命令创建一个Deployment：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl create deployment nginx --image=nginx:latest --port=80 --replicas=3 -n dev<br><br><span class="hljs-comment"># 命令格式: kubectl create deployment 名称  [参数] </span><br><span class="hljs-comment"># --image  指定pod的镜像</span><br><span class="hljs-comment"># --port   指定端口</span><br><span class="hljs-comment"># --replicas  指定创建pod数量</span><br><span class="hljs-comment"># --namespace  指定namespace</span><br></code></pre></td></tr></table></figure><p>之后可以通过<code>kubectl get deploy -n dev</code>查看到相关Deployment的信息。创建Deployment的同时也会创建对应的Pod，也可以通过<code>kubectl get pod -n dev</code>来查看相关Pod信息。</p><p>此时如果我们手动使用delete命令删除Pod，该Pod会被删除，但是由于Deployment的存在，它会新建一个Pod来顶替被删除的Pod。</p><p>当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发现Pod死亡，会立即重建。如果要完全删除Pod的话，则需要先删除Pod控制器。</p><ul><li>参考yaml配置文件：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><h2 id="service">Service</h2><p>Deployment可以通过创建一组Pod来提供具有高可用性的服务，其中每个Pod都会分配一个单独的PodIP。但是还是存在两个问题：</p><ul><li>Pod IP 会随着Pod的重建产生变化</li><li>Pod IP 仅仅是集群内可见的虚拟IP，外部无法访问</li></ul><p>为了能够从外部访问服务以及固定IP，Kubernetes提供了Service。Service可以看作是一组同类Pod提供的对外访问接口，借助Service，应用可以很方便地实现服务发现以及负载均衡。</p><p>Service分为两类，分别对应两种type，<code>ClusterIP</code>以及<code>NodePort</code>。其中ClusterIP表示集群内部可访问的Service，主要解决了IP变化的问题，而NodePort表示集群内外都可以访问的Service。</p><p>我们可以通过如下命令创建一个<code>ClusterIP</code>类型的Service。expose命令可以将resource暴露为新的KubernetesService（暴露resource，不是创建新resource，除了新得到的Service）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl expose deploy nginx --name=svc-nginx1 --<span class="hljs-built_in">type</span>=ClusterIP --port=80 --target-port=80 -n dev<br></code></pre></td></tr></table></figure><p>这里我们将名为nginx的deployment暴露为了一个ClusterIP类型的Service，可以通过<code>kubectl get svc</code>命令查看，可以发现其中有一个<code>CLUSTER-IP</code>字段，这就是Service的IP。在Service的生命周期中，这个地址是不会变动的，可以通过访问这个IP来访问当前Service对应的Pod。</p><p>同样我们也可以将nginxdeployment暴露为一个<code>NodePort</code>类型的Service，只需要指定type为NodePort即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl expose deploy nginx --name=svc-nginx2 --<span class="hljs-built_in">type</span>=NodePort --port=80 --target-port=80 -n dev<br></code></pre></td></tr></table></figure><p>创建完成之后，同样可以查看svc详情，使用命令<code>kubectl get svc svc-nginx2 -n dev -o wide</code>。发现其中的端口映射如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">NAME         TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE   SELECTOR<br>svc-nginx2   NodePort   10.97.137.15   &lt;none&gt;        80:31727/TCP   56m   app=nginx<br></code></pre></td></tr></table></figure><p>这表示将宿主机的31727端口和Deployment对应的80端口进行映射，此时可以使用浏览器访问<code>http://localhost:31727</code>，可以看见nginx的欢迎页面。这里的浏览器就是从集群之外进行访问的。</p><ul><li>参考配置yaml文件：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">svc-nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.105</span><span class="hljs-number">.165</span><span class="hljs-number">.43</span> <span class="hljs-comment">#固定svc的内网ip</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span> <span class="hljs-comment"># or NodePort</span><br></code></pre></td></tr></table></figure><h2 id="label">Label</h2><p>Label是Kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。</p><ul><li>一个Label会以key/value键值对的形式附加到各种对象上，如Node、Pod、Service等等</li><li>一个资源对象可以定义任意数量的Label，同一个Label也可以被添加到任意数量的资源对象上去</li><li>Label通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除</li></ul><p>可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。</p><blockquote><p>一些常用的Label 示例如下：</p><ul><li>版本标签："version":"release", "version":"stable"......</li><li>环境标签："environment":"dev"，"environment":"test"，"environment":"pro"</li><li>架构标签："tier":"frontend"，"tier":"backend"</li></ul></blockquote><p>可以通过label命令来为Resource进行标签相关操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 给Pod打Label</span><br>kubectl label pod nginx-cd55c47f5-jh9sf version=1.0 -n dev<br><br><span class="hljs-comment"># 更新Pod的Label [--overwrite]</span><br>kubectl label pod nginx-cd55c47f5-jh9sf version=2.0 -n dev -- overwrite<br><br><span class="hljs-comment"># 查看Label [--show-labels]</span><br>kubectl get pod nginx-cd55c47f5-jh9sf -n dev --show-labels<br><br><span class="hljs-comment"># 删除Label [-]</span><br>kubectl label pod nginx-cd55c47f5-jh9sf version- -n dev<br></code></pre></td></tr></table></figure><p>基于标签，我们可以进行标签的选择。Kubernetes提供了LabelSelector来完成这一操作。Label用于给某个资源对象定义标识，而LabelSelector用于查询和筛选拥有某些标签的资源对象。</p><p>在Kubernetes中有两类Label Selector，分别是基于等式的LabelSelector，使用关键字为<code>=, !=</code>；以及基于集合的LabelSelector，使用关键字为<code>in, not in</code>。同时Label的选择条件也可以多次使用，使用逗号<code>,</code>将多个LabelSelector进行分隔即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 筛选Label [-l / --selector]</span><br>kubectl get pod -n dev -l version=2.0 --show-labels<br></code></pre></td></tr></table></figure><ul><li>参考配置yaml文件：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.0&quot;</span> <br>    <span class="hljs-attr">env:</span> <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">pod</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><hr /><p>经过GettingStarted的全流程，我们可以得到下面一张概述图，描述Resource的组织方式。</p><img src="/2023/07/29/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/GettingStarted.png" class="" title="Getting Started">]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python单元测试之Mock的使用</title>
    <link href="/2023/07/28/Python%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8BMock%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/07/28/Python%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8BMock%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>在单元测试中，Mock是一个很重要的行为，它可以帮助我们排除其他服务的依赖，将需要进行的测试隔离开来。<code>mock</code>是Python中提供的测试库，在Python2中，<code>mock</code>是独立的库，而在Python3中，<code>mock</code>被加入了标准单元测试库<code>unittest</code>当中，官方文档为<ahref="https://docs.python.org/3/library/unittest.mock.html">unittest.mock|docs</a>。</p><p>在<code>mock</code>库中，有两个非常重要的概念，分别是<code>Mock</code>以及<code>patch</code>。<code>Mock</code>指的是<code>mock</code>库中提供的<code>Mock</code>类，它产生的对象可以模拟各种行为，简单来说就是根据程序员指定输入和输出进行工作。而<code>patch</code>则用于在特定作用范围内执行模拟，将指定的实际对象变为<code>Mock</code>对象，此时实际对象就会按照我们预先指定的方式进行工作。<code>Mock</code>和<code>patch</code>结合工作，联系紧密。</p><h1 id="mock">Mock</h1><h2 id="quick-start">quick start</h2><p>Mock是unittest.mock库中提供的一个类，要使用它首先得进行对象的创建。</p><p>Mock类的构造方法签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">unittest</span>.mock.Mock(spec=<span class="hljs-literal">None</span>, side_effect=<span class="hljs-literal">None</span>, return_value=DEFAULT, wraps=<span class="hljs-literal">None</span>, name=<span class="hljs-literal">None</span>, spec_set=<span class="hljs-literal">None</span>, unsafe=<span class="hljs-literal">False</span>, **kwargs)<br></code></pre></td></tr></table></figure><p>其中最重要的两个参数是<code>return_value</code>和<code>side_effect</code>。</p><p><code>return_value</code>用于指定该Mock对象被调用时的返回值，且该返回值始终不变。</p><p><code>side_effect</code>用于指定可变的返回值或者抛出特定的异常，该参数可以设置为三种类型：</p><ul><li>如果设置为异常类，则执行该Mock对象时会抛出异常</li><li>如果设置为方法，则执行该Mock对象时，会将传入的参数传递给设置的方法，然后返回方法的返回值</li><li>如果设置为可迭代对象，则执行该Mock对象时会按照迭代顺序进行返回，得到可变的返回值</li></ul><p>需要注意的是<code>side_effect</code>的优先级高于<code>return_value</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> Mock<br><br><span class="hljs-comment"># 设置固定的return_value</span><br>mock = Mock(return_value=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">assert</span> mock() == <span class="hljs-number">1</span><br><br><span class="hljs-comment"># side_effect 设置抛出异常</span><br>mock = Mock(side_effect=RuntimeError)<br><br><span class="hljs-comment"># side_effect 设置方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_one</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span><br>mock = Mock(side_effect=add_one)<br><span class="hljs-keyword">assert</span> mock(<span class="hljs-number">2</span>) == <span class="hljs-number">3</span><br><br><span class="hljs-comment"># side_effect 设置可迭代对象</span><br>mock = Mock(side_effect=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-keyword">assert</span> mock() == <span class="hljs-number">1</span><br><span class="hljs-keyword">assert</span> mock() == <span class="hljs-number">2</span><br><span class="hljs-keyword">assert</span> mock() == <span class="hljs-number">3</span><br><span class="hljs-comment"># 再次调用mock会报错，因为迭代器没有next了</span><br></code></pre></td></tr></table></figure><p>我们可以手动指定某个对象的方法，将其使用Mock进行替换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self, a, b</span>):<br>        <span class="hljs-keyword">return</span> a + b<br><br><br>tc = TestClass()<br>tc.func = Mock(return_value=<span class="hljs-number">666</span>)<br><span class="hljs-built_in">print</span>(tc.func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment"># print content: 666</span><br></code></pre></td></tr></table></figure><p>Mock类同样支持对Python中所有的magic方法进行mock。不过如果需要使用到magic方法，最简单的方法是使用<code>MagicMock</code>类。<code>MagicMock</code>类是<code>Mock</code>类的一个子类，它实现了所有常用的magic方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> Mock, MagicMock<br><br><span class="hljs-comment"># mock magic method</span><br>mock = Mock()<br>mock.__str__ = Mock(return_value=<span class="hljs-string">&quot;my mock&quot;</span>)<br><span class="hljs-built_in">print</span>(mock)  <span class="hljs-comment"># print content: my mock</span><br><br><span class="hljs-comment"># MagicMock</span><br>magic_mock = MagicMock()<br>magic_mock.__str__.return_value = <span class="hljs-string">&quot;my magic mock&quot;</span><br><span class="hljs-built_in">print</span>(magic_mock)  <span class="hljs-comment"># print content: my magic mock</span><br></code></pre></td></tr></table></figure><p>另外，我们还可以使用<code>create_autospec</code>方法来创建与原对象相同的api。</p><p>创建一个具有相同入参签名的Mock方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> create_autospec<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span>, c: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> a + b + c<br><br><br>mock_func = create_autospec(func, return_value=<span class="hljs-string">&quot;abc&quot;</span>)<br><span class="hljs-built_in">print</span>(func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 6</span><br><span class="hljs-built_in">print</span>(mock_func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># abc</span><br><span class="hljs-built_in">print</span>(mock_func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># TypeError: missing a required argument: &#x27;c&#x27;</span><br></code></pre></td></tr></table></figure><p>创建一个具有相同属性以及方法签名的Mock测试类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> create_autospec<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCase</span>:<br>    test_attr = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">return</span> self.test_attr + num<br><br><br>mock_class = create_autospec(TestCase, return_value=<span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(mock_class.test_attr)  <span class="hljs-comment"># &lt;NonCallableMagicMock name=&#x27;mock.test_attr&#x27; spec=&#x27;int&#x27; id=&#x27;4328630928&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(mock_class.test_attr_not_exist)  <span class="hljs-comment"># AttributeError: Mock object has no attribute &#x27;test_attr_not_exist&#x27;</span><br><br><span class="hljs-built_in">print</span>(mock_class.test_func)  <span class="hljs-comment"># &lt;MagicMock name=&#x27;mock.test_func&#x27; spec=&#x27;function&#x27; id=&#x27;4335451600&#x27;&gt;</span><br>mock_class.test_func.return_value = <span class="hljs-number">123</span><br><span class="hljs-built_in">print</span>(mock_class.test_func(<span class="hljs-number">1</span>))  <span class="hljs-comment"># 123</span><br><span class="hljs-built_in">print</span>(mock_class.test_func_not_exist)  <span class="hljs-comment"># AttributeError: Mock object has no attribute &#x27;test_func_not_exist&#x27;</span><br></code></pre></td></tr></table></figure><p>这里我们得到的Mock测试类具有与TestCase相同的属性和方法签名，不过对应的属性和方法签名仍然是一个Mock类，我们可以像之前的操作一样指定它的return_value等相关信息。</p><h2 id="相关方法">相关方法</h2><p>Mock类还有其他一些常用的方法，主要是一些assert方法。因为Mock对象除了可以用来模拟对象、属性和方法等，它还会记录自身被使用的过程。利用相关assert方法可以验证代码是否被执行过，被怎样执行过。</p><ul><li><code>assert_called(*args, **kwargs)</code>：断言mock至少被调用一次</li><li><code>assert_called_once(*args, **kwargs)</code>：断言mock调用仅一次</li><li><code>assert_called_with(*args, **kwargs)</code>：断言mock以某种参数至少调用一次，且符合条件的调用是最近一次</li><li><code>assert_called_once_with(*args, **kwargs)</code>：断言mock调用仅一次，并且调用参数符合条件</li><li><code>assert_any_called(*args, **kwargs)</code>：断言mock以某种参数曾经被调用过，注意上面的<code>assert_called_with()</code>必须是最近的那次调用符合断言，而any不需要</li><li><code>assert_has_calls(calls, any_order=False)</code>：断言mock被按照的特定一组调用的方式调用过。如果<code>any_order</code>是False，那么必须满足calls中的调用顺序，而且必须是连续的，如果<code>any_order</code>是True，那么就只需要执行了calls中的调用即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># assert_has_calls</span><br><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> Mock, call<br><br>mock = Mock(return_value=<span class="hljs-string">&quot;123&quot;</span>)<br>mock(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>mock(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>mock.assert_has_calls([call(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), call(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)], any_order=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># assert pass</span><br>mock.assert_has_calls([call(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), call(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)], any_order=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># assert error</span><br></code></pre></td></tr></table></figure><ul><li><p><code>assert_not_called()</code>： 断言没有被调用</p></li><li><p><code>reset_mock(*args, return_value=False, side_effect=False)</code>：重置mock对象的所有调用</p></li><li><p><code>call_count</code>： 返回调用次数</p></li><li><p><code>call_args</code> ：返回最后调用的参数</p></li><li><p><code>call_args_list</code>：返回调用的历史参数列表</p></li><li><p><code>method_calls</code>：返回调用的历史方法列表</p></li></ul><h2 id="其他mock类">其他Mock类</h2><ul><li><code>NonCallableMock</code>：一个不可被调用的Mock类，<code>return_value</code>和<code>side_effect</code>这两个参数对它来说是无意义的</li><li><code>PropertyMock</code>：一个专门用于替换属性的Mock类，它提供了属性对应的get和set方法</li><li><code>AsyncMock</code>：MagicMock的异步版本。AsyncMock对象会像一个异步数一样运行，它的调用的返回值是一个awaitable对象，这个awaitable对象返回<code>side_effect</code> 或者 <code>return_value</code> 指定的值</li></ul><h1 id="patch">Patch</h1><h2 id="quick-start-1">quick start</h2><p><code>patch</code>可以帮助我们在特定范围内执行模拟，在代码运行时将指定的对象变为Mock对象。<code>patch</code>有多种使用方式，可以使用装饰器、with语句以及利用<code>start()</code>和<code>stop()</code>方法指定模拟的开始和结束。</p><p><code>patch</code>实际上是一个方法，方法签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">unittest.mock.patch(target, new=DEFAULT, spec=<span class="hljs-literal">None</span>, create=<span class="hljs-literal">False</span>, spec_set=<span class="hljs-literal">None</span>, autospec=<span class="hljs-literal">None</span>, new_callable=<span class="hljs-literal">None</span>, **kwargs)<br></code></pre></td></tr></table></figure><p>其中参数<code>target</code>用于指定被模拟的对象，是一个类似<code>package.module.className</code>格式的字符串；参数<code>new_callable</code>可以用于指定最终创建的模拟对象类型，默认情况下是MagicMock类型的Mock对象。</p><p>patch装饰器的使用方式如下。通过target参数指定被模拟的类，创建出的Mock对象通过参数传递给方法。此时的模拟范围是函数的范围。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> patch<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span>:<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-meta">@patch(<span class="hljs-params"><span class="hljs-string">&#x27;__main__.SomeClass&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b, mock_class</span>):<br>    <span class="hljs-built_in">print</span>(a)<br>    <span class="hljs-built_in">print</span>(b)<br>    <span class="hljs-built_in">print</span>(mock_class)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    func(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    <br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">print content: </span><br><span class="hljs-string">2</span><br><span class="hljs-string">3</span><br><span class="hljs-string">&lt;MagicMock name=&#x27;SomeClass&#x27; id=&#x27;4488196304&#x27;&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>patchwith语句的使用方式如下。通过上下文管理的方式设置模拟范围，创建出的Mock对象通过as语句进行传递。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> patch(<span class="hljs-string">&#x27;__main__.SomeClass&#x27;</span>) <span class="hljs-keyword">as</span> mock_class:<br>    <span class="hljs-built_in">print</span>(mock_class)<br>    <br><span class="hljs-comment"># &lt;MagicMock name=&#x27;SomeClass&#x27; id=&#x27;4365561808&#x27;&gt;</span><br></code></pre></td></tr></table></figure><p>patch手动指定作用范围的使用方式如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">patcher = patch(<span class="hljs-string">&#x27;__main__.SomeClass&#x27;</span>)<br>mock_class = patcher.start()<br><span class="hljs-built_in">print</span>(mock_class)<br>patcher.stop()<br><br><span class="hljs-comment"># &lt;MagicMock name=&#x27;SomeClass&#x27; id=&#x27;4437302224&#x27;&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的情况中，使用注解的情况非常常见，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> patch<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span>:<br>    num = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self, other_num</span>):<br>        <span class="hljs-keyword">return</span> self.num + other_num<br><br><br><span class="hljs-meta">@patch(<span class="hljs-params"><span class="hljs-string">&#x27;__main__.SomeClass.func&#x27;</span>, return_value=<span class="hljs-string">&quot;mock&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_patch_some_class</span>(<span class="hljs-params">mock_func</span>):<br>    some_class = SomeClass()<br>    <span class="hljs-built_in">print</span>(some_class.func(<span class="hljs-number">2</span>))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test_patch_some_class()<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">print content: mock</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="其他方法">其他方法</h2><ul><li><code>patch.object()</code>：用于模拟对象的属性，使用Mock对象模拟对象的属性。初始化时使用参数<code>target</code>指定对象，使用参数<code>attribute</code> 设置模拟的属性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 仍然借用上面最近的SomeClass定义，包含一个num属性以及一个func相加方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_patch_some_class</span>():<br>    <span class="hljs-keyword">with</span> patch.<span class="hljs-built_in">object</span>(SomeClass, <span class="hljs-string">&#x27;func&#x27;</span>, return_value=<span class="hljs-string">&quot;mock&quot;</span>) <span class="hljs-keyword">as</span> mock_func:<br>        some_class = SomeClass()<br>        <span class="hljs-built_in">print</span>(some_class.func(<span class="hljs-number">2</span>))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test_patch_some_class()<br>    <br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">print content: mock</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><code>patch.dict()</code>：用于模拟dict类型的对象，在模拟结束时恢复被模拟对象的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_patch_dict</span>():<br>    foo = &#123;<span class="hljs-string">&#x27;key&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>&#125;<br>    original = foo.copy()  <span class="hljs-comment"># 浅拷贝</span><br>    <span class="hljs-comment"># clear参数表示是否保留原有的项，True表示不保留， 默认保留</span><br>    <span class="hljs-keyword">with</span> patch.<span class="hljs-built_in">dict</span>(foo, &#123;<span class="hljs-string">&#x27;new_key&#x27;</span>: <span class="hljs-string">&#x27;new_value&#x27;</span>&#125;, clear=<span class="hljs-literal">True</span>):<br>        <span class="hljs-built_in">print</span>(foo)<br>        <span class="hljs-keyword">assert</span> foo == &#123;<span class="hljs-string">&#x27;new_key&#x27;</span>: <span class="hljs-string">&#x27;new_value&#x27;</span>&#125;<br><br>    <span class="hljs-built_in">print</span>(foo)  <span class="hljs-comment"># foo原本的值并没有被改变</span><br>    <span class="hljs-keyword">assert</span> foo == original<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test_patch_dict()<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">print content：</span><br><span class="hljs-string">&#123;&#x27;new_key&#x27;: &#x27;new_value&#x27;&#125;</span><br><span class="hljs-string">&#123;&#x27;key&#x27;: &#x27;value&#x27;&#125;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><code>patch.multiple()</code>： 用于同时模拟多个对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">thing = <span class="hljs-built_in">object</span>()<br>other = <span class="hljs-built_in">object</span>()<br><br><span class="hljs-comment"># from unittest.mock import DEFAULT</span><br><span class="hljs-meta">@patch.multiple(<span class="hljs-params"><span class="hljs-string">&#x27;__main__&#x27;</span>, thing=DEFAULT, other=DEFAULT</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_function</span>(<span class="hljs-params">thing, other</span>):  <span class="hljs-comment"># 对于patch.multiple对应的参数，并没有特别顺序要求</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(thing, MagicMock)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(other, MagicMock)<br><br>test_function()<br></code></pre></td></tr></table></figure><p>如果在with语句中使用，则返回一个字典对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">thing = <span class="hljs-built_in">object</span>()<br>other = <span class="hljs-built_in">object</span>()<br><br><span class="hljs-keyword">with</span> patch.multiple(<span class="hljs-string">&#x27;__main__&#x27;</span>, thing=DEFAULT, other=DEFAULT) <span class="hljs-keyword">as</span> values:<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;other&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">repr</span>(values[<span class="hljs-string">&#x27;other&#x27;</span>])<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;thing&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">repr</span>(values[<span class="hljs-string">&#x27;thing&#x27;</span>])<br>    <span class="hljs-keyword">assert</span> values[<span class="hljs-string">&#x27;thing&#x27;</span>] <span class="hljs-keyword">is</span> thing<br>    <span class="hljs-keyword">assert</span> values[<span class="hljs-string">&#x27;other&#x27;</span>] <span class="hljs-keyword">is</span> other<br></code></pre></td></tr></table></figure><h2 id="特殊情况">特殊情况</h2><h3 id="method-not-exist">Method not exist</h3><p>在一些时候，我们可能需要模拟一个不存在的方法，例如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 仍然借用上面最近的SomeClass定义，包含一个num属性以及一个func相加方法</span><br><span class="hljs-meta">@patch(<span class="hljs-params"><span class="hljs-string">&#x27;__main__.SomeClass.func_not_exist&#x27;</span>, return_value=<span class="hljs-string">&quot;mock&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_patch_some_class</span>(<span class="hljs-params">mock_func</span>):<br>    some_class = SomeClass()<br>    <span class="hljs-built_in">print</span>(some_class.func(<span class="hljs-number">2</span>))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test_patch_some_class()<br>    <br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">AttributeError: &lt;class &#x27;__main__.SomeClass&#x27;&gt; does not have the attribute &#x27;func_not_exist&#x27;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>这里我们模拟了一个不存在的方法，默认情况是会报错的，报无法找到属性的错。此时我们可以指定<code>create=True</code>，此时如果patch对象不存在的话，会自动创建，不会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@patch(<span class="hljs-params"><span class="hljs-string">&#x27;__main__.SomeClass.func_not_exist&#x27;</span>, return_value=<span class="hljs-string">&quot;mock&quot;</span>, create=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_patch_some_class</span>(<span class="hljs-params">mock_func</span>):<br>    some_class = SomeClass()<br>    <span class="hljs-built_in">print</span>(some_class.func(<span class="hljs-number">2</span>))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test_patch_some_class()<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">print content: 3</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>上面的代码不会报错，并且由于我们并没有Mock真实的逻辑，因此输出也是正常的3。</p><h3 id="module-not-exist">Module not exist</h3><p>在一些时候，我们可能要模拟一个方法，但是这个方法所属的Module又没有安装，例如下面的代码，正常运行的话，会报错为<code>Module not found</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> patch<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">method_need_to_be_test</span>():<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">from</span> xxx.yyy.zzz <span class="hljs-keyword">import</span> some_method<br>    <span class="hljs-keyword">except</span> ModuleNotFoundError:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Module not found, please make sure the dependency have installed&quot;</span>)<br>    <span class="hljs-keyword">return</span> some_method()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_method</span>():<br>    method_need_to_be_test()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test_method()<br><br></code></pre></td></tr></table></figure><p>为了解决Module不存在的情况，我们首先需要安装<code>surrogate</code>。这个库允许为一个不存在的Module创建测试桩。</p><p>安装了依赖之后，利用<code>@surrogate</code>装饰器为不存在的Module创建测试桩之后，再利用<code>@patch</code>装饰器为这个不存在的方法进行模拟和Mock，如下所示。之后再次运行，就可以得到Mock后的结果了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> patch<br><span class="hljs-keyword">from</span> surrogate <span class="hljs-keyword">import</span> surrogate<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">method_need_to_be_test</span>():<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">from</span> xxx.yyy.zzz <span class="hljs-keyword">import</span> some_method<br>    <span class="hljs-keyword">except</span> ModuleNotFoundError:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Module not found, please make sure the dependency have installed&quot;</span>)<br>    <span class="hljs-keyword">return</span> some_method()<br><br><br><span class="hljs-meta">@surrogate(<span class="hljs-params"><span class="hljs-string">&#x27;xxx.yyy.zzz.some_method&#x27;</span></span>)</span><br><span class="hljs-meta">@patch(<span class="hljs-params"><span class="hljs-string">&#x27;xxx.yyy.zzz.some_method&#x27;</span>, return_value=<span class="hljs-string">&quot;mock result&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_method</span>(<span class="hljs-params">mock_func</span>):<br>    <span class="hljs-built_in">print</span>(method_need_to_be_test())<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test_method()<br>    <br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">print content: mock result</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><p><ahref="https://hustyichi.github.io/2018/11/24/mock/">单元测试mock模块介绍</a></p></li><li><p><ahref="https://www.cnblogs.com/guyuyun/p/14880885.html">Python内置库unittest.mock 的基础使用</a></p></li><li><p><ahref="https://stackoverflow.com/questions/12585046/how-do-i-mock-the-hierarchy-of-non-existing-modules">Howdo I mock the hierarchy of non-existingmodules|StackOverflow</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>UnitTest</tag>
      
      <tag>Mock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python环境管理-Pyenv与Virtualenv</title>
    <link href="/2023/07/27/Python%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86-Pyenv%E4%B8%8EVirtualenv/"/>
    <url>/2023/07/27/Python%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86-Pyenv%E4%B8%8EVirtualenv/</url>
    
    <content type="html"><![CDATA[<h1 id="pyenv">Pyenv</h1><p><ahref="https://github.com/pyenv/pyenv">pyenv</a>可以帮助我们轻松地管理多个Python版本并且在其中进行切换。在官方文档中有详细的介绍，这里主要记录了在使用MacOS，同时使用zsh的情况下，pyenv的安装过程，已经相关的使用方式。</p><p>首先需要安装pyenv，在MacOS上直接使用<ahref="https://brew.sh/">HomeBrew</a>进行安装即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew update<br>brew install pyenv<br></code></pre></td></tr></table></figure><p>之后需要修改配置文件，由于使用的是<code>zsh</code>，因此需要执行下面的命令将相关配置添加到<code>.zshrc</code>，当然也可以添加到<code>.zprofile</code>配置文件中。修改完毕之后重启Shell，pyenv就安装完毕了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;eval &quot;$(pyenv init -)&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure><p>pyenv提供简单而强大的功能，其中最常用的就是不同版本的Python安装，切换以及卸载。</p><p>首先是安装不同版本的Python，通过命令<code>pyenv install -l</code>可以查看所有可供下载的Python版本，之后通过<code>install</code>命令即可安装指定的版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pyenv install &lt;version&gt;<br></code></pre></td></tr></table></figure><p>通过命令<code>pyenv versions</code>我们可以看到目前pyenv管理的版本以及当前正在使用的版本。实际上，通过pyenv下载的Python，都被存放在<code>~/.pyenv/versions/</code>目录下。</p><p>之后是Python版本的切换。pyenv提供了三个命令来完成版本的切换，对应三种不同的生效层级。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 仅指定当前shell会话的Python版本</span><br>pyenv shell &lt;version&gt;<br><br><span class="hljs-comment"># 指定当前目录使用的Python版本，当处于当前目录或者子目录的时候自动选择</span><br>pyenv <span class="hljs-built_in">local</span> &lt;version&gt;<br><br><span class="hljs-comment"># 指定全局的Python版本</span><br>pyenv global &lt;version&gt;<br></code></pre></td></tr></table></figure><p>pyenv卸载对应版本的Python也非常简单，只需要通过<code>uninstall</code>命令即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pyenv uninstall &lt;version&gt;<br></code></pre></td></tr></table></figure><h1 id="virtualenv">Virtualenv</h1><p><ahref="https://virtualenv.pypa.io/en/latest/index.html">virtualenv</a>是一个Python工具，能够帮助我们创建隔离的Python虚拟环境。</p><p>virtualenv推荐使用<ahref="https://pypi.org/project/pipx/">pipx</a>进行安装，pipx可以帮助用户在一个隔离的环境中安装和运行Python应用。pipx同样可以通过HomeBrew来进行安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew install pipx<br>pipx ensurepath<br></code></pre></td></tr></table></figure><p>安装好了之后，就可以利用pipx来安装virtualenv。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">pipx install virtualenv<br>virtualenv --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><blockquote><p>如果由于特殊原因连接不上Python官方源，可以使用<code>--index-url</code>来临时指定一个其他的下载源。</p></blockquote><p>使用虚拟环境，我们只需要关注虚拟环境的创建，管理，卸载以及依赖下载即可。</p><p>首先是环境创建，使用下面的命令即可创建一个虚拟环境。执行该命令之后，virtualenv会在当前目录下生成一个文件夹，表示生成的虚拟环境。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">virtualenv env_name<br><span class="hljs-comment"># 虚拟环境的常用name为venv，即virtualenv venv</span><br></code></pre></td></tr></table></figure><p>在创建虚拟环境的时候，可以指定Python版本，使用<code>--python=pythonx.x</code>。但是virtualenv不会下载对应的Python版本，只会进行本地的Python发现，需要使用的Python版本需要在本地存在。此时使用pyenv进行多版本的Python管理就正中下怀。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">virtualenv venv --python=python3.6<br><span class="hljs-comment"># RuntimeError: failed to find interpreter for Builtin discover of python_spec=&#x27;python3.6&#x27;</span><br><br>virtualenv venv --python=python3.7<br><span class="hljs-comment"># created virtual environment CPython3.7.15.final.0-64 in 3765ms</span><br></code></pre></td></tr></table></figure><p>环境创建之后需要激活，在Linux：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 激活虚拟环境</span><br><span class="hljs-built_in">source</span> env_name/bin/activate<br></code></pre></td></tr></table></figure><p>激活环境之后，依赖的下载正常使用pip即可。此时下载的依赖都会被存放在生成的虚拟环境中，即对应的文件夹下。</p><p>退出虚拟环境的命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 退出虚拟环境</span><br>deactivate<br></code></pre></td></tr></table></figure><p>要想删除这个虚拟环境，只需要删除对应的文件夹即可。</p><blockquote><p>virtualenv结合Pycharm使用非常容易。事实上我们可以直接在Pycharm项目解释器设置中利用virtualenv创建虚拟环境，只需要指定对应的Python解释器即可。当然需要Python解释器在本地存在。</p><p>之后Pycharm会自动在当前项目目录下创建一个venv文件夹，即该项目对应的虚拟环境</p></blockquote><h1 id="pyenv-virtualenv">Pyenv-Virtualenv</h1><p>pyenv和virtualenv实际上是配合工作的，在上面的过程中我们已经可以发现这一点了。我们可以利用pyenv来管理Python的多版本，然后利用virtualenv来创建虚拟环境，在创建虚拟环境的之后指定需要使用的Python版本。</p><p>实际上，pyenv与virtualenv还有另一种配合使用的方式，即使用pyenv相关插件pyenv-virtualenv。</p><p>首先进行插件的安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew install pyenv-virtualenv<br></code></pre></td></tr></table></figure><p>之后可以使用如下命令来创建虚拟环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># eg：pyenv virtualenv 3.7.15 venv_3_7_15</span><br>pyenv virtualenv &lt;python-version&gt; &lt;env-name&gt;<br></code></pre></td></tr></table></figure><p>需要注意的是，这里使用的Python版本同样需要提前使用pyenv进行下载。执行命令之后，我们就可以通过<code>pyenv virtualenvs</code>来查看所有的虚拟环境。</p><p>环境的激活和退出命令也是类似：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 激活虚拟环境</span><br>pyenv activate &lt;env-name&gt;<br><br><span class="hljs-comment"># 退出虚拟环境</span><br>pyenv deactivate<br></code></pre></td></tr></table></figure><p>创建出的虚拟环境实际对应了两个文件夹，位置为<code>~/.pyenv/versions/&lt;env-name&gt;</code>，以及<code>~/.pyenv/versions/&lt;python-version&gt;/envs/&lt;env-name&gt;</code>。</p><p>实际上可以理解为，pyenv-virtualenv插件帮助我们管理了virtualenv创建出的虚拟环境，将其统一管理在同一个目录下。而如果我们使用原生的virtualenv进行创建，随着使用的增多，虚拟环境会散落在各个角落。当然两种方式各有利弊，按需选择即可。</p><blockquote><p>推荐结合Pycharm进行虚拟环境的创建，每个Project对应一个虚拟环境venv。同时利用pyenv来管理多版本Python。</p></blockquote><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://realpython.com/intro-to-pyenv/">Intro ToPyenv|RealPython</a></li><li><ahref="https://realpython.com/python-virtual-environments-a-primer/">PythonVirtual Environments A Primer|RealPython</a></li><li><ahref="https://fathomtech.io/blog/python-environments-with-pyenv-and-vitualenv/">PythonEnvironments With Pyenv And Virtualenv</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记(3)-Docker网络,Docker compose与其他相关工具</title>
    <link href="/2023/07/13/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Docker%E7%BD%91%E7%BB%9C-Docker-compose%E4%B8%8E%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/07/13/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Docker%E7%BD%91%E7%BB%9C-Docker-compose%E4%B8%8E%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="docker网络">Docker网络</h1><h2 id="简介">简介</h2><p>Docker网络主要包括容器如何进行网络通信和传输，容器之间的互联等相关问题。在后面的语境中，Docker网络根据上下文通常表达一个实体概念，类似于网段，处于同一个Docker网络中的容器相当于处于同一个网段。</p><p>可以通过下面的相关命令来对Docker网络进行操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看网络(初始情况下会包含三个网络：bridge，host，none)</span><br>docker network <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 查看网络详细数据</span><br>docker network inspect network_name<br><br><span class="hljs-comment"># 创建网络</span><br>docker network create [options] network_name<br><br><span class="hljs-comment"># 删除网络</span><br>docker network <span class="hljs-built_in">rm</span> network_name<br></code></pre></td></tr></table></figure><h2 id="网络模式">网络模式</h2><p>在使用<code>docker run</code>命令运行容器的时候，可以通过<code>--network</code>来指定需要使用的网络模式，默认情况下该参数值为bridge。Docker网络模式总体分为下面四种：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">bridge模式：使用--network bridge指定，默认使用docker()<br><br>host模式：使用 --network host指定<br><br>none模式：使用 --network none指定<br><br>container模式：使用 --network container:Name或者容器ID指定<br></code></pre></td></tr></table></figure><h3 id="bridge模式">bridge模式</h3><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker默认指定了 docker0接口的IP地址和子网掩码，让主机和容器之间可以通过网桥相互通信。在这种情况下主机是默认网关，容器通过主机进行外网的访问。</p><h3 id="host模式">host模式</h3><p>host模式下，容器直接使用宿主机的IP地址与外界进行通信，不再需要额外进行NAT转换。容器将不会获得 一个独立的Network Namespace， 而是和宿主机共用一个NetworkNamespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。在这种情况下，指定端口映射将会失效。</p><h3 id="none模式">none模式</h3><p>none模式表示禁用网络功能，只有lo标识（localhost）</p><h3 id="contianer模式">contianer模式</h3><p>在container模式下，新建的容器和已经存在的一个容器共享网络IP配置。新建的容器不会创建自己的网卡，配置自己的IP，而是和指定的另一个容器进行共享。当然在除了网络的其他方面，例如文件系统，进程列表等，两个容器还是相互隔离的。</p><h2 id="自定义网络">自定义网络</h2><p>我们可以使用<code>docker network create</code>来创建自定义网络，然后利用命令<code>docker run --network network_name</code>在运行容器的使用指定使用自定义网络。自定义网络属于上面的bridge模式，但是自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通），相当于在自定义网络中提供了DNS服务。</p><h1 id="docker-compose">Docker Compose</h1><p><ahref="https://docs.docker.com/compose/compose-file/compose-file-v3/">Docker-Compose</a>是官方的容器开源项目，负责实现对Docker容器集群的快速编排。容器编排是指对运行容器化工作负载和服务所需的大部分运维工作进行自动化。这包括软件团队管理容器生命周期所需完成的大量工作，包括置备、部署、扩展（扩展和缩减）、网络连接、负载均衡等。</p><p>DockerCompose允许用户通过一个单独的<code>docker-compose.yml</code>模板文件来将一组相关的容器关联为一个项目，之后可以很容易地使用一条指令来完成项目的构建。在过程中会涉及到两个概念，分别是服务（service）以及项目（project），其中service指的是一个个应用容器实例，而工程指的是由一组关联的应用容器组成的一个完整的业务单元。</p><p>在使用DockerCompose的过程中，首先需要编写Dockerfile定义好各个service并构建出对应的镜像文件，之后使用<code>docker-compose.yml</code>来定义完整的业务单元，安排好整体应用中的各个容器服务，最后执行<code>docker-compose up</code>命令来启动并运行整个应用程序。</p><h1 id="其他相关工具">其他相关工具</h1><p>该部分简单介绍了其他Docker相关工具，包括Docker轻量级可视化工具Portainer以及Docker容器监控方案。</p><p><a href="https://www.portainer.io/">Portainer</a>是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p><p>Docker容器监控，一个常见的方案是CAdvisor监控收集+InfluxDB存储数据+Grafana展示图表。</p><p><ahref="https://github.com/google/cadvisor">CAdvisor</a>是一个容器资源监控工具，可监控的Metric包括容器的内存、CPU、网络IO、磁盘IO等，同时提供了一个Web页面用于查看容器的实时运行状态。CAdvisor默认存储2分钟的数据，并且仅针对单台物理机。但是CAdvisor提供了很多数据集成接口，支持与InfluxDB、Redis、Kafka、Elasticsearch等集成，通过增加相关配置将监控数据发送到这些数据库中。</p><p><ahref="https://www.influxdata.com/">InfluxDB</a>是使用Go语言编写的一个开源分布式的时序、事件和指标数据库。该数据库基于时间序列，支持与时间有关的相关函数。</p><p><ahref="https://grafana.com/">Grafana</a>是一个开源的数据监控分析可视化平台，支持多种数据源配置，包括InfluxDB、MySQL、Elasticserach、OpenTSDB、Graphite等，同时提供丰富的插件以及模板功能，支持图表权限控制，alert报警等。</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记(2)-镜像,容器数据卷与DockerFile</title>
    <link href="/2023/07/12/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E9%95%9C%E5%83%8F-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E4%B8%8EDockerFile/"/>
    <url>/2023/07/12/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E9%95%9C%E5%83%8F-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E4%B8%8EDockerFile/</url>
    
    <content type="html"><![CDATA[<h1 id="docker镜像">Docker镜像</h1><h2 id="简介">简介</h2><p>DockerImage镜像是一种轻量级的、可执行的独立软件包，它包含了运行某个软件所需要的所有内容。应用程序和配置依赖被打包好形成一个可交付的运行环境，这个打包好的运行环境就是Image镜像文件，通过Image镜像文件才能生成Docker容器实例。</p><p>Docker镜像是分层构建的，其中使用了UnionFS（联合文件系统）。UnionFS是一种分层、轻量级、高性能的文件系统。它将对文件系统的修改看作一次次的提交，最终的状态则是一层层叠加之后的结果。同时UnionFS支持将不同目录挂载到同一个虚拟文件系统下。UnionFS是DockerImage的基础，Image可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。Image分层的一个最大好处就是能够做到共享资源，方便复用和迁移。</p><p>Docker镜像是分层的文件系统，其中最底层是启动层BootFS（Boot FileSystem），其中主要包含了BootLoader以及Kernel，BootLoader主要用于引导加载文件系统，该层与典型的Unix系统是一致的。当加载完成之后，整个Kernel就都存放在内存当中了。此时内存的使用权就会从BootFS转交给Kernel，系统也会卸载BootFS。</p><p>而在BootFS之上是RootFS层，包含的就是典型 Linux 系统中的 /dev, /proc,/bin, /etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><p>在Docker的分层结构当中，又可以分为镜像层和容器层，这两种类型最大的区别就是镜像层是只读的，而容器层是可写的。当从一个镜像中启动出容器之后，一个新的可写的容器层就会被加载到现有分层结构的最顶层，之后所有的针对容器的修改都会记录到该层中。而在容器层之下的其他所有层次，则都属于镜像层，都是只读的。</p><h2 id="commit-push">commit &amp; push</h2><p>前面提到容器层可以进行修改，我们可以将修改后的容器重新打包成为一个镜像，这就需要使用到commit命令。下面的命令可以将contianer_id对应的容器提交成为一个新的镜像，新的镜像为target_image:tag。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 提交容器副本使之成为一个新的镜像</span><br>docker commit -m=<span class="hljs-string">&quot;commit message&quot;</span> -a=<span class="hljs-string">&quot;author&quot;</span> container_id target_image:tag<br></code></pre></td></tr></table></figure><p>生成的新镜像目前只在本地存在，可以通过push命令将本地镜像推送到Docker仓库中。当然还可以部署私有仓库，此时需要借助DockerRegistry镜像，相关操作可以参考官方文档<ahref="https://docs.docker.com/registry/deploying/">Deploy a registryserver | docker docs</a>，或者相关博客<ahref="https://www.baeldung.com/ops/docker-private-registry">A Guide toDocker Private Registry | Baeldung</a>。</p><blockquote><p>虚悬镜像，danlingimage，指的是仓库名，标签都是<code>&lt;none&gt;</code>的镜像。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看虚悬镜像</span><br>docker image <span class="hljs-built_in">ls</span> -f dangling=<span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 删除虚悬镜像</span><br>docker image prune <br></code></pre></td></tr></table></figure></blockquote><h1 id="容器数据卷">容器数据卷</h1><h2 id="使用">使用</h2><p>一个容器如果被删除了，那么容器内部的数据也都被删除了。但是在一些场景下，我们希望容器内部的数据能够被保存下来，这就需要使用到容器数据卷，起到一个数据备份的效果。</p><p>容器数据卷的挂载在容器启动的时候完成，通过<code>-v</code>属性。下面的命令可以挂载一个容器数据卷：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动一个容器，并且完成数据卷挂载</span><br>docker run -it -privileged=<span class="hljs-literal">true</span> -v /宿主机绝对路径目录:/容器内目录 image_name[:tag]<br></code></pre></td></tr></table></figure><blockquote><p>--privileged=true表示扩大容器的权限，否则可能出现无法操作对应目录的情况。</p></blockquote><p>该命令完成的功能是在启动容器的时候完成数据卷挂载，如果不使用数据卷，则容器内的目录是虚拟出来的，与宿主机是隔离的；如果使用了数据卷，那么容器内的对应目录直接映射到了宿主机的对应目录，能够达到一个类似双向绑定的效果。容器内目录改动能够传到宿主机中，反之亦然。并且此时如果我们删除了容器，相关数据仍然能够在宿主机中查看到。</p><p>如果挂载了数据卷，我们可以通过<code>docker inspect</code>命令在详细信息中查看到。</p><p>在挂载数据卷的时候，可以通过相关属性来配置容器对应该目录的读写权限，默认是读写权限都具备，当然也可以配置成只读。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 默认读写权限都具备 (read/write)</span><br>-v /宿主机绝对路径目录:/容器内目录:rw<br><span class="hljs-comment"># 配置成只读权限 (read only)</span><br>-v /宿主机绝对路径目录:/容器内目录:ro<br></code></pre></td></tr></table></figure><p>另外，容器数据卷可以在容器之间进行继承，通过<code>--volumes-from</code>属性完成。此时启动的容器与父容器除了具有相同的数据卷规则之外没有任何联系，一方的删除并不会导致另一方数据卷规则失效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 在启动容器的时候继承父容器的容器数据卷规则</span><br>docker run -it --privileged=<span class="hljs-literal">true</span> --volumes-from 父容器 --name xxx image_name[:tag]<br></code></pre></td></tr></table></figure><h2 id="卷挂载">卷挂载</h2><p>在使用数据卷的时候，我们也可以只提供容器内的路径，而不提供宿主机的路径，这种挂载方式被称为卷挂载VolumeMount。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">-v [name:]/容器内路径 <br><span class="hljs-comment"># name可选，它代替了宿主机路径，作为新的参数传递</span><br></code></pre></td></tr></table></figure><p>卷挂载只提供容器内路径，但是可以传入一个name来代替之前的宿主机路径。如果没有name，则属于匿名挂载；如果提供了name，则属于具名挂载。</p><p>虽然卷挂载不提供宿主机目录，但是实际上还是有这个概念的。在卷挂载的情况下，对应的宿主机目录都是<code>/var/lib/docker/volumes/xxx</code>。如果是匿名挂载，后面的名字就是一串哈希值；如果是具名挂载，后面的名字就是指定的name。</p><h1 id="dockerfile">DockerFile</h1><h2 id="简介-1">简介</h2><p>想要获取一个Image镜像，可以通过从仓库中拉取，也可以通过DockerFile来进行构建。DockerFile就是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的参数构成的脚本。首先编写一个DockerFile文件，之后可以通过<code>docker build</code>命令来构建镜像。</p><h2 id="保留字介绍">保留字介绍</h2><blockquote><p>命令的详细介绍可以参考官方文档<ahref="https://docs.docker.com/engine/reference/builder/">Dockerfilereference</a></p></blockquote><p>首先有一些基础知识：</p><ol type="1"><li>每条保留字指令都是大写字母，并且后面至少跟随一个参数</li><li>指令按照从上到下的顺序执行</li><li><code>#</code>表示注释</li></ol><p>下面介绍常用的相关保留字：</p><p><code>FROM</code>：指定基础镜像。指定一个已经存在的镜像作为模板，每个Dockerfile的第一条必须是FROM。</p><p><code>MANINTAINER</code>：指定镜像维护者的姓名和邮箱地址。</p><p><code>RUN</code>：在容器<strong>构建</strong>过程中需要运行的命令，命令可以用两种形式进行书写。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># shell格式，等同于在终端操作的shell命令</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install vim</span><br><br><span class="hljs-comment"># exec格式，类似于python中subprocess</span><br><span class="hljs-comment"># RUN [&quot;可执行文件&quot;, &quot;arg1&quot;, &quot;arg2&quot;]</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;./test.sh&quot;</span>, <span class="hljs-string">&quot;arg1&quot;</span>, <span class="hljs-string">&quot;arg2&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><code>EXPOSE</code>：指定当前容器向外暴露的端口。</p><p><code>WORKDIR</code>：指定在创建容器之后，终端默认登陆进来的工作目录。</p><p><code>USER</code>：指定该镜像该以哪个用户去执行，一般不指定，默认为root用户。</p><p><code>ENV</code>：用来在镜像构建过程中设置环境变量。在该命令后面的其他指令可以直接使用已经定义了的环境变量。</p><p><code>ADD</code>：将宿主机目录下的文件拷贝到镜像中，会自动处理URL以及解压tar压缩包。</p><p><code>COPY</code>：类似ADD，但是不会进行解压处理，只是单纯的拷贝。</p><p><code>VOLUME</code>：指定容器数据卷，用于数据保存和持久化的工作。</p><p><code>CMD</code>：指定容器启动之后需要运行的命令。需要注意的是，Dockerfile中可以有多个CMD指令，但是只有最后一个生效，并且CMD会被dockerrun之后的参数替换。</p><p><code>ENTRYPOINT</code>：同样是指定容器之后需要运行的命令。不过与CMD不同的是，ENTRYPOINT并不会被dockerrun后面的命令覆盖，并且传入的命令行参数会被当作提供给ENTRYPOINT对应命令的参数。当然在Dockerfile中同样可以有多个ENTRYPOINT指令，也只有最后一个生效。</p><p>CMD如果单独使用，则表示是运行的命令，同时可以被dockerrun参数覆盖。CMD如果和ENTRYPOINT一起使用，则CMD相当于在给ENTRYPOINT传参，此时CMD仍然可以被dockerrun参数覆盖。</p><p>因此，我们可以利用CMD来达到可变参数的目的：</p><p>假设有如下的Dockerfile，然后利用该Dockerfile构建出镜像，假设名为<code>nginx:test</code>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>于是在利用dockerrun运行镜像的时候，可以通过是否提供命令行参数来达到控制参数的目的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 不提供命令参数</span><br>docker run nginx:<span class="hljs-built_in">test</span><br><span class="hljs-comment"># 容器内部相当于运行</span><br>nginx -c /etc/nginx/nginx.conf<br><br><span class="hljs-comment"># 提供命令参数</span><br>docker run nginx:<span class="hljs-built_in">test</span> /etc/nginx/new.conf<br><span class="hljs-comment"># 容器内部相当于运行</span><br>nginx -c /etc/nginx/new.conf<br></code></pre></td></tr></table></figure><h2 id="案例">案例</h2><p>下面的案例Dockerfile完成了从centos基础镜像出发，设置好java8的环境。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 需要在Dockerfile的同级目录中准备jdk8的压缩包</span><br><span class="hljs-keyword">FROM</span> centos<br>  <br><span class="hljs-keyword">ENV</span> MYPATH /usr/local <br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$MYPATH</span> </span><br>  <br><span class="hljs-comment">#安装vim编辑器 </span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install vim </span><br><span class="hljs-comment">#安装java8及lib库 </span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install glibc.i686 </span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /usr/local/java </span><br><span class="hljs-comment">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置 </span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> jdk-8u171-linux-x64.tar.gz /usr/local/java/ </span><br><span class="hljs-comment">#配置java环境变量 </span><br><span class="hljs-keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class="hljs-number">8.0</span>_171 <br><span class="hljs-keyword">ENV</span> JRE_HOME $JAVA_HOME/jre <br><span class="hljs-keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH <br><span class="hljs-keyword">ENV</span> PATH $JAVA_HOME/bin:$PATH <br>  <br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span> <br> <br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$MYPATH</span> </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;success--------------ok&quot;</span> </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /bin/bash </span><br></code></pre></td></tr></table></figure><p>之后运行docker build命令进行镜像构建：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 在Dockerfile同级目录下运行命令</span><br>docker build -t new_image:tag<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记(1)-简介与Docker基础</title>
    <link href="/2023/07/08/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E7%AE%80%E4%BB%8B%E4%B8%8EDocker%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/08/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E7%AE%80%E4%BB%8B%E4%B8%8EDocker%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="docker概述">Docker概述</h1><h2 id="简介">简介</h2><p>Docker的出现主要是为了解决运行环境和配置的问题。通过Docker镜像将程序代码与所需要的系统环境打包成一个整体，达到程序在不同平台，不同环境上都能做到统一运行。用一句话来概括，Docker是一种容器虚拟化技术，解决了程序的运行环境和配置问题，方便持续集成，并且有助于整体发布。</p><p>Docker与虚拟机类似，但是它们在一些方面上有所不同。虚拟机可以在一种操作系统里面运行另一种操作系统，对于底层系统来说，虚拟机只是一个普通文件，对其他部分毫无影响。虚拟机首先虚拟出一套硬件，然后基于该硬件运行一个完整的操作系统，在该系统上再运行所需的应用进程。</p><p>Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统。而传统虚拟机则是在硬件层面上实现虚拟化。在Docker容器内的进程直接运行于宿主机的内核，并没有进行硬件虚拟，因此容器要比传统虚拟机更为轻便。<strong>容器不需要捆绑一整套操作系统，只需要准备好程序工作所需的相关库资源和设置即可</strong>。同时每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。</p><table><thead><tr class="header"><th></th><th>Docker</th><th>虚拟机</th></tr></thead><tbody><tr class="odd"><td>操作系统</td><td>与宿主机共享OS</td><td>宿主机OS上运行虚拟机OS</td></tr><tr class="even"><td>存储大小</td><td>镜像小，便于存储和传输</td><td>镜像庞大</td></tr><tr class="odd"><td>运行性能</td><td>几乎没有额外性能损失</td><td>操作系统额外的CPU、内存消耗</td></tr><tr class="even"><td>可移植性</td><td>轻便、灵活、适用于Linux</td><td>笨重、与虚拟化技术耦合度高</td></tr><tr class="odd"><td>面向群体</td><td>面向软件开发者</td><td>面向硬件运维者</td></tr><tr class="even"><td>部署速度</td><td>快速、秒级</td><td>较慢</td></tr></tbody></table><blockquote><p>一个常见的面试题：为什么Docker会比VM虚拟机要快？</p><ol type="1"><li>Docker有着比虚拟机更少的抽象层由于Docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上Docker将会在效率上有明显优势。</li><li>Docker利用的是宿主机的内核,而不需要加载操作系统OS内核当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核，进而避免了引寻、加载操作系统内核返回等比较费时费资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，省略了返回过程，因此新建一个Docker容器只需要几秒钟。</li></ol></blockquote><p>Docker的安装可以直接查看官方文档：<ahref="https://www.docker.com">Docker: Develop faster.Runanywhere</a>。需要注意的是，Docker核心功能都由DockerEngine提供，但是Docker Engine需要Linux的支持，即DockerEngine能够直接安装在Linux。如果我们需要在Mac或者Windows上使用Docker的话，则需要直接安装DockerDesktop。DockerDesktop能够帮助我们在Mac和Windows构建、共享和运行容器。</p><blockquote><p>关于Docker镜像加速，可以参考：<ahref="https://www.runoob.com/docker/docker-mirror-acceleration.html">Docker镜像加速 - RUNOOB</a></p></blockquote><h2 id="核心概念">核心概念</h2><p>在Docker包含了三个重要的核心概念，分别是镜像image、容器container以及仓库repository。</p><ul><li>镜像（Image）：镜像是一个只读的模板，它可以用来创建出Docker容器。镜像相当于是一个root文件系统，其中包含了一个基础操作系统所必须的root文件等。</li><li>容器（Container）：容器是从镜像创建而来的运行的实例。Docker使用容器来独立运行一个或一组应用。容器类似于一个虚拟化的运行环境，应用程序或者服务就运行在容器当中。容器为镜像提供了一个标准的、隔离的运行环境，它可以被启动、开始、停止、删除。</li><li>仓库（Repository）：仓库则用于集中存放镜像文件的场所，可以类比Maven仓库，Github仓库等。仓库根据访问属性可以分为公开仓库和私有仓库。Docker官方仓库地址为<ahref="https://hub.docker.com">Docker Hub</a>，国内的公开仓库则包括<ahref="https://www.alibabacloud.com/zh/product/container-registry">阿里云镜像仓库</a>等。</li></ul><p>概括来说，Docker本身是一个管理引擎。我们将应用程序和配置依赖打包形成Image镜像文件之后，通过镜像文件生成Docker容器实例再运行。同一个镜像生成可以生成多个容器实例，这些容器能够保证环境层面的相同。</p><blockquote><p>Docker是一个Client-Server架构的系统。在宿主机上会运行一个Docker守护进程，客户端通过Socket连接来访问守护进程。守护进程接受客户端的命令，同时管理运行在主机上的容器。Docker的整个后端是一个松耦合的架构，拥有众多模块，不同模块各司其职。</p></blockquote><h2 id="hello-world">Hello World</h2><p>安装完成之后，可以通过命令行运行<code>docker --version</code>或者<code>docker info</code>来验证，如果有相关信息打印出来，则表示Docker已经正常安装完毕了。</p><p>接下来可以运行HelloWorld项目来体验Docker的用法。运行命令也非常简单，只需要运行<code>docker run hello-world</code>即可。执行该命令之后，Docker首先会查找本地是否有对应的镜像，由于是刚完成Docker安装，自然在本地是找不到的，所以Docker会继续从Hub上搜索并拉取对应的镜像，并基于该镜像运行容器，最终会打印出下面的提示信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>To generate this message, Docker took the following steps:<br> 1. The Docker client contacted the Docker daemon.<br> 2. The Docker daemon pulled the <span class="hljs-string">&quot;hello-world&quot;</span> image from the Docker Hub.<br>    (amd64)<br> 3. The Docker daemon created a new container from that image <span class="hljs-built_in">which</span> runs the<br>    executable that produces the output you are currently reading.<br> 4. The Docker daemon streamed that output to the Docker client, <span class="hljs-built_in">which</span> sent it<br>    to your terminal.<br><br>To try something more ambitious, you can run an Ubuntu container with:<br> $ docker run -it ubuntu bash<br><br>Share images, automate workflows, and more with a free Docker ID:<br> https://hub.docker.com/<br><br>For more examples and ideas, visit:<br> https://docs.docker.com/get-started/<br></code></pre></td></tr></table></figure><h1 id="常用命令">常用命令</h1><h2 id="image命令">Image命令</h2><h3 id="查看image">查看Image</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看本地主机上的镜像</span><br>docker images [options]<br></code></pre></td></tr></table></figure><p>该命令会列出本地主机上的镜像，镜像以列表形式展示，包括如下字段：</p><ul><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签版本号</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul><p>每个镜像可能具有多个标签，表示该镜像的多个不同版本。我们可以使用<code>REPOSITORY:TAG</code>来唯一标识一个image，如果不指定image的版本，默认使用最新的latest版本。</p><p>该命令还可以使用相关参数：</p><ul><li><code>-a</code>：列出本地所有的镜像（包括历史映像层）</li><li><code>-q</code>：只列出Image ID</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker system <span class="hljs-built_in">df</span><br></code></pre></td></tr></table></figure><p>该命令可以查看镜像/容器/数据卷所占用的空间</p><h3 id="搜索image">搜索Image</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker search [options] image_name<br><span class="hljs-comment"># --limit x: 仅列出x个镜像</span><br></code></pre></td></tr></table></figure><h3 id="拉取image">拉取Image</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull image_name[:tag]<br></code></pre></td></tr></table></figure><h3 id="删除image">删除Image</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 根据image id删除[-f表示强制删除]</span><br>docker rmi -f image_id<br><br><span class="hljs-comment"># 根据image name删除</span><br>docker rmi -f image_name:image_tag<br><br><span class="hljs-comment"># 删除全部image</span><br>docker rmi -f $(docker images -qa)<br></code></pre></td></tr></table></figure><h2 id="container命令">Container命令</h2><h3 id="创建container">创建Container</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run [options] image [<span class="hljs-built_in">command</span>][arg...]<br><br><span class="hljs-comment"># eg: 启动交互式Container，启动前台shell命令行</span><br>docker run -it ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p>该命令表示从image中创建出container，并执行相应命令command。包含如下可用参数：</p><ul><li><code>--name="xxx"</code>：为容器指定一个名称，如果没有指定则会默认命名</li><li><code>-d</code>：以后台模式运行容器，并返回容器ID</li><li><code>-i</code>：以交互式模式运行容器，通常与 -t 一起使用</li><li><code>-t</code>：为容器重新分配一个伪输入终端，通常与 -i一起使用</li><li><code>-P</code>：随机端口映射</li><li><code>-p</code>：指定端口映射</li></ul><blockquote><p>通过后台运行容器的时候需要注意，要求容器运行的命令应该是一直挂起的，否则容器会运行完成命令之后直接退出，无法达到后台运行的目的。最佳的解决方案是,将你要运行的程序以前台进程的形式运行，常见就是命令行模式。</p></blockquote><h3 id="查看container">查看Container</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 列出当前所有正在运行的容器</span><br>docker ps [options]<br></code></pre></td></tr></table></figure><p>命令参数如下：</p><ul><li><code>-a</code>：列出所有的容器，包括正在运行的和历史上运行过的</li><li><code>-l</code>：显示最近创建的容器</li><li><code>-n x</code> ：显示最近创建的x个容器</li><li><code>-q</code>：仅显示容器编号id</li></ul><p>还有如下命令可以查看Container相关信息，包括查看容器日志、容器进程以及容器细节</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看容器日志</span><br>docker logs container_id<br><br><span class="hljs-comment"># 查看容器内运行的进程</span><br>docker top container_id<br><br><span class="hljs-comment"># 查看容器内部细节</span><br>docker inspect container_id<br></code></pre></td></tr></table></figure><h3 id="进入container">进入Container</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入正在运行的容器，并新建命令行进行交互，这里的bashShell需要填写对应命令，例如/bin/bash</span><br>docker <span class="hljs-built_in">exec</span> -it container_id [bashShell]<br><br><span class="hljs-comment"># 进入正在运行的容器，不会启动新的进程</span><br>docker attach container_id<br></code></pre></td></tr></table></figure><p><code>exec</code>和<code>attach</code>命令都可以进入正在运行的容器，但是它们有所区别：</p><ul><li>attach是直接进入容器在启动的时候对应的终端，而不会启动新的进程。如果此时使用exit退出，则会导致容器的停止</li><li>exec是在容器中打开新的终端，启动新的进程。如果此时使用exit退出，并不会导致容器的停止</li></ul><h3 id="退出container">退出Container</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 两种退出方式</span><br><span class="hljs-comment"># 1、run进去容器，exit退出，容器停止</span><br><span class="hljs-built_in">exit</span> <br><span class="hljs-comment"># 2、run进去容器，ctrl+p+q退出，容器不停止</span><br>ctrl+p+q<br></code></pre></td></tr></table></figure><h3 id="启停container">启停Container</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动已停止运行的容器</span><br>docker start 容器ID或者容器名<br><br><span class="hljs-comment"># 重启容器</span><br>docker restart 容器ID或者容器名<br><br><span class="hljs-comment"># 停止容器</span><br>docker stop 容器ID或者容器名<br><br><span class="hljs-comment"># 强制停止容器</span><br>docker <span class="hljs-built_in">kill</span> 容器ID或容器名<br></code></pre></td></tr></table></figure><h3 id="删除container">删除Container</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 删除已停止的容器</span><br>docker <span class="hljs-built_in">rm</span> 容器ID<br><br><span class="hljs-comment"># 删除所有容器</span><br>docker <span class="hljs-built_in">rm</span> -rf $(docker ps -a -q)<br></code></pre></td></tr></table></figure><h3 id="container文件导出">Container文件导出</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 将容器内的文件拷贝到宿主机上</span><br>docker <span class="hljs-built_in">cp</span> 容器ID:容器内路径  目的主机路径<br></code></pre></td></tr></table></figure><h3 id="container导入与导出">Container导入与导出</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 容器导出，将容器整体内容导出为一个tar归档文件</span><br>docker <span class="hljs-built_in">export</span> container_id &gt; xxx.tar<br><br><span class="hljs-comment"># 容器导入，从归档文件创建出对应的镜像</span><br><span class="hljs-built_in">cat</span> xxx.tar | docker import image_name:tag<br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>Docker相关的主要围绕Image、Container、Repository以及相关的文件进行，下面是Docker基础命令的图形化总结，上面仅介绍了一些基础的常用命令，还有其他相关命令会在后面的笔记中介绍。</p><img src="/2023/07/08/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E7%AE%80%E4%BB%8B%E4%B8%8EDocker%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4.png" class="" title="基础命令"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs sh">attach    Attach to a running container                 <span class="hljs-comment"># 当前 shell 下 attach 连接指定运行镜像 </span><br>build     Build an image from a Dockerfile              <span class="hljs-comment"># 通过 Dockerfile 定制镜像 </span><br>commit    Create a new image from a container changes   <span class="hljs-comment"># 提交当前容器为新的镜像 </span><br><span class="hljs-built_in">cp</span>        Copy files/folders from the containers filesystem to the host path   <span class="hljs-comment">#从容器中拷贝指定文件或者目录到宿主机中 </span><br>create    Create a new container                        <span class="hljs-comment"># 创建一个新的容器，同 run，但不启动容器 </span><br>diff      Inspect changes on a container<span class="hljs-string">&#x27;s filesystem   # 查看 docker 容器变化 </span><br><span class="hljs-string">events    Get real time events from the server          # 从 docker 服务获取容器实时事件 </span><br><span class="hljs-string">exec      Run a command in an existing container        # 在已存在的容器上运行命令 </span><br><span class="hljs-string">export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件 </span><br><span class="hljs-string">history   Show the history of an image                  # 展示一个镜像形成历史 </span><br><span class="hljs-string">images    List images                                   # 列出系统当前镜像 </span><br><span class="hljs-string">import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的镜像</span><br><span class="hljs-string">info      Display system-wide information               # 显示系统相关信息 </span><br><span class="hljs-string">inspect   Return low-level information on a container   # 查看容器详细信息 </span><br><span class="hljs-string">kill      Kill a running container                      # kill 指定 docker 容器 </span><br><span class="hljs-string">load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save] </span><br><span class="hljs-string">login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器 </span><br><span class="hljs-string">logout    Log out from a Docker registry server          # 从当前 Docker registry 退出 </span><br><span class="hljs-string">logs      Fetch the logs of a container                 # 输出当前容器日志信息 </span><br><span class="hljs-string">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口 </span><br><span class="hljs-string">pause     Pause all processes within a container        # 暂停容器 </span><br><span class="hljs-string">ps        List containers                               # 列出容器列表 </span><br><span class="hljs-string">pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像 </span><br><span class="hljs-string">push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器 </span><br><span class="hljs-string">restart   Restart a running container                   # 重启运行的容器 </span><br><span class="hljs-string">rm        Remove one or more containers                 # 移除一个或者多个容器 </span><br><span class="hljs-string">rmi       Remove one or more images       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] </span><br><span class="hljs-string">run       Run a command in a new container              # 创建一个新的容器并运行一个命令 </span><br><span class="hljs-string">save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load] </span><br><span class="hljs-string">search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像 </span><br><span class="hljs-string">start     Start a stopped containers                    # 启动容器 </span><br><span class="hljs-string">stop      Stop a running containers                     # 停止容器 </span><br><span class="hljs-string">tag       Tag an image into a repository                # 给源中镜像打标签 </span><br><span class="hljs-string">top       Lookup the running processes of a container   # 查看容器中运行的进程信息 </span><br><span class="hljs-string">unpause   Unpause a paused container                    # 取消暂停容器 </span><br><span class="hljs-string">version   Show the docker version information           # 查看 docker 版本号 </span><br><span class="hljs-string">wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值 </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RateLimiter: 服务限流的简单实现</title>
    <link href="/2023/07/08/RateLimiter-%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/07/08/RateLimiter-%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="ratelimiter">RateLimiter</h1><p>在限流算法中，典型的有令牌桶和漏桶，RateLimiter类提供了令牌桶的实现以及方便的使用接口。RateLimiter由GoogleGuava提供，因此在使用之前首先需要引入相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>32.0.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="简单使用">简单使用</h2><h3 id="acquire">acquire</h3><p>一个简单的入门例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">2.0</span>); <span class="hljs-comment">// the num of permit per second</span><br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) &#123;<br>    rateLimiter.acquire(<span class="hljs-number">2</span>); <span class="hljs-comment">// permit needed</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先通过工厂方法<code>create</code>创建出一个<code>RateLimiter</code>类。在创建的时候需要给定一个double类型的数字，该值表示每秒钟产生的令牌数量。而进行限流的核心操作则是<code>acquire(int)</code>，该方法表示需要获取令牌才能继续执行，当令牌数不够的时候，会阻塞在该方法上。该方法接受一个int类型的值，表示此次操作需要的令牌数量，默认为1。<code>acquire()</code>返回一个double类型的值，该值表示此次方法阻塞的时间，单位为秒。</p><p>因此上面的示例代码实际的运行效果就是每一秒钟输出数组中的一个值。</p><p>值得注意的一点是，RateLimiter有一个特性就是预先支付令牌，并且所需要等待的时间在下次获取令牌的时候再实际执行，也就是<strong>每次acquire的时候实际上是在偿还上次的令牌</strong>，阻塞对应的时间。这种特性使得RateLimter能够应对突发流量。</p><p>观察如下测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">2.0</span>);<br>System.out.println(<span class="hljs-string">&quot;get 4 permits: &quot;</span> + rateLimiter.acquire(<span class="hljs-number">4</span>) + <span class="hljs-string">&quot;s&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;get 1 permits: &quot;</span> + rateLimiter.acquire(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;s&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;get 2 permits: &quot;</span> + rateLimiter.acquire(<span class="hljs-number">2</span>) + <span class="hljs-string">&quot;s&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">get</span> <span class="hljs-number">4</span> permits: <span class="hljs-number">0</span>.<span class="hljs-number">0</span>s<br><span class="hljs-attribute">get</span> <span class="hljs-number">1</span> permits: <span class="hljs-number">1</span>.<span class="hljs-number">997184</span>s<br><span class="hljs-attribute">get</span> <span class="hljs-number">2</span> permits: <span class="hljs-number">0</span>.<span class="hljs-number">493471</span>s<br></code></pre></td></tr></table></figure><p>直接观察上面的结果，会发现似乎获取令牌的数目和时间对不上，但是实际上这就是RateLimiter预先支付令牌的特性。</p><p>首先创建RateLimiter对象，该对象每秒钟均匀产生2个令牌，即0.5秒产生一个令牌。执行到第一个acquire方法，由于预先支付令牌，因此首次acquire无需等待直接返回。之后执行到第二个acquire方法，它需要偿还第一个acquire方法所需的4个令牌，因此阻塞接近2秒。接下来到第三个acquire方法，它需要偿还第二个acquire方法所需的1个令牌，因此阻塞接近0.5s。</p><h3 id="tryacquire">tryAcquire</h3><p>另一个非常有用的方法是<code>tryAcquire()</code>，该方法包括多种重载实现，不过核心参数只有三个，分别是需要获取的令牌数、超时时间以及时间单位。<code>tryAcquire()</code>返回一个布尔值，该方法在超时时间内执行acquire，如果在时间内获取成功，则返回true，反之则返回false。</p><p>下面是测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">2.0</span>);<br>System.out.println(rateLimiter.acquire(<span class="hljs-number">4</span>));<br>System.out.println(rateLimiter.tryAcquire(<span class="hljs-number">8</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS));<br>System.out.println(rateLimiter.acquire(<span class="hljs-number">2</span>));<br>System.out.println(rateLimiter.tryAcquire(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS));<br></code></pre></td></tr></table></figure><p>这里同样需要注意RateLimiter的预先支付令牌的特性。tryAcquire相当于给acquire提供了一个超时时间，因此对于每个tryAcquire方法，我们实际上需要观察上一个acquire所需的令牌数量。测试代码输出如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">0.0<br><span class="hljs-literal">false</span><br>1.997894<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>第一次acquire直接返回，消耗0.0秒。接下来执行tryAcquie，它需要偿还第一次acquire申请的4个令牌。由于无法在1秒内获得，因此返回false。接下来执行acquire。由于上面tryAcquire偿还失败，此次acuqire来继续偿还第一次acquire申请的4个令牌，因此消耗大约2秒。最后一次tryAcquire，需要偿还上次acquire申请的两个令牌，能够在一秒之内获得，因此返回ture。</p><h3 id="warmup">warmup</h3><p>在利用工厂方法完成RateLimiter对象创建的时候，也能够提供额外的参数，使得RateLimiter具备预热功能。RateLimiter的预热指的是带有预热期的平滑限流。它在启动之后会有一段时间的预热期，令牌生成的频率在这段时间内逐步平滑过滤到设置的目标频率。如果没有设置预热的话，则是启动直接达到目标频率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    System.out.println(rateLimiter.acquire());<br>&#125;<br></code></pre></td></tr></table></figure><p>代码运行结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">0.0<br>1.330551<br>0.991947<br>0.661334<br>0.496869<br>0.498878<br>0.494644<br>0.497765<br>0.496662<br>0.496844<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们设置了预热期限为3秒，因此在前面几次的acquire中，阻塞的时间逐渐变短，到大约三秒之后，才变为了正常的阻塞时间，即生成令牌的频率变为目标频率。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://www.baeldung.com/guava-rate-limiter">Quick Guide tothe Guava - RateLimiter</a></li><li><ahref="https://cidoliu.github.io/2021/02/24/RateLimiter%E8%A7%A3%E8%AF%BB/">RateLimiter解读</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>Guava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lombok: 简化样板代码</title>
    <link href="/2023/07/01/Lombok-%E7%AE%80%E5%8C%96%E6%A0%B7%E6%9D%BF%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/07/01/Lombok-%E7%AE%80%E5%8C%96%E6%A0%B7%E6%9D%BF%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>Java本身是一种非常强大的语言，但是它有一个缺点，就是过于冗余。在很多情况下，我们按照规范实现一个简单的功能却需要非常多的代码，例如许多的getter、setter等。这些代码与业务逻辑无关，属于样板代码，但是完成起来却是枯燥乏味且消耗时间的。而Lombok可以帮助我们简化这些样板代码。</p><p>Lombok的目的是帮助程序员简化样板代码的书写，避免编写重复冗余的样板代码。在Lombok中，提供了许多注解，它们各自有不同的功能。在编译阶段，Lombok会根据这些注解来生成对应的样板代码，添加到.class文件当中，从而简化我们的开发过程。</p><p>Lombok的引入可以通过Maven来完成，如下所示。注意这里的作用范围指定为<code>provided</code>，这是因为我们只在编写代码以及编译阶段会用到该依赖，在编译完成之后，Lombok就已经完成了它的使命。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="常用注解">常用注解</h1><p>Lombok的使用主要就是注解的使用，不同的注解对应不同的简化功能。完整的注解功能可以参考官方文档：<ahref="https://projectlombok.org/features/">projectlombok|features</a>，这里主要结合案例来介绍一些常用的注解。</p><h2 id="gettersetter">Getter&amp;Setter</h2><p>首先是<code>@Getter</code>和<code>@Setter</code>注解。该注解辅助生成对应的Getter和Setter。默认情况下生成的是public方法，如果需要指定其他作用范围，则需要在注解的Value值中进行指定，可选值有<code>PUBLIC</code>、<code>PROTECTED</code>、<code>PACKAGE</code>、<code>PRIVATE</code>等，在<code>AccessLevel</code>的实现当中。同时需要注意的是，在生成的方法名称中，布尔类型对应的Getter方法名称为<code>isXXX</code>。</p><p>使用Lombok的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-meta">@Setter(AccessLevel.PROTECTED)</span><br>    String name;<br>    <span class="hljs-type">boolean</span> active;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>等价Java原始实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    <span class="hljs-type">boolean</span> active;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isActive</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> active;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setActive</span><span class="hljs-params">(<span class="hljs-type">boolean</span> active)</span> &#123;<br>        <span class="hljs-built_in">this</span>.active = active;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="constructor">Constructor</h2><p>构造器相关的注解包括<code>@NoArgsConstructor</code>、<code>@RequiredArgsConstructor</code>和<code>@AllArgsConstructor</code>，对应不同参数构造器。</p><p>无参构造器以及完整参数构造器容易理解，其中<code>@RequiredArgsConstructor</code>注解处理的则是那些一定需要初始化的字段，例如使用final修饰的字段，使用<code>@NonNull</code>修饰的字段等。不过该注解不会处理静态属性字段，</p><h2 id="tostring">ToString</h2><p><span class="citation"data-cites="ToString注解辅助完成">@ToString注解辅助完成</span><code>toString</code>方法的生成。</p><p>默认情况下返回的是一个包含类名的字符串，后面跟上每个字段的的名称以及值，使用逗号分隔，类似<code>Worker(id=0, name=null, active=false)</code>。可以使用<code>includeFieldNames=false</code>来排除字段名，类似<code>Worker(0, null, false)</code>。</p><p>默认情况下返回字符串会考虑所有非静态字段。可以使用<code>@ToString.Exclude</code>修饰字段来手动忽略。或者是指定<code>@ToString(onlyExplicitlyIncluded = true)</code>，然后利用<code>@ToString.Include</code>来显示指定需要包含的字段。</p><p>使用Lombok的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> active;<br>&#125;<br></code></pre></td></tr></table></figure><p>等价Java原始实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> active;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Worker(&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&quot;</span> + name +<br>                <span class="hljs-string">&quot;, active=&quot;</span> + active +<br>                <span class="hljs-string">&#x27;)&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="equalsandhashcode">EqualsAndHashCode</h2><p><code>@EqualsAndHashCode</code>注解辅助生成<code>equals()</code>方法以及<code>hashCode()</code>方法，默认考虑所有非static以及所有非transient字段，不过也可以参考<code>@ToString</code>中的字段Include以及Exclude方法来进行手动调整。</p><h2 id="data">Data</h2><p><code>@Data</code>注解的功能类似于上面一系列注解的集合。该注解可以帮助我们直接创建出一个POJO对象，也就是说其中会包括所有字段的Getter、所有非final字段的Setter、涉及类中每个字段的toString、equeals以及hashCode实现，以及所有final字段的构造函数。</p><p>使用Lombok的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    <span class="hljs-type">boolean</span> active;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="value">Value</h2><p><code>@Value</code>类似于<code>@Data</code>注解，它会生成相关的方法，但是不包括Setter方法；此外它会将所有属性都看作不可变的final类型，同时使用private进行修饰；同时类本身也会被标注为final。</p><p>使用Lombok的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    <span class="hljs-type">boolean</span> active;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="nonnull">NonNull</h2><p><code>@NonNull</code>可以帮助生成对应的空检查语句。需要注意的是，该注解只能出现在可能为null的类型上，例如String，而不能修饰Primitivetype，例如int、boolean上，为了解决这个问题，我们可以使用包装类代替原始类型。</p><p>使用Lombok的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> active;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-meta">@NonNull</span> String name, <span class="hljs-type">boolean</span> active)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.active = active;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>等价Java原始实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> active;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, <span class="hljs-type">boolean</span> active)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-keyword">if</span>(name == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;name is marked non-null but is null&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.active = active;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高级注解">高级注解</h1><h2 id="cleanup">Cleanup</h2><p><code>@Cleanup</code>注解能够确保资源的关闭方法被调用。默认情况下，资源的关闭方法为<code>close()</code>，不过也可以在注解中进行指定。该注解背后使用的是try-with-resource表达方式来完成的。</p><h2 id="synchronized">Synchronized</h2><p><code>@Synchronized</code>可以帮助我们生成类似synchronized功能的代码。默认情况下普通方法对<code>$lock</code>对象加锁、静态方法对<code>$LOCK</code>对象加锁。当然我们也可以在注解Value中可以指定需要加锁的对象。</p><p>使用Lombok的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectToLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  <br>  <span class="hljs-meta">@Synchronized</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-meta">@Synchronized</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <br>  <span class="hljs-meta">@Synchronized(&quot;objectToLock&quot;)</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printObject</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(objectToLock);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>等价Java原始实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">$LOCK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">$lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>($LOCK) &#123;<br>      System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>($lock) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printObject</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(readLock) &#123;<br>      System.out.println(objectToLock);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sneakythrows">SneakyThrows</h2><p>对于一个方法来说，如果它会抛出异常，那么它要么需要在方法内部使用try-catch进行异常处理，要么需要在方法后面声明异常抛出，否则将无法通过编译。而<code>@SneakyThrows</code>会抛出所有受检异常，我们只需要使用该注解，而不需要使用上面的解决方案。</p><p>使用Lombok的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwException</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>等价Java原始实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwException</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>();<br>&#125;<br><br><span class="hljs-comment">// or</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwException</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="builder">Builder</h2><p><code>@Builder</code>可以帮助我们方便的实现一个build模式的对象，添加该注解之后，我们就可以使用相关的构建方法来完成对象的构建。</p><p>使用Lombok的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Builder</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    <span class="hljs-type">boolean</span> active;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加注解之后，Lombok会辅助生成一个Builder内部类，以及多个相关方法，包括<code>builder()</code>、<code>build()</code>等，之后可以使用如下方法来构建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Worker.<span class="hljs-type">WorkerBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> Worker.builder();<br><span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> Worker.builder().id(<span class="hljs-number">1</span>).name(<span class="hljs-string">&quot;name&quot;</span>).active(<span class="hljs-literal">true</span>).build();<br></code></pre></td></tr></table></figure><h2 id="log">Log</h2><p>绝大多数的日志框架在使用之前都需要我们在类中声明一个staticfinal的日志记录器类Logger。使用<code>@Log</code>能够帮助我们简化这一声明，Lombok会自动帮助创建一个日志记录器对象，名称为<code>log</code>。在<code>lombok.extern</code>中提供了多种不同的日志注解，用于适配不同的日志框架，我们可以根据实际情况来使用不同的注解。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://auth0.com/blog/a-complete-guide-to-lombok/#Most-Common-Lombok-Annotations">AComplete Guide to Lombok</a></li><li><ahref="https://www.baeldung.com/intro-to-project-lombok">Introduction toProject Lombok | Baeldung</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>Java</tag>
      
      <tag>Lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>依赖重命名 maven-shade-plugin</title>
    <link href="/2023/05/28/%E4%BE%9D%E8%B5%96%E9%87%8D%E5%91%BD%E5%90%8D-maven-shade-plugin/"/>
    <url>/2023/05/28/%E4%BE%9D%E8%B5%96%E9%87%8D%E5%91%BD%E5%90%8D-maven-shade-plugin/</url>
    
    <content type="html"><![CDATA[<h1 id="maven-shade-plugin">Maven Shade Plugin</h1><h2 id="简介">简介</h2><p>maven-shade-plugin是一个maven打包插件，主要用于辅助完成maven项目打包，同时还提供了许多增强功能，包括依赖添加与排除、依赖重命名等。</p><p>maven-shade-plugin打包生成的jar，其中包含了项目所需要的全部依赖，所以jar包的文件大小相对来说会更大。此时生成的jar包往往是为了单独运行，而不是为了作为其他项目的依赖。</p><h2 id="使用方式">使用方式</h2><h3 id="jar打包">jar打包</h3><p>使用该插件进行打包，只需要在<code>pom.xml</code>文件中指定相关插件与版本，并增加<code>execution</code>选项，为其绑定在pacakge阶段：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="可运行jar包">可运行jar包</h3><p>如果要生成一个可指定jar包，那么还需要指定main方法的入口，可以在<code>configuration</code>标签中指定对应的mainClass：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transformers</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transformer</span> <span class="hljs-attr">implementation</span>=<span class="hljs-string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>&#123; mainClass 全路径&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">transformer</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">transformers</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="依赖添加与排除">依赖添加与排除</h3><p>在<code>configuration</code>标签中可以增加<code>artifactSet</code>标签，其中可以配置需要添加的第三方依赖或者排除不需要打包的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactSet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>*:*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>org.projectlombok:lombok<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">artifactSet</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以通过配置filter来决定在第三方依赖中哪些文件进行打包，哪些文件不进行打包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filters</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifact</span>&gt;</span>javax.servlet.jsp:jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifact</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>javax/servlet/jsp/**<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filters</span>&gt;</span><br>    ... <br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="依赖重命名">依赖重命名</h3><p>有时候我们的jar包在某些环境或者平台上运行，而jar包与平台之间存在依赖冲突，此时就需要利用到依赖重命名。</p><p>或者可以考虑一个更加形象的例子。现在有一个A项目，它依赖于B项目的1.0版本。然后我们需要开发一个C项目，C项目既需要引入A项目的依赖，又需要引入B项目的2.0版本。问题在于B项目的1.0版本与2.0版本之间是不兼容的，例如有API修改。那么对于C项目来说就会存在冲突，即C项目到底需要使用B:1.0还是B:2.0。使用B:1.0，那么直接依赖B:2.0的C项目无法工作；如果使用B:2.0，那么直接依赖B:1.0的A项目无法工作，从而依赖于A项目的C项目依旧无法工作。</p><p>利用maven-shade-plugin提供的依赖重命名功能，我们就可以解决上面的问题，达到隔离第三方包、解决包冲突等效果。例如在上面的例子中，就可以将C项目依赖的B:2.0进行重命名，使之与B:1.0不再冲突。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">relocations</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">relocation</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>com.B<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">shadedPattern</span>&gt;</span>com.shaded.B<span class="hljs-tag">&lt;/<span class="hljs-name">shadedPattern</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">relocation</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">relocations</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure><p>这里的relation就是完成重命名的工作。其中pattern表示匹配模式，shadedPattern表示需要重命名成什么名称。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://run-zheng.github.io/2019/11/06/maven-shade-plugin/">maven-shade-plugin介绍</a></li><li><ahref="https://stackoverflow.com/questions/13620281/what-is-the-maven-shade-plugin-used-for-and-why-would-you-want-to-relocate-java">Whatis the maven-shade-plugin used for - StackOverflow</a></li><li><ahref="https://maven.apache.org/plugins/maven-shade-plugin/">Apache MavenShade Plugin</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java日志框架介绍与使用</title>
    <link href="/2023/05/09/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/05/09/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="日志实现">日志实现</h1><h2 id="log4j2">Log4j2</h2><p>Log4j 是 Apache的一个日志开源框架，提供多个分级（DEBUG/INFO/WARN/ERROR）记录级别，可以很好地将不同日志级别的日志分开记录，极大地方便了日志的查看。Log4j2也就是Log4j的2.x版本，也是目前官方推荐使用的版本。我们可以在官网<ahref="https://logging.apache.org/log4j/2.x/index.html">Apache-log4j-2.x</a>中看到更加详细的介绍</p><p>使用Log4j2，需要引入下面的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.20.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.20.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同时我们还需要一个配置文件，我们可以在其中指定日志系统的相关配置，具体位置为<code>resources/log4j2.xml</code>，下面是一个简单的配置文件例子。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stdout&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; %p %m%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stdout&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，我们首先指定了一个<code>Appender</code>，其中主要用于指定日志记录的位置以及日志的格式，之后我们在<code>Loggers</code>标签中增加了标签使得我们的<code>Appender</code>生效，注意这里的<code>level="info"</code>指定了日志等级。接下来我们就可以在代码中记录日志了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log4J</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LogManager.getLogger(Log4J.class);<br>        logger.debug(<span class="hljs-string">&quot;Debug Message&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;Info Message&quot;</span>);<br>        logger.warn(<span class="hljs-string">&quot;Warning Message&quot;</span>);<br>        logger.error(<span class="hljs-string">&quot;Error Message&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现在控制台中打印如下，由于指定了日志等级为info，因此只有INFO等级以上的日志被打印出来了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">2023-04-27 16:57:31 INFO Info Message<br>2023-04-27 16:57:31 WARN Warning Message<br>2023-04-27 16:57:31 ERROR Error Message<br></code></pre></td></tr></table></figure><p>如果想要将日志打印到文件中，可以修改配置文件如下，修改主要就是增加了一个新的<code>Appender</code>，即这里的<code>File</code>标签，在其中指定日志输出位置以及日志格式。之后在<code>Loggers</code>中进行挂载增加即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stdout&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; %p %m%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file-out&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;log/logger-log4j2.log&quot;</span> <span class="hljs-attr">append</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %m%nw<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stdout&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;file-out&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="logback">Logback</h2><p>Logback是Log4j的改进版本，它的开发者也是Log4j的开发人员，Logback的官网地址为：<ahref="https://logback.qos.ch/index.html">logback.qos.ch</a>。Logback当前分为三个模块，<code>logback-core</code>、<code>logback-classic</code>和<code>logback-access</code>。其中<code>logback-core</code>是其他两个模块的基础，而<code>logback-classic</code>是log4j的一个改良版本，它完整实现了SLf4japi，使得我们可以很方便地更换成其他日志系统。<code>logback-access</code>则通过与Servlet容器集成，提供通过Http来访问日志的功能。</p><p>要想使用Logback，我们同样需要先引入下面的依赖。注意该依赖会自动引入其他两个依赖，分别是<code>logback-core</code>和<code>slf4j-api</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>类似地，我们也需要提供相关的配置文件，位置为<code>resources/logback.xml</code>，下面是一个简单的配置文件示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;std-out&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file-out&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>log/logger-logback.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">append</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">append</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;std-out&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;file-out&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到这里的概念和之前log4j中配置文件的概念是非常类似的。下面完成测试代码，需要注意的是这里使用的是<code>slf4j</code>的相关类，而没有直接使用<code>logback</code>相关的类。最终的运行效果与上面log4j中也是非常类似的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logback</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Logback.class);<br>        logger.debug(<span class="hljs-string">&quot;Debug Message&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;Info Message&quot;</span>);<br>        logger.warn(<span class="hljs-string">&quot;Warning Message&quot;</span>);<br>        logger.error(<span class="hljs-string">&quot;Error Message&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="日志门面">日志门面</h1><h2 id="sif4j">SIf4J</h2><p>在实际的项目应用当中，有时候可能会从一个日志框架切换到另一个日志框架。通常两个日志框架的使用方式是有所差异的，这就导致我们需要在代码上进行大量改动。所以为了避免切换日志组件时大量的代码改动，Slf4J出现了。Slf4J全称为SimpleLogging Facade forJava，意为Java简单日志记录接口集。这是一个日志的接口规范，它向用户提供了统一的日志接口，而底层屏蔽了不同日志组件的差异。这样我们在实际编写代码的时候，只需要使用Slf4J提供给我们的接口即可，而不需要关注底层日志框架的区别。而当我们需要更换日志组件的时候，也只需要更换一个具体的日志组件Jar包就可以了。</p><p>下面的测试代码与上面Logback完全相同，因为Logback本身已经实现了Slf4J的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logback</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Logback.class);<br>        logger.debug(<span class="hljs-string">&quot;Debug Message&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;Info Message&quot;</span>);<br>        logger.warn(<span class="hljs-string">&quot;Warning Message&quot;</span>);<br>        logger.error(<span class="hljs-string">&quot;Error Message&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要使用其他的日志实现作为底层框架，则一般我们只需要修改引入的Maven依赖即可。通常我们需要引入<code>slf4j-api</code>以及具体日志实现的依赖，同时还需要引入一层连接器依赖，例如<code>slf4j-log4j12</code>，用于关联Slf4J和底层实际的日志组件。</p><h1 id="最佳实践">最佳实践</h1><p>目前主流的日志框架解决方案为Slf4J +Logback的组合，有如下几点原因：</p><ul><li>LogBack自身实现了Slf4J的日志接口，而不需要Slf4J去做进一步的适配</li><li>LogBack是在Log4J的基础上优化而来的，其运行速率和效率都要高于Log4J</li><li>Slf4J + Logback支持占位符，方便日志代码的阅读，而Log4J则不支持</li></ul><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://www.baeldung.com/java-logging-intro">Introductionto Java Logging - Baeldung</a></li><li><ahref="https://www.cnblogs.com/chanshuyi/p/something_about_java_log_framework.html">Java日志框架那些事</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Java中进行重试 guava-retrying</title>
    <link href="/2023/04/29/%E5%9C%A8Java%E4%B8%AD%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%AF%95-guava-retrying/"/>
    <url>/2023/04/29/%E5%9C%A8Java%E4%B8%AD%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%AF%95-guava-retrying/</url>
    
    <content type="html"><![CDATA[<h1 id="guava-retrying">Guava-retrying</h1><h2 id="简介">简介</h2><p>在实际的过程中，我们开发一个函数功能往往会需要用到其他的服务，但是我们无法保证其他服务是稳定可用的，于是重试逻辑就是一个非常常见的行为，同时也是一个比较普遍适用的功能。同时考虑到对代码的侵入性，我们希望能够有一个统一的外部逻辑来进行函数的重试。<code>guava-retrying</code>就能够提供这样的功能，它是googleGuava库的一个小扩展，允许为任意函数调用创建可配置的重试策略，为我们提供了一个简单易用的重试框架。该项目的官方地址为<ahref="https://github.com/rholder/guava-retrying">rholder/guava-retrying</a>。</p><blockquote><p>Guava：GoogleGuava是一组由Google开源的Java通用库，其中提供了许多在Java中实用的功能。</p></blockquote><h2 id="quick-start">Quick Start</h2><p>首先我们需要引入相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.rholder<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava-retrying<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通常来说，我们需要重试的情况有函数出现异常，函数返回值与预期不一致等，因此我们首先可以通过随机数来模拟可能的情况，下面两个函数在运行的时候会随机返回，一个随机返回null，另一个随机抛出错误。这里<code>MyException</code>是继承了<code>RuntimeException</code>的自定义异常，主要用于异常统一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Boolean <span class="hljs-title function_">randomFailed</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> random.nextBoolean();<br>    <span class="hljs-keyword">if</span> (res) &#123;<br>        System.out.println(<span class="hljs-string">&quot;return true&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;return null&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">randomThrowException</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> random.nextBoolean();<br>    <span class="hljs-keyword">if</span> (res) &#123;<br>        System.out.println(<span class="hljs-string">&quot;throw my exception.&quot;</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyException</span>(<span class="hljs-string">&quot;res is true&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;dont throw my exception&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的两个方法在运行的时候是带有随机性的，无法保证每次运行都能返回正确的结果，因此我们需要引入重试功能。<code>guava-retrying</code>采用Callable的方式对需要进行重试的方法进行包装，然后对运行结果进行监听，从而控制重试逻辑。</p><p>对于第一个随机失败的方法来说，我们可以设置当结果返回null的时候进行重试，那么可以用下面的代码完成。这里需要通过<code>RetryerBuilder</code>来构造出一个<code>Retryer</code>对象，通过该对象来调用<code>Callable</code>对象。在构造的时候，我们可以指定对应的重试逻辑，像这里我们就可以指定当结果返回null的时候进行重试，同时重试策略为重试三次之后不再重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">randomFailedWithRetry</span><span class="hljs-params">()</span> &#123;<br>    Callable&lt;Boolean&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Boolean&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-keyword">return</span> randomFailed();<br>        &#125;<br>    &#125;;<br>    Retryer&lt;Boolean&gt; retryer = RetryerBuilder.&lt;Boolean&gt;newBuilder()<br>            .retryIfResult(Objects::isNull)<br>            .withStopStrategy(StopStrategies.stopAfterAttempt(<span class="hljs-number">3</span>))<br>            .build();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> retryer.call(callable);<br>    &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">catch</span> (RetryException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于第二个随机抛出错误的方法来说，我们也可以设置当出现异常的时候进行重试，相关代码如下。注意这里设置返回类型为<code>Void</code>，还是需要一个返回结果的，这里选择返回为<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">randomThrowExceptionWithRetry</span><span class="hljs-params">()</span> &#123;<br>    Callable&lt;Void&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Void&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            randomThrowException();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;;<br>    Retryer&lt;Void&gt; retryer = RetryerBuilder.&lt;Void&gt;newBuilder()<br>            .retryIfExceptionOfType(MyException.class)<br>            .withStopStrategy(StopStrategies.stopAfterAttempt(<span class="hljs-number">3</span>))<br>            .build();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        retryer.call(callable);<br>    &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">catch</span> (RetryException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到上面，构造出<code>Retryer</code>对象的过程是非常类似的，所以对于类似的重试逻辑，我们完全可以再进行一层封装，方便后续的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">retry</span><span class="hljs-params">(Callable&lt;T&gt; callable, <span class="hljs-type">int</span> retryTimes,</span><br><span class="hljs-params">                          Class&lt;? extends Throwable&gt; retryException)</span> <span class="hljs-keyword">throws</span> RuntimeException &#123;<br>    Retryer&lt;T&gt; retryer = RetryerBuilder.&lt;T&gt;newBuilder()<br>            .retryIfExceptionOfType(retryException)<br>            .withStopStrategy(StopStrategies.stopAfterAttempt(retryTimes))<br>            .build();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> retryer.call(callable);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然除了代码中使用到的这些，<code>guava-retrying</code>还提供了很多其他更加灵活的重试策略，我们可以在使用的时候进行参考使用。</p><h2 id="retrylistener">RetryListener</h2><p>如果在发生重试之后，我们需要做一些额外的处理动作，例如告警，那么可以使用<code>RetryListener</code>。每次重试之后，<code>guava-retrying</code>会自动回调我们注册的监听。当然也可以注册多个RetryListener，会按照注册顺序依次调用。</p><p>首先，我们可以实现自定义的监听类，需要实现<code>RetryListener</code>接口以及其中的方法。其中的Attempt对象会给我们提供许多重试的相关信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRetryListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RetryListener</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRetry</span><span class="hljs-params">(Attempt&lt;V&gt; attempt)</span> &#123;<br>        <span class="hljs-comment">// 重试次数，第一次重试指的是第一次调用</span><br>        System.out.println(<span class="hljs-string">&quot;retry times = &quot;</span> + attempt.getAttemptNumber());<br>        <span class="hljs-comment">// 该次重试距离第一次调用的延迟</span><br>        System.out.println(<span class="hljs-string">&quot;delay = &quot;</span> + attempt.getDelaySinceFirstAttempt());<br>        <span class="hljs-comment">// 重试中是否出现异常</span><br>        System.out.println(<span class="hljs-string">&quot;hasException = &quot;</span> + attempt.hasException());<br>        System.out.println(<span class="hljs-string">&quot;hasResult = &quot;</span> + attempt.hasResult());<br>        <span class="hljs-comment">// 如果有异常可以获取异常，否则直接拿到返回结果</span><br>        <span class="hljs-keyword">if</span>(attempt.hasException())&#123;<br>            System.out.println(<span class="hljs-string">&quot;causeBy = &quot;</span> + attempt.getExceptionCause());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + attempt.getResult());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成之后，只需要在构造Retry对象的时候增加相关配置即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">.withRetryListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRetryListener</span>())<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://juejin.cn/post/7014099031718641694">Java开发利器之重试框架guava-retrying</a></li><li><ahref="https://java.jverson.com/tools/guava-retryer.html">重试工具: GuaaRetryer</a></li><li><ahref="https://blog.csdn.net/lvyuan1234/article/details/78875298">线程任务接口Callable使用void作为返回类型</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Guava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python集合模块 Collections</title>
    <link href="/2023/04/24/Python%E9%9B%86%E5%90%88%E6%A8%A1%E5%9D%97-Collections/"/>
    <url>/2023/04/24/Python%E9%9B%86%E5%90%88%E6%A8%A1%E5%9D%97-Collections/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>在collections中，主要包括如下相关类和方法：</p><table><thead><tr class="header"><th>相关类/方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>namedtuple()</td><td>创建命名元组子类的工厂函数，生成可以使用名字来访问元素内容的tuple子类</td></tr><tr class="even"><td>deque</td><td>类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)</td></tr><tr class="odd"><td>ChainMap</td><td>类似字典(dict)的容器类，将多个映射集合到一个视图里面</td></tr><tr class="even"><td>Counter</td><td>字典的子类，提供了可哈希对象的计数功能</td></tr><tr class="odd"><td>OrderedDict</td><td>字典的子类，保存了他们被添加的顺序，有序字典</td></tr><tr class="even"><td>defaultdict</td><td>字典的子类，提供了一个工厂函数，为字典查询提供一个默认值</td></tr><tr class="odd"><td>UserDict</td><td>封装了字典对象，简化了字典子类化</td></tr><tr class="even"><td>UserList</td><td>封装了列表对象，简化了列表子类化</td></tr><tr class="odd"><td>UserString</td><td>封装了字符串对象，简化了字符串子类化</td></tr></tbody></table><p>我们可以引入该模块，然后打印出对应的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><span class="hljs-built_in">print</span>(collections.__all__)<br><br>[<span class="hljs-string">&#x27;ChainMap&#x27;</span>, <span class="hljs-string">&#x27;Counter&#x27;</span>, <span class="hljs-string">&#x27;OrderedDict&#x27;</span>, <span class="hljs-string">&#x27;UserDict&#x27;</span>, <span class="hljs-string">&#x27;UserList&#x27;</span>, <span class="hljs-string">&#x27;UserString&#x27;</span>, <span class="hljs-string">&#x27;defaultdict&#x27;</span>, <span class="hljs-string">&#x27;deque&#x27;</span>, <span class="hljs-string">&#x27;namedtuple&#x27;</span>]<br></code></pre></td></tr></table></figure><h1 id="named-tuple">Named Tuple</h1><p>namedtuple含义为命名元组，它可以帮助我们生成一个允许使用名字访问元素内容的Tuple子类，提高程序的可读性。</p><p>例如，如果我们需要表示平面上的一个点，我们可以使用一个元组<code>(x, y)</code>来进行表示，但是这样的元组只能用下标来访问其中的内容。另一种解决方案是定义一个类Point，其中保存对应的坐标。而命名元组实际上就可以帮助我们更加简单地构造出这样一个类，利用该方法，我们可以指定类名以及元组的名次，之后就可以用更加具有可读性的代码来完成相关工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>Point = namedtuple(<span class="hljs-string">&#x27;Point&#x27;</span>, [<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>])<br><br>point = Point(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment"># 使用字段名</span><br><span class="hljs-built_in">print</span>(point.x)  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(point.y)  <span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 使用index</span><br><span class="hljs-built_in">print</span>(point[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(point[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 实际上就是构造出的类 Point 就是内置 tuple 的一个子类</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(point, Point))  <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(point, <span class="hljs-built_in">tuple</span>))  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p><code>namedtuple</code>可以接收如下参数：</p><ul><li><code>typename</code>：指定所创建的tuple子类的类名</li><li><code>field_names</code>：接收一个字符串序列，用于表示tuple中的字段名称</li><li><code>rename</code>：如果该参数设置为True，那么无效的字段会被自动替换为位置名称</li><li><code>verbose</code>：如果该参数设置为True，那么子类被创建之后，类定义就会被立即打印出来</li><li><code>module</code>：用于指定类所在的module</li></ul><h1 id="deque">Deque</h1><p>python原生的list类型是线性存储数据的，按照索引访问元素很快，但是数据量很大的时候，插入和删除效率较低，而<code>deque</code>是一个双端队列，其中高效实现了插入和删除操作，适合用于队列和栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>q = deque([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;3&#x27;</span>])<br>q.append(<span class="hljs-number">2</span>)<br>q.appendleft(<span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-built_in">print</span>(q)  <span class="hljs-comment"># deque([&#x27;c&#x27;, &#x27;a&#x27;, 1, &#x27;3&#x27;, 2])</span><br></code></pre></td></tr></table></figure><p>deque和list具有几乎相同的使用方式，相关方法如下：</p><ul><li><code>append(x)</code>：向队尾添加元素</li><li><code>appendleft(x)</code>：向队首添加元素</li><li><code>clear()</code>：清空队列元素</li><li><code>copy()</code>：获得一个浅拷贝</li><li><code>count(x)</code>：计算队列中值为x的个数</li><li><code>extend(x_deque)</code>：向队尾扩展队列</li><li><code>extendleft(x_deque)</code>：向队首扩展队列</li><li><code>index(x)</code>：获取x的下标index</li><li><code>insert(index, x)</code>：在指定index处插入值x</li><li><code>pop()</code>：弹出队尾元素</li><li><code>popleft()</code>：弹出队首元素</li><li><code>remove(value)</code>：删除第一个value值</li><li><code>reverse()</code>：队列反转</li><li><code>rotate(n=1)</code>：将队列向右循环移动n步</li><li><code>maxlen</code>：deque的最大尺寸</li></ul><h1 id="chain-map">Chain Map</h1><p><code>ChainMap</code>可以把一组<code>dict</code>组合成一个逻辑上的dict。在使用的使用，仍然可以按照操作一个dict那样操作，但是内部的逻辑则会在这组dict上依次进行。实际上，ChainMap实际上就是一个映射链，在进行操作的时候，会依次在内部的链上进行。</p><p>ChainMap的一个常见应用场景是程序参数的获取。在获取应用程序参数的时候，我们通常可以从三个地方获取，分别是命令行传入、环境变量传入以及默认参数，它们可以对应三个dict，利用ChainMap可以实现参数的优先级查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> ChainMap<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-comment"># default args</span><br>defaults = &#123;<br>    <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>    <span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;guest&#x27;</span><br>&#125;<br><br><span class="hljs-comment"># cmd args</span><br>parser = argparse.ArgumentParser()<br>parser.add_argument(<span class="hljs-string">&#x27;-u&#x27;</span>, <span class="hljs-string">&#x27;--user&#x27;</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;--color&#x27;</span>)<br>namespace = parser.parse_args()<br>command_line_args = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">vars</span>(namespace).items() <span class="hljs-keyword">if</span> v&#125;<br><br><span class="hljs-comment"># 组合成ChainMap, 优先级依次下降：cmd args &gt; env args &gt; default args</span><br>combined = ChainMap(command_line_args, os.environ, defaults)<br><br><span class="hljs-comment"># 打印参数:</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;color=%s&#x27;</span> % combined[<span class="hljs-string">&#x27;color&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;user=%s&#x27;</span> % combined[<span class="hljs-string">&#x27;user&#x27;</span>])<br><br></code></pre></td></tr></table></figure><p>之后我们可以使用不同方式传入相关参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 不主动传入任何参数，则使用默认参数</span><br>python3 collections-test.py <br>color=red<br>user=guest<br><br><span class="hljs-comment"># 传入命令行参数，则使用命令行参数</span><br>python3 collections-test.py -u bob<br>color=red<br>user=bob<br><br><span class="hljs-comment"># 同时传入命令行参数和环境变量，命令行参数优先级更高</span><br>user=admin color=green python3 collections-test.py -u bob<br>color=green<br>user=bob<br></code></pre></td></tr></table></figure><h1 id="counter">Counter</h1><p><code>Counter</code>是一个计数器，可以帮助我们统计次数。它本身也是<code>dict</code>的一个子类，key为元素值，value则为对应元素值出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><span class="hljs-comment"># 像操作dict一样使用计数器</span><br>count = Counter()<br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]:<br>    count[word] += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(count)<br><span class="hljs-comment"># Counter(&#123;&#x27;blue&#x27;: 3, &#x27;red&#x27;: 2, &#x27;green&#x27;: 1&#125;)</span><br><br><span class="hljs-comment"># 直接传入列表进行计算</span><br><span class="hljs-built_in">print</span>(Counter([<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]))<br><span class="hljs-comment"># Counter(&#123;&#x27;blue&#x27;: 3, &#x27;red&#x27;: 2, &#x27;green&#x27;: 1&#125;)</span><br><br><span class="hljs-comment"># 直接传入字符串进行计算</span><br><span class="hljs-built_in">print</span>(Counter(<span class="hljs-string">&quot;abcabcabcd&quot;</span>))<br><span class="hljs-comment"># Counter(&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 3, &#x27;c&#x27;: 3, &#x27;d&#x27;: 1&#125;)</span><br></code></pre></td></tr></table></figure><p>Counter作为dict的子类，能够提供dict相关的方法，同时它本身还提供了一些特有的方法：</p><ul><li><code>elements()</code>：返回一个迭代器，其中每个元素将重复计数器所指定的次数，同时元素会按照首次出现的顺序返回</li><li><code>most_common(n)</code>：返回一个列表，其中包含n个出现最多的元素以及对应的出现次数。计数值相等的元素按照首次出现的顺序进行排序。如果n为None，则返回所有元素</li><li><code>substract(another_counter)</code>：从迭代对象或者映射对象减去元素，对应值对应相减</li></ul><p>此外，Counter还提供强大的数学操作功能，要点在于对应位置的值进行对应操作，如果得到的计数小于等于0则会被忽略</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br>c = Counter(a=<span class="hljs-number">3</span>, b=<span class="hljs-number">1</span>)<br>d = Counter(a=<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>)<br><span class="hljs-comment"># c[x] + d[x]</span><br><span class="hljs-built_in">print</span>(c + d)  <span class="hljs-comment"># Counter(&#123;&#x27;a&#x27;: 4, &#x27;b&#x27;: 3&#125;)</span><br><br><span class="hljs-comment"># c[x] - d[x]</span><br><span class="hljs-built_in">print</span>(c - d)  <span class="hljs-comment"># Counter(&#123;&#x27;a&#x27;: 2&#125;)</span><br><br><span class="hljs-comment"># intersection: min(c[x], d[x])</span><br><span class="hljs-built_in">print</span>(c &amp; d)  <span class="hljs-comment"># Counter(&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 1&#125;)</span><br><br><span class="hljs-comment"># union: max(c[x], d[x])</span><br><span class="hljs-built_in">print</span>(c | d)  <span class="hljs-comment"># Counter(&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 2&#125;)</span><br></code></pre></td></tr></table></figure><h1 id="ordered-dict">Ordered Dict</h1><p>在使用dict的时候，key是无序的，因此我们在对dict进行迭代的时候，是无法确定key的顺序的，而<code>OrderedDict</code>就为我们解决了这个问题。它可以按照插入的顺序对Key进行保存，这样在进行迭代的时候同样是可以保证顺序的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<br><br>orderedDict = OrderedDict([(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>)])<br><span class="hljs-built_in">print</span>(orderedDict)  <span class="hljs-comment"># OrderedDict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)])</span><br><span class="hljs-built_in">print</span>(orderedDict.keys())  <span class="hljs-comment"># odict_keys([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span><br></code></pre></td></tr></table></figure><p>OrderedDict的使用方法几乎等同于内置的dict，不过它自身还是提供了一些其他的功能：</p><ul><li><code>popitem(last=True)</code>：移除字典中的一个键值对。如果last为真，则按照LIFO后进先出的顺序返回键值对，否则按照FIFO先进先出的顺序返回键值对</li><li><code>move_to_end(key, last=True)</code>：将key对应的键值对移动到其中一端。如果last为True则移动到最后，否则移动到开头</li><li><code>reversed(order_list)</code>：相对于通常的映射方法，有序字典还另外提供了逆序迭代的支持</li></ul><blockquote><p>需要注意，Python3.8之后，内置的dict已经是有序的了。</p></blockquote><h1 id="default-dict">Default Dict</h1><p>使用Python内置的dict，如果我们访问一个不存在的key，则会抛出KeyError错误。而<code>defaultdict</code>可以帮助我们指定默认值，如果Key不存在，返回的是实现指定的默认值。而<code>default dict</code>的其他使用方式与内置的dict完全相同。</p><p><code>defaultdict</code>对象包含一个名为<code>default_factory</code>的属性。在构造的时候，第一个参数用于为该属性提供初始构造方法，默认为None。所有其他参数（包括关键字参数）都相当于传递给 dict 的构造函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br>s = [(<span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">1</span>)]<br>d = defaultdict(<span class="hljs-built_in">list</span>)<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> s:<br>    d[k].append(v)<br><span class="hljs-built_in">print</span>(d)  <span class="hljs-comment"># defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;yellow&#x27;: [1, 3], &#x27;blue&#x27;: [2, 4], &#x27;red&#x27;: [1]&#125;)</span><br></code></pre></td></tr></table></figure><p>例如这里我们使用list作为default_factory。当第一次遇见某个key的时候，它还没有在字典里面，所以会自动创建，调用default_factory方法返回一个空的list，之后空的list进行append。再次遇到对应的key，就与正常dict操作相同了。</p><h1 id="基类">基类</h1><p>除了上面专门的数据类型之外，在Collections中还提供了三个基类，分别是UserDict、UserList和UserString，以方便用户创建自定义的字典、列表和字符串。如果我们想要自定义类似于dict、list和str的类，那么可以继承这些基类，之后进行个性化地定制即可。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://docs.python.org/3/library/collections.html#module-collections">Collections-PythonDoc</a></li><li><a href="https://zhuanlan.zhihu.com/p/343747724">万字长文详解Python库collections，让你击败99%的Pythoner</a></li><li><ahref="https://www.liaoxuefeng.com/wiki/1016959663602400/1017681679479008">collectionspython</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask-Socketio的使用</title>
    <link href="/2023/04/18/Flask-Socketio%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/18/Flask-Socketio%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="websocket">WebSocket</h1><p>WebSocket是一种网络协议，可以用来实现在客户端和服务器之间的双向实时通信，前端可以向后端发送请求，同时后端也可以向前端进行实时数据推送。传统的HTTP协议是无状态的，每次请求都需要重新建立连接，而利用WebSocket可以在建立连接之后保持连接状态，双方可以随时发送信息。</p><p>在一个实时的Web应用程序中，我们可以使用Vue作为前端框架，使用Flask作为后端框架。前后端都有相关的工具来支持WebSocket，使得开发WebSocket应用更加容易。</p><h1 id="案例介绍">案例介绍</h1><h2 id="相关概念">相关概念</h2><p>在介绍案例之前，我们可以简单了解一下WebSocket的工作原理。WebSocket可以实现服务器和客户端之间的双向通信，我们可以想象是在双方之间建立了一个通道，前后端都可以进行信息发送和信息接收。具体来说，我们会在后面见到<code>emit</code>和<code>on</code>的操作，分别代表发送信息以及接收信息。</p><p>如果客户端想要使用websocket接受服务器推送的话，Socketio是一个不错的选择。Socket.io将Websocket、轮询机制以及其它的实时通信方式（ajax等）封装成了通用的接口，并且在服务端也实现了这些实时机制的相应代码。所以，使用Socket.io便不需要担心浏览器兼容问题。</p><p>在socketio中还有两个重要的概念，分别为<code>namespace</code>和<code>event</code>，前后端如果要进行双向通信，这些信息应该同属于一个namespace。而event则是在信息发送和接收的时候使用到，我们可以触发一个event，也可以监听一个event，这样就形成了一个通道，使得数据能够正确传递。在后面我们也可以在代码中看到对应的概念。</p><h2 id="flask-socketio">Flask SocketIO</h2><p>FlaskSocketIO是在Flask框架中对WebSocket的支持，通过它我们能够在Flask中很方便地完成WebSocket应用的编写。可以通过pip来进行依赖的安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install flask-socketio<br></code></pre></td></tr></table></figure><p>之后，我们可以通过如下的代码来获取对应的SocketIO对象。这里为了解决跨域问题，我们使用了CORS以及<code>cors_allowed_origins='*'</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> flask_cors <span class="hljs-keyword">import</span> CORS<br><span class="hljs-keyword">from</span> flask_socketio <span class="hljs-keyword">import</span> SocketIO<br><br>app = Flask(__name__)<br>CORS(app, cors_allowed_origins=<span class="hljs-string">&#x27;*&#x27;</span>)<br>socketIO = SocketIO(app, cors_allowed_origins=<span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><p>下一步，我们可以完成一个通信方法。可以看到，在代码中我们指定了<code>namespace</code>为<code>/api</code>，同时还调用了SocketIO对象的<code>on</code>和<code>emit</code>方法。首先，后端会监听<code>/api</code>下的<code>my event</code>事件，如果监听到了，就会触发该函数。在函数中，我们可以接收推送的信息data，然后后端调用<code>emit</code>方法，触发<code>my response</code>事件，同时传递数据。这里传递的数据就是在得到的data基础上进行了一层包装。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@socketIO.on(<span class="hljs-params"><span class="hljs-string">&quot;my event&quot;</span>, namespace=<span class="hljs-string">&quot;/api&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">testSocketIO</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-built_in">print</span>(data)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test socket io...&quot;</span>)<br>    socketIO.emit(<span class="hljs-string">&quot;my response&quot;</span>, &#123;<span class="hljs-string">&#x27;dataInBackend&#x27;</span>: data&#125;, namespace=<span class="hljs-string">&quot;/api&quot;</span>)<br></code></pre></td></tr></table></figure><p>SocketIO应用的启动和传统的Flask有所区别，需要使用<code>SocketIO</code>对象来run。如果使用的是dev模式，则需要额外增加属性<code>allow_unsafe_werkzeug=True</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    socketIO.run(app, allow_unsafe_werkzeug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="vue-前端展现">Vue 前端展现</h2><p>在前端我们同样需要SocketIO的支持。这里我们使用Vue框架作为前端的实现。在Vue中有两种方式来使用SocketIO，一种是直接使用官方包<code>SocketIO</code>，第二种是使用<code>VueSocketio</code>。第二种方式是对SocketIO的一层封装，更适合在Vue项目中使用，不过在案例实现的过程中，第二种方法会有版本不匹配的问题出现，因此这里还是选择使用第一种方式。</p><p>首先需要通过npm安装相关依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install socket.io-client<br></code></pre></td></tr></table></figure><p>之后，我们可以在需要使用WebSocket的组件中进行使用。下面来介绍一个简单案例。首先展现组件的完整代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h1&gt;SocketIO Shower&lt;/h1&gt;<br>  &lt;div&gt;&#123;&#123; this.data &#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import io from &#x27;socket.io-client&#x27;;<br><br>export default &#123;<br>  name: &quot;SocketIOShower&quot;,<br>  data() &#123;<br>    return &#123;<br>      data: &#123;&#125;<br>    &#125;<br>  &#125;,<br>  mounted() &#123;<br>    const socket = io(&#x27;http://127.0.0.1:5000/api&#x27;);<br>    socket.emit(&#x27;my event&#x27;, &#123;&#x27;data&#x27;: &quot;data from fronend&quot;&#125;);<br>    socket.on(&#x27;my response&#x27;, (data) =&gt; &#123;<br>      this.data = data<br>    &#125;)<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在测试组件中，我们的data中返回一个data字段，用于承接后端推送的信息，并将其渲染在页面中。在组件mounted的声明周期，我们通过<code>io</code>获取一个<code>SocketIO</code>对象，然后通过该对象分别调用了emit以及on方法。注意这里在对象初始化的时候，我们已经在url中指定了<code>namespace</code>，实际上namespace就相当于path的拼接。</p><p>对应到前面Flask的案例代码，首先前端通过<code>emit</code>触发<code>my event</code>事件传递数据<code>&#123;'data': "data from fronend"&#125;</code>，后端flask监听了对应namespace下的该事件，于是会在控制台中进行打印，同时调用<code>emit</code>方法触发<code>my response</code>事件，向前端传送信息。前端使用了<code>on</code>方法来监听<code>my response</code>事件，因此能够得到后端传送来的数据，同时更新<code>this.data</code>，进行页面渲染。</p><p>最终我们可以在前端页面上看见如下效果：</p><img src="/2023/04/18/Flask-Socketio%E7%9A%84%E4%BD%BF%E7%94%A8/socketio-frontend.png" class="" title="socketio-frontend"><h2 id="动态推送">动态推送</h2><p>上面的案例中，后端只是向前端完成了一次简单的数据推送，更常见的场景是后端持续向前端进行数据推送，我们可以简单修改上面的示例代码来模拟对应场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@socketIO.on(<span class="hljs-params"><span class="hljs-string">&quot;my event&quot;</span>, namespace=<span class="hljs-string">&quot;/api&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">testSocketIO</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-built_in">print</span>(data)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test socket io...&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        socketIO.emit(<span class="hljs-string">&quot;my response&quot;</span>, &#123;<span class="hljs-string">&#x27;dataInBackend&#x27;</span>: data, <span class="hljs-string">&#x27;nowIndex&#x27;</span>: i&#125;, namespace=<span class="hljs-string">&quot;/api&quot;</span>)<br></code></pre></td></tr></table></figure><p>之后在前端页面上，我们就可以看到动态变化的信息了。</p><h2 id="注意事项">注意事项</h2><p>在使用过程中，可能出现如下异常情况。在Flask后端中出现下面的提示信息，同时前端控制台上会一直提示400以及跨域错误。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">The client is using an unsupported version of the Socket.IO or Engine.IO protocols<br></code></pre></td></tr></table></figure><p>这是因为相关依赖的版本不能匹配。在使用过程中，前后端使用的SocketIO以及相关依赖的版本需要能够匹配上，否则会无法工作。匹配的版本可以在<ahref="https://flask-socketio.readthedocs.io/en/latest/intro.html#version-compatibility">Introduction— Flask-SocketIOdocumentation</a>中进行查看，目前的对应关系如下所示。</p><table><thead><tr class="header"><th style="text-align: left;">JavaScript Socket.IO version</th><th style="text-align: left;">Socket.IO protocol revision</th><th style="text-align: left;">Engine.IO protocol revision</th><th style="text-align: left;">Flask-SocketIO version</th><th style="text-align: left;">python-socketio version</th><th style="text-align: left;">python-engineio version</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0.9.x</td><td style="text-align: left;">1, 2</td><td style="text-align: left;">1, 2</td><td style="text-align: left;">Not supported</td><td style="text-align: left;">Not supported</td><td style="text-align: left;">Not supported</td></tr><tr class="even"><td style="text-align: left;">1.x and 2.x</td><td style="text-align: left;">3, 4</td><td style="text-align: left;">3</td><td style="text-align: left;">4.x</td><td style="text-align: left;">4.x</td><td style="text-align: left;">3.x</td></tr><tr class="odd"><td style="text-align: left;">3.x and 4.x</td><td style="text-align: left;">5</td><td style="text-align: left;">4</td><td style="text-align: left;">5.x</td><td style="text-align: left;">5.x</td><td style="text-align: left;">4.x</td></tr></tbody></table><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://juejin.cn/post/6844904201781248007">vue flask nginxsocketio实现服务器推送（demo实现一个聊天室） - 掘金 (juejin.cn)</a></li><li><ahref="https://flask-socketio.readthedocs.io/en/latest/index.html">Flask-SocketIO— Flask-SocketIO documentation</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask</tag>
      
      <tag>SocketIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式(6)-避免浪费与类表现</title>
    <link href="/2023/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E9%81%BF%E5%85%8D%E6%B5%AA%E8%B4%B9%E4%B8%8E%E7%B1%BB%E8%A1%A8%E7%8E%B0/"/>
    <url>/2023/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E9%81%BF%E5%85%8D%E6%B5%AA%E8%B4%B9%E4%B8%8E%E7%B1%BB%E8%A1%A8%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="flyweight">Flyweight</h1><h2 id="简介">简介</h2><p>Flyweight的含义是轻量级，该设计模式的作用是让对象变轻。具体来说，当程序中需要大量对象的时候，如果都使用new关键字来分配内存，将会消耗大量的内存空间，而Flyweight模式的核心思想就是“通过尽量共享实例来避免new出实例”。通常我们在使用的时候，会将共享实例使用一个工厂来进行管理，每次需要相应示例的时候，都从工厂中获得。工厂会将这些实例管理在一个pool中，当有请求过来的时候，如果pool中已经存在了对应的实例，则将其返回共享出去，而不用重新创建；如果没有，则新创建一个返回之后，将其管理到pool中，以便后续的共享。但既然是进行了共享，那么就会出现一处修改多处改变的情况，这种时候就需要我们认真考虑对象是否能够进行共享，需要结合具体的场景。</p><h1 id="proxy">Proxy</h1><h2 id="简介-1">简介</h2><p>Proxy表示代理，也就是代理模式。在代理模式下，真实的功能实现对象会被增加一层代理。具体来说，代理对象会持有一个功能对象，然后向外暴露接口。我们在使用功能的时候，需要使用的是代理对象，而代理对象对应方法的核心功能，则又是由被代理的功能对象来实现的。在代理模式中有如下角色：</p><ul><li><code>Subject</code>：该角色定义了功能角色和代理角色需要实现的接口，该接口使得Proxy角色与RealSubject角色具有一致性。在使用的时候，我们不需要在意使用的是哪种角色，因为对于功能的提供来说，两者都是能够完成的</li><li><code>Proxy</code>：该角色为代理角色。它会持有一个<code>RealSubject</code>对象，同时会实现Subject接口</li><li><code>RealSubject</code>：该角色为实际的功能提供角色</li></ul><h2 id="示例程序">示例程序</h2><p>在示例程序中，我们会模拟一个打印过程。我们通过一个代理对象<code>PrinterProxy</code>来进行功能调用，该对象实际上调用了真实的<code>Printer</code>对象来实现相关功能。</p><p>首先，我们可以声明一个接口表示打印所需的相关功能，这个接口应该同时由代理对象与被代理对象实现。接口<code>Printable</code>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Printable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrinterName</span><span class="hljs-params">(String name)</span>;<br><br>    String <span class="hljs-title function_">getPrinterName</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后，可以完成核心的功能实现对象<code>Printer</code>，它完成的是打印过程的核心功能，同时需要实现上面的接口。这里为了模拟一个复杂耗时的创建操作，在程序中模拟了5s的睡眠。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Printable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Printer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.heavyJob(<span class="hljs-string">&quot;Generating Printer Instance.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Printer</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.heavyJob(<span class="hljs-string">&quot;Generating Printer Instance (&quot;</span> + name + <span class="hljs-string">&quot;).&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heavyJob</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(message);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Completed.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrinterName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPrinterName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;=== &quot;</span> + name + <span class="hljs-string">&quot; ===&quot;</span>);<br>        System.out.println(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成实际的功能对象之后，就可以完成对应的代理对象<code>PrinterProxy</code>。该对象会持有一个Printer对象，但是并不会完成初始化。只有当真正需要使用到它的时候才会去完成初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrinterProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Printable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Printer real;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrinterProxy</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrinterName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">if</span> (real != <span class="hljs-literal">null</span>) &#123;<br>            real.setPrinterName(name);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPrinterName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span> &#123;<br>        realize();<br>        real.print(str);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">realize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (real == <span class="hljs-literal">null</span>) &#123;<br>            real = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Printer</span>(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此就完成了所有的示例代码，我们可以进行如下测试。在测试代码中，我们先给代理对象命名为Alice，但是此时它持有的Printer对象并没有初始化。之后我们改名为Bob，再调用print的时候，此时才进行Printer对象的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">PrinterProxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrinterProxy</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>    proxy.setPrinterName(<span class="hljs-string">&quot;Bob&quot;</span>);<br>    proxy.print(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="说明">说明</h2><p>在示例程序中，我们发现代理对象可以使得实际功能对象的创建延后，在必要的时候才进行创建，可以很好地改善用户体验。当然也可以通过代理模式实现AOP的效果，具体来说就是在代理对象方法中，调用功能对象方法的前后增加相关的逻辑，例如日志的打印和记录等。</p><p>在代理模式中，代理对象需要持有一个被代理对象，但是反过来，被代理对象是不知道代理对象的，它并不知道代理对象的存在。</p><h1 id="command">Command</h1><h2 id="简介-2">简介</h2><p>当我们调用一个对象的方法完成相关工作的时候，我们可以从结果的变化中发现工作已经完成，但是并没有办法留下工作的历史记录。而Command就希望解决这种问题，它使用命令对象来表示进行工作这件事，一次工作就对应一个实例。之后再进行相关工作的时候，就不是调用对应对象的方法，而是调用命令对象的execute方法。这样的好处在于我们可以进行工作历史记录的管理，实际上就是管理一个命令对象的集合，同时我们还可以随时重新执行这些命令。而关于命令中应该包含哪些信息，实际上没有绝对的答案，命令的目的不同，应该包含的信息也不同，并且根据保存信息的不同，我们能够重现的粒度也不同。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Technique</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式(5)-状态管理</title>
    <link href="/2023/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-5-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <url>/2023/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-5-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="observer">Observer</h1><h2 id="简介">简介</h2><p>Observer意为观察者。在Observer模式中，当观察对象的状态发生变化的时候，会通知给观察者，而观察者再根据状态进行相应的处理。在Observer模式中有如下角色：</p><ul><li><code>Subject</code>：该角色表示被观察的对象。在该角色中主要声明了相关方法，包括注册观察者、删除观察者、获取当前状态等</li><li><code>ConcreteSubject</code>：该角色表示具体的被观察对象，当自身状态发生改变之后，它会通知所有已经注册了的Observer角色</li><li><code>Observer</code>：该角色表示观察者。在该角色中声明了update方法，用于接收Subject角色状态变化的通知，同时进行相应的处理</li><li><code>ConcreteObserver</code>：该角色表示具体的观察者。实现了Observer角色中的相应方法</li></ul><p>实际上，Observer角色并非主动地去观察，而是被动地接收来自观察对象的通知。在这种角度上理解，Observer模式可能被称为发布-订阅模式更加合适。由观察对象进行信息的发布，而Observer角色完成信息的订阅</p><h2 id="示例程序">示例程序</h2><p>在示例程序中，我们考虑这样一个场景，我们首先有一个随机数值生成对象，它作为一个被观察的对象存在。同时我们实现两个不同的观察者，用于观察这个数值生成对象，当数值变化的时候将数值进行显示，当然不同的观察者显示方式不一样。</p><p>首先我们完成一个抽象类<code>NumberGenerator</code>，它表示数值生成对象，也是被观察对象。作为数值生成对象，它声明了两个抽象方法，<code>getNumber</code>用于获取当前状态下的数值，<code>execute</code>方法用于执行数值生成。而作为被观察对象，它首先持有一个列表对象，用于保存已经注册了的观察者，同时提供相关的<code>addObserver</code>以及<code>deleteObserver</code>方法，用于观察者的增加和删除。最后还实现了一个notifyObservers方法，用来通知所有观察者状态发生变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.add(observer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.remove(observer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Observer next : observers) &#123;<br>            next.update(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是我们就可以完成确切的子类<code>RandomNumberGenerator</code>，它继承了NumberGenerator，并且可以完成数值的随机生成。在每次完成数值生成时，都会调用notifyObservers方法，通常所有注册了的Observer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomNumberGenerator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NumberGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.number;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            number = random.nextInt(<span class="hljs-number">50</span>);<br>            notifyObservers();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们关注Observer观察者部分。首先实现<code>Observer</code>接口，其中只有一个抽象方法<code>update</code>，用于接收来自被观察者的状态更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(NumberGenerator generator)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里实现了Observer的两个不同实现类，其中<code>DigitObserver</code>会将生成的数值打印出来，而<code>GraphObserver</code>会将生成的数值以<code>*</code>的形式进行表示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DigitObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(NumberGenerator generator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;DigitObserver: &quot;</span> + generator.getNumber());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(NumberGenerator generator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;GraphObserver:&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> generator.getNumber();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们就可以完成测试代码，如下所示。程序启动之后，每次数值状态的更改都会通知两个Observer，它们也会相应做出反应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RandomNumberGenerator</span> <span class="hljs-variable">generator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomNumberGenerator</span>();<br>    <span class="hljs-type">Observer</span> <span class="hljs-variable">observer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DigitObserver</span>();<br>    <span class="hljs-type">Observer</span> <span class="hljs-variable">observer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GraphObserver</span>();<br>    generator.addObserver(observer1);<br>    generator.addObserver(observer2);<br>    generator.execute();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="memento">Memento</h1><h2 id="简介-1">简介</h2><p>在一些情况下，我们需要将对象的状态进行恢复，例如一些带有撤销功能的编辑器。我们需要事先保存实例的相关状态信息，然后在撤销的时候，根据所把保存的信息将实例恢复至原来的状态。想要恢复实例，通常的想法是我们需要能够自由访问实例内部结构的权限，但是这样做的话，容易导致依赖实例内部结构的代码分散在程序的各个部分，难以维护，导致破坏了面向对象中的封装性。而Memento模式就是用来解决这种问题的，Memento有备忘录的意思，它通过引入表示实例状态的角色，来防止在保存和恢复实例时对象的封装性遭到破坏。</p><p>在Memento模式中有如下角色：</p><ul><li><code>Originator</code>：Originator为生成者角色。该角色会在保存自己最新状态的时候生成Memento角色，同时它也可以接受一个Memento角色，然后将自己恢复成对应的状态</li><li><code>Memento</code>：Memento为状态角色。该角色会将Originator角色内部的信息进行整合和保存。不过虽然Memento角色保存了Originator角色的信息，它并不会公开这些信息，或者说公开的信息非常有限。在Memento角色中提供两类接口，分别是宽接口和窄接口。<ul><li><code>wide interface</code>：宽接口。Memento角色提供的宽接口可以用于获取对象的所有状态信息，由于宽接口能够暴露所有内部信息，因此能够调用的应该只有Originator角色</li><li><code>narraw interface</code>：窄接口。Memento角色提供的窄接口可以用于获取对象内部的有限信息，能够被外部角色进行调用</li></ul></li><li><code>Caretaker</code>：Caretaker为负责人，它是一个外部角色。该角色会根据情况来决定是否需要保存当前Originator角色的状态，当需要保存的时候，则会通过Originator角色，Originator角色在接收到通知之后会生成Memento角色并将其返回给Caretake角色。同时Caretaker角色无法访问Memento角色内部的所有信息，它只是将Originator角色生成的Menento角色当作一个黑盒进行保存</li></ul><p>利用Memento模式，我们可以实现撤销undo、重做redo、历史记录history、快照snapshot等功能。在这个模式中，尤其需要注意各个角色之间的调用关系以及可见关系。</p><h2 id="示例程序-1">示例程序</h2><p>在示例程序中，我们来模拟一个收集水果和获取金钱的投骰子游戏。游戏的主人公通过投骰子来决定下一个状态，根据骰子点数不同，发生的事件也不同，分别可能获取金钱，金钱减半以及获取水果。如果获取了金钱，我们会将当前的状态进行保存，而如果金钱损失太多，我们则会恢复之前的状态。</p><p>首先我们创建一个<code>Memento</code>类，用于保存主人公的状态。在这个类中，分别有两个属性，金钱和当前水果。尤其注意这里不同方法的作用范围。构造函数、getFruits方法使用的是默认作用范围，只能被同一个package下的对象访问，而无法被外部访问，这里就对应上面提到的Memento提供的宽API。而getMoney方法使用了public进行修饰，可以被外部访问到，则对应Momento角色提供的窄API。注意这里的宽窄对应的是暴露内部信息的多少，而不是方法作用范围的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;<br>    <span class="hljs-type">int</span> money;<br>    ArrayList&lt;String&gt; fruits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    Memento(<span class="hljs-type">int</span> money) &#123;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoney</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.money;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFruit</span><span class="hljs-params">(String fruit)</span> &#123;<br>        fruits.add(fruit);<br>    &#125;<br><br>    List&lt;String&gt; <span class="hljs-title function_">getFruits</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (List&lt;String&gt;) fruits.clone();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>之后，我们可以完成Originator角色。这里对应的是<code>Gamer</code>类，用于表示游戏主人公。整个游戏的关键运行逻辑都实现在<code>bet</code>方法中。而状态保存和状态恢复的方法则分别对应<code>createMemento()</code>和<code>restoreMemento()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Gamer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> money;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; fruits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] fruitsName = &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;grape&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Gamer</span><span class="hljs-params">(<span class="hljs-type">int</span> money)</span> &#123;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoney</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.money;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFruit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (random.nextBoolean()) &#123;<br>            prefix = <span class="hljs-string">&quot;delicious-&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prefix + fruitsName[random.nextInt(fruitsName.length)];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dice</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">6</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (dice == <span class="hljs-number">1</span>) &#123;<br>            money += <span class="hljs-number">100</span>;<br>            System.out.println(<span class="hljs-string">&quot;money added.&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dice == <span class="hljs-number">2</span>) &#123;<br>            money /= <span class="hljs-number">2</span>;<br>            System.out.println(<span class="hljs-string">&quot;money cut in half&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dice == <span class="hljs-number">6</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> getFruit();<br>            System.out.println(<span class="hljs-string">&quot;get fruit: &quot;</span> + fruit);<br>            fruits.add(fruit);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;nothing happened&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">createMemento</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Memento</span> <span class="hljs-variable">memento</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(money);<br>        <span class="hljs-keyword">for</span> (String fruit : fruits) &#123;<br>            <span class="hljs-keyword">if</span> (fruit.startsWith(<span class="hljs-string">&quot;delicious-&quot;</span>)) &#123;<br>                memento.addFruit(fruit);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memento;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreMemento</span><span class="hljs-params">(Memento memento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.money = memento.money;<br>        <span class="hljs-built_in">this</span>.fruits = memento.getFruits();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[Money = &quot;</span> + money + <span class="hljs-string">&quot;, fruits = &quot;</span> + fruits + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们就可以完成测试代码了。实际上在这里，我们的测试代码就相当于Caretaker角色，它根据当前的状态来判断是否需要进行状态存储以及状态更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Gamer</span> <span class="hljs-variable">gamer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gamer</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-type">Memento</span> <span class="hljs-variable">memento</span> <span class="hljs-operator">=</span> gamer.createMemento();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        System.out.println(<span class="hljs-string">&quot;====&quot;</span> + i);<br>        System.out.println(<span class="hljs-string">&quot;now status:&quot;</span> + gamer);<br><br>        gamer.bet();<br><br>        System.out.println(<span class="hljs-string">&quot;now player&#x27;s money is &quot;</span> + gamer.getMoney());<br>        <span class="hljs-keyword">if</span> (gamer.getMoney() &gt; memento.getMoney()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;money add, save status.&quot;</span>);<br>            memento = gamer.createMemento();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gamer.getMoney() &lt; memento.getMoney() / <span class="hljs-number">2</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;money cut, restore former status.&quot;</span>);<br>            gamer.restoreMemento(memento);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="说明">说明</h2><p>在Memento模式中，尤其需要注意的就是各个角色之间的调用关系以及方法的可见性。在这里我们引入Caretaker角色的目的是为了进行职责分担。Caretake角色的职责是决定何时拍摄快照、何时撤销以及保存Memento角色，而Originator角色的职责是生成Memento角色以及使用接收到的Memento角色来恢复自己的状态。有了这样的职责分担，如果有对应需求变更的时候，就可以非常方便的进行修改。这也是设计模式带给我们的便利之处。</p><h1 id="state">State</h1><h2 id="简介-2">简介</h2><p>在面向对象编程中，我们使用类来表示对象，但是类对应的东西可能是真实存在的，也可能只是一个概念。例如在接下来的State设计模式中，我们就使用类来表示状态。用类来表示状态，我们就能够通过切换类来方便地改变对象的状态，如果需要增加新的状态，只需要增加新的状态类即可。而在使用到状态的地方，也只需要动态切换持有的表示状态的类即可。State模式较为简单，它的逻辑并不复杂，只是思想上的小改变，这里就不提供示例代码了。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Technique</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy的介绍与使用</title>
    <link href="/2023/04/16/Scrapy%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/16/Scrapy%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="scrapy">Scrapy</h1><h2 id="框架概述">框架概述</h2><p>Scrapy是一个非常流行的基于Python的网络爬虫框架，可以用来抓取Web站点并从页面中提取结构化的数据。利用Scrapy框架，我们仅需要关注核心的网页解析框架，而不用关注其他的一些常规流程，例如发送请求，下载请求，失败重试等等，极大地简化了爬虫程序的开发。下面是Scrapy的核心组件以及它的工作流程示意图：</p><img src="/2023/04/16/Scrapy%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/Scrapy%E6%9E%B6%E6%9E%84.png" class="" title="Scrapy架构"><p>在Scrapy中，有如下的核心组件：</p><ol type="1"><li>Scrapy引擎（Engine）：用来控制整个系统的数据处理流程</li><li>调度器（Scheduler）：调度器从引擎接受请求并排序列入队列，同时接受引擎的调度请求</li><li>下载器（Downloader）：负责抓取网页并将网页内容返回给爬虫程序</li><li>爬虫程序（Spiders）：爬虫程序是用户自定义的用来解析网页并抓取特定URL的类，每个蜘蛛都能够处理一个域名或者一组域名。简单来说，就是用来定义特定网站的抓取和解析规则的模块</li><li>数据管道（ItemPipeline）：主要负责处理爬虫程序从网页中抽取的数据条目，负责数据的清理，验证和存储。</li><li>中间件（Middleware）：提供自定义的代码来扩展Scrapy的功能，包括下载器中间件以及爬虫中间件</li></ol><p>下面是Scrapy的工作流程：</p><ol type="1"><li>引擎询问爬虫程序需要处理哪个或者哪些网站，爬虫程序将第一个需要处理的URL返回</li><li>引擎将需要处理的URL传送给调度器，调度器负责URL的调度</li><li>引擎从调度器中获取接下来需要爬取的URL，并将其发送给下载器</li><li>当网页被下载器下载完成之后，响应内容通过下载中间件被发送到引擎当中；如果下载失败，则引擎会通知调度器记录这个URL，等待后续重试</li><li>引擎收到了下载器的响应之后，将其通过爬虫程序进行处理</li><li>爬虫程序处理响应，并返回爬取到的数据条目，此外还需要将新的URL发送给引擎</li><li>引擎将爬取到的数据条目送入数据管道，并将新的URL传送给调度器</li><li>重复以上过程，直到调度器中没有需要请求的URL</li></ol><h2 id="getting-started">Getting Started</h2><p>我们可以通过下面的案例，利用Scrapy快速创建一个爬虫项目。首先需要安装Scrapy，通过pip或者conda进行安装都可以。安装完成之后，可以执行下面的<code>scrapy startproject</code>命令来创建一个模板项目，其中会提供Scrapy项目所需要的基本文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install scrapy<br><br>scrapy startproject xxx<br></code></pre></td></tr></table></figure><p>这里我们选择创建一个项目，名称为<code>scrapytest</code>。进入创建好的目录中，我们可以看到如下的项目结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">- scrapytest<br>- scrapytest<br>- spiders<br>- __init__.py<br>- __init__.py<br>- items.py<br>- middlewares.py<br>- pipelines.py<br>- settings.py<br>- scrapy.cfg<br></code></pre></td></tr></table></figure><p>可以看到这里的文件或者目录名称，与Scrapy中的相关组件可以相互对应。其中我们首先需要关注的就是爬虫程序，这里是存放在<code>spiders</code>目录下。根据创建项目时命令行中打印的提示，我们可以通过<code>scrapy genspider example example.com</code>来创建示例爬虫程序。我们这里拿一个经典新手例子，豆瓣电影Top250。创建douban爬虫程序，会生成如下的基本内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy <span class="hljs-keyword">import</span> Selector, Request<br><span class="hljs-keyword">from</span> scrapy.http <span class="hljs-keyword">import</span> HtmlResponse<br><span class="hljs-keyword">from</span> scrapytest.items <span class="hljs-keyword">import</span> MovieItem<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DouBanSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;douban&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;movie.douban.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://movie.douban.com/top250&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response: HtmlResponse</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>这里就是我们需要核心关注的地方。其中，name是这个爬虫的识别名称，必须是唯一的，在不同的爬虫必须定义不同的名字。</p><p><code>allow_domains</code>是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页，不存在的URL会被忽略。</p><p><code>start_urls</code>是爬取的URL元祖/列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些urls开始。其他子URL将会从这些起始URL中继承性生成。</p><p>parse方法接收响应，然后对响应进行解析。在这里我们主要需要将网页中的内容进行解析，解析成一个<code>Item</code>类的形式，以便持久化到后续的文件当中。同时我们还可以解析网页中的相关url，将其传送给核心引擎，进行下一轮的爬取。在这里，我们首先可以定义一个相关的Item类，来进行数据的承接。这个类需要继承<code>Scrapy.Item</code>，且需要定义在<code>item.py</code>文件当中。这里我们简单的利用三个属性来进行承接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieItem</span>(scrapy.Item):<br>    title = scrapy.Field()<br>    rank = scrapy.Field()<br>    subject = scrapy.Field()<br></code></pre></td></tr></table></figure><p>之后我们就可以完成parse方法，进行网页内容的解析。相关代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response: HtmlResponse</span>):<br>    sel = Selector(response)<br>    list_items = sel.css(<span class="hljs-string">&#x27;#content &gt; div &gt; div.article &gt; ol &gt; li&#x27;</span>)<br>    <span class="hljs-keyword">for</span> list_item <span class="hljs-keyword">in</span> list_items:<br>        movie_item = MovieItem()<br>        movie_item[<span class="hljs-string">&#x27;title&#x27;</span>] = list_item.css(<span class="hljs-string">&#x27;span.title::text&#x27;</span>).extract_first()<br>        movie_item[<span class="hljs-string">&#x27;rank&#x27;</span>] = list_item.css(<span class="hljs-string">&#x27;span.rating_num::text&#x27;</span>).extract_first()<br>        movie_item[<span class="hljs-string">&#x27;subject&#x27;</span>] = list_item.css(<span class="hljs-string">&#x27;span.inq::text&#x27;</span>).extract_first()<br><br>        <span class="hljs-keyword">yield</span> movie_item<br><br>    hrefs_list = sel.css(<span class="hljs-string">&quot;div.paginator &gt; a::attr(href)&quot;</span>)<br>    <span class="hljs-keyword">for</span> href <span class="hljs-keyword">in</span> hrefs_list:<br>        url = response.urljoin(href.extract())<br>        <span class="hljs-keyword">yield</span> Request(url=url)<br></code></pre></td></tr></table></figure><p>这里我们首先将<code>HtmlResponse</code>包装成一个选择器，然后通过XPath进行解析，获取到我们需要的内容。有关XPath的具体内容这里不进行赘述，总之我们可以获取到对应的信息，将其赋值给<code>MovieItem</code>对象的对应属性，之后使用<code>yield</code>进行生成。之后我们也可以通过类似的方式获取到该网页中的相关链接，将其包装成<code>Request</code>对象之后，使用<code>yield</code>进行生成。需要注意的是，这里的<code>yield</code>生成的对象包括Item对象以及Request对象，核心引擎接收之后，会分别传递给数据管道以及调度器，然后分别进行不同的处理。调度器会持续接收URL，并判断是否爬取过，再决定是否发送给下载器进行爬取。</p><blockquote><p>不过这里需要注意，调度器判断是否爬取是根据url的名称进行判断的，而不是通过网页内容进行判断的。可能出现不同的url对应的网页内容是相同的，这种情况会重复爬取。</p></blockquote><p>这样，一个简单的爬虫程序就完成了。不过在运行之前，我们还需要调整一些相关配置。整个爬虫程序相关的设置都存放在<code>settings.py</code>文件中，其中定义了许多的常量，包括User-Agent、随机延迟、绕过robots协议、并发请求数量等等，这些都可以直接通过常量的定义来进行调整。</p><p>完成之后，我们就可以启动项目了。在项目目录下执行下面的命令，就可以启动爬虫项目。这个命令表示我们需要启动<code>douban</code>爬虫，也就是对应爬虫程序中的<code>douban.py</code>。<code>-o</code>则表示将爬取的内容持久化到对应的路径中。项目执行会打印一些日志，可以使用<code>--nolog</code>来禁止日志打印。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">scrapy crawl douban -o douban.csv<br></code></pre></td></tr></table></figure><p>Scrapy保存信息的基本格式有四种，分别是<code>json</code>，<code>jsonl</code>，<code>csv</code>和<code>xml</code>。</p><h2 id="pipeline">Pipeline</h2><p>利用数据管道，我们可以将数据存储到更多形式的文件中，例如excel，mysql中，同时可以进行更多的数据处理。数据管道的相关代码都存放在<code>pipelines.py</code>中。初始生成的数据管道中会有一个默认的<code>process_item</code>方法，它不做任何处理直接返回Item对象。当然我们也可以自定义自己的数据管道类，进行定制化的处理。</p><p>除了<code>process_item(self, item, spider)</code>方法，在数据管道中还可以定义其他的方法，包括爬虫开始时执行，爬虫结束时执行的方法等，详情可以在官方文档中进行查询：<ahref="https://docs.scrapy.org/en/latest/topics/item-pipeline.html">ItemPipeline — Scrapy 2.8.0 documentation</a>。</p><p>数据管道的使用配置同样需要在<code>settings.py</code>中进行，对应常量为<code>ITEM_PIPELINES</code>，这是一个字典对象，Key为数据管道的全类名，Value是一个数值，表示管道执行的优先级，数字越小优先级越高，越先执行。</p><h2 id="middleware">Middleware</h2><p>中间件分为下载中间件和爬虫中间件。中间件实质上就是一个拦截器，例如下载中间件就可以在发送Request以及接收Response之前对相应的对象进行一次处理，然后再放行。比如再发送Request之前，给请求加上相关的proxy，cookie信息等。</p><p>中间件的内容存放在<code>middlewares.py</code>中，每个中间件类同样有许多方法，可以达到不同的效果。中间件的配置在<code>settings.py</code>中对应<code>xxx_MIDDLEWARES</code>常量，这同样是一个字典常量，与上面的数据管道配置有相同的约定，Key为全类名，Value为数字。数字越小优先级越高。</p><h2 id="不同页面的爬取">不同页面的爬取</h2><p>在上面的例子中，我们只定义了一种解析的方式。但是一种更加常见的需求是我们通过第一个页面得到了进一步的网页链接之后，需要进入新的链接，提取新的信息，此时需要使用的parse方式是不同的，这种情况下需要利用到callback方法。</p><p>举例来说，我们还想要得到每一部电影的相关信息，则需要进入详情页查看。我们首先可以通过XPath得到链接信息，但是此时并不能将<code>Item</code>对象进行yield，因为这个对象还没有获取到全部的信息。此时我们应该先yield一个新的<code>Request</code>对象，对应的url就是我们得到的新的detail链接。同时由于对于这个链接的解析需要新的方法，所以我们首先需要实现一个方法<code>parse_detail</code>，然后在<code>Request</code>对象的<code>callback</code>属性中指定。最后，为了最后能够将<code>Item</code>对象进行生成，这里还需要将对应的<code>Item</code>对象传入下一步的<code>parse_detail</code>方法中。改进代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response: HtmlResponse</span>):<br>    sel = Selector(response)<br>    list_items = sel.css(<span class="hljs-string">&#x27;#content &gt; div &gt; div.article &gt; ol &gt; li&#x27;</span>)<br>    <span class="hljs-keyword">for</span> list_item <span class="hljs-keyword">in</span> list_items:<br>        detail_url = list_item.css(<span class="hljs-string">&#x27;div.info &gt; div.hd &gt; a::attr(href)&#x27;</span>).extract_first()<br><br>        movie_item = MovieItem()<br>        movie_item[<span class="hljs-string">&#x27;title&#x27;</span>] = list_item.css(<span class="hljs-string">&#x27;span.title::text&#x27;</span>).extract_first()<br>        movie_item[<span class="hljs-string">&#x27;rank&#x27;</span>] = list_item.css(<span class="hljs-string">&#x27;span.rating_num::text&#x27;</span>).extract_first()<br>        movie_item[<span class="hljs-string">&#x27;subject&#x27;</span>] = list_item.css(<span class="hljs-string">&#x27;span.inq::text&#x27;</span>).extract_first()<br><br>        <span class="hljs-keyword">yield</span> Request(url=detail_url, callback=self.parse_detail,<br>                      cb_kwargs=&#123;<span class="hljs-string">&#x27;item&#x27;</span>: movie_item&#125;)<br><br>    hrefs_list = sel.css(<span class="hljs-string">&quot;div.paginator &gt; a::attr(href)&quot;</span>)<br>    <span class="hljs-keyword">for</span> href <span class="hljs-keyword">in</span> hrefs_list:<br>        url = response.urljoin(href.extract())<br>        <span class="hljs-keyword">yield</span> Request(url=url)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_detail</span>(<span class="hljs-params">self, response, **kwargs</span>):<br>    movie_item = kwargs[<span class="hljs-string">&#x27;item&#x27;</span>]<br><br>    sel = Selector(response)<br>    movie_item[<span class="hljs-string">&#x27;duration&#x27;</span>] = sel.css(<span class="hljs-string">&#x27;span[property=v:runtime]::attr(content)&#x27;</span>).extract()<br>    movie_item[<span class="hljs-string">&#x27;intro&#x27;</span>] = sel.css(<span class="hljs-string">&#x27;span[property=v:summary]::text&#x27;</span>).extract_first()<br><br>    <span class="hljs-keyword">yield</span> movie_item<br></code></pre></td></tr></table></figure><p>在第一步的<code>parse</code>方法中，我们先获取到了相关信息和详情链接，yield新的<code>Request</code>对象，这个对象的回调方法是<code>parse_detail</code>，在这个方法中我们进一步获取详情信息，同时yield完整的<code>Item</code>对象。</p><h2 id="爬虫过程中的信号">爬虫过程中的信号</h2><p>在爬虫过程中还会涉及到一些信号的使用。例如我们可能会有这样的需求，就是在爬虫的开始和结束的时候进行一些操作，此时我们可以通过信号以及函数绑定的方式来完成。</p><p>首先我们需要在自定义的爬虫Spider中实现一个<code>from_crawler</code>方法，在其中我们需要先获取到自己的spider，然后利用信号进行函数的方法绑定，这里signals的引入方法为<code>from scrapy import signals</code>。在这里我们绑定了开始行为以及结束行为，分别打印相关的提示信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;Test&quot;</span><br><br>    allowed_domains = []<br>    start_urls = []<br>    start_url = <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">from_crawler</span>(<span class="hljs-params">cls, crawler, *args, **kwargs</span>):<br>        spider = <span class="hljs-built_in">super</span>(TestSpider, cls).from_crawler(crawler, *args, **kwargs)<br>        crawler.signals.connect(spider.open_action, signal=signals.spider_opened)<br>        crawler.signals.connect(spider.close_action, signal=signals.spider_closed)<br>        <span class="hljs-keyword">return</span> spider<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open_action</span>(<span class="hljs-params">self, spider</span>):<br>        spider.logger.info(<span class="hljs-string">&#x27;Spider open: %s&#x27;</span>, spider.name)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close_action</span>(<span class="hljs-params">self, spider</span>):<br>        spider.logger.info(<span class="hljs-string">&#x27;Spider closed: %s&#x27;</span>, spider.name)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response: HtmlResponse</span>):<br>        <span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><p>在Scrapy中还提供了一些其他的信号，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可选信号</span><br>engine_started = <span class="hljs-built_in">object</span>()<br>engine_stopped = <span class="hljs-built_in">object</span>()<br>spider_opened = <span class="hljs-built_in">object</span>()<br>spider_idle = <span class="hljs-built_in">object</span>()<br>spider_closed = <span class="hljs-built_in">object</span>()<br>spider_error = <span class="hljs-built_in">object</span>()<br>request_scheduled = <span class="hljs-built_in">object</span>()<br>request_dropped = <span class="hljs-built_in">object</span>()<br>response_received = <span class="hljs-built_in">object</span>()<br>response_downloaded = <span class="hljs-built_in">object</span>()<br>item_scraped = <span class="hljs-built_in">object</span>()<br>item_dropped = <span class="hljs-built_in">object</span>()<br></code></pre></td></tr></table></figure><h2 id="链接提取器">链接提取器</h2><p>通常爬虫程序应对的都是多网页的爬取，这就要求我们能够从单个网页出发，爬取出多个链接，然后递归进行对应的操作。在上面不同页面的爬取当中，我们可以通过Selector手动从其中抽取出相关的链接，而实际上，Scrapy也提供了相关的链接提取器给我们使用。Scrapy中提供了一个专门用于提取链接的类<code>LinkExtractor</code>，在提取大量链接或者提取规则比较复杂的时候，使用LinkExtractor更加方便。该类的引入为：<code>from scrapy.linkextractors import LinkExtractor</code></p><p>该类的使用非常简单，我们只需要初始化得到一个对象之后，利用它的extract_links方法即可。该方法接收一个Response对象，然后就可以返回其中的存在的链接数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response: HtmlResponse, *args</span>):<br>    link_extractor = LinkExtractor()<br>    links = link_extractor.extract_links(response)<br>    <span class="hljs-built_in">print</span>([link.url <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links])<br></code></pre></td></tr></table></figure><p>如果在初始化<code>LinkExtractor</code>的时候不提供任何参数，则链接抽取的规则使用默认的全部抽取。当然我们还可以定制化一些提取规则，只需要在初始化的时候提供对应参数即可，相关参数如下</p><ul><li><code>allow</code>：该参数接收一个正则表达式或者一个正则表达式列表，提取绝对url与正则表达式匹配的链接。如果参数为空，则提取全部链接</li><li><code>deny</code>：该参数效果与allow正好相反，排除与正则表达式匹配的链接</li><li><code>allow_domains</code>：接收一个域名或一个域名列表，提取到指定域的链接</li><li><code>deny_domains</code>：与allow_domains正好相反，排除到指定域的链接</li><li><code>restrict_xpaths</code>：接收一个XPath表达式或者一个XPath表达式列表，提取XPath选中区域下的链接</li><li><code>restrict_css</code>：接收一个CSS表达式或者CSS表达式列表，提取选中区域中的链接</li><li><code>tags</code>：接收一个标签或者标签列表，提取指定标签内的链接，默认为<code>['a', 'area']</code></li><li><code>attrs</code>：接收一个属性或者属性列表，提取指定属性内的链接，默认为<code>['href']</code></li><li><code>procss_value</code>：接收一个形如<code>func(value)</code>的回调函数。如果传递了该参数，则<code>LinkExtractor</code>会调用这个函数对提取的每个链接进行处理，回调函数需要返回一个字符串为最终的处理结果，如果想要抛弃所处理的链接，则需要返回None</li></ul><h2 id="日志管理">日志管理</h2><p>在Scrapy运行的时候，会打印出非常多的日志信息，Scrapy中也提供了相关方法进行日志的管理。默认情况下，所有的日志都是打印在控制台的，同时默认的日志等级是DEBUG。我们可以在<code>setting.py</code>中修改日志等级，例如<code>LOG_LEVEL = 'ERROR'</code>，同时我们可以在运行命令的时候指定日志的输出位置以及日志等级：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">scrapy crawl spiderName -s LOG_FILE=spider.log -s LOG_LEVEL=ERROR<br></code></pre></td></tr></table></figure><p>Scrapy日志有五种等级，按照范围递增顺序排列如下：</p><ul><li>CRITICAL - 严重错误</li><li>ERROR - 一般错误</li><li>WARNING - 警告信息</li><li>INFO - 一般信息</li><li>DEBUG - 调试信息</li></ul><p>在使用Scrapy的时候，我们也可以在Scrapy中输出日志信息。在每个Spider实例中，都有一个内置的logger，我们可以通过<code>self.logger</code>来获取到日志记录器，然后调用相关方法进行日志输出。使用这个日志记录器输出的日志，将会与Scrapy中的日志放在一起统一管理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.logger.info(<span class="hljs-string">&quot;get url:%s&quot;</span>, response.url)<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://docs.scrapy.org/en/latest/">Scrapy 2.8documentation — Scrapy 2.8.0 documentation</a></li><li><a href="https://www.runoob.com/w3cnote/scrapy-detail.html">Scrapy入门教程 | 菜鸟教程 (runoob.com)</a></li><li><ahref="https://blog.csdn.net/x2584179909/article/details/102502226">优雅的操作scrapy爬虫的开始和结束</a></li><li><ahref="https://blog.csdn.net/qq_45617055/article/details/115149001">爬虫框架Scrapy（8）使用LinkExtractor 提取链接</a></li><li><a href="https://www.cnblogs.com/pythonClub/p/9853078.html">scrapy日志处理 - CrossPython - 博客园 (cnblogs.com)</a></li><li><ahref="https://www.yiibai.com/scrapy/scrapy_logging.html">Scrapy日志 -Scrapy教程 (yiibai.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python watchdog与增量文件监听</title>
    <link href="/2023/04/14/python-watchdog%E4%B8%8E%E5%A2%9E%E9%87%8F%E6%96%87%E4%BB%B6%E7%9B%91%E5%90%AC/"/>
    <url>/2023/04/14/python-watchdog%E4%B8%8E%E5%A2%9E%E9%87%8F%E6%96%87%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="watch-dog">Watch Dog</h1><p>在Python中，我们可以使用watchdog来实现文件监控。下面将介绍watchdog的使用。首先可以使用pip进行安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install watchdog<br></code></pre></td></tr></table></figure><p>watchdog使用观察者模型，主要参与角色有<code>observer</code>，<code>event_handler</code>以及被监听的路径。当被监听的路径出现相关变化之后，就会触发event_handler中定义的方法。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">from</span> watchdog.observers <span class="hljs-keyword">import</span> Observer<br><span class="hljs-keyword">from</span> watchdog.events <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileEventHandler</span>(<span class="hljs-title class_ inherited__">FileSystemEventHandler</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        FileSystemEventHandler.__init__(self)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_moved</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-keyword">if</span> event.is_directory:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;directory moved from &#123;0&#125; to &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(event.src_path, event.dest_path))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;file moved from &#123;0&#125; to &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(event.src_path, event.dest_path))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_created</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-keyword">if</span> event.is_directory:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;directory created:&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(event.src_path))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;file created:&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(event.src_path))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_deleted</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-keyword">if</span> event.is_directory:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;directory deleted:&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(event.src_path))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;file deleted:&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(event.src_path))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_modified</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-keyword">if</span> event.is_directory:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;directory modified:&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(event.src_path))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;file modified:&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(event.src_path))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    observer = Observer()<br>    event_handler = FileEventHandler()<br>    observer.schedule(event_handler, <span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-literal">False</span>)<br>    observer.start()<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-built_in">print</span>(datetime.datetime.now())<br>            time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        observer.stop()<br><br>    observer.join()<br><br></code></pre></td></tr></table></figure><p>在watchdog中，observer实际上是一个守护线程，它并不会阻塞主线程的运行，所以我们这里在主线程中使用循环等待来查看相关效果。使用watchdog，我们主要完成的是继承<code>FileSystemEventHandler</code>类，然后覆盖相关方法，之后利用observer提供的schedule方法进行关联。需要注意的是，这里schedule有三个参数。第一个参数表示对应的事件Handler类；第二个参数表示需要监听的目录（而不是文件）；第三个参数表示是否递归监听。如果仅需要监听某一个文件，则需要在相关触发方法中进行判断。</p><h1 id="增量文件监听">增量文件监听</h1><p>利用watchdog的文件监听功能，我们可以实现一个增量文件的监听功能。在业务场景中，日志文件是非常常见的。日志文件实际上就是一个增量文件，我们可以监听日志文件内容的增加，然后获取到增加的内容，下面我们就实现这个功能。</p><p>首先直接展示完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> watchdog.observers <span class="hljs-keyword">import</span> Observer<br><span class="hljs-keyword">from</span> watchdog.events <span class="hljs-keyword">import</span> FileSystemEventHandler<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileUtil</span>:<br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">increment_read</span>(<span class="hljs-params">begin_index: <span class="hljs-built_in">int</span>, file: <span class="hljs-built_in">str</span></span>):<br>        fd = <span class="hljs-built_in">open</span>(file, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        fd.seek(begin_index, <span class="hljs-number">0</span>)<br>        lines = fd.readlines()<br>        now_index = fd.tell()<br>        fd.close()<br>        <span class="hljs-keyword">return</span> now_index, lines<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">raw_read</span>(<span class="hljs-params">file: <span class="hljs-built_in">str</span></span>):<br>        fd = <span class="hljs-built_in">open</span>(file, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        lines = fd.readlines()<br>        fd.close()<br>        <span class="hljs-keyword">return</span> lines<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileEventHandler</span>(<span class="hljs-title class_ inherited__">FileSystemEventHandler</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, file: <span class="hljs-built_in">str</span></span>):<br>        self.file = file<br>        self.now_index = os.path.getsize(file)<br>        FileSystemEventHandler.__init__(self)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_modified</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> event.is_directory <span class="hljs-keyword">and</span> os.path.basename(self.file) == os.path.basename(event.src_path):<br>            new_index, new_lines = FileUtil.increment_read(self.now_index, self.file)<br>            self.now_index = new_index<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[&#123;0&#125;] new lines: &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(datetime.datetime.now(), new_lines))<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IncrementSpy</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, directory: <span class="hljs-built_in">str</span>, filename: <span class="hljs-built_in">str</span></span>):<br>        self.directory = directory<br>        self.filename = filename<br>        self.file = os.path.join(directory, filename)<br>        self.observer = <span class="hljs-literal">None</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[&#123;0&#125;] origin file content: &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(datetime.datetime.now(), FileUtil.raw_read(self.file)))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self</span>):<br>        self.observer = Observer()<br>        event_handler = FileEventHandler(self.file)<br>        self.observer.schedule(event_handler, self.directory, <span class="hljs-literal">False</span>)<br>        self.observer.start()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.observer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.observer.stop()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    spy = IncrementSpy(<span class="hljs-string">&#x27;./&#x27;</span>, <span class="hljs-string">&#x27;test.txt&#x27;</span>)<br>    spy.execute()<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-built_in">print</span>(datetime.datetime.now())<br>            time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        spy.close()<br><br></code></pre></td></tr></table></figure><p>我们可以准备一个<code>test.txt</code>文件，其中可以填一些初始内容。之后启动程序，同时使用编辑器对test.txt文件进行编辑，当我们完成编辑保存之后，在运行界面中就会出现相关的提示。同时我们在主线程中循环打印时间，目的是为了表现监听线程并不会阻塞主线程的执行。运行效果如下：</p><img src="/2023/04/14/python-watchdog%E4%B8%8E%E5%A2%9E%E9%87%8F%E6%96%87%E4%BB%B6%E7%9B%91%E5%90%AC/%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C.png" class="" title="运行效果"><blockquote><p>注意只能监听增量文件，并不能监听文件内容的修改（指delete/update）</p></blockquote><p>接下来就开始介绍相关功能的实现。</p><p>首先我们实现了一个工具类<code>FileUtil</code>，其中提供两个静态方法，分别是用于读取文件的全部内容<code>raw_read</code>以及从指定index开始读取文件内容的<code>increment_read</code>，第二个增量读取的方法在读取内容的同时还会返回当前文件的index，方便下一次的增量读取。</p><p>之后我们实现watchdog中相关的处理类，即<code>FileEventHandler</code>。它继承<code>FileSystemEventHandler</code>，但是我们只实现了其中的<code>on_modified</code>方法，用于监听文件修改事件。由于我们这里只需要监听对应的文件，所以我们需要在这个方法中进行判断，只有event对应的<code>src_path</code>符合我们的要求时才进行动作。触发的动作就是进行增量读取，同时保存当前的index。</p><p>最后，我们将整个监听操作进行包装，实现<code>IncrementSpy</code>类。在构造方法中，它会首先读取文件的初始内容并进行输出，之后执行<code>execute</code>方法进行监听。在<code>execute</code>方法中，我们完成的主要是Observer对象的创建以及schedule的指定。对于使用者来说，只需要在初始化<code>IncrementSpy</code>类之后调用execute方法即可，就如同在main中的使用方法一样。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://bbs.huaweicloud.com/blogs/325805">python watchdog详细讲解-云社区-华为云 (huaweicloud.com)</a></li><li><ahref="https://cloud.tencent.com/developer/article/1567515?from=article.detail.1567377&amp;areaSource=106000.3&amp;traceId=vpZgjvS-Kfd-xf43exLri">python中文件变化监控-watchd- 腾讯云开发者社区-腾讯云 (tencent.com)</a></li><li><a href="https://www.jianshu.com/p/a89cfaee5e39">python实现增量的读取文件 - 简书 (jianshu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementUI中的分页功能</title>
    <link href="/2023/04/13/ElementUI%E4%B8%AD%E7%9A%84%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD/"/>
    <url>/2023/04/13/ElementUI%E4%B8%AD%E7%9A%84%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="案例介绍">案例介绍</h1><p>为了查看分页组件的效果，我们首先准备一个table。当然后面会提到，分页组件并非是与table绑定使用的，只是举例查看效果而已。这里使用了ElementUI官方文档中的table示例，关键代码如下，同时在<code>table_data</code>中复制了较多数据用于分页展示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-table</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;table_data.slice((currentPage-1)*pageSize, currentPage*pageSize)&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;80%&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Date&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;180&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Name&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;180&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Address&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意这里的关键，我们使用了<code>.slice</code>来获取表格数据的一部分，同时在data中初始化对应的值如下。见名知意，这两个参数分别表示当前页码以及每页的数据量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">currentPage</span>:<span class="hljs-number">1</span>,<br><span class="hljs-attr">pageSize</span>: <span class="hljs-number">5</span>,<br></code></pre></td></tr></table></figure><p>之后我们可以添加分页组件如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-pagination</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-model:current-page</span>=<span class="hljs-string">&quot;currentPage&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:page-size</span>=<span class="hljs-string">&quot;pageSize&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:total</span>=<span class="hljs-string">&quot;table_data.length&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;-&gt;, total, prev, pager, next, jumper&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-pagination</span>&gt;</span><br></code></pre></td></tr></table></figure><p>于是我们就简单地完成了一个分页功能，分页效果如下：</p><img src="/2023/04/13/ElementUI%E4%B8%AD%E7%9A%84%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD/table_view.png" class="" title="table view"><blockquote><p>分页组件并不是和某个其他组件绑定使用的，它完成的是分页关键信息的双向绑定以及相关事件的封装。在我们点击上一页，下一页或者跳转按钮的时候，分页组件会自动修改关键属性如<code>currentPage</code>，而我们只需要在需要的地方使用这个属性即可。例如在案例中，点击按钮改变了currentPage，而在table组件中我们通过currentPage来获取slice的范围，而得益于Vue的数据双向绑定，数据改变之后页面也就进行渲染，从而达到了一个分页切换的效果。</p></blockquote><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://element-plus.gitee.io/zh-CN/component/pagination.html">Pagination分页 | Element Plus (gitee.io)</a></li><li><ahref="https://blog.csdn.net/weixin_46214344/article/details/104051480">使用element-ui实现表格分页_elementui表格分页</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>功能模块</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>elementUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式(4)-访问数据结构与简单化</title>
    <link href="/2023/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%80%E5%8D%95%E5%8C%96/"/>
    <url>/2023/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%80%E5%8D%95%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="vistor">Vistor</h1><h2 id="简介">简介</h2><p>在程序中会有很多数据结构，其中保存了许多元素，我们需要对这些元素进行处理。对于一个类来说，访问其中元素的代码通常是放在表示数据结构的类中。但是如果处理有多种的时候，每增加一种处理，都需要再去修改表示数据结构的类。而在Visitor模式中，数据结构与处理被分离开来。我们通过编写一个表示访问者的类来访问数据结构中的元素，将各个元素的处理交给访问者。这样当需要增加新处理的时候，只需要编写新的访问者，然后让数据结构接受访问者的访问即可。</p><p>在Vistor模式中有如下一些角色：</p><ul><li><code>Vistor</code>：该角色负责对数据结构中的每个具体元素声明一个用于访问某个元素的visit方法，该方法的实现由具体的ConcreteVisitor角色完成</li><li><code>ConcreteVistor</code>：该角色负责实现Visitor角色所定义的接口，实现其中所有的visit方法，确定该如何实现不同的访问</li><li><code>Element</code>：该角色是Visitor角色的访问对象，其中声明了接受访问者的accept方法。该方法接收一个Visitor角色参数</li><li><code>ConcreteElement</code>：该角色负责具体实现Element角色所定义的接口</li><li><code>ObjectStructure</code>：ObjectStructur角色负责处理Element角色的集合，由于ConcreteVisitor角色为每个Element角色都准备了处理方法，因此我们可以轻易地实现Element的遍历访问</li></ul><h2 id="示例程序">示例程序</h2><p>假设我们现在有两个类<code>Book</code>和<code>Movie</code>，分别代表书籍和电影，其中分别有不同的属性，我们现在希望取访问这些属性，但是是通过visitor模式进行。首先定义一个<code>Visitor</code>类，这是一个抽象类，其中声明了对应的访问方法，包括对Book以及Movie的访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Book book)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Movie movie)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们需要定义一个<code>Element</code>接口，这个接口表示能够在Visitor模式中被visitor访问。这个接口中只有一个accept方法，用于接受对应的Visitor对象，完成访问操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们可以完成Book与Movie这两个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String author;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(String name, String author)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.author = author;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAuthor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> author;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Movie</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer year;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Movie</span><span class="hljs-params">(String name, Integer year)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.year = year;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getYear</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> year;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里的Book和Movie都实现了Element接口。由于访问操作在Visitor对象中提供，所以这里的accept的实现都是简单的进行方法调用，然后将自身对象this作为参数进行传入即可。</p><p>接下来，我们就可以定义Visitor具体的子类，在其中完成对对象具体的访问操作。这里子类的名称为<code>ShowVisitor</code>，意为访问操作是用于展示对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShowVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Book book)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;now visit one book named &quot;</span> + book.getName() + <span class="hljs-string">&quot;, whose author is &quot;</span> + book.getAuthor());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Movie movie)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;now visit one movie named &quot;</span> + movie.getName() + <span class="hljs-string">&quot;, released in &quot;</span> + movie.getYear());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，整个Visitor模式的逻辑就已经完成了，可以用如下代码进行测试。在测试代码中，不同的对象通过接收相应的Visitor对象，来进行访问操作。可以看到在这个过程中，数据结构与实际的访问操作进行了分离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;book1&quot;</span>, <span class="hljs-string">&quot;author1&quot;</span>);<br>    <span class="hljs-type">Movie</span> <span class="hljs-variable">movie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Movie</span>(<span class="hljs-string">&quot;movie1&quot;</span>, <span class="hljs-number">2023</span>);<br>    <span class="hljs-type">Visitor</span> <span class="hljs-variable">visitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShowVisitor</span>();<br><br>    book.accept(visitor);<br>    movie.accept(visitor);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="说明">说明</h2><p>Visitor模式的目的是将处理从数据结构中分离出来。数据结构完成的是元素集合等的关联，而保存数据结构和以数据结构为基础进行处理是两种不同的东西，分离之后我们可以更加有条理地完成管理。同时Visitor模式提高了组件的独立性，在增加处理模式的时候我们不需要去修改原先代表数据结构的类，而只需要新增新的Visitor类的实现即可，这样使得功能扩展和修改变得更加有条理，易于管理。关于功能扩展和修改有一个著名的开闭原则。</p><p>开闭原则（The Open-ClosePrinciple，OCP），它的核心观点可以用一句话来概括，就是“对扩展开放，对修改关闭”。</p><p>对扩展开放指的是在设计类的时候，通常需要考虑到将来可能会扩展类。对修改关闭则是说需要能够在不用修改现有类的前提下进行类的扩展。因为如果每次扩展类的时候都需要修改现有代码，这样就太麻烦了。<strong>在不修改现有代码的前提下进行扩展，这就是开闭原则</strong>。</p><p>但是另一方面，由于在Visitor模式中，对数据结构中元素进行处理的任务被交给了Visitor类，这意味着Element角色必须要向Visitor角色公开足够多的信息。访问者只有从数据结构中获取了足够多的信息之后才能工作。在这种意义上，数据结构需要小心地平衡信息的公开以及处理。</p><h1 id="chain-of-responsibility">Chain of Responsibility</h1><h2 id="简介-1">简介</h2><p><code>Chain of Responsibility</code>，含义为责任链。直观地说，就是将多个对象组织成一条责任链，当有需求需要进行处理的时候，就从头开始，依次判断是否能够进行处理。对于责任链上的每一个对象来说，它都是从前面收到需求，如果自己能够处理这个需求，那么就进行处理，如果不能处理，就沿着责任链交给下一个对象进行处理，直到没有下一个对象，则表示无法处理这个需求。使用ChainofResponsibitly模式弱化了请求方和处理方之间的关联关系，让各自都成为可独立复用的组件。同时，使用责任链设计模式的程序，它能够应对的需求时可扩展的，我们可以根据情况的不同增加或者修改负责处理的对象。</p><p>在责任链设计模式中出现了如下角色：</p><ul><li><code>Handler</code>：该角色定义了处理请求的接口，同时持有另一个或者说下一个Handler对象。如果自己无法处理请求，就将请求转给下一对象。向外暴露support方法接口，用于支持问题解决。</li><li><code>ConcreteHandler</code>：该角色实现了Handler角色，是处理请求的具体角色。</li></ul><h2 id="示例程序-1">示例程序</h2><p>在示例程序中，我们将模拟一条责任链的构成和运行。首先我们构造一个表示问题或者说需求的类<code>Trouble</code>，每个问题有一个编号ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trouble</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trouble</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[Trouble &quot;</span> + number + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们定义一个类表示用于解决需求的类<code>Support</code>，这个类是抽象类，其他所有具体的解决需求的类都需要继承该类。在这个抽象类中，有如下几个需要注意的点。首先，每个Support对象内部还会持有一个Support对象，这表示在该对象沿着责任链的下一个对象。之后，我们声明了抽象的resolve方法，它接收一个Trouble对象，这个方法表示该对象应该如何处理对应的Trouble，返回值表示是否成功处理。而Support暴露出来用于支持Trouble处理的方法就是support，这也是整个责任链模式的核心所在。如果当前对象能够处理这个Trouble，就让它进行处理，如果不能，就交给下一个对象进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Support</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Support next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Support</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Support <span class="hljs-title function_">setNext</span><span class="hljs-params">(Support next)</span> &#123; <span class="hljs-comment">// 设置返回值为Support方便后续的链式调用</span><br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(Trouble trouble)</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">done</span><span class="hljs-params">(Trouble trouble)</span> &#123;<br>        System.out.println(trouble + <span class="hljs-string">&quot; is resolved by &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot;.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fail</span><span class="hljs-params">(Trouble trouble)</span> &#123;<br>        System.out.println(trouble + <span class="hljs-string">&quot; cannot be resolved.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">support</span><span class="hljs-params">(Trouble trouble)</span> &#123;<br>        <span class="hljs-keyword">if</span> (resolve(trouble)) &#123;<br>            done(trouble);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.next != <span class="hljs-literal">null</span>) &#123;<br>            next.support(trouble);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fail(trouble);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>之后，我们就可以完成Support的实现类了，不同的实现类处理Trouble的逻辑也不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 什么问题都不能解决</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoSupport</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Support</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NoSupport</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(Trouble trouble)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 只能解决序号小于limit的问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LimitSupport</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Support</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> limit;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LimitSupport</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.limit = limit;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(Trouble trouble)</span> &#123;<br>        <span class="hljs-keyword">return</span> trouble.getNumber() &lt; limit;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 只能解决奇数序号问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OddSupport</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Support</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OddSupport</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(Trouble trouble)</span> &#123;<br>        <span class="hljs-keyword">return</span> trouble.getNumber() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 只能解决特定序号问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialSupport</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Support</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SpecialSupport</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(Trouble trouble)</span> &#123;<br>        <span class="hljs-keyword">return</span> trouble.getNumber() == <span class="hljs-built_in">this</span>.number;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么最后，我们可以完成一段测试代码来查看对应的效果。在测试代码中我们首先定义了多个Support对象，它们的具体类各有不同，能够处理的Trouble也各不相同。之后我们利用setNext的链式调用构造了一条责任链，最后生成了一系列Trouble，模拟解决过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Support</span> <span class="hljs-variable">alice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSupport</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>    <span class="hljs-type">Support</span> <span class="hljs-variable">bob</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LimitSupport</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">100</span>);<br>    <span class="hljs-type">Support</span> <span class="hljs-variable">charlie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpecialSupport</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">429</span>);<br>    <span class="hljs-type">Support</span> <span class="hljs-variable">diana</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LimitSupport</span>(<span class="hljs-string">&quot;Diana&quot;</span>,<span class="hljs-number">200</span>);<br>    <span class="hljs-type">Support</span> <span class="hljs-variable">elmo</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">OddSupport</span>(<span class="hljs-string">&quot;Elmo&quot;</span>);<br>    <span class="hljs-type">Support</span> <span class="hljs-variable">fred</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LimitSupport</span>(<span class="hljs-string">&quot;Fred&quot;</span>, <span class="hljs-number">300</span>);<br><br>    alice.setNext(bob).setNext(charlie).setNext(diana).setNext(elmo).setNext(fred);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i+=<span class="hljs-number">33</span>) &#123;<br>        alice.support(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Trouble</span>(i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终的输出效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Trouble 0] is resolved by [Bob].<br>[Trouble 33] is resolved by [Bob].<br>[Trouble 66] is resolved by [Bob].<br>[Trouble 99] is resolved by [Bob].<br>[Trouble 132] is resolved by [Diana].<br>[Trouble 165] is resolved by [Diana].<br>[Trouble 198] is resolved by [Diana].<br>[Trouble 231] is resolved by [Elmo].<br>[Trouble 264] is resolved by [Fred].<br>[Trouble 297] is resolved by [Elmo].<br>[Trouble 330] cannot be resolved.<br>[Trouble 363] is resolved by [Elmo].<br>[Trouble 396] cannot be resolved.<br>[Trouble 429] is resolved by [Charlie].<br>[Trouble 462] cannot be resolved.<br>[Trouble 495] is resolved by [Elmo].<br></code></pre></td></tr></table></figure><h2 id="说明-1">说明</h2><p>Chain ofResponsibility模式的最大优点就是它弱化了发出请求的角色（Client）和处理请求的角色（ConcreteHandler）之间的关系。Client角色只需要向第一个ConcreteHandler角色发出请求，之后请求会在责任链中进行传播，直到某个ConcreteHandler角色处理了该请求。不过也是因为ChainofResponsibility模式一直在推卸责任，直到找到合适的处理请求的对象，这一方面提高了程序的灵活性，另一方面导致了延迟的处理。这是一个需要权衡的问题。实际上，如果请求和处理者之间的对应关系是能够确定的，而且需要非常快的响应时间，此时不使用Chainof Responsibility模式会更好。</p><h1 id="facade">Facade</h1><h2 id="说明-2">说明</h2><p>在进行复杂程序开发的时候，我们会涉及到许许多多的类，这些类之间相互关联，导致程序结构变得越来越复杂。在使用这些类之前，我们需要格外注意它们之间的关系，这导致在开发时会增加许多复杂度。而Facade模式就能够帮助我们将这种情况进行简单化。Facade源自一个法语单词，意思为建筑物的正面。使用Facade模式，我们可以将互相关联在一起的错综复杂的类整理出高层API，其中Facade角色让系统对外只有一个简单接口，而内部实际类的关系和调用则由Facade角色来完成。Facade模式本质上就是对一个复杂系统进行包装，向外暴露简单的API，对使用者隐藏内部的复杂逻辑。</p><h1 id="mediator">Mediator</h1><h2 id="说明-3">说明</h2><p>在一个复杂程序的运行过程中，一种常见的情况是许多不同的类都需要对某种状态进行维护或者更改，根据不同情况做出不同反应。如果将状态控制的代码分散在各个相关类中，会导致使用和调试变得非常困难，而Mediator模式则可以帮助我们简单化这种情况。Mediator意为仲裁者，它来决定程序中如何进行状态的维护以及后续行为的定义。每个相关类发现状态更新，则报告给仲裁者，由仲裁者来决定如何进行下一步的行为。Mediator模式本质上就是将分散的控制逻辑统一集中在一个类中，便于管理和调试。当其他相关类需要使用到其中的某种逻辑时，就通知仲裁者即可。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Technique</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python日志模块-logging</title>
    <link href="/2023/04/03/Python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97-logging/"/>
    <url>/2023/04/03/Python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97-logging/</url>
    
    <content type="html"><![CDATA[<h1 id="logging">logging</h1><h2 id="相关概念">相关概念</h2><p>首先的概念是日志等级<code>logging level</code>。在logging中有如下几个日志等级，同时每个日志等级对应一个整数：<code>NOTSET=0</code>,<code>DEBUG=10</code>,<code>INFO=20</code>,<code>WARN=30</code>,<code>ERROR=40</code>, and<code>CRITICAL=50</code>。注意这里的NOTSET，严格来说它并不是一个日志等级，它的作用与真实场景有关，实际起作用的日志等级与它的父日志器有关。</p><p>第二个概念是日志格式化器<code>logging formatter</code>，它是用来指定我们日志的记录格式的。在这里我们可以添加程序的上下文信息，包括程序执行时间，所在linenumber，方法名等等，全部可以使用的上下文信息可以参考官方文档：<ahref="https://docs.python.org/3/library/logging.html#logrecord-attributes">python-logging#LogRecordattributes</a>。我们原始的日志信息会经过格式化器formatter形成新的字符串格式。</p><p>第三个概念是日志处理器<code>logging handler</code>，同它的名称一样，这是用来处理我们的日志的。当我们的原始日志信息经过格式化器之后，实际上得到的还是字符串，要如何处理这些字符串，就是handler完成的事情。例如，将日志信息直接打印是一种处理方式，将日志信息持久化到文件中是一种处理方式，甚至我们可以将日志信息发送到其他机器上等等。每个日志处理器都会包含两个重要的属性，一个是日志formatter，用于完成日志的格式化，另一个是logginglevel，代表该handler的日志等级，低于设置日志等级的日志是不会被记录的。在Python中已经提供了一些封装好的handler，例如用于将日志输出到流当中的<code>StreamHandler</code>，以及将日志保存到文件中的<code>FileHandler</code>.</p><p>第四个概念是日志记录器<code>logger</code>，它就是我们用于日志记录的对象，也就是我们在程序中直接使用的对象。如果我们需要在某个地方进行日志记录的话，就调用该对象的相关方法，例如<code>info/debug/error</code>等，用于表示当前这条日志的等级同时进行日志记录。</p><p>每个logger可以用一个字符串进行标识，我们可以使用字符串来获取一个日志记录器。相同的字符串得到的日志记录器也是相同的。同时logger的标识字符串使用<code>.</code>来表示层级关系。表示一个从根日志记录器开始的继承关系。不过需要注意的是，层级关系是无法递归构建出日志记录器的。也就是说，在下面的例子中，如果我们没有<code>a logger</code>的话，<code>a.b logger</code>则表示一个没有层级的日志记录器，它的名称就是<code>a.b</code>。每个日志记录器有三个重要属性，第一个是<code>propagate</code>，表示是否将日志传播到父级logger中，默认为<code>true</code>；第二个是日志等级，同样用于过滤较低等级的日志；第三个是<code>handler</code>日志处理器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.getLogger(<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-comment"># same logger if their name is the same</span><br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">id</span>(logging.getLogger(<span class="hljs-string">&quot;a&quot;</span>)) == <span class="hljs-built_in">id</span>(logging.getLogger(<span class="hljs-string">&quot;a&quot;</span>))<br><br>logging.getLogger(<span class="hljs-string">&quot;a.b&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="使用实践">使用实践</h2><p>虽然我们可以直接使用类似于<code>logging.info("xxx")</code>的方式来输出日志，但是不推荐这样使用。实际上，我们可以事先准备好一个获取日志记录器Logger的py文件，在其中暴露一些方法来统一获取Logger，后面在需要的时候直接进行日志输出即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> logging.handlers <span class="hljs-keyword">import</span> TimedRotatingFileHandler<br><br>FORMATTER = logging.Formatter(<span class="hljs-string">&quot;%(asctime)s %(levelname)s in %(filename)s,%(funcName)s,line%(lineno)s &quot;</span><br>                              <span class="hljs-string">&quot;[%(processName)s-%(process)d-%(threadName)s-%(thread)d][%(name)s] %(message)s&quot;</span>)<br>LOG_FILE = <span class="hljs-string">&quot;my_app.log&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_console_handler</span>():<br>    console_handler = logging.StreamHandler(sys.stdout)<br>    console_handler.setFormatter(FORMATTER)<br>    <span class="hljs-keyword">return</span> console_handler<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_handler</span>(<span class="hljs-params">logging_path=LOG_FILE</span>):<br>    file_handler = TimedRotatingFileHandler(logging_path, when=<span class="hljs-string">&#x27;midnight&#x27;</span>)<br>    file_handler.setFormatter(FORMATTER)<br>    <span class="hljs-keyword">return</span> file_handler<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_logger</span>(<span class="hljs-params">logger_name, logging_level=logging.DEBUG, logging_path=LOG_FILE, propagate=<span class="hljs-literal">True</span></span>):<br>    logger = logging.getLogger(logger_name)<br>    logger.setLevel(logging_level)  <span class="hljs-comment"># better to have too much log than not enough</span><br>    logger.addHandler(get_console_handler())<br>    logger.addHandler(get_file_handler(logging_path))<br>    logger.propagate = propagate<br>    <span class="hljs-keyword">return</span> logger<br><br></code></pre></td></tr></table></figure><p>之后我们就可以在需要使用的地方调用，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mylogger <span class="hljs-keyword">import</span> get_logger<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_logging</span>():<br>    logger = get_logger(<span class="hljs-string">&quot;test-logger&quot;</span>)<br>    logger.info(<span class="hljs-string">&quot;test info&quot;</span>)<br>    logger.debug(<span class="hljs-string">&quot;test debug&quot;</span>)<br>    logger.warning(<span class="hljs-string">&quot;test warning&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test_logging()<br><br></code></pre></td></tr></table></figure><p>于是可以得到如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">2023-04-03 14:52:04,443 INFO in main.py,test_logging,line8 [MainProcess-89912-MainThread-4559111680][test-logger] test info<br>2023-04-03 14:52:04,443 DEBUG in main.py,test_logging,line9 [MainProcess-89912-MainThread-4559111680][test-logger] test debug<br>2023-04-03 14:52:04,443 WARNING in main.py,test_logging,line10 [MainProcess-89912-MainThread-4559111680][test-logger] test warning<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://www.toptal.com/python/in-depth-python-logging">PythonLogging: An In Depth Tutorial</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>logging</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础与相关使用</title>
    <link href="/2023/03/29/Vue%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/03/29/Vue%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="vue">Vue</h1><h2 id="简单介绍">简单介绍</h2><p>Vue是一款用于构建用户界面的JavaScript框架内，基于标准的HTML、CSS和JavaScript构建，同时提供了一套声明式的、组件化的编程模型。相比于传统的前端三件套，Vue框架提供了更为优秀的开发体验，能够帮助开发人员高效地开发用户界面。</p><h2 id="项目创建">项目创建</h2><p>接下来可以创建一个Vue项目。项目创建可以通过npm来完成，在此之前我们需要确保Node.js相关环境已经安装成功。之后运行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm init vue@latest<br></code></pre></td></tr></table></figure><p>这一指令将会安装并执行 create-vue，它是 Vue官方的项目脚手架工具。它会使用vite来进行项目构建。vite是一个轻量级、速度极快的构建工具。执行指令之后，我们将会看到诸如TypeScript和测试支持之类的可选功能提示，之后按照提示进行操作即可。这里需要注意的是，vite在引入组件的时候默认不支持省略<code>.vue</code>，为了配合它，需要在pycharm中设置引入时保留后缀<code>.vue</code>。相关设置可以查看参考文章。下面是一些目录说明：</p><ul><li><code>node_modules</code>：第三方库</li><li><code>public</code>：首页html（index.html）等，一些静态资源可能要放到这个目录下面才可以被访问到</li><li><code>src</code>：源码存储<ul><li><code>assets</code>：项目中的静态资源，css样式表、图片资源等</li><li><code>components</code>：可复用的组件</li><li><code>main.ts</code>：项目的入口文件，整个项目的运行需要先执行<code>main.ts</code></li><li><code>App.vue</code>：项目的根组件</li></ul></li></ul><p>在项目的实际开发过程中，我们是离不开安装外部依赖的，通常我们使用<code>npm install</code>进行。在使用<code>npm install</code>安装模块或插件时，有两种参数会把它们写入到<code>package.json</code> 文件中去，在<code>package.json</code>里面体现出的区别就是，使用<code>--save</code>安装的插件，会被写入到<code>dependencies</code>（需要发布到生产环境）对象里面去，使用<code>--save -dev</code>安装的插件，会被写入到<code>devDependencies</code>（这里的插件只用于开发环境）对象里面去。</p><blockquote><p>一个比较方便的工具，可以在本地模拟服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g live-server<br></code></pre></td></tr></table></figure><p>首先使用npm安装live-server，然后将Vue项目进行打包。项目打包之后会生成一个dist文件夹，在dist文件夹中直接输入live-server，就可以得到作为一个前端的简易服务器。</p></blockquote><h2 id="vue组件">vue组件</h2><h3 id="简介">简介</h3><p>一个Vue项目的起始组件是<code>src</code>目录下的<code>App.vue</code>组件，这也是整个项目的根组件，这个根组件需要在<code>main.ts</code>中进行注册。而一个真实的项目大多都是由一棵嵌套的，可重用的组件树构成的。组件可以理解为是一个自定义标签，其中可以放入对应的内容，同时我们可以在其他地方通过标签引用这个组件，显示相应的内容。Vue项目中的组件统一放在<code>src/components</code>目录下。一个Vue组件通常遵循下面的模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    test data &#123;&#123;count&#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &quot;TestComponent&quot;,<br>  data() &#123;<br>    return &#123;<br>      count: 0<br>    &#125;<br>  &#125;,<br>  methods: &#123;&#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br><br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>在<code>template</code>标签中，定义了该组件的基本内容模板，在<code>script</code>标签中，定义了组件可以使用的一些相关属性和方法，其中基础的有name，data和methods，分别代表组件的名称，组件数据以及组件方法。在data中定义的数据可以在template中使用插值表达式<code>&#123;&#123;&#125;&#125;</code>进行获取，同时这里的数据，如果在data中发生变化，在页面上也会同步发生变化。而在<code>style</code>标签中，则定义了该组件使用的css风格。默认情况下是scoped，代表css仅在这个组件中局部生效。</p><h3 id="组件注册">组件注册</h3><p>定义完成组件之后，如果需要在其他组件中使用，则需要经过一下步骤。首先使用import语法导入需要的组件，之后使用<code>components</code>注册组件，之后就可以以标签形式使用注册的组件了。注意，通过components注册的是私有子组件。如果在声明组件的时候，没有为组件指定name名称，则组件的名称默认是注册时候的名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">components</span>: &#123;<br><span class="hljs-title class_">ComponentA</span>: xxxx<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过在<code>&lt;script setup&gt;</code>的单文件组件中，导入的组件可以直接在模板中使用，无需注册。</p><p>如果想要全局注册，则需要在vue项目的<code>main.ts</code>入口文件中，通过<code>Vue.component()</code>方法来完成，这个方法接收两个参数（名称字符串，对应组件），其中名称字符串就是给组件注册的名字，也就是后面使用的标签名称。</p><h3 id="组件数据传递">组件数据传递</h3><h4 id="父向子传递">父向子传递</h4><p>组件之间的相互使用形成了父子组件的关系，在一些场景中就会涉及到组件之间传值的需求。其中完成数据从父组件传递到子组件的是<code>prop</code>。</p><p>在子组件中指定prop，其中中可以指定字符串数组，也可以指定对象形式（其中包括各自的名称和类型），表示在组件中可以接收到外面的数据。在组件内部的模板中，需要使用插值表达式来将属性值展开<code>&#123;&#123;&#125;&#125;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    outer data: &#123;&#123;data&#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &quot;TestComponent&quot;,<br>  props:[&#x27;data&#x27;]<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>之后父组件可以在调用的时候通过标签进行数据传递：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;test-component data=&quot;app-data&quot;/&gt;<br></code></pre></td></tr></table></figure><p>这里的关键就在于<code>props</code>。<code>props</code>是组件的自定义属性，在封装通用组件的时候，合理地使用props可以极大提高组件的复用性。props属性的值可以直接在插值表达式中使用，同时props是只读的。props可以使用列表，也可以使用一个对象，用于指定默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">props</span>:&#123;<br>    属性<span class="hljs-attr">A</span>:&#123;配置选项&#125;<br>    <span class="hljs-attr">init</span>:&#123;<br>        <span class="hljs-attr">default</span>:<span class="hljs-number">0</span>,<br>        <span class="hljs-attr">type</span>:<span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">require</span>:ture,<span class="hljs-comment">//必填项约束</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于props中相关命名，有如下的说明：HTML 中的 attribute名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的kebab-case(短横线分隔命名)。也就是说在向子组件传递值的时候，需要使用短横线风格。</p><p>从父级prop到子组件中的数据流动是单向的。父级 prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态。这意味着你<strong>不</strong>应该在一个子组件内部改变prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p><h4 id="子向父传递">子向父传递</h4><p>父组件向子组件传值，使用props。子组件向父组件传值，则可以使用自定义命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">//父组件中调用子组件<br>&lt;template&gt;<br>&lt;son @numchange=&#x27;getNewcount&#x27;&gt;&lt;/son&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    data()&#123;<br>        return &#123;count_from_son:0&#125;<br>    &#125;,<br>    method:&#123;<br>        getNewcount(value)&#123;<br>            this.count_from_son = value <br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br><br>//子组件<br>&lt;template&gt;...&lt;/template&gt;<br><br>&lt;script&gt;<br>    data()&#123;<br>        return &#123;count:0&#125;<br>    &#125;,<br>    method:&#123;<br>        add()&#123;<br>            this.count += 1;<br>            //通过$emit()触发自定义事件，参数为自定义事件名和事件传递参数<br>            this.$emit(&#x27;numchange&#x27;,this.count)<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="兄弟传递">兄弟传递</h4><p>兄弟组件之间的数据共享方案：EventBus</p><p>首先定义一个中间方，创建eventBus.js模块，并向外共享一个Vue的实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//中间方：EventBus 文件名：eventbus.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> ‘vue’<br><br><span class="hljs-comment">//向外共享Vue的实例对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br></code></pre></td></tr></table></figure><p>在数据发送方，调用bus.$emit('事件名称'，发送数据)方法触发自定义事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//兄弟组件A：数据发送方</span><br><span class="hljs-keyword">import</span> bus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventbus.js&#x27;</span><br><br><span class="hljs-keyword">export</span> defalut&#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;hello,mybrother&#x27;</span>,<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-title function_">sendMsg</span>(<span class="hljs-params"></span>)&#123;<br>            bus.$emit(<span class="hljs-string">&#x27;share&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在数据接收方，调用<code>bus.$on('事件名称'，事件处理函数)</code>方法注册一个自定义事件（需要在created生命周期中完成。自定义事件不同于组件和prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。也就是说需要完全匹配。这里建议不使用驼峰命名法，而是使用小写+短横线命名法（<strong>kebab-case</strong> ）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> bus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventbus.js&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">msgFromBro</span>:<span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;<br>        bus.$on(<span class="hljs-string">&#x27;share&#x27;</span>, <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">msgFromBro</span> = value<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态组件">动态组件</h3><p>动态组件指的是组件之间的动态切换，动态的显示和隐藏。vue提供了一个内置的<code>&lt;component&gt;</code>组件，专门用来实现动态组件的渲染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button @click=<span class="hljs-string">&quot;conName = &#x27;Left&#x27;&quot;</span>&gt;切换left&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;conName&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这里的<code>&lt;component&gt;</code>是一个占位符，给组件占用位置。其中<code>is</code>指定组件的名称，动态修改is的值，就可以完成组件的动态切换。通常是绑定事件来修改is对应的值。</p><p>默认情况下，组件切换会重新渲染，在每次进行组件切换的时候，隐藏组件会被销毁，显示组件会重新生成。我们可以使用<code>keep-alive</code>防止这种情况。使用keep-alive标签将上面的component包起来，就可以把内部组件缓存而不是销毁。</p><p>keep-alive包含相关的的生命周期函数，组件被缓存（deactivated）以及组件被激活（activated）。keep-alive作为一个标签，也有一些属性：</p><ul><li><code>include</code>：指定缓存哪些属性，多个属性使用逗号分隔。默认不指定表示缓存所有属性</li><li><code>exclude</code>：指定哪些属性不被缓存，用法与include一致，但是不能和上面的include同时使用</li></ul><h2 id="vue指令">vue指令</h2><p>Vue指令是一种以<code>v-</code>开头的特殊语法，下面介绍一些常用的vue指令。</p><p><strong>v-text</strong>：写在标签的属性当中，设置标签的内容，默认写法会替换全部内容（原有的标签的内容被覆盖），可以使用插值表达式<code>&#123;&#123;&#125;&#125;</code>来替换部分内容</p><p><strong>v-html</strong>：设置标签的内嵌innerHTML，如果是普通字符，则和上面的v-text类似；如果是内嵌的html标签格式，那么可以渲染成html对应格式</p><p><strong>v-on</strong>：为元素绑定事件，绑定触发条件以及调用函数，下面是一个示例，其中使用了一个语法糖，将<code>v-on:</code>替换为<code>@</code>，完整的写法为<code>v-on:click='add'</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    count data: &#123;&#123; count &#125;&#125;<br>    &lt;button @click=&quot;add&quot;&gt;add&lt;/button&gt;<br>    &lt;button @click=&quot;print(&#x27;haha&#x27;)&quot;&gt;print&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &quot;TestComponent&quot;,<br>  data() &#123;<br>    return &#123;<br>      count: 0<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    add: function () &#123;<br>      this.count += 1;<br>    &#125;,<br>    print: function (message) &#123;<br>      alert(message)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>v-show</strong>：根据表达式的真假，切换元素的显示和隐藏。这里v-show接收的是一个字符串，里面可以的东西最终都是转化成布尔值，例如可以写<code>'false' 'true' 'data' 'data&lt;1'</code>，也可以写表达式。原理为修改标签的display来操纵样式。并且数据改变，元素同步更新</p><p><strong>v-if</strong>：根据表达式的真假，切换元素的显示和隐藏，效果与v-show类似，但是这个的原理是直接操作DOM树，在审查元素中直接看不到该元素了。建议频繁的切换使用v-show，反之使用v-if。前者的切换消耗更小</p><p><strong>v-bind</strong>：设置元素的属性，多用于动态设置，来绑定元素的attribute。完整使用为在标签中添加<code>v-bind:src="data中的一个key"</code>，语法糖可以将<code>v-bind:</code>替换为<code>:</code>。如果需要动态绑定多个值，则可以使用不带参数的v-bind</p><p><strong>v-for</strong>：根据数据生成列表结构，用于迭代遍历生成多个标签。这个指令通常与数组结合使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ul&gt;<br>    &lt;li v-for=&#x27;item in arr&#x27;&gt;&#123;&#123;con[item-1]&#125;&#125;&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p><strong>v-model</strong>：获取和设置表单元素的值，注意是双向数据绑定，一般与表单元素一起使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input type=&quot;text&quot; @keyup.enter=&#x27;add&#x27; v-model=&#x27;item_add&#x27;&gt;<br># v-model将数据绑定，获取用户输入<br># @keyup.enter=&#x27;add&#x27;表示将此时的数据加入列表当中<br></code></pre></td></tr></table></figure><h2 id="axios">axios</h2><p>axios是一个开源的可以用在浏览器端和NodeJs的异步通信框架，主要作用是实现AJAX异步通信。当然也可以用来存取本地存在的json文件。axios专注于网络请求，以较为简单的方式进行网络请求。下面是axios的基础语法。当然在使用之前，还需要安装axios模块，同时在需要使用的地方进行引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模块安装</span><br>npm install axios --save<br><br><span class="hljs-comment">// 引入</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><br><span class="hljs-comment">// 语法:</span><br><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;请求类型&#x27;</span>,<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;请求的url地址&#x27;</span>,<br>    <span class="hljs-attr">params</span>:&#123;&#125; <span class="hljs-comment">//url中的查询参数(query)</span><br>    <span class="hljs-attr">data</span>:&#123;&#125; <span class="hljs-comment">//请求体参数(post)</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//.then用来指定请求成功后的回调函数</span><br>    <span class="hljs-comment">//形参中的result是请求成功之后的结果，是一个Promise对象</span><br>&#125;) <br><br><span class="hljs-comment">// eg:</span><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://localhost:8080&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason)<br>&#125;)<br><br><span class="hljs-comment">// 请求本地json</span><br><span class="hljs-attr">data</span>:&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">nodes</span>:[]<br>    &#125;<br>&#125;<br><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// 本地json放在public目录下</span><br>        <span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">data</span>: res&#125; = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/json/node.json&#x27;</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> res)&#123;<br>            <span class="hljs-keyword">var</span> url = res[index][<span class="hljs-string">&#x27;image&#x27;</span>];<br>            res[index][<span class="hljs-string">&#x27;image&#x27;</span>] = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets&#x27;</span>+url);<br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">nodes</span> = res;<br>    &#125;<br>&#125;,<br><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">// 生命周期</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get_data</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>调用axios方法得到的返回值是一个Promise对象，其中返回的不只是接口的数据，axios在请求得到数据之后，在这个数据之上进行了一层包装，因此其中还会有一系列其他参数数据。实际我们需要的业务数据放在data属性中。在获取到数据之后，我们可以在回调中进行处理。如果在获取过程中出现了错误，也可以通过catch进行获取并处理。</p><p>在axios的使用过程中，经常会结合async/await使用。async/await是一种基于Promise的解决异步的方案。async是一个加在函数前的修饰符，被async定义的函数会默认返回一个Promise对象resolve的值。因此对async函数可以直接then，返回值就是then方法传入的函数。</p><p>await也是一个修饰符，只能放在async定义的函数内。可以理解为等待。await修饰的如果是Promise对象：可以获取Promise中返回的内容（resolve或reject的参数），且取到值后语句才会往下执行；如果不是Promise对象：把这个非promise的东西当做await表达式的结果。</p><h2 id="路由router">路由router</h2><h3 id="基本使用">基本使用</h3><p>路由router指的是地址与页面之间的对应关系。Vue官方推荐使用<code>vue-router</code>完成路由的使用。官方文档地址为：<ahref="https://router.vuejs.org/zh/#/">Vue Router(vuejs.org)</a>。在使用之前需要安装对应的包，不过通常这一步在创建项目的配置过程中已经选中了。</p><p>要使用vue-router，首先需要配置路由模块。创建<code>src/router/index.ts</code>路由模块，并书写如下的初始化代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">BASE_URL</span>),<br>  <span class="hljs-attr">routes</span>: []<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><p>在这个路由模块中，最重要的是<code>routes</code>列表，这里面定义了所有的映射关系。例如我们可以如下定义。这里的component组件在使用之前需要引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">routes</span>: [<br>    &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/test_1&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">TestPage1</span>&#125;,<br>    &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/test_2&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">TestPage2</span>&#125;<br>]<br></code></pre></td></tr></table></figure><p>定义好路由之后，就可以在代码中使用，分别使用vue-router提供的路由组件进行链接声明和占位符定义：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/test_1&quot;</span>&gt;</span>test_1<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/test_2&quot;</span>&gt;</span>test_2<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了<code>router-link</code>标签之外，也可以通过<code>$router</code>来访问路由实例。因此我们可以调用<code>this.$router.push()</code>来进行路由跳转。这点在实现按钮点击跳转的时候非常常用。这个方法可以接收是一个字符串路径，或者一个描述地址的对象，下面是官方文档中的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> username = <span class="hljs-string">&#x27;eduardo&#x27;</span><br><span class="hljs-comment">// 我们可以手动建立 url，但我们必须自己处理编码</span><br>router.<span class="hljs-title function_">push</span>(<span class="hljs-string">`/user/<span class="hljs-subst">$&#123;username&#125;</span>`</span>) <span class="hljs-comment">// -&gt; /user/eduardo</span><br><span class="hljs-comment">// 同样</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;username&#125;</span>`</span> &#125;) <span class="hljs-comment">// -&gt; /user/eduardo</span><br><span class="hljs-comment">// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; username &#125; &#125;) <span class="hljs-comment">// -&gt; /user/eduardo</span><br><span class="hljs-comment">// `params` 不能与 `path` 一起使用</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; username &#125; &#125;) <span class="hljs-comment">// -&gt; /user</span><br></code></pre></td></tr></table></figure><h3 id="动态路由">动态路由</h3><p>动态路由指的是可以在路由中传入参数，例如<code>/test_3/:id</code>，任何形如<code>/test_3/xxx</code>的路由都会进行匹配，同时我们可以获取这个id参数。我们可以在路由模块中定义动态路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/test_3/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">TestPage3</span>&#125;<br></code></pre></td></tr></table></figure><p>这个参数可以通过<code>$route.params.id</code>获取。同时我们可以通过v-bind来指定router-link中的跳转路径，使其能够动态变化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;/test_3/+count&quot;</span>&gt;</span>test_3<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="views文件夹">views文件夹</h3><p>通过vite创建出的默认项目中会存在一个views目录。这个目录中通常会存放我们已经写好的各种页面，例如login、main等。<code>src/components</code>和<code>src/views</code>中均包含了Vue组件，区别在于views中存放的组件通常是一些已经写好的具体页面，是页面级组件，会被至少一个router使用，而在<code>src/components</code>中存放的是各种公共组件，例如header，sider等。在开发的时候通常建议将可重用的组件放在<code>src/components</code>中，而将能够通过路由访问到的视图组件存放在<code>src/views</code>中。</p><h2 id="插槽slot">插槽Slot</h2><p>Slot，意为插槽。这是vue为组件的封装者提供的能力，允许开发者在封装组件的时候，把不确定的，希望由用户指定的部分定义为插槽。我们可以把插槽认为是组件封装期间，为用户预留的内容的占位符。下面是插槽的基本使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        这是第一个p标签<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>默认内容（自定义内容）<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>// 在使用的时候，自定义内容就会填充到插槽所在的位置<br><span class="hljs-tag">&lt;<span class="hljs-name">my-com</span>&gt;</span>自定义内容<span class="hljs-tag">&lt;/<span class="hljs-name">my-com</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，没有预留插槽的自定义内容会被丢弃。同时在封装组件的时候，可以为预留的slot插槽提供默认内容，如果组件的使用者没有为插槽提供任何默认内容，则后备内容生效。</p><p>如果在封装组件的时候需要预留多个插槽节点，则需要为每一个slot插槽指定更具体的name名称，这种带有具体名称的插槽叫做<strong>具名插槽</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;header&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;footer&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>使用：<br><span class="hljs-tag">&lt;<span class="hljs-name">my-com</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><br>        添加到指定的插槽<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">my-com</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在具名插槽中，有一些规则，没有指定name名称的插槽，会有隐含的名称叫做“defalut”。如果没有指定填充到哪一个插槽，则填充到默认插槽。同时我们可以将<code>v-slot:header</code>简写为<code>#header</code></p><p>在封装组件的过程中，可以为预留的slot插槽绑定props数据，这种带有props数据的slot插槽就叫做作用域插槽</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:info</span>=<span class="hljs-string">&quot;infomation&quot;</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>// 使用<br>// 这里的scope可以接收到上面slot中的内容，包括info和msg。其中scope的名称可以自定义<br><span class="hljs-tag">&lt;<span class="hljs-name">my-com</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span>&#123;&#123;scope.info&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">my-com</span>&gt;</span><br>// 使用对象的解构赋值<br><span class="hljs-tag">&lt;<span class="hljs-name">my-com</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;&#123;info,msg&#125;&quot;</span>&gt;</span>&#123;&#123;info&#125;&#125;&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">my-com</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="状态管理-deprecated">状态管理 [deprecated]</h2><div class="note note-success">            <p>注意，目前在Vue中推荐使用Pinia进行状态管理，vue-x的使用已经过时。Pinia的使用可以参考<ahref="https://evernorif.github.io/2022/07/20/Pinia状态管理/">Pinia状态管理- EverNorif</a></p>          </div><p>在Vue中可以实现组件之间的数据共享，包括父子组件之间传值，兄弟组件之间传值。但是这种数据的传输只适合在小范围内进行，如果范围扩大的话，就会变得非常的繁琐。我们希望能有一种管理更大范围数据状态，同时复杂度较低的机制。Vuex就是这样一种实现<strong>组件全局状态（数据）管理</strong>的机制，可以方便的实现组件之间的数据共享。Vuex有如下优点：</p><ul><li>能够在vuex中集中管理共享的数据，易于开发和后期维护</li><li>能够高效地实现组件之间的数据共享，提高开发效率</li><li>存储在vuex中的数据都是响应式的，能够实时保持数据与页面的同步</li></ul><p>一般来说，只有<strong>组件之间共享的数据</strong>才有必要存储到vuex中。</p><p>Vuex的基本安装只需要使用npm install即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install vuex --save<br></code></pre></td></tr></table></figure><p>安装完成之后，需要导入Vuex包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">import Vues from &#x27;vuex&#x27;<br>Vue.use(Vuex)<br></code></pre></td></tr></table></figure><p>创建store对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>:&#123;<span class="hljs-attr">count</span>:<span class="hljs-number">0</span>&#125; <span class="hljs-comment">//state中存放的就是全局共享的数据</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>将store对象挂载到vue实例中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(app),<br>    router,<br>    store<br>&#125;)<br></code></pre></td></tr></table></figure><p>下面将介绍Vuex中的核心概念</p><p><strong>State</strong>：state提供唯一的公共数据源，所有共享的数据都要统一放到Store的State中进行存储。在组件中访问State数据有如下的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//第一种方式</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.全局数据名称 <br><br><span class="hljs-comment">//第二种方式</span><br><span class="hljs-keyword">import</span> &#123; mapState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span> <span class="hljs-comment">//按需导入mapState函数</span><br><br><span class="hljs-comment">//将全局数据映射为当前组件的计算属性</span><br><span class="hljs-attr">computed</span>: &#123;<br>    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;count&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Mutations</strong>：vuex不允许组件直接修改store中的公有数据，而是利用Mutations来变更store中的数据。虽然通过这种方式虽然操作起来稍微繁琐，但是可以统一监控所有的数据的变化，相当于提供一种统一管理的方法来修改store中的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>:&#123;<span class="hljs-attr">count</span>:<span class="hljs-number">0</span>&#125;, <span class="hljs-comment">//state中存放的就是全局共享的数据</span><br>    <span class="hljs-attr">mutations</span>: &#123;<br>        <span class="hljs-title function_">add</span>(<span class="hljs-params">state</span>)&#123;<br>            state.<span class="hljs-property">count</span>++<br>        &#125;,<br>        <span class="hljs-title function_">addN</span>(<span class="hljs-params">state, step</span>)&#123;<br>            state.<span class="hljs-property">count</span> += step<br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//在组件中触发mutation</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;add&#x27;</span>) <span class="hljs-comment">//第一种方式</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">//带参触发</span><br><br><span class="hljs-comment">//第二种方式</span><br><span class="hljs-keyword">import</span> &#123; mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span> <span class="hljs-comment">//从vuex中按需导入mapMutations函数</span><br><br><span class="hljs-comment">//将需要的mutations函数，映射为当前组件的methods方法</span><br><span class="hljs-attr">methods</span>:&#123;<br>    ...<span class="hljs-title function_">mapMutations</span>([<span class="hljs-string">&#x27;add&#x27;</span>,<span class="hljs-string">&#x27;addN&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Actions</strong>：mutations中不能使用异步函数，触发异步任务需要actions。如果通过异步操作变更数据，必须通过Action，而不能使用Mutation，但是在Action中还是要通过触发Mutation的方法间接变更数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>:&#123;<span class="hljs-attr">count</span>:<span class="hljs-number">0</span>&#125;, <span class="hljs-comment">//state中存放的就是全局共享的数据</span><br>    <span class="hljs-attr">actions</span>: &#123;<br>        <span class="hljs-title function_">addAsync</span>(<span class="hljs-params">context</span>)&#123;<br>            <span class="hljs-built_in">setTimeout</span>((=&gt;&#123;<br>                 context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;add&#x27;</span>)<br>            &#125;))<br>        &#125;,<br>        <span class="hljs-title function_">addNAsync</span>(<span class="hljs-params">context, step</span>)&#123;<br>            <span class="hljs-built_in">setTimeout</span>((=&gt;&#123;<br>                context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;addN&#x27;</span>, step)<br>            &#125;))<br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//在组件中触发actions</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;addAsync&#x27;</span>) <span class="hljs-comment">//第一种方式</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;addNAsync&#x27;</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">//带参触发</span><br><br><span class="hljs-comment">//第二种方式</span><br><span class="hljs-keyword">import</span> &#123; mapActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span> <span class="hljs-comment">//从vuex中按需导入mapActions函数</span><br><br><span class="hljs-comment">//将需要的Actions函数，映射为当前组件的methods方法</span><br><span class="hljs-attr">methods</span>:&#123;<br>    ...<span class="hljs-title function_">mapActions</span>([<span class="hljs-string">&#x27;addAsync&#x27;</span>,<span class="hljs-string">&#x27;addNAsync&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Getters</strong>：getter用于对Store中的数据进行加工处理形成新的数据。getter可以对store中已有的数据进行加工处理之后形成新的数据，类似Vue的计算属性。Store中数据发生改变，getter的数据也会跟着变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>:&#123;<span class="hljs-attr">count</span>:<span class="hljs-number">0</span>&#125;, <span class="hljs-comment">//state中存放的就是全局共享的数据</span><br>    <span class="hljs-attr">getters</span>:&#123;<br>        <span class="hljs-title function_">showNum</span>(<span class="hljs-params">state</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;当前最新的数量是&#x27;</span> + state.<span class="hljs-property">count</span><br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//在组件中使用getters</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>.名称 <span class="hljs-comment">//第一种方式</span><br><br><span class="hljs-comment">//第二种方式</span><br><span class="hljs-keyword">import</span> &#123; mapGetters&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span> <span class="hljs-comment">//从vuex中按需导入mapGetters函数</span><br><br><span class="hljs-comment">//将全局数据映射为当前组件的计算属性</span><br><span class="hljs-attr">computed</span>: &#123;<br>    ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;count&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="监听器">监听器</h2><p>在Vue中数据的改变会实时反应在页面上，数据是双向绑定的。同时在Vue中也可以使用watch监听器来监听某个对象的变化，当对象发生变化时，就会触发对应的行动。例如在下面的例子中，我们为count数据绑定了一个监听器方法，同时可以分别接收这个数据的新值和旧值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-title function_">count</span>(<span class="hljs-params">newCount, oldCount</span>) &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;oldCount: &quot;</span> + oldCount + <span class="hljs-string">&quot;,newCount: &quot;</span> + newCount)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要监听一个对象中的值，则可以使用相应的路径，注意这里的引号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">object</span>: &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-string">&#x27;object.count&#x27;</span>() &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;count change&quot;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过watch监听器默认是浅层的，只有当在被监听的属性赋新值的时候才会触发，而嵌套属性的变化并不会被监听到。例如在上面的例子中，如果我们只监听object的话，该对象中count的变化并不会触发监听器。如果想要做到嵌套属性的监听，则需要深层监听器。不过仍然需要注意的是，如果只是内部嵌套属性变化，而object本身没有变化的话，那么这里的newObject和oldObject是相同的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>  <span class="hljs-attr">object</span>: &#123;<br>    <span class="hljs-title function_">handler</span>(<span class="hljs-params">newObject, oldObject</span>) &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;object change&quot;</span>)<br>    &#125;,<br>    <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>watch相关还有一些知识，例如即使回调，回调触发时机，监听器停止等，更多细节可以参考官方文档。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://cn.vuejs.org/">Vue.js - 渐进式 JavaScript 框架 |Vue.js (vuejs.org)</a></li><li><ahref="https://blog.csdn.net/u010281877/article/details/116491779?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-116491779-blog-121388855.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-116491779-blog-121388855.pc_relevant_aa&amp;utm_relevant_index=1">vite忽略.vue扩展名</a></li><li><ahref="https://blog.csdn.net/u010281877/article/details/116492833">webstorm引入时不要忽略文件扩展名</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript简单入门</title>
    <link href="/2023/03/27/javascript%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <url>/2023/03/27/javascript%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="javascript">JavaScript</h1><h2 id="简述javascript">1. 简述JavaScript</h2><p>JavaScript：是一种弱类型脚本语言，其源码不需要经过编译，而是由浏览器解释运行，用于控制网络的行为</p><ul><li><p>jQuery：一个库，封装了许多方法。优点是简化了DOM操作，缺点是DOM操作太频繁，影响前端性能。在前端看来使用它仅仅是为了兼容IE6，7，8。</p></li><li><p>JavaScript几大框架：Angular、React、Vue、Axios</p></li><li><p>UI框架：</p><ul><li>Ant-Design：阿里巴巴出品，基于React的UI框架</li><li>ElementUI、iview、ice：饿了么出品，基于Vue的UI框架</li><li>Bootstrap：Twitter推出的一个用于前端开发的开源工具包</li><li>AmazeUI：一款HTML5跨屏前端框架</li></ul></li><li><p>JavaScript构建工具：Babel、WebPack</p></li><li><p>微信小程序：方便开发微信小程序UI的框架：WeUI</p></li></ul><p>JavaScript的设计思想：</p><ul><li>借鉴C语言的基本语法</li><li>借鉴Java语言的数据类型和内存管理</li><li>借鉴Scheme语言，将函数提升到“第一等公民”（frist class）的地位</li><li>借鉴Self语言，使用基于原型（prototype）的继承机制</li></ul><h2 id="基本使用及helloworld">2. 基本使用及HelloWorld</h2><ul><li><p>引入JavaScript</p><ul><li><p>可以直接嵌入在html代码中（内部引入）</p><ul><li><p>利用<code>&lt;script&gt;&lt;/script&gt;</code>标签</p></li><li><p>将其同样放在head标签内部</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello,world&quot;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>上代码实现的是弹窗效果</li></ul></li><li><p>可以单独使用一个文件（外部引入）</p><ul><li><p>与CSS类似，也可以单独写一个<code>.js</code>文件，里面是JavaScript的代码</p></li><li><p>然后在html代码中进行引入。引入并不是使用link标签，而还是使用<code>&lt;script&gt;&lt;/script&gt;</code></p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;konjavascript.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js文件路径&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>注意script必须成对出现，不能使用自闭合标签像这个&lt;script.../&gt;</li><li>有一个type属性不需要显式定义，默认是JavaScript</li></ul></li></ul></li><li><p>注释写法：<code>//我是注释</code></p></li></ul><h2 id="浏览器控制台使用">3. 浏览器控制台使用</h2><ul><li>基本语法<ul><li>定义变量：弱类型 变量类型不存在<ul><li>所有都是 <code>var xxx = ...</code></li><li>var可写可不写（弱类型，类比python）</li></ul></li><li>条件控制：<code>if/else/else if</code></li><li>基本语法balabala与c类似</li></ul></li><li>JavaScript代码调试<ul><li>使用浏览器</li><li>浏览器-审查元素-控制台 里面可以写JavaScript代码</li><li>常用console.log()：打印变量</li></ul></li></ul><h2 id="数据类型快速浏览">4. 数据类型快速浏览</h2><p>弱类型指的是在写代码的时候不需要指定类型，但是实际上数据还是有类型的区分</p><p>数据类型（typeof）</p><ul><li><p>number：不区分小数和整数</p><ul><li>特殊的有NaN（not a number，但是类型是number）、Infinity、...</li></ul></li><li><p>string：没有char的概念</p></li><li><p>bool：...</p></li><li><p>...</p></li><li><p>null：空</p></li><li><p>undefined：未定义。例如数组越界的时候不报错但是是undefined</p></li><li><p>一些运算符</p><ul><li>= == ===<ul><li>=：赋值</li><li>==：判断相等（仅需要值相同即可，不需要类型相同）</li><li>===：绝对等于（必须类型和值都相同）<ul><li>坚持使用===来比较</li><li>NaN===NaN：结果为false（NaN与所有东西都不等，包括自己）</li><li>方法：isNaN()</li></ul></li></ul></li></ul></li><li><p>使用规则啥的类似于python</p></li></ul><h2 id="严格检模式strict">5. 严格检模式strict</h2><p>考虑一些问题：</p><ul><li><p>定义变量的时候：var表示自适应，根据定义的位置决定，不加默认是全局变量</p></li><li><p>定义变量的两个关键字<code>var</code>和<code>let</code></p><ul><li>作用域：var是函数作用域，let是块作用域</li><li>使用：let不能在定义之前访问该变量，但是var可以<ul><li>局部变量建议都是用let</li></ul></li></ul></li></ul><p>严格检查模式：<code>'use strict'</code></p><ul><li>将这个字符写到.js文件的第一行</li><li>使用严格检查模式！</li></ul><h2 id="字符串类型详解">6. 字符串类型详解</h2><ul><li><p>字符串：双引号单引号都行</p></li><li><p>转义符：<code>\</code></p></li><li><p>长字符串：飘号（自命名的），可以带换行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">`aksldjkasd</span><br><span class="hljs-string">asdasd</span><br><span class="hljs-string">asdasda</span><br><span class="hljs-string">asdasdasd</span><br><span class="hljs-string">asdasd`</span>;<br></code></pre></td></tr></table></figure></li><li><p>格式字符串：利用<code>$&#123;&#125;</code>嵌入变量（EL表达式？）</p></li><li><p>字符串的每一位可以获取，但是不可变（不可用赋值号来直接改变）</p></li><li><p>一些方法：</p><ul><li><code>.length()</code></li><li><code>.toUpperCase()</code></li><li><code>.toLowerCase()</code></li><li><code>.indexof()</code></li><li><code>.substring()</code></li><li>...</li></ul></li></ul><h2 id="数组类型详解">7. 数组类型详解</h2><p>数组可以包含任意类型的数据。</p><ul><li>长度<code>arr.length</code><ul><li>可以直接给length赋值，这样数组的长度会发生变化，填充元素为empty，使用的时候为未定义</li><li>或者元素丢失</li></ul></li><li>下标索引<code>.indexOf()</code></li><li>截取数组<code>.slice()</code><ul><li>截取数组的一部分，返回一个新数组。类似于substring</li></ul></li><li><code>.push()</code>和<code>.pop()</code></li><li><code>.unshift()</code>和<code>shift</code>:<ul><li>unshift：压入到头部</li><li>shift：弹出头部的第一个元素</li></ul></li><li><code>.sort</code></li><li><code>.reverse</code></li><li><code>.join()</code></li></ul><h2 id="对象类型详解">8. 对象类型详解</h2><p>JavaScript也是面向对象的语言。</p><p>JavaScript中键值对，键是字符串，值可以是任意类型</p><p>定义对象是使用键值对的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">name</span>:xxx，<br>    <span class="hljs-attr">age</span>:xxx,<br>    <span class="hljs-attr">email</span>:xxx,<br>    <span class="hljs-attr">score</span>:xxx<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>JS中对象使用大括号表示<ul><li>用键值对来描述属性，属性之间使用逗号隔开</li><li>对象赋值，直接用=</li><li>使用一个不存在的对象属性，不会报错，而是undefined</li><li>可以动态删减属性<ul><li><code>delete</code></li></ul></li><li>动态添加：直接用=</li><li>判断一个属性是否在对象中<code>in</code><ul><li>包括它父类的属性也会查找</li></ul></li><li>判断一个属性是否是这个对象自身拥有的<code>.hasOwnProperty()</code><ul><li>不去查找父类</li></ul></li></ul></li></ul><h2 id="分支和循环详解">9. 分支和循环详解</h2><p>流程控制：</p><ul><li><p>判断控制</p><ul><li><code>if/else/else if</code></li></ul></li><li><p>循环控制</p><ul><li><p><code>while</code> / <code>do while</code></p></li><li><p><code>for</code></p><ul><li>其中循环变量用let</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;xxx;i++)<br></code></pre></td></tr></table></figure></li><li><p>引入一个<code>foreach</code>循环</p></li><li><p><code>for in</code>循环：与python中的还是有一些区别，需要注意</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> arr)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> y <span class="hljs-keyword">in</span> arr)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第一个循环打印0，1，2</li><li>第二个循环打印3，4，5</li><li><code>for in</code>获取的是下标或者是key</li><li><code>for of</code>获取的是真实值value<ul><li>for of不能用于不可迭代的类型</li></ul></li></ul><h2 id="map和set集合">10. Map和Set集合</h2><p>ES6的新特性</p><p>Map：类似python中的字典</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br></code></pre></td></tr></table></figure><ul><li>可以用二维数组来初始化（小数组存放键值对的关系）</li><li>通过<code>.get(key)</code>方法来获取值value</li><li>通过<code>.set(key,value)</code>来设置值</li><li><code>delete</code></li></ul><p>Set：无需不重复的集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br></code></pre></td></tr></table></figure><ul><li><p>用数组来初始化</p></li><li><p>一些方法：</p><ul><li><code>.add()</code></li><li><code>delete</code></li><li><code>has()</code></li></ul></li><li><p>遍历Map和Set只能使用<code>for of</code></p><ul><li>使用<code>for in</code>没有效果</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>],[<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>],[<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">3</span>]]);<br><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> map)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> set)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数的定义和参数获取">11. 函数的定义和参数获取</h2><ul><li>定义函数一：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> 方法名(参数)<br>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span> xxx<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params">x</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> x&gt;<span class="hljs-number">0</span>?<span class="hljs-attr">x</span>:-x; <span class="hljs-comment">//这个运算符也是存在的</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>不用显式指定返回类型</p></li><li><p>用<code>function</code>表示定义函数</p></li><li><p>如果没有执行return，函数执行也会返回结果，结果是NaN（再次表明JavaScript很随意，很难报错）</p></li><li><p>定义方式二：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> abs = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)&#123;<br>    <span class="hljs-keyword">return</span> x&gt;<span class="hljs-number">0</span>?<span class="hljs-attr">x</span>:-x;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>function(x)&#123;...&#125;</code>是一个匿名函数，但是可以把结果赋值给abs，通过abs就可以调用</p></li><li><p>参数问题：可以传递任意参数，也可以不传递参数</p><ul><li><p>这样的随意性就会带来不好</p></li><li><p>假设参数不存在，如何规避？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params">x</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">typeof</span>(x) !== <span class="hljs-string">&#x27;number&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;Not a Number&#x27;</span>)<br>        &#125;<br>    <span class="hljs-keyword">return</span> x&gt;<span class="hljs-number">0</span>?<span class="hljs-attr">x</span>:-x;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>假设参数存在多个：</p><ul><li><p>使用<code>arguments</code>，这是JavaScript免费赠送的一个关键字</p><ul><li>代表传递进来的所有参数，组织成数组形式</li><li>但是最终生效的x，还是第一个传进来的生效（即<code>arguments[0]</code>）</li></ul></li><li><p>使用<code>rest</code>，可以获取除了第一个参数之外的后面的参数，组织为数组形式</p><ul><li>ES6引入的新特性</li><li>使用的时候，放在最后面<code>...rest</code>，接收多余参数。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params">x,...rest</span>)<br>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于上面的函数，调用<code>abs(1,2,3)</code></li><li>输出结果为：[1,2,3] [2,3]</li></ul></li></ul></li></ul><h2 id="变量的作用域letconst详解">12. 变量的作用域、let、const详解</h2><ul><li><p>var定义变量实际是有作用域的</p><ul><li>在函数体内定义的变量在函数体外不能使用</li><li>（如果一定要在函数体外使用，需要使用‘闭包’相关概念）</li><li>自己有就找自己的，不然往上找</li></ul></li><li><p>自动提升声明，但是不提升赋值？？</p></li><li><p>养成规范：所有的变量定义都放在函数的开头，不要乱</p><ul><li>类似C</li></ul></li><li><p>全局对象，默认所有的全局对象都会绑定在window对象上</p><ul><li>JavaScript的实际上的仅仅一个全局作用域</li></ul></li><li><p>由于所有的全局对象都会绑定到window对象上，多个文件之间就可能会出现命名冲突的情况</p></li><li><p>所以一般会有以下规范，在一个文件中，所有的全局对象都绑定在自己的一个对象上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这是一个.js文件</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> xxx = &#123;&#125;;<span class="hljs-comment">// 定义一个用来绑定其他对象的对象</span><br><br><span class="hljs-comment">//下面定义对象（包括变量和函数）</span><br>xxx.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>xxx.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;<br>xxx.<span class="hljs-property">f</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    ....<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类似于C++中的命名空间</li></ul></li><li><p>局部作用域 let</p><ul><li>ES6引入的新特性</li></ul></li><li><p>举个栗子：<code>for(let i=0;i&lt;100;i++)</code></p></li><li><p>建议使用var</p></li><li><p>常量 <code>const</code>：常量定义的之后不允许修改</p></li></ul><h2 id="方法的定义和调用apply">13. 方法的定义和调用、apply</h2><p>方法：对象里面的函数</p><ul><li>重新提示，JavaScript的对象类似于python中的字典，利用<code>&#123;&#125;</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> student1 = &#123;<br>    <span class="hljs-attr">name</span>:zhangsan;<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>;<br>    <span class="hljs-comment">// 方法</span><br>    run = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;逃离罗翔老师&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>依然存在<code>this</code>关键字，指向调用它的对象</p></li><li><p><code>apply</code>：在JS中可以控制this的指向</p></li><li><p><code>函数名.apply(需要调用这个函数的对象，函数需要的参数[组织成数组的形似])</code></p></li></ul><h2 id="json对象">14. JSON对象</h2><ul><li><p><a href="https://baike.baidu.com/item/JSON">JSON</a>(<ahref="https://baike.baidu.com/item/JavaScript">JavaScript</a> ObjectNotation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 <ahref="https://baike.baidu.com/item/ECMAScript">ECMAScript</a>(欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p></li><li><p>在JavaScript中，一切皆对象</p></li><li><p>任何JS支持的类型都可以使用JSON来表示</p></li><li><p>格式：</p><ul><li>对象使用<code>&#123;&#125;</code></li><li>数组使用<code>[]</code></li><li>键值对使用<code>key:value</code></li></ul></li><li><p>对象转化为json字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(对象)<br></code></pre></td></tr></table></figure></li><li><p>json字符串转化为对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>字符串)<br></code></pre></td></tr></table></figure></li></ul><h2 id="面向对象原型继承">15. 面向对象原型继承</h2><p>JavaScript的面向对象有点区别：</p><p>传统的面向对象：</p><ul><li>类：模板</li><li>对象：实例</li></ul><p>类似继承的原型<code>__proto__</code></p><p>可以通过指定这个参数，来指定某个对象的原型是谁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xiaoming.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Student</span><br></code></pre></td></tr></table></figure><ul><li><p>这种方法可以随意指定，在运行期间也可以修改</p></li><li><p>实际效果就是父类，于是改进成为父类</p></li></ul><h2 id="面向对象class继承">16. 面向对象class继承</h2><ul><li><code>class</code>关键字<ul><li>ES6</li></ul></li></ul><ol type="1"><li><p>定义一个类，属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-title function_">constuctor</span>(<span class="hljs-params">name</span>)&#123; <span class="hljs-comment">//构造器（类似c++构造函数）</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> xiaoming = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;xiaoming&#x27;</span>);<br><span class="hljs-keyword">var</span> xiaohong = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;xiaohong&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>开始正规了起来</li></ul></li><li><p>继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">xiaoxuesheng</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Student</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, grade</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(name);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>    &#125;<br>    <span class="hljs-title function_">xiaoxueshengnohello</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello,woshixiaoxuesheng&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>本质还是修改了原型，就是写法上对后端更加友好</li></ul></li></ol><ul><li>原型链：原型的原型的原型，开始套娃<ul><li>原型一直追溯，最终肯定到oject，而object的原型也是object（点不完）</li></ul></li></ul><h2 id="操作bom对象">17. 操作BOM对象</h2><ul><li>JavaScript诞生是为了能够在浏览器中运行</li></ul><p>DOM：一套操作HTML标签的API</p><p>BOM：一套操作浏览器的API</p><ul><li><p>浏览器对象模型</p></li><li><p>window对象：（最顶层对象）</p><ul><li>window代表浏览器窗口</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(xxx)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">outerHeight</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">outerwidth</span><br>...<br></code></pre></td></tr></table></figure></li><li><p>下面的重要对象都附属于window对象</p></li><li><p>Navigator：封装了浏览器的信息</p><ul><li>navigator</li><li>里面的信息可以人为修改，不建议使用这些属性来判断和编写代码</li></ul></li><li><p>screen：屏幕信息（width，height）</p></li><li><p>location：</p><ul><li>代表当前页面的url信息<ul><li>host：主机</li><li>href：链接</li><li>protocol：协议</li><li>reload()：方法，刷新</li><li>assign(url)：跳转到设定的url</li></ul></li></ul></li><li><p>document：代表当前的页面</p><ul><li>HTML，DOM文档树</li><li>获取具体的文档树结点，达到控制网页行为的目的</li><li>可以获取网页的cookie</li><li>服务器端可以设置cookie：httpOnly</li></ul></li><li><p>history：浏览器的历史记录</p><ul><li>实现了前进，后退操作</li><li>back()、forward()</li></ul></li></ul><p>浏览器网页就是一个DOM树形结构</p><ul><li>更新DOM节点</li><li>遍历DOM节点（得到）</li><li>删除DOM节点</li><li>增加DOM节点</li></ul><p>DOM对象：文档对象模型</p><ul><li>DOM节点，树形结构中的节点</li></ul><p>后面的操作都是要调用document中的方法：</p><ul><li>获取DOM节点<ul><li>在html，css中，获取是通过选择器来实现的，选择器又有基于标签，id和类等等。</li><li>这里也是同样的思想</li><li><code>document.getElementsByTagName()</code></li><li><code>document.getElementById()</code></li><li><code>document.getElementsByClassName()</code><ul><li>这里同样有css中选择器的返回规则</li><li>id选择器返回具体的某一个元素</li><li>标签选择器和类选择器返回元素的列表</li></ul></li><li>获取子节点：<code>.children</code></li><li>...</li></ul></li><li>要想操作就首先需要定位到那个节点</li></ul><p>获取了节点之后才能进行相关的操作。假设已经获得了节点为<code>id1</code>，则可以调用相关的方法。</p><ul><li>操作文本：（利用=赋值）<ul><li><code>.innerText</code>：修改文本的值</li><li><code>.innerHTML</code>：增加html代码，可以增加一些样式（可以解析html文本标签）</li></ul></li><li><code>.style</code>：可以修改风格，其中又有很多属性可以设置<ul><li><code>.color</code></li><li><code>.fontSize</code></li><li><code>.padding</code></li></ul></li></ul><p>删除节点的步骤：（不能自己删除自己）</p><ol type="1"><li>获取父节点</li><li>通过父节点删除自己</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;father&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>        标题一<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;p1&#x27;</span>&gt;</span><br>        p1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;p2&#x27;</span>&gt;</span><br>        p2<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">//下面要删除p1节点</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;p1&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> father = p1.<span class="hljs-property">parentElement</span>;</span><br><span class="language-javascript">    father.<span class="hljs-title function_">removeChild</span>(self)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>father.removeChild()</code>：需要传入的参数是将要删除的那个DOM对象节点</li></ul><p>插入节点：</p><ul><li><code>.appendChild()</code></li><li>传入参数为需要添加的DOM节点<ul><li>可以是新创建的节点，也可以是事先存在的节点</li><li>如果是事先存在的节点，会造成位置的移动而不是复制过来</li></ul></li></ul><p>创建节点：</p><ul><li><code>.createElement()</code></li><li>传入标签的值，例如<code>document.createElement('p')</code>表示创建一个空的p标签</li></ul><h2 id="获得和设置表单的值">18. 获得和设置表单的值</h2><p>表单标签，form。它也是DOM树中的一个节点。</p><ul><li><p>表单的目的是提交信息</p></li><li><p><code>.value</code>：得到输入框的值</p></li><li><p>...多种方法</p></li></ul><h2 id="表单提交验证及前端密码md5加密">19.表单提交验证及前端密码MD5加密</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>= <span class="hljs-string">&#x27;en&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&#x27;UTF-8&#x27;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&#x27;post&#x27;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text&#x27;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;username&#x27;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;passward&#x27;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;passward&#x27;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;button&#x27;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;aaa()&quot;</span>&gt;</span><br>                提交<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>        <br>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-keyword">function</span> <span class="hljs-title function_">aaa</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> uname = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;username&#x27;</span>);</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> pwd = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;passward&#x27;</span>);</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uname.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pwd.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">             </span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://www.liaoxuefeng.com/wiki/1022910821149312">JavaScript教程- 廖雪峰的官方网站 (liaoxuefeng.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html简单入门</title>
    <link href="/2023/03/27/html%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <url>/2023/03/27/html%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="html">HTML</h1><h2 id="初认html">1. 初认HTML</h2><p><strong>一、HTML、CSS、JavaScript简介和分工</strong></p><p>1、什么是HTML（超文本标记语言 Hyper Text Markup Language），HTML是用来描述网页的一种语言。</p><p>2、CSS(层叠样式表 Cascading Style Sheets),用来定义如何显示 HTML元素，语法为：selector {property：value} (选择符 {属性：值})</p><p>3、JavaScript是一种脚本语言，其源代码在发往客户端运行之前不需经过编译，而是将文本格式的字符代码发送给<strong>浏览器</strong>由浏览器解释运行。有一个封装JavaScript的库，JQuery。</p><p>对于一个网页，HTML定义网页的结构，CSS描述网页的样子，JavaScript定义网页的行为，打个比喻，HTML就像一个人的骨骼、器官，而CSS就是人的皮肤，有了这两样也就构成了一个植物人了，加上javascript这个植物人就可以对外界刺激做出反应，可以思考、运动、可以给自己整容化妆（改变CSS）等等，成为一个活生生的人；如果说HTML是肉身、CSS就是皮相、Javascript就是灵魂。没有Javascript,HTML+CSS是植物人，没有Javascript和CSS是个毁容的植物人；如果说HTML是建筑师，CSS就是干装修的，Javascript是魔术师</p><p>HTML：Hyper Text Markup Language（超文本标记语言）</p><ul><li><p>超文本：包括文字、图片、音频、视频、动画等等</p></li><li><p>HTML5+CSS3：目前的主流技术搭配</p></li></ul><p>W3C：World Wide Web Consortium（万维网联盟）</p><ul><li>成立于1994年，Web技术领域最权威和具有影响力的国际中立性技术标准机构</li><li>W3C标准包括<ul><li>结构化标准语言（HTML、XML）</li><li>表现标准语言（CSS）</li><li>行为标准（DOM、ECMAScript）</li></ul></li></ul><p>try一个网页：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br>            Title<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>自闭合标签：如<code>&lt;meta charset="UTF-8"&gt;</code></li><li>开放标签和闭合标签：<code>&lt;body&gt; &lt;/body&gt;</code></li></ul><h2 id="网页基本信息">2. 网页基本信息</h2><ul><li><p>注释：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--这里是注释 --&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>&lt;!DOCTYPR&gt;</code>：告诉浏览器我们要使用什么规范</p></li><li><p><code>&lt;html&gt;&lt;/html&gt;</code>：网页的总标签，所有的网页内容都在其中</p></li><li><p><code>&lt;head&gt;&lt;/head&gt;</code>：</p></li><li><p><code>&lt;body&gt;&lt;/body&gt;</code>:网页的主体</p></li><li><p><code>&lt;title&gt;&lt;/title&gt;</code>:网站的标题</p></li><li><p><code>&lt;meta&gt;</code>：描述性标签，用来描述网站的一些信息</p><ul><li>一般用来做SEO（搜索引擎优化）</li></ul></li></ul><h2 id="网页基本标签">3. 网页基本标签</h2><ul><li><p>标题标签：<code>&lt;h1&gt;&lt;/h1&gt; &lt;h2&gt;&lt;/h2&gt; &lt;h3&gt;&lt;/h3&gt; &lt;h4&gt;&lt;/h4&gt; &lt;h5&gt;&lt;/h5&gt; &lt;h6&gt;&lt;/h6&gt;</code></p><ul><li>分别是一级到六级标签，大小从大到小</li></ul></li><li><p>段落标签：<code>&lt;p&gt;&lt;/p&gt;</code></p></li><li><p>换行标签：<code>&lt;br&gt;</code></p><ul><li>换行和段落之间的间隔不同</li></ul></li><li><p>水平线标签：<code>&lt;hr&gt;</code></p></li><li><p>字体样式标签：</p><ul><li>粗体：<code>&lt;strong&gt;&lt;/strong&gt;</code></li><li>斜体：<code>&lt;em&gt;&lt;/em&gt;</code></li></ul></li><li><p>注释：<code>&lt;!--注释--&gt;</code></p></li><li><p>特殊符号：<code>&amp;xxx;</code></p><ul><li>&amp;开头 ;结尾</li><li>空格：<code>&amp;nbsp;</code></li><li>版权符号：<code>&amp;copy;</code></li></ul></li></ul><h2 id="图像标签">4. 图像标签</h2><p>常见的图像格式有：jpg、gif、png、bmp...</p><ul><li><p>嵌入图像：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图像地址&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;图像的替代文字（图片加载失败的时候会显示）&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;鼠标悬停提示文字&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;图像宽度&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;图像高度&quot;</span> <span class="hljs-attr">...</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>必选项有src和alt</li><li>高和宽设置不是截取，而是压缩或者拉伸</li></ul></li></ul><h2 id="超链接标签及应用">5. 超链接标签及应用</h2><ul><li><p>页面间链接：页面之间的跳转</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;path链接路径&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;目标窗口位置&quot;</span> <span class="hljs-attr">...</span>&gt;</span>链接文本或图像<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>必选项有href</li><li>链接文本或图像指的是提示信息<ul><li>文本直接填写文本即可</li><li>图像需要用上面的img标签进行嵌套</li></ul></li><li>target表示在什么位置打开新的窗口<ul><li><code>_self</code>：默认选项，在当前页面打开</li><li><code>_blank</code>：在新页面打开</li><li><code>_parent</code>：</li><li><code>_top</code>：</li></ul></li></ul></li><li><p>锚链接：指定地址之间的跳转</p><ul><li>首先需要一个锚标记，然后才可以跳转到标记</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;标记名&quot;</span>&gt;</span>标记在网页中的提示<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#标记名&quot;</span>&gt;</span>点击跳转的提示文字或者图片<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span>顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#top&quot;</span>&gt;</span>点击跳转回到顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>可以和上面的网页间链接一起使用</p><ul><li>在后面加上#标记，表示去到新页面的指定位置</li></ul></li></ul></li><li><p>功能性链接</p><ul><li><p>邮箱链接<code>mailto</code></p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:1320346985@qq.com&quot;</span>&gt;</span>点击联系我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></p></li></ul></li></ul><h2 id="块元素和行内元素">6. 块元素和行内元素</h2><ul><li>块元素<ul><li>无论内容多少，该元素独占一行。新起换行。</li><li>如<code>&lt;p&gt;,&lt;h1&gt;,...</code></li></ul></li><li>行内元素<ul><li>内容是可以撑开宽度的，左右都是行内元素的可以排在一行。新起不换行。</li><li>如<code>&lt;a&gt;,&lt;strong&gt;,&lt;em&gt;,...</code></li></ul></li></ul><h2 id="列表标签">7. 列表标签</h2><ul><li><p>无序列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第一个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第二个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>有序列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第一个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第二个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>自定义列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>自定义名称1<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>自定义选项1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>自定义选项2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>自定义选项3<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="表格标签">8. 表格标签</h2><ul><li><p><code>&lt;table&gt;&lt;/table&gt;</code>：生成表格</p></li><li><p><code>&lt;tr&gt;&lt;/tr&gt;</code>：生成一行</p></li><li><p><code>&lt;td&gt;&lt;/td&gt;</code>：生成一列</p></li><li><p>生成的表格是有边框分隔的，只是默认没有显示出来</p><ul><li>在table标签中增加属性<code>border=""</code><ul><li>1px：指定边框的宽度</li></ul></li></ul></li><li><p>实现跨列，在td标签上操作<code>colspan="xxx"</code></p><ul><li><code>&lt;td colspan="2"&gt;&lt;/td&gt;</code>，这样该列就会占两列的长度</li></ul></li><li><p>实现跨行，也是在td标签上操作<code>rowspan="xxx"</code></p><ul><li><code>&lt;td rowspan="2"&gt;&lt;/td&gt;</code>，这样该行的该列就有两行的高度</li></ul></li></ul><h2 id="媒体元素">9. 媒体元素</h2><ul><li><p>视频元素 video</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;视频路径&quot;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>必选项为src</p></li><li><p>controls表示显示控制选项，如播放暂停，进度条等等</p></li><li><p>autoplay：自动播放</p></li></ul></li><li><p>音频元素 audio</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;音频路径&quot;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>相关操作与视频元素的添加类似</li></ul></li></ul><h2 id="页面结构分析">10 .页面结构分析</h2><p>页面结构，元素和描述。</p><p>这些是规范，利于源代码的查看和分析，并不会强制改变位置，只是用来标记相应的位置。</p><ul><li><p>header：标记头部区域的内容（用于页面或页面中的一块区域）</p></li><li><p>footer：标记脚部区域的内容（用于整个页面或页面的一块区域）</p></li><li><p>section：Web页面中的一块独立区域</p></li><li><p>article：独立的完整内容</p></li><li><p>aside：相关内容或应用（常用于侧边栏）</p></li><li><p>nav：导航类辅助内容</p></li></ul><h2 id="iframe内联框架">11. iframe内联框架</h2><p>在一个网页中嵌套另一个网页。（套娃）</p><ul><li>b站分享视频，嵌入代码尝试</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;链接网站&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;标记名&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>必选项为src</li><li>src可以为空，即src=""，这样可以利用name的标记名，结合a跳转来在对应地方生成内容<ul><li>内联对象</li></ul></li></ul><h2 id="初始表单post和get提交">12. 初始表单post和get提交</h2><p>表单提交，如应用在登录等操作的信息提交部分。</p><p>举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://www.baidu.com&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>帐号: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>密码: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>action：表单提交的位置，可以是网站，也可以是一个请求处理地址</li><li>method：提交方法 有post和get提交方式，还有dialog<ul><li>GET：点击提交之后，会跳转到第一个action中的网站<ul><li>但是此时会在url中显示帐号和密码信息，不安全但是高效</li></ul></li><li>POST：点击提交之后，在url中不会显示帐号和密码信息，但是同样可以在其他地方抓到相关信息<ul><li>检查 - network - 找到请求 - header - 表单数据</li><li>这里面有请求的帐号密码数据</li><li>可以利用其他的后台加密技术来实现在这一阶段的加密</li></ul></li></ul></li></ul><h2 id="文本框和单选框">13. 文本框和单选框</h2><p>表单元素格式 input标签：</p><ul><li>type：指定元素的类型<ul><li>有text、password、checkbox、radio（单选框）、submit、reset、file、hidden、image和button等</li><li>默认为text</li></ul></li><li>name：指定表单元素的名称</li><li>value：元素的初始值。type为radio的时候必须指定一个初始值</li><li>size：指定表单元素的初始长度。<ul><li>当type为text或passeard的时候，表单元素的大小以字符为单位，对于其他类型，宽度以像素为单位</li></ul></li><li>maxlength：type为text或password的时候，输入的最大字符</li><li>checked：type为radio或checkbox的时候，指定按钮是否选中，表示是否默认选中</li></ul><p>单选框分组概念，value是对应的选项值，而name表示组的概念：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;boy&quot;</span>&gt;</span> 男<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;girl&quot;</span>&gt;</span> 女<br><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;boy&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span> 男<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;girl&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span> 女<br></code></pre></td></tr></table></figure><ul><li>如果没有指定name的话，那么此时可以同时选中男女</li><li>value可以理解为是在后台中的提交信息中的值，而外面的男女是提示信息，类似注释的意思</li><li>value就是单选框或者多选框的值(在后台获取的时候的value)</li></ul><h2 id="按钮和多选框">14. 按钮和多选框</h2><ul><li>多选框</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sing&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span> 唱<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dance&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span> 跳<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;rap&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span> rap<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;baskerball&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span> 篮球<br></code></pre></td></tr></table></figure><ul><li><p>同样有利用name实现的分组概念</p></li><li><p>获取的值会提交为数组的形式</p></li><li><p>按钮</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;btn1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;我是按钮&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图片路径&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>按钮中value的值为显示在按钮上的文字提示<ul><li>于是也可以在submit和reset中利用value来修改默认值</li></ul></li><li>type为image形式的时候，也是按钮的功能，并且起到的是submit的作用</li></ul><h2 id="列表框-文本域和文件域">15. 列表框 文本域和文件域</h2><ul><li>列表框（下拉框）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Kon轻音少女&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mio&quot;</span>&gt;</span>澪<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lv&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>律<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yoi&quot;</span>&gt;</span>唯<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mugi&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zimiao&quot;</span>&gt;</span>梓<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>name表示列表的后台名称</p></li><li><p>下拉框中的可选项用option</p></li><li><p>select表示初始选择哪一个，都没有selected就是第一个</p></li><li><p>文本域：即多行文本</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;reply&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>可以指定初始行列的大小，但是在网页中是可以拖动的</p></li><li><p>文件域：用来上传文件等等</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;files&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>还只是选择文件，真正提交需要利用前面的submit</li></ul><h2 id="搜索框滑块和简单验证">16. 搜索框滑块和简单验证</h2><p>目前的表单，即使没有任何信息也能够提交，现在需要对提交信息作初步的验证。</p><p>举例一些简单地带验证功能的input：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">邮箱验证：<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><br>url验证：<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span><br>数字验证：<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;num&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>但是验证是初级验证，比较简单的验证。</p></li><li><p>如果不满足要求是无法提交的</p></li><li><p>滑块：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>搜索框：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;search&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;search&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="表单的应用">17. 表单的应用</h2><ul><li><p>增加属性 <code>readonly</code></p></li><li><p>禁用 <code>disabled</code></p></li><li><p>隐藏 <code>hidden</code></p><ul><li>隐藏了但是仍旧存在</li></ul></li><li><p>增强鼠标的可用性</p><ul><li><p>目前的文字只是提示用语，点击文字并不会有任何的作用</p></li><li><p>希望能够实现文字和输入框的绑定</p></li><li><p>利用label，一个label可以绑定一个id</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mark&quot;</span>&gt;</span>你点我光标就到id=mark的输入框中去<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mark&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>也可以直接用label将提示文字和input输入框包在一起，这样不需要for也能实现对应功能</li></ul></li></ul><h2 id="表单初级验证">18. 表单初级验证</h2><ul><li><code>placeholder</code>：提示信息<ul><li>举例：请输入用户名。提示信息在没有输入之前都会存在，即使光标点击了没输仍然存在</li><li>注意与默认值的区别</li></ul></li><li><code>required</code>：表示该区域的值必须要填写，不能为空</li><li><code>pattern</code>：正则表达式判断<ul><li>pattern="正则表达式的内容"</li><li>需要满足正则表达式才能够提交</li></ul></li></ul><p>这些只是初级验证，高级的验证更加复杂，需要利用JavaScript</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css简单入门</title>
    <link href="/2023/03/27/css%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <url>/2023/03/27/css%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="css基础">CSS基础</h1><h2 id="简介">简介</h2><p>css：层叠样式表</p><ul><li><p>可以在html中内嵌CSS代码实现格式</p><ul><li>首先不建议这么做，更优方法是前后端分离</li><li>利用标签<code>&lt;style&gt;&lt;/style&gt;</code>，在标签的范围内书写CSS代码</li><li>style标签放在head标签里面</li></ul></li><li><p>将html与CSS分离</p><ul><li><p>CSS文件同样是如上面的<code>&lt;style&gt;&lt;/style&gt;</code>标签中的内容</p><ul><li>但是在单独的文件中无需再次使用style标签</li></ul></li><li><p>将其单独写进一个<code>.css</code>文件中</p></li><li><p>然后需要将其链接到html文件中来</p><ul><li>在html文件中<code>head</code>标签中引入</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./koncss.css&quot;</span>&gt;</span>、<br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;需要引入的css文件的位置&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>此时在浏览器中可以点击看到css文件</li><li>建议使用html和css分离的方式</li></ul></li><li><p>css中的注释是使用<code>/*注释*/</code></p></li></ul><p>CSS的优势：</p><ol type="1"><li>内容和表现分离</li><li>网页结构表现统一，可以实现复用</li><li>样式十分丰富</li><li>建议使用独立于html的css文件</li><li>利于SEO，容易被搜索引擎收录</li></ol><h2 id="导入方式">导入方式</h2><ul><li><p>内部样式表：css代码嵌套在html中</p></li><li><p>外部样式表：css与html分离</p></li><li><p>行内样式：在html的标签中利用style</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>多种样式生效规则：覆盖原则，外部样式表的按照link引入的位置顺序</p><ul><li>从上到下按顺序执行，每次执行覆盖执行效果</li></ul></li><li><p>扩展：外部样式的两种写法</p><ul><li><p>链接式：link</p></li><li><p>导入式：（CSS2.1）</p></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;需要导入的css的路径&quot;</span>)</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>弊端：顺序是先展示结构，在渲染效果。在网络卡顿或者网站庞大的时候这种先后效果会更加明显</li><li>不推荐，还是建议使用链接式link</li></ul><h2 id="三种基本选择器">三种基本选择器</h2><p>选择器的作用是选择页面上的某一个或者某一类元素。</p><p>基本选择器：</p><ol type="1"><li><p>标签选择器</p><ul><li>会选择到页面中所有的相应标签<ul><li>选择器格式为<code>标签名（如h1）</code></li></ul></li><li>选择所有有时候也是弊端</li></ul></li><li><p>类选择器（class）</p><ul><li><p>首先在标签中可以添加class属性，class属性可以任意命名（应该有意义）</p></li><li><p>然后通过class来选择</p><ul><li>选择器格式为<code>.类名（.class）</code></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ctitle&quot;</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>.ctitle<br>&#123;<br>    color:red;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以多个标签归类</li></ul></li><li><p>id选择器</p><ul><li>与类选择器类似，需要在标签中定义id，id也可以任意命名，然后通过id来选择<ul><li>选择器格式为<code>#id</code></li></ul></li><li>id必须保证全局唯一（是规范）<ul><li>如果有相同的id，还是能够使用</li></ul></li></ul></li></ol><p>优先级：id选择器&gt;class选择器&gt;标签选择器</p><ul><li>多个选择器共用一个格式，就让选择器之间使用逗号<code>,</code>隔开</li></ul><p>这些是最基本的选择器，还有更加高级的选择器。</p><ul><li><p>id选择器选择到的是唯一确定的一个元素。</p></li><li><p>类选择器和标签选择器返回的是元素的列表。如果只有一个元素也将会组织成列表的形式。</p></li></ul><h2 id="层次选择器">层次选择器</h2><p>网页的结构是天然的一种树形结构。层次选择器适应这种树形结构。</p><ol type="1"><li><p>后代选择器</p><ul><li><p>在某个元素的后面的所有元素（树形结构的后代关系）</p></li><li><p>使用方法：当前标签 后代标签(中间有一个空格)</p></li><li><p>eg：<code>body p&#123;color:#xxxxxx&#125;</code></p></li></ul></li><li><p>子选择器</p><ul><li>在某个元素的后一代元素</li><li>使用方法：当前标签&gt;后代标签</li></ul></li><li><p>相邻兄弟选择器（弟弟选择器，对下不对上，且只有一个）</p><ul><li>这需要选中许多标签中的一个元素，应该会使用到类选择器</li><li>使用方法：当前元素+后代元素</li></ul></li><li><p>通用选择器</p><ul><li>通用兄弟选择器，同样是对下不对上，但是选择所有（所有弟弟选择器）</li><li>使用方法：当前元素~后代元素</li></ul></li></ol><h2 id="结构伪类选择器">结构伪类选择器</h2><p>选择器选择到了某类元素之后，再加条件进行限定（增加条件来进行更加精准地定位）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">ul li:first-child<br>ul li:last-child<br></code></pre></td></tr></table></figure><ul><li><code>当前元素:first-child</code>：当前元素的第一个子元素</li><li><code>当前元素:last-child</code>：当前元素的最后一个子元素</li><li><code>当前元素:nth-child(x)</code>：找到当前元素的父级元素，再找到父级元素的第x个子元素（无视标签类型），如果这个第x个子元素是与当前元素同标签，就选中生效。否则不生效。</li><li><code>当前元素:nth-of-type(x)</code>：选择父元素中第二个类型与当前元素相同的子元素。（与上相似，找子元素的时候考虑标签类型）</li></ul><p>理解伪类：增加的条件限定（比如找到第几个元素，或者在某些情况下生效，像鼠标悬停，选中之类的）</p><h2 id="属性选择">属性选择</h2><p>功能更加强大，可以使用正则表达式进行匹配操作。</p><p>选择器格式：<code>属性[条件表达式]&#123;声明&#125;</code></p><ul><li>条件表达式中，可以使用正则表达式<ul><li>举例说明：</li><li><code>[attr="val"]</code>：选择attr属性等于val的元素</li><li><code>[attr]</code>：选择拥有attr属性的元素</li><li><code>[attr~="val"]</code>：选择attr属性包含val（单词）的元素</li><li><code>[attr$="val"]</code>：选择attr属性以val结尾的元素</li><li><code>[attr^="val"]</code>：选择attr属性以val开头的元素</li><li><code>[attr*="val"]</code>：选择attr属性任意位置包含val（字符）的元素</li><li><code>[attr|="val"]</code>：选择attr属性的值开头为val（单词）或为val-（单词）的元素</li><li><code>[attr*="val" I(或者i)]</code>：表示val不区分大小写（i正则）</li><li>...</li></ul></li></ul><h2 id="盒子模型及边框使用">盒子模型及边框使用</h2><ul><li><p>盒子模型：就是一个类似于盒子的东西</p><ul><li>margin：外边距</li><li>padding：内边距</li><li>border：边框</li></ul></li><li><p>很多元素有默认盒子的边距，例如body，h等等</p><ul><li>可以利用一系列初始化动作将其还原</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">h1,ul,li,a,body&#123;<br>    margin:0;<br>    padding:0;<br>    text-decoration:none;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>盒子模型的参数可以直接指定，也可以分开上下左右来指定（上右下左）</li><li>边框：border<ul><li>border:粗细，边框样式，颜色</li></ul></li><li>外边距：margin<ul><li>外边距妙用：实现元素居中<ul><li><code>margin:0 auto</code></li><li>居中有要求，外元素是一个有宽度的盒子</li></ul></li></ul></li><li>内边距：padding</li><li>盒子元素：来确定整个元素的大小<ul><li>margin+border+padding+内容宽度</li></ul></li></ul><h2 id="display和浮动">display和浮动</h2><ul><li>块级元素：独占一行<ul><li><code>h1~h6 p div 列表...</code></li></ul></li><li>行内元素：不独占一行<ul><li><code>span a img strong ...</code></li></ul></li></ul><p>行内元素可以包含在块级元素中，但是反之不可以。</p><ul><li>display：有很多属性，可以修改元素的块级元素或者行内元素等，可以打破上面的规则<ul><li>重要属性值：<ul><li>block：块元素</li><li>inline：行内元素</li><li>inline-block：即使块元素又是行内元素（是块元素，但是可以写在一行）</li><li>none：消失（但是在源码中是有的）</li></ul></li><li>是一种简单的行内元素的排列方式，但是在很多情况下使用的是float</li></ul></li></ul><p>浮动：元素浮动效果</p><ul><li><code>float</code></li><li>浮动的时候会边框塌陷，改变页面大小会造成排版失败等</li></ul><h2 id="overflow及父级边框塌陷问题">overflow及父级边框塌陷问题</h2><ul><li><code>clear</code>：对浮动的效果加以一些限制<ul><li>right：清除右侧浮动（右侧不允许有浮动元素）</li><li>left：清除左侧浮动</li><li>both：两侧均不允许浮动</li><li>none：不clear</li></ul></li></ul><p>父级边框塌陷问题解决：</p><ul><li>增加父级元素的高度</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#father</span>&#123;<br>    <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> <span class="hljs-number">#000</span> solid;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">800px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在漂浮块后面增加一个空的div标签并清除浮动</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span> class=&quot;xxx&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br><br><span class="hljs-selector-class">.clear</span>&#123;<br>    <span class="hljs-attribute">clear</span>:both;<br>    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>overflow：可以完成的效果是，在块元素设定了宽高的时候，内容如何显示的问题</p><ul><li>在默认情况下，会展现出所有内容，且内容可以超出边框</li><li>使用overflow：<ul><li>hidden：隐藏超出部分</li><li>scroll：形成滚动条的形式</li></ul></li></ul></li><li><p>在父类中添加一个伪类：after</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#father</span><span class="hljs-selector-pseudo">:after</span>&#123;<br>    <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">display</span>:block;<br>    <span class="hljs-attribute">clear</span>:both;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>与增加空div标签的原理类似，只不过不用在html代码中增加空div，可以直接利用伪类完成</li></ul><p>小结：</p><ol type="1"><li>设置父元素高度<ul><li>简单，但是父元素有了固定的高度，会被限制</li></ul></li><li>浮动元素后面增加空div<ul><li>简单，但是代码中加入空的div不太好</li></ul></li><li>overflow<ul><li>简单，但是在一些下拉，内容不能清除的地方不建议使用（因为丑）</li></ul></li><li>在父类增加伪类<ul><li>简单，推荐使用</li></ul></li></ol><ul><li><p>对比</p><ul><li><p>display：方向不可控</p></li><li><p>float：方向可控，但是会增加父级边框塌陷的问题</p></li></ul></li></ul><h2 id="绝对定位和固定定位">绝对定位和固定定位</h2><p>绝对定位：基于xxx定位的情况，给定上下左右</p><ul><li><p>不在标准文档流中，原来的位置不会被保留</p></li><li><p>在父级元素没有定位的情况下，相对于浏览器定位</p><ul><li>这种情况一般会使用后面的fixed</li></ul></li><li><p>如果父级元素有定位（即指定了position属性），相对于父级元素定位</p><ul><li>更过情况是这个</li></ul></li><li><p><code>postion:absolute</code></p></li><li><p>需要上下左右来确定元素如何偏移</p><ul><li>top bottom left right</li></ul></li></ul><p>固定定位：</p><ul><li><p>直接定死，定死在画面中。也并非是相对于浏览器，而相对于屏幕画面（可以这样理解）</p></li><li><p><code>postion:fixed</code></p></li><li><p>需要上下左右来确定元素如何偏移</p><ul><li>top bottom left right</li></ul></li></ul><h2 id="z-index以及透明度">z-index以及透明度</h2><p>类似于图层概念。</p><p><code>z-index</code>来指定层级（0最小，往上递增）</p><ul><li>堆叠了才有图层的概念</li></ul><p>透明操作：</p><ul><li>直接指定透明：透明度<code>opacity</code></li><li><code>filter</code>实现：<code>filter:alpha(透明度)</code><ul><li>早期版本使用，历史了不建议使用</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask中异常的统一管理</title>
    <link href="/2023/03/25/Flask%E4%B8%AD%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86/"/>
    <url>/2023/03/25/Flask%E4%B8%AD%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="异常统一管理">异常统一管理</h1><h2 id="自定义异常">自定义异常</h2><p>Flask默认的返回的异常是html格式的页面，但是为了更好地支持json相关信息的返回，我们需要重写异常类的返回。在Flask中，异常类统一继承了<code>werkzeug.exceptions</code>中的<code>HTTPException</code>异常类，因此我们也需要重写一个类来继承它。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> request, json<br><span class="hljs-keyword">from</span> werkzeug.exceptions <span class="hljs-keyword">import</span> HTTPException<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">APIException</span>(<span class="hljs-title class_ inherited__">HTTPException</span>):<br>    code = <span class="hljs-number">500</span><br>    description = <span class="hljs-string">&#x27;one unknown exception happened in backend.&#x27;</span><br>    error_code = <span class="hljs-number">999</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, description=<span class="hljs-literal">None</span>, code=<span class="hljs-literal">None</span>, error_code=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> code:<br>            self.code = code<br>        <span class="hljs-keyword">if</span> error_code:<br>            self.error_code = error_code<br>        <span class="hljs-keyword">if</span> description:<br>            self.description = description<br>        <span class="hljs-built_in">super</span>(APIException, self).__init__(description, <span class="hljs-literal">None</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_body</span>(<span class="hljs-params">self, environ=<span class="hljs-literal">None</span>, scope=<span class="hljs-literal">None</span></span>):<br>        body = <span class="hljs-built_in">dict</span>(<br>            description=self.description,<br>            error_code=self.error_code,<br>            request=request.method + <span class="hljs-string">&#x27; &#x27;</span> + self.get_url_no_param()<br>        )<br>        text = json.dumps(body)<br>        <span class="hljs-keyword">return</span> text<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_headers</span>(<span class="hljs-params">self, environ=<span class="hljs-literal">None</span>, scope=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">return</span> [(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>)]<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_url_no_param</span>():<br>        full_path = <span class="hljs-built_in">str</span>(request.full_path)<br>        main_path = full_path.split(<span class="hljs-string">&#x27;?&#x27;</span>)<br>        <span class="hljs-keyword">return</span> main_path[<span class="hljs-number">0</span>]<br><br></code></pre></td></tr></table></figure><p>这里我们完成了一个<code>APIException</code>类，其中主要重写了<code>get_headers</code>以及<code>get_body</code>，默认的headers是html，body是对应的网页内容，而我们的需求是headers是支持json，body是对应的json内容。同时在这个类中我们引入了code以及error_code，其中error_code是我们自定义的标识。完成自定义内容的保存之后，将其中的description传递给父类。</p><p><code>APIException</code>是接下来我们所有自定义异常的统一父类，我们可以实现各个具体的异常类，如下所示，只需要更新其中的属性即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoSuchIDException</span>(<span class="hljs-title class_ inherited__">APIException</span>):<br>    code = <span class="hljs-number">400</span><br>    description = <span class="hljs-string">&#x27;no such id&#x27;</span><br>    error_code = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>引入了对应的异常，则可以在对应的地方进行raise，按照正常的使用逻辑即可。</p><h2 id="异常处理">异常处理</h2><p>完成了自定义异常的定义之后，我们需要向整个系统进行异常处理的注册，用于全局的异常捕获。这个方法需要在app初始化之后执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># handle all exception</span><br><span class="hljs-meta">@app.errorhandler(<span class="hljs-params">Exception</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">framework_exception</span>(<span class="hljs-params">exception</span>):<br>    logging.exception(exception)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(exception, HTTPException):<br>        <span class="hljs-keyword">return</span> exception<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> APIException()<br></code></pre></td></tr></table></figure><p>这个方法将异常分为两个部分，一个是HTTPException，其中就包括我们自定义的异常，对于这部分异常我们可以直接返回。另一个是非HTTPException，对于这类异常，我们将其包装成统一的一个默认异常，使用的是我们在APIException中的默认实现。同时为了后端异常的定位，这里可以使用<code>logging.exception</code>来打印异常的堆栈信息。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://flask.palletsprojects.com/en/2.0.x/errorhandling/">HandlingApplication Errors — Flask Documentation (2.0.x)(palletsprojects.com)</a></li><li><a href="https://www.cnblogs.com/se7enjean/p/12955417.html">flask重写HTTPException类并自定义异常信息 - 吹神 - 博客园(cnblogs.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式(3)-分开考虑与一致性</title>
    <link href="/2023/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E5%88%86%E5%BC%80%E8%80%83%E8%99%91%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2023/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E5%88%86%E5%BC%80%E8%80%83%E8%99%91%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="bridge">Bridge</h1><h2 id="简介">简介</h2><p>Birdge模式的功能是完成类的功能层次结构和实现层次结构的连接。在介绍之前，我们首先需要分别介绍什么是类的功能层次结构，什么是类的实现层次结构。</p><p>对于一个类来说，我们可能想要基于它新增一些功能，这样实际上就构成了类的功能层次结构。在父类中具有基本功能，在子类中增加新的功能。例如我们可以得到如下的功能层次结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">Something<br>+- SomethingGood<br>+- SomethingBetter<br></code></pre></td></tr></table></figure><p>另一方面，对于抽象类来说，子类需要对其中的抽象方法进行实现。此时也会形成一种层次结果，实际上就是类的实现层次结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">AbstractClass<br>  +- ConcreteClass<br>  +- AnotherConcreteClass<br></code></pre></td></tr></table></figure><p>由于这两种层次结构的存在，我们在编写子类的时候，首先应该确认自己的意图，是需要新增功能还是需要新增实现。当类的层次结构只有一层的时候，功能结构层次与实现结构层次混杂在一起，这样很容易使得类的层次结构变得复杂，也难以透彻理解类的层次结构。而Bridge模式就是用于这两种层次结构的分离。</p><h2 id="示例程序">示例程序</h2><p>考虑我们现在有一个顶级的抽象类Display，它的核心方法是display，它需要达到的效果是按照顺序分别调用三个抽象方法，分别是open、print和close。一方面，由于Display是抽象类，因此我们还需要有具体的实现StringDisplay。另一方面，我们会需要拓展Display的功能，让它能够提供循环输出的能力，因此会有一个CountDisplay来进行功能扩展。</p><p>如果不使用Bridge模式，我们可能会得到如下的程序。首先定义顶级抽象类<code>Display</code>，其中分别声明三个方法open、print和close，同时实现核心方法display。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>&#123;<br>        open();<br>        print();<br>        close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后，完成具体的实现<code>StringDisplay</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">private</span> String string;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StringDisplay</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">this</span>.string = string;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;string display open&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;&lt; &quot;</span> + string + <span class="hljs-string">&quot; &gt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;string display close&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后基于这个实现，我们可以进一步使用继承来扩展Display的功能，即完成<code>CountDisplay</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StringDisplay</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDisplay</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">super</span>(string);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">multiDisplay</span><span class="hljs-params">(<span class="hljs-type">int</span> times)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; times; i++) &#123;<br>            print();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然上面这种实现的确能够达到效果，但是从类的层次结构来看，却可能存在一些问题。我们可以看到它们的继承关系如下：</p><img src="/2023/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E5%88%86%E5%BC%80%E8%80%83%E8%99%91%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/no-bridge.png" class="" title="no-bridge"><p>对于抽象类Display来说，它的实现层次结构里包含了StringDisplay，实现的确是基于Display的。可是对于它的功能层次结构，CountDisplay却是基于了StringDisplay，这就导致了类的实现结构层次与功能结构层次没有分离。在相关逻辑较为简单的时候，可能还能够管理，如果逻辑更加复杂，那么理解起来就会比较混乱了。</p><p>那么下面我们来看看Bridge模式如何达到实现结构层次和功能结构层次的分离。</p><p>首先同样需要定义顶级类<code>Display</code>。但是与上面不同的是，Display本身并不是一个抽象类，但是它持有一个抽象类<code>DisplayImpl</code>。其中对应的方法则是调用这个抽象类的相关方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">private</span> DisplayImpl displayImpl;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Display</span><span class="hljs-params">(DisplayImpl displayImpl)</span> &#123;<br>        <span class="hljs-built_in">this</span>.displayImpl = displayImpl;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.displayImpl.rawOpen();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.displayImpl.rawPrint();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.displayImpl.rawClose();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        open();<br>        print();<br>        close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从名字上来看，<code>DisplayImpl</code>应该是Display的实现类，但是这里它是一个抽象类，它代表的逻辑含义是所有的Display的实现类都应该来实现DisplayImpl，或者说该类可以理解为Display的抽象实现类，当然可能有点拗口。不过就是这个抽象的DisplayImpl，实现了类功能层次结构与实现层次结构的分离，同时起到birdge的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisplayImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rawOpen</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rawPrint</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rawClose</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，对于真正的实现<code>StringDisplay</code>，它需要继承的是<code>DisplayImpl</code>，并实现其中相关的抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DisplayImpl</span> &#123;<br>    <span class="hljs-keyword">private</span> String string;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StringDisplay</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">this</span>.string = string;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rawOpen</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;string display open&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rawPrint</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;&lt; &quot;</span> + string + <span class="hljs-string">&quot; &gt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rawClose</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;string display close&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而对于功能扩展<code>CountDisplay</code>，它继承的则是<code>Display</code>，然后完成对应的功能扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Display</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDisplay</span><span class="hljs-params">(DisplayImpl displayImpl)</span> &#123;<br>        <span class="hljs-built_in">super</span>(displayImpl);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">multiDisplay</span><span class="hljs-params">(<span class="hljs-type">int</span> times)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; times; i++) &#123;<br>            print();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后就可以完成测试代码了。在使用Display的时候，我们还需要传入对应的实现类，表示当前的Display需要使用那一个DisplayImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Display</span> <span class="hljs-variable">display1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Display</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplay</span>(<span class="hljs-string">&quot;Hello string display&quot;</span>));<br>    <span class="hljs-type">Display</span> <span class="hljs-variable">display2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDisplay</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplay</span>(<span class="hljs-string">&quot;Hello Count Display&quot;</span>));<br>    <span class="hljs-type">CountDisplay</span> <span class="hljs-variable">display3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDisplay</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplay</span>(<span class="hljs-string">&quot;Hello Count Display&quot;</span>));<br><br>    display1.display();<br>    display2.display();<br>    display3.display();<br>    display3.multiDisplay(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对比之前没有使用Bridge的实现，Bridge模式完成了类功能结构层次与实现结构层次的分离，就像示例代码中类之间的继承关系一样。</p><img src="/2023/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E5%88%86%E5%BC%80%E8%80%83%E8%99%91%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/bridge.png" class="" title="bridge"><h2 id="说明">说明</h2><p>从上面的示例代码中我们可以看到，Bridge模式的核心就在于DisplayImpl的引入。顶级类Display并不是自己去定义抽象方法，而是委托DisplayImpl去完成这项工作。相比于继承，委托是更加弱的关联关系。因为只有当对应的实例生成并赋值给委托对象之后，才会建立关联，因此很容易地改变当前需要使用的实现类。</p><p>而利用Bridge模式，我们实现了“类的功能层次结构”与“类的实现层次结构”分离，分离之后更加有利于独立地对它们进行扩展。当想要增加功能的时候，只需要在功能层次结构一侧增加类即可，而不必对实现层次结构做任何修改。而功能的扩展不再是基于某个特定的实现类了，而是所有的实现类都可以使用，只需要在初始化的时候传入对应的实现类就行。</p><h1 id="strategy">Strategy</h1><p>无论什么程序，它的目的都是用来解决问题的，在程序中我们通过编写特定的算法来实现问题的解决。Strategy指的就是这个算法，或者称为解决问题的策略。利用Strategy模式，可以实现整体地替换算法的实现部分。整体替换算法，使得我们能够轻松地以不同的方法去解决同一个问题，这就是Strategy模式。</p><p>在Strategy模式中，关键点在于确定Strategy接口。在这个接口中会声明抽象策略方法所需要的参数类型以及返回值类型，其他相关的实现类则可以实现对应的方法。而在使用的时候，则直接使用接口方法即可，而接口具体对应的是哪一个实现类，则进行简单替换即可。由于Strategy模式代码的逻辑结构相对简单，这里就不给出代码示例了。</p><p>Strategy模式将程序中的算法与其他部分分离开来，只定义了与算法相关的接口，然后在程序中以委托的方式来实现算法。使用这种弱关联关系可以很方便地整体替换算法，并且借助委托，算法的替换特别是动态替换成为了可能。</p><h1 id="composite">Composite</h1><h2 id="简介-1">简介</h2><p>在计算机中有目录的概念，而在目录中可以存放文件，也可以存放目录。我们可以将目录理解为一种容器，在容器中又可以存放文件或者目录。在这种层面上来说，目录形成了一种容器结构，同时这种容器具有递归结构。文件和目录都可以被存放在目录中，从这个角度来看，文件和目录被统称为目录条目DirectoryEntry，在目录条目中，文件夹和文件被当作是同一种对象，即它们具有一致性。</p><p>如果扩大视角，从容器层面来看，则表达的意思是在容器中既可以放入内容，也可以放入小容器，而在小容器中同样可以继续放入内容或者容器，形成递归结构的容器。Composite的意思是混合物，复合物。Composite模式能够完成的就是创建出这种递归结构的容器，在其中容器和内容具有一致性。</p><p>在Composite中主要三类角色：</p><ul><li><code>Content</code>：表示内容的角色。在该角色中不能放入其他对象</li><li><code>Composite</code>：表示容器的角色，在其中可以放入Content角色或者Composite角色</li><li><code>Component</code>：该角色用于统一Content和Composite角色，使这两个角色具有一致性。通常来说Component角色是Content和Composite角色的父类</li></ul><h2 id="示例程序-1">示例程序</h2><p>下面我们使用一个示例程序来表示上面目录的层级结构。首先可以完成目录和文件的统一抽象父类<code>Entry</code>。实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> Entry <span class="hljs-title function_">add</span><span class="hljs-params">(Entry entry)</span> <span class="hljs-keyword">throws</span> FileTreatmentException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileTreatmentException</span>(<span class="hljs-string">&quot;you can&#x27;t add content into it&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(String prefix)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">()</span> &#123;<br>        printList(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getName() + <span class="hljs-string">&quot;(&quot;</span> + getSize() + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中首先声明了两个抽象方法，分别用于获取名称以及大小，然后定义了一个add添加方法，用于向目录中增加新的元素。这个方法有默认实现，默认为抛出异常，这也就意味着只有重写了add方法的子类才能正常调用add添加方法。然后完成了输出方法，用于按照路径格式输出目录或者文件的路径。这里默认抛出的异常<code>FileTreatmentException</code>简单继承了<code>RuntimeException</code>。</p><p>之后可以分别实现Entry的子类，文件<code>File</code>以及目录<code>Directory</code>。下面是文件类<code>File</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">private</span> String filename;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String filename, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filename = filename;<br>        <span class="hljs-built_in">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> filename;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(String prefix)</span> &#123;<br>        System.out.println(prefix + <span class="hljs-string">&quot;/&quot;</span> + filename);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在文件类中，只需要在类中保存文件名称以及大小，然后简单实现对应的方法即可。而目录类则相对复杂一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">private</span> String directoryName;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Entry&gt; directory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Directory</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.directoryName = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> directoryName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Entry entry : directory) &#123;<br>            size += entry.getSize();<br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(String prefix)</span> &#123;<br>        System.out.println(prefix + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">for</span> (Entry entry : directory) &#123;<br>            entry.printList(prefix + <span class="hljs-string">&quot;/&quot;</span> + directoryName);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Entry <span class="hljs-title function_">add</span><span class="hljs-params">(Entry entry)</span> <span class="hljs-keyword">throws</span> FileTreatmentException &#123;<br>        directory.add(entry);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在目录类中需要定义目录名称，同时需要定义一个容器来存放Entry对象。但是并不需要定义大小，因为目录的大小实际上是根据其中保存的Entry对象容器计算出来的。在目录类中需要实现add方法，其中的实现就是向容器中添加传入的Entry对象。这里的printList方法实现，也是遍历容器然后进行输出。由于这里的Entry可能是File也可能是Directory，所以在输出的时候会有递归的效果。</p><h2 id="说明-1">说明</h2><p>在日常编程中，有很多地方都存在递归结构，而利用Composite模式就可以完成容器和内容的统一，在使用的时候则会更加方便。</p><h1 id="decorator">Decorator</h1><h2 id="简介-2">简介</h2><p>Decorator意为装饰者模式。假设程序中的对象具有基本的功能，而利用装饰者模式，我们就可以不断地为其增加功能，同时不会掩盖初始的功能API，这就是装饰者模式。</p><p>在装饰者模式中，主要有如下角色：</p><ul><li><code>Component</code>：指的是被增加功能的核心角色。一般是抽象类，其中声明了核心功能API</li><li><code>ConcreteComponent</code>：指的是实现了Component的具体角色，具有基本的功能</li><li><code>Decorator</code>：指的是装饰者角色，该角色与Component角色具有相同的接口，保证功能API不被覆盖。同时该角色内部还保存一个Component对象，作为被装饰的对象</li><li><code>ConcretDecorator</code>：指的是具体的装饰者，需要实现Decorator</li></ul><p>装饰者模式的结构示意图如下：</p><img src="/2023/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E5%88%86%E5%BC%80%E8%80%83%E8%99%91%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/Decorator.png" class="" title="Decorator"><h2 id="示例程序-2">示例程序</h2><p>下面我们就利用装饰者模式来完成一个示例程序，这个程序的功能是给文字字符串添加装饰边框。</p><p>首先我们完成一个抽象类<code>Display</code>，这个抽象类可以显示多行字符串，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getColumns</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRows</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getRowText</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; getRows(); i++) &#123;<br>            System.out.println(getRowText(i));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Display抽象类中有三个抽象方法，分别用于获取需要打印的字符串的行数和列数，以及根据给定的行数row来获取对应行的信息。之后利用这些抽象方法来完成show方法，用于字符串的显示。单独看这个抽象类可能不容易理解，那么下面我们就通过继承这个抽象类，完成一个实现子类<code>StringDisplay</code>。这个子类可以打印一行字符串，具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String string;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StringDisplay</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">this</span>.string = string;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getColumns</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> string.length();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRows</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRowText</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> string;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是getRowText方法只能接收row=0的情况，其他情况都会返回null。至此，基本的功能实现类已经有了，就是StringDisplay，下面我们需要对其进行装饰，完成功能的扩展。而在这里，功能的扩展指的就是给字符串添加显示边框。</p><p>首先我们需要完成一个<code>Border</code>类，它是后续相关装饰功能类的统一父类。需要注意的是，Border类是Display的子类，同时自身也还是一个抽象类。通过继承，装饰边框与被装饰物具有了相同的方法。而在这个Border类中，又持有了一个Display对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Border</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">protected</span> Display display;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Border</span><span class="hljs-params">(Display display)</span> &#123;<br>        <span class="hljs-built_in">this</span>.display = display;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么接下来就可以来实现Border类的子类了，这里分别实现了<code>SideBorder</code>类和<code>FullBorder</code>类。SideBorder类可以使用指定的字符来装饰字符串的左右两侧，而FullBorder类则使用固定的边框来框住字符串的上下左右，它们的实现分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SideBorder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Border</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> borderChar;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SideBorder</span><span class="hljs-params">(Display display, <span class="hljs-type">char</span> borderChar)</span> &#123;<br>        <span class="hljs-built_in">super</span>(display);<br>        <span class="hljs-built_in">this</span>.borderChar = borderChar;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getColumns</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + display.getColumns() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRows</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> display.getRows();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRowText</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span> &#123;<br>        <span class="hljs-keyword">return</span> borderChar + display.getRowText(row) + borderChar;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FullBorder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Border</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FullBorder</span><span class="hljs-params">(Display display)</span> &#123;<br>        <span class="hljs-built_in">super</span>(display);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getColumns</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + display.getColumns() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRows</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + display.getRows() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRowText</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span> || row == getRows() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;+&quot;</span> + makeLine(<span class="hljs-string">&#x27;-&#x27;</span>, display.getColumns()) + <span class="hljs-string">&quot;+&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;|&quot;</span> + display.getRowText(row - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;|&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">makeLine</span><span class="hljs-params">(<span class="hljs-type">char</span> ch, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            stringBuilder.append(ch);<br>        &#125;<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就可以完成测试代码了，尤其需要体会下面display4对象的构造过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Display</span> <span class="hljs-variable">display1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplay</span>(<span class="hljs-string">&quot;Hello,world&quot;</span>);<br>    <span class="hljs-type">Display</span> <span class="hljs-variable">display2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SideBorder</span>(display1, <span class="hljs-string">&#x27;#&#x27;</span>);<br>    <span class="hljs-type">Display</span> <span class="hljs-variable">display3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FullBorder</span>(display2);<br>    <span class="hljs-type">Display</span> <span class="hljs-variable">display4</span> <span class="hljs-operator">=</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SideBorder</span>(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">FullBorder</span>(<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FullBorder</span>(<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SideBorder</span>(<br>                                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FullBorder</span>(<br>                                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplay</span>(<span class="hljs-string">&quot;Hello,world&quot;</span>)<br>                                            ),<span class="hljs-string">&#x27;*&#x27;</span>))),<span class="hljs-string">&#x27;/&#x27;</span>);<br>    display1.show();<br>    display2.show();<br>    display3.show();<br>    display4.show();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">Hello,world<br><span class="hljs-comment">#Hello,world#</span><br>+-------------+<br>|<span class="hljs-comment">#Hello,world#|</span><br>+-------------+<br>/+-----------------+/<br>/|+---------------+|/<br>/||*+-----------+*||/<br>/||*|Hello,world|*||/<br>/||*+-----------+*||/<br>/|+---------------+|/<br>/+-----------------+/<br></code></pre></td></tr></table></figure><h2 id="说明-2">说明</h2><p>在Decorator模式中，装饰者与被装饰者具有一致性。它们的接口都是统一的，这是因为装饰者抽象类继承了被装饰者抽象类，保证了接口的统一，同时装饰者通过持有被装饰者，来完成功能的扩展。这样即使被装饰者进行了多次的装饰，原始核心的功能API也不会被隐藏起来。得益于API的透明性，Decorator模式中也形成了类似于Composite模式中的递归结构。换句话说，装饰边框里面的“被装饰物”实际上又是别的物体的“装饰边框”。</p><p>Decorator模式主要用于功能的增加，通过该模式，我们可以实现不修改被装饰的类即可增加功能。它使用委托，使得类之间形成弱关联关系。但是Decorator模式本身还是有一定的缺点，就是会导致在程序中增加许多功能类似但是很小的类。实际上，在<code>java.io</code>包中，有很多用于IO的类就是使用了装饰者模式。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Technique</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark学习笔记-SparkSQL(2)-DataFrame相关API的使用</title>
    <link href="/2023/03/19/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkSQL-2-DataFrame%E7%9B%B8%E5%85%B3API%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/03/19/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkSQL-2-DataFrame%E7%9B%B8%E5%85%B3API%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="dataframe">DataFrame</h1><p>在SparkSQL中，DataFrame就类似于一张关系型数据库表。我们可以通过相关API来对DataFrame进行操作，就相当于是在数据库中对表进行操作。完整的操作API可以参考官方文档：<ahref="https://spark.apache.org/docs/latest/api/scala/org/apache/spark/sql/Dataset.html">ScalaDoc-DataSet</a>。可以看到这里的文档实际上是属于DataSet的，DataFrame可以看作是DataSet的一个特例，即<code>DataFrame = DataSet[Row]</code>。</p><h2 id="数据准备">数据准备</h2><p>为了进行后续的说明，首先我们需要进行数据准备，即构造出一个带有数据的DataFrame。DataFrame可以从现有的表文件中生成，例如csv、parquet、json等格式的数据，也可以直接从RDD对象中生成。</p><blockquote><p>如果是从现有的表文件中读取数据，会使用到<code>read</code>函数。记得在读取的时候可以使用<code>.option()</code>来指定相关的参数，例如读取表头，推断类型等。</p></blockquote><p>这里我们直接从RDD对象中生成，数据准备的代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 创建SparkSQL的运行环境</span><br><span class="hljs-keyword">val</span> sparkConf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;sparkSQL&quot;</span>)<br><span class="hljs-keyword">val</span> spark = <span class="hljs-type">SparkSession</span>.builder().config(sparkConf).getOrCreate()<br><span class="hljs-keyword">import</span> spark.implicits._<br><br><span class="hljs-comment">// 创建RDD, DataFrame和DataSet</span><br><span class="hljs-keyword">val</span> rdd = spark.sparkContext.makeRDD(<br>  <span class="hljs-type">List</span>((<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">30</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;AB&quot;</span>, <span class="hljs-number">40</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&quot;ABC&quot;</span>, <span class="hljs-number">50</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">&quot;DE&quot;</span>, <span class="hljs-number">20</span>)))<br><span class="hljs-keyword">var</span> df: <span class="hljs-type">DataFrame</span> = rdd.toDF(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们可以将对应的结果进行展示，使用<code>df.show()</code>即可，得到如下的结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">+---+---+---+<br>| _1| _2| _3|<br>+---+---+---+<br>|  1|  A| 30|<br>|  2| AB| 40|<br>|  3|ABC| 50|<br>|  4| DE| 20|<br>+---+---+---+<br></code></pre></td></tr></table></figure><p>我们还可以打印这个表的schema，如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">println(df.schema)<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">StructType(StructField(_1,IntegerType,<span class="hljs-literal">false</span>), StructField(_2,StringType,<span class="hljs-literal">true</span>), StructField(_3,IntegerType,<span class="hljs-literal">false</span>))<br></code></pre></td></tr></table></figure><p>由于我们的DataFrame是直接从RDD中生成的，并没有指定列名，因此这里使用了默认的列名<code>_1,_2,_3</code>。</p><hr /><p>这里有一个小tips：在默认情况下，我们使用IDEA进行本地Spark项目运行的时候，在控制台中会显示出很多日志信息，这是因为默认的日志配置中会输出所有INFO级别以上的日志。这些日志能够帮助我们更好地了解程序运行的情况，进行错误的排查，但是众多的日志输出也会干扰我们对实际结果的观察。</p><p>为了不打印这些日志，我们可以找到默认使用的<code>log4j.properties</code>。默认使用的配置文件位置在<code>org/apache/spark/log4j-defaults.properties</code>，我们也可以在Spark对应的安装目录中找到模板文件<code>SPARK_HOME/conf/log4j.properties.template</code>。将日志文件放在resources目录下，并将其中第一行有效配置<code>log4j.rootCategory=INFO, console</code>修改为<code>log4j.rootCategory=ERROR, console</code>，这样就只会打印ERROR级别以上的日志了。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#</span><br><span class="hljs-comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="hljs-comment"># contributor license agreements.  See the NOTICE file distributed with</span><br><span class="hljs-comment"># this work for additional information regarding copyright ownership.</span><br><span class="hljs-comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="hljs-comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="hljs-comment"># the License.  You may obtain a copy of the License at</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment"># See the License for the specific language governing permissions and</span><br><span class="hljs-comment"># limitations under the License.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># Set everything to be logged to the console</span><br><span class="hljs-attr">log4j.rootCategory</span>=<span class="hljs-string">INFO, console</span><br><span class="hljs-attr">log4j.appender.console</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-attr">log4j.appender.console.target</span>=<span class="hljs-string">System.err</span><br><span class="hljs-attr">log4j.appender.console.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-attr">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;yy/MM/dd HH:mm:ss&#125; %p %c&#123;1&#125;: %m%n</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># Set the default spark-shell log level to WARN. When running the spark-shell, the</span><br><span class="hljs-comment"># log level for this class is used to overwrite the root logger&#x27;s log level, so that</span><br><span class="hljs-comment"># the user can have different defaults for the shell and regular Spark apps.</span><br><span class="hljs-attr">log4j.logger.org.apache.spark.repl.Main</span>=<span class="hljs-string">WARN</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># Settings to quiet third party logs that are too verbose</span><br><span class="hljs-attr">log4j.logger.org.sparkproject.jetty</span>=<span class="hljs-string">WARN</span><br><span class="hljs-attr">log4j.logger.org.sparkproject.jetty.util.component.AbstractLifeCycle</span>=<span class="hljs-string">ERROR</span><br><span class="hljs-attr">log4j.logger.org.apache.spark.repl.SparkIMain$exprTyper</span>=<span class="hljs-string">INFO</span><br><span class="hljs-attr">log4j.logger.org.apache.spark.repl.SparkILoop$SparkILoopInterpreter</span>=<span class="hljs-string">INFO</span><br><span class="hljs-attr">log4j.logger.org.apache.parquet</span>=<span class="hljs-string">ERROR</span><br><span class="hljs-attr">log4j.logger.parquet</span>=<span class="hljs-string">ERROR</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># SPARK-9183: Settings to avoid annoying messages when looking up nonexistent UDFs in SparkSQL with Hive support</span><br><span class="hljs-attr">log4j.logger.org.apache.hadoop.hive.metastore.RetryingHMSHandler</span>=<span class="hljs-string">FATAL</span><br><span class="hljs-attr">log4j.logger.org.apache.hadoop.hive.ql.exec.FunctionRegistry</span>=<span class="hljs-string">ERROR</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># For deploying Spark ThriftServer</span><br><span class="hljs-comment"># SPARK-34128ï¼Suppress undesirable TTransportException warnings involved in THRIFT-4805</span><br><span class="hljs-attr">log4j.appender.console.filter.1</span>=<span class="hljs-string">org.apache.log4j.varia.StringMatchFilter</span><br><span class="hljs-attr">log4j.appender.console.filter.1.StringToMatch</span>=<span class="hljs-string">Thrift error occurred during processing of message</span><br><span class="hljs-attr">log4j.appender.console.filter.1.AcceptOnMatch</span>=<span class="hljs-string">false</span><br></code></pre></td></tr></table></figure><h2 id="数据查询">数据查询</h2><p>最基本的数据展示就是使用<code>show()</code>方法，它有多种重载形式。</p><ul><li><code>show()</code>：默认只显示前20条记录</li><li><code>show(numRows: Int)</code>：传入的参数numRows表示需要显示前多少条记录</li><li><code>show(truncate: Boolean)</code>：有时候一个字段的内容可能很长，超过了20个字符。truncate表示是否最多只显示20个字符，默认值为true</li><li><code>show(numRows: Int, truncate: Boolean)</code>：前面两者的综合效果</li></ul><p>还有其他相关的方法可以帮助我们进行部分数据的查询，获取若干行数据。这些数据会以<code>Row</code>或者<code>Array[Row]</code>的形式返回</p><ul><li><code>first</code>：获取第一行数据</li><li><code>head</code>：获取第一行数据</li><li><code>head(n: Int)</code>：获取前n行数据</li><li><code>take(n: Int)</code>：获取前n行数据</li><li><code>takeAsList(n: Int)</code>：获取前n行数据，并以List的形式展现出来</li></ul><p><code>limit(n: Int)</code>方法也可以获取DataFrame的前n行记录，不过这是得到一个新的DataFrame对象。与take和head不同，limit方法并不是action操作，不会触发Job的执行。</p><p><code>describe</code>方法可以帮助我们获取各个字段的统计信息，该方法接受一个或者若干个表示列名的字符串，如果不传参数，则默认处理所有的字段。结果仍然是一个DataFrame对象。统计信息包括count、mean、stddev、min、max等。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">df.describe().show()<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">+-------+------------------+----+------------------+<br>|summary|                _1|  _2|                _3|<br>+-------+------------------+----+------------------+<br>|  count|                 4|   4|                 4|<br>|   mean|               2.5|null|              35.0|<br>| stddev|1.2909944487358056|null|12.909944487358056|<br>|    min|                 1|   A|                20|<br>|    max|                 4|  DE|                50|<br>+-------+------------------+----+------------------+<br></code></pre></td></tr></table></figure><p>在SQL中，最为基本的查询操作就是Select操作，在SparkSQL中也提供相关API。包括<code>select</code>与<code>selectExpr</code>。在select可以传入字符串作为需要查询的列名，也可以直接传入Column参数，此时可以进行一些特殊处理。在selectExpr中，则可以直接传入一些查询字符串，进行操作或者指定别名等，更加灵活：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 字符串指定列名</span><br>df.select(<span class="hljs-string">&quot;_1&quot;</span>, <span class="hljs-string">&quot;_2&quot;</span>).show()<br><br><span class="hljs-comment">// 获取Column列</span><br>df.select(df(<span class="hljs-string">&quot;_1&quot;</span>), df(<span class="hljs-string">&quot;_3&quot;</span>) + <span class="hljs-number">1</span>).show()<br><br><span class="hljs-comment">// 使用字符串操作表达式</span><br>df.selectExpr(<span class="hljs-string">&quot;_1 as id&quot;</span>, <span class="hljs-string">&quot;_2 as name&quot;</span>, <span class="hljs-string">&quot;round(_3) as age&quot;</span>).show()<br></code></pre></td></tr></table></figure><p>还有一些方法可以获取指定的列：</p><ul><li><code>col(colName: String)</code>：获取某一个指定的字段</li><li><code>apply(colName: String)</code>：获取某一个指定的字段，同时由于是apply方法，因此可以直接使用括号进行调用</li></ul><h2 id="数据处理">数据处理</h2><p>对于DataFrame中列的处理，除了上面的查询之外，还可以进行增加和删除。列的删除可以使用drop方法，与上面类似，它可以接受String类型的参数，也可以接受Column的参数。drop返回一个新的DataFrame对象，去除指定字段，保留其他字段。drop一次只能去除一个字段。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">df.drop(<span class="hljs-string">&quot;_1&quot;</span>)<br>df.drop(df(<span class="hljs-string">&quot;_2&quot;</span>))<br></code></pre></td></tr></table></figure><p>在DataFrame中增加一列，使用的是<code>withColumn</code>方法。该方法签名为<code>withColumn(colName: String, col: Column)</code>。该方法可以向DataFrame中新增一列，如果colName已经存在，则会覆盖对应的列。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 新增一列名称为new，值为随机值</span><br><span class="hljs-comment">// 需要注意引入的package路径：import org.apache.spark.sql.functions.rand</span><br>df.withColumn(<span class="hljs-string">&quot;new&quot;</span>, rand())<br></code></pre></td></tr></table></figure><p>还有一个与它名称类似的方法，为<code>withColumnRenamed</code>。该方法用于字段的重命名，如果指定的字段名不存在，则不进行任何操作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">df.withColumnRenamed(<span class="hljs-string">&quot;_3&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>)<br></code></pre></td></tr></table></figure><p>关于DataFrame的数据去重，与SQL中类似，可以使用<code>distinct</code>方法。它默认会对全表进行去重，比较的条件是所有的字段。另外一种方式是根据指定字段进行去重，对应方法为<code>dropDuplicates</code>。该方法可以接收多个字符串，也可以接受字符串列表，其中可以传入需要指定去重的字段。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// distinct</span><br>df.distinct()<br><br><span class="hljs-comment">// dropDuplicates</span><br>df.dropDuplicates(<span class="hljs-string">&quot;_1&quot;</span>, <span class="hljs-string">&quot;_2&quot;</span>)<br>df.dropDuplicates(<span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;_1&quot;</span>, <span class="hljs-string">&quot;_2&quot;</span>))<br>df.dropDuplicates(<span class="hljs-type">Array</span>(<span class="hljs-string">&quot;_1&quot;</span>, <span class="hljs-string">&quot;_2&quot;</span>))<br></code></pre></td></tr></table></figure><p>DataFrame的数据排序相关的方法为<code>sort</code>和<code>orderBy</code>。这两个方法可以按照指定字段进行排序，默认为升序。如果需要降序，则只需要增加一个<code>-</code>即可。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// orderBy</span><br>df.orderBy(<span class="hljs-string">&quot;_3&quot;</span>).show()<br>df.orderBy(- df(<span class="hljs-string">&quot;_3&quot;</span>)).show()<br><br><span class="hljs-comment">// sort 与 orderBy 用法一致</span><br>df.sort(<span class="hljs-string">&quot;_3&quot;</span>).show()<br>df.sort(- df(<span class="hljs-string">&quot;_3&quot;</span>)).show()<br></code></pre></td></tr></table></figure><p><code>union</code>则表示两个DataFrame的简单拼接，与SQL中的unionall的效果一致。同时还提供一个<code>unionAll</code>API，与<code>union</code>是等价的，<code>unionALL</code>内部就是直接调用了<code>union</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">df.union(df)<br>df.unionAll(df)<br></code></pre></td></tr></table></figure><p><code>collect</code>和<code>collectAsList</code>可以获取所有数据到数组中，需要注意的就是它们的返回值不同。前者返回的是Scala中的Array，而后者返回的是Java中的List。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> rows1:<span class="hljs-type">Array</span>[<span class="hljs-type">Row</span>] = df.collect()<br><span class="hljs-keyword">val</span> rows2:util.<span class="hljs-type">List</span>[<span class="hljs-type">Row</span>]= df.collectAsList()<br></code></pre></td></tr></table></figure><h2 id="聚合计算">聚合计算</h2><p>在DataFrame中可以使用聚合函数来进行字段的聚合计算，例如计算某个字段的最值。在聚合函数中指定需要计算的最值。当然除了最值之外，还可以使用其他的相关聚合函数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 最值计算</span><br><span class="hljs-comment">// package: import org.apache.spark.sql.functions.&#123;min, max&#125;</span><br><span class="hljs-keyword">val</span> row: <span class="hljs-type">Row</span> = df.agg(min(<span class="hljs-string">&quot;_3&quot;</span>), max(<span class="hljs-string">&quot;_3&quot;</span>)).head()<br><span class="hljs-keyword">val</span> minValue = row.getInt(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">val</span> maxValue = row.getInt(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><code>agg</code>本身返回的是一个DataFrame，只不过这个DataFrame只有一行。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">df.agg(<span class="hljs-string">&quot;_1&quot;</span> -&gt; <span class="hljs-string">&quot;mean&quot;</span>, <span class="hljs-string">&quot;_2&quot;</span> -&gt; <span class="hljs-string">&quot;max&quot;</span>, <span class="hljs-string">&quot;_3&quot;</span> -&gt; <span class="hljs-string">&quot;sum&quot;</span>).show()<br></code></pre></td></tr></table></figure><p>上面操作会打印出下面的内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">+-------+-------+-------+<br>|avg(_1)|max(_2)|<span class="hljs-built_in">sum</span>(_3)|<br>+-------+-------+-------+<br>|    2.5|     DE|    140|<br>+-------+-------+-------+<br></code></pre></td></tr></table></figure><p>聚合函数也通常与groupBy进行连用，与SQL的表达类似，这里主要关注生成的数据格式（为了测试需要，这里临时在原始DataFrame的数据中将第一行数据重复了三遍）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">df.groupBy(<span class="hljs-string">&quot;_2&quot;</span>).count().show()<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">| _2|count|<br>+---+-----+<br>| DE|    1|<br>|  A|    3|<br>| AB|    1|<br>|ABC|    1|<br>+---+-----+<br></code></pre></td></tr></table></figure><h2 id="条件过滤">条件过滤</h2><p>在DataFrame中，可以使用filter或者where来进行条件过滤，过滤掉相关的行。过滤之后仍然返回一个DataFrame。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// filter</span><br>df.filter(df.col(<span class="hljs-string">&quot;_3&quot;</span>).geq(<span class="hljs-number">25</span>) &amp;&amp; df.col(<span class="hljs-string">&quot;_3&quot;</span>).leq(<span class="hljs-number">45</span>)).show()<br>df.filter(<span class="hljs-string">&quot;_3 &gt;= 25 and _3 &lt;= 45&quot;</span>).show()<br><br><span class="hljs-comment">// where</span><br>df.where(df.col(<span class="hljs-string">&quot;_3&quot;</span>).geq(<span class="hljs-number">25</span>) &amp;&amp; df.col(<span class="hljs-string">&quot;_3&quot;</span>).leq(<span class="hljs-number">45</span>)).show()<br>df.where(<span class="hljs-string">&quot;_3 &gt;= 25 and _3 &lt;= 45&quot;</span>).show()<br></code></pre></td></tr></table></figure><p>得到如下结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">+---+---+---+<br>| _1| _2| _3|<br>+---+---+---+<br>|  1|  A| 30|<br>|  2| AB| 40|<br>+---+---+---+<br></code></pre></td></tr></table></figure><h2 id="连接处理">连接处理</h2><p>在SQL语言中，非常常用的操作就是join操作，在DataFrame中同样提供，下面主要介绍joinAPI的使用方式。为了演示操作，这里创建了一个新的DataFrame</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> rdd2 = spark.sparkContext.makeRDD(<br><span class="hljs-type">List</span>((<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;AB&quot;</span>))<br>)<br><span class="hljs-keyword">val</span> df2: <span class="hljs-type">DataFrame</span> = rdd2.toDF()<br></code></pre></td></tr></table></figure><p>join的相关使用如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 笛卡尔积</span><br>df.join(df2).show()<br><br><span class="hljs-comment">// using某一个字段</span><br>df.join(df2, <span class="hljs-string">&quot;_1&quot;</span>).show()<br><br><span class="hljs-comment">// using多个字段</span><br>df.join(df2, <span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;_1&quot;</span>, <span class="hljs-string">&quot;_2&quot;</span>)).show()<br><br><span class="hljs-comment">// 更加灵活的条件指定</span><br>df.join(df2, df(<span class="hljs-string">&quot;_1&quot;</span>) === df(<span class="hljs-string">&quot;_2&quot;</span>)).show()<br>df.join(df2, df(<span class="hljs-string">&quot;_1&quot;</span>) =!= df(<span class="hljs-string">&quot;_2&quot;</span>)).show()<br><br><span class="hljs-comment">// 指定join类型</span><br>df.join(df2, <span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;_1&quot;</span>), <span class="hljs-string">&quot;right&quot;</span>).show()<br>df.join(df2, df(<span class="hljs-string">&quot;_1&quot;</span>) === df2(<span class="hljs-string">&quot;_1&quot;</span>), <span class="hljs-string">&quot;right&quot;</span>).show()<br></code></pre></td></tr></table></figure><p>具体的结果这里就不再进行展示了，都是非常符合直觉的结果。其中在灵活的条件指定中，我们使用的是Column之间的比较。Column提供<code>===</code>来表示相等，对应的<code>=!=</code>表示不相等。在指定join类型的时候，表示join类型的字符串只能是第三个参数，同时必须是下面这些值之一：inner,cross, outer, full, fullouter, full_outer, left, leftouter, left_outer,right, rightouter, right_outer, semi, leftsemi, left_semi, anti,leftanti,left_anti。在需要使用join类型的时候，一定要认真观察它提供给我们的方法签名。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://blog.csdn.net/dabokele/article/details/52802150">Spark-SQL之DataFrame操作大全</a></li><li><ahref="https://spark.apache.org/docs/latest/api/scala/org/apache/spark/sql/Dataset.html">Spark-ScalaDoc-Dataset</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Spark</tag>
      
      <tag>SparkSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式(2)-实例生成</title>
    <link href="/2023/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%AE%9E%E4%BE%8B%E7%94%9F%E6%88%90/"/>
    <url>/2023/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%AE%9E%E4%BE%8B%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="singleton">Singleton</h1><h2 id="简介">简介</h2><p>在程序运行的时候，通常都会生成很多实例。但是有时我们也会希望某个类在程序运行的过程中只能生成一个实例，此时就需要用到Singleton模式。当然，只要我们在编写程序的时候多加注意，确保只调用一次new，那么就可以达到只生成一个实例的目的。但是这种来自程序员本身的保障是不可靠的，而利用Singleton模式，我们能够确保在任何情况下都绝对只有一个实例，并且能够在程序上表现出只存在一个实例。</p><h2 id="实例程序">实例程序</h2><p>下面我们将介绍单例模式的不同实现方式。单例模式主要分为两种实现方式，分别是饿汉式和懒汉式。第一种实现方式是饿汉式，这种方式不会存在线程安全问题，因为它是一开始就将资源创建好，在需要使用的时候直接返回资源即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br> <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>     <span class="hljs-keyword">return</span> instance;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方式是懒汉式，这种方式是在需要使用的时候才新建资源，但是基础的实现会存在线程安全问题。下面是懒汉式的基本实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br> <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>     <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>         instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>     &#125;<br>     <span class="hljs-keyword">return</span> instance;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过我们可以将其改造成线程安全版本。这种实现下，当使用的时候才去创建资源，同时由于方法使用了synchronized关键字修饰，同一个时刻只有一个线程可以调用，于是不会重复创建资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br> <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>     <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>         instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>     &#125;<br>     <span class="hljs-keyword">return</span> instance;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是上面的方式还是存在缺陷的，就是无论何时，getInstance方法都只能有一个线程调用，这样实际上会造成一些效率上的问题。而事实上，在实例创建完成之后，我们就应该允许并发调用getInstance。因此有如下的双重检验锁版本，它只在创建实例的时候不允许并发，保证单例模式的正确性，而在实例创建完成之后，就允许并发调用获取实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br> <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>     <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>         <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>             <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                 instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>             &#125;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> instance;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="prototype">Prototype</h1><h2 id="简介-1">简介</h2><p>在Java中，通常情况下，我们生成一个实例都是通过new关键字来完成的，这就意味着在源代码中一定会出现特定类的名称。这似乎是个很自然的结果，但是一些情况下我们不希望在源代码中出现某个特定类的名称，因为这样就意味着该源代码与这个特定类强耦合。</p><p>Prototype模式想要达到的效果就是不通过new关键字来生成实例，而是通过实例的复制来生成实例。在Prototype模式中有如下的角色：</p><ul><li><code>Prototype</code>：原型角色。需要声明复制现有实例创建新实例的方法</li><li><code>ConcretePrototype</code>：具体的原型。需要实现Prototype角色，并实现具体的通过复制创建新实例的方法</li></ul><h2 id="示例程序">示例程序</h2><p>在这个示例程序中，我们的目标类是两个可以分别完成不同形式字符串的类，但是需要通过Prototype模式来对它们进行管理。在实际使用的时候，通过原型复制进行生成。</p><p>首先定义<code>Prototype</code>接口，这个接口表示原型。在接口中声明了两个方法，一个是use方法，这个方法与实际业务相联系，不是该设计模式中的必备。另外一个方法是createClone方法，它表示通过这个方法能够创建出一个实体类。同时Prototype接口本本身继承了Cloneable，从实现了该接口的类对应的示例可以调用clone方法来自动复制实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Prototype</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">(String string)</span>;<br>    Prototype <span class="hljs-title function_">createClone</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们创建一个类<code>ProtorypeManager</code>用来管理各种原型。该类中有一个Map类型的成员变量，用于管理字符串和实际原型的映射。该类提供两个方法，第一个是<code>register</code>，用于注册原型从而进行管理；第二个方法是<code>create</code>，它接收一个字符串，然后根据对应的原型创建出实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrototypeManager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashMap&lt;String, Prototype&gt; prototypeCases = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String name, Prototype prototype)</span> &#123;<br>        prototypeCases.put(name, prototype);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Prototype <span class="hljs-title function_">create</span><span class="hljs-params">(String prototypeName)</span> &#123;<br>        <span class="hljs-type">Prototype</span> <span class="hljs-variable">prototype</span> <span class="hljs-operator">=</span> prototypeCases.get(prototypeName);<br>        <span class="hljs-keyword">return</span> prototype.createClone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就到了具体的原型实现。这里实现两个原型，它们分别可以完成不同格式字符串的输出，<code>MessageBox</code>可以输出一个被<code>*</code>包裹的字符串，而<code>UnderlinePen</code>则可以输出一个带下划线的字符串。这两个类都需要实现Prototype接口，并实现其中的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Prototype</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; string.length() + <span class="hljs-number">4</span>; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>        &#125;<br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;* &quot;</span> + string + <span class="hljs-string">&quot; *&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; string.length() + <span class="hljs-number">4</span>; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Prototype <span class="hljs-title function_">createClone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> ((Prototype) clone());<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnderlinePen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Prototype</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">(String string)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;\&quot;&quot;</span> + string + <span class="hljs-string">&quot;\&quot;&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; string.length() + <span class="hljs-number">2</span>; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;=&quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Prototype <span class="hljs-title function_">createClone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> ((Prototype) clone());<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们就可以进行Prototype模式的测试。在测试程序中，我们首先需要在管理类中注册原型，之后才能从管理类中根据原型进行实例的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// prototype register</span><br>    <span class="hljs-type">PrototypeManager</span> <span class="hljs-variable">prototypeManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrototypeManager</span>();<br>    prototypeManager.register(<span class="hljs-string">&quot;messageBox&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageBox</span>());<br>    prototypeManager.register(<span class="hljs-string">&quot;underlinePen&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnderlinePen</span>());<br><br>    <span class="hljs-comment">// create instance from prototype</span><br>    <span class="hljs-type">Prototype</span> <span class="hljs-variable">messageBox</span> <span class="hljs-operator">=</span> prototypeManager.create(<span class="hljs-string">&quot;messageBox&quot;</span>);<br>    messageBox.use(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>    <span class="hljs-type">Prototype</span> <span class="hljs-variable">underlinePen</span> <span class="hljs-operator">=</span> prototypeManager.create(<span class="hljs-string">&quot;underlinePen&quot;</span>);<br>    underlinePen.use(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="说明">说明</h2><p>Prototype模式通过复制来生成实例，我们可以避免代码之间的强耦合，达到组件的更强的复用性，同时便于管理各种原型。在上面的示例程序中，我们在测试代码中手动注册了原型。事实上，我们完全可以将原型的注册过程放在PrototypeManager的构造方法中，这样在测试代码中将不会出现具体的类名称，进一步解耦了相关代码。</p><p>注意到Prototype接口继承了Cloneable接口。在Java中已经提供了用于复制实例的clone方法，但是想要调用该方法，则对应的类必须要实现<code>java.lang.Cloneable</code>接口。如果没有实现该接口的实例调用了clone方法，则会在运行的时候抛出<code>CloneNotSupportedException</code>异常。不过需要注意的是，clone方法并不是定义在Cloneable接口中，而是定义在ObjectClass中的。Cloneable仅仅是一个标记接口（markerinterface），它只是用来标记，说明“可以使用clone方法来进行复制”。同时clone方法进行的是浅复制，当浅复制无法满足要求时，则可以重写clone方法，进行定制化的处理。</p><p>不过实例的复制流程一般来说都是一致的。像在上面的createClone方法中，我们可以看到在MessageBox和UnderlinePen中实现是一致的，因此我们完全可以在接口中提供一个默认实现，完成最基本的复制。而如果某个子类需要进行定制化的复制，则只需要覆盖接口中的默认实现即可。</p><h1 id="abstract-factory">Abstract Factory</h1><p>在谈到工厂Factory的时候，我们都是希望通过工厂来构建出具体的实例。在一些时候，我们可能需要许多不同的工厂，这些不同的具体的工厂完成不同的具体的行为，但是又具有一定的共性。AbstractFactory模式就是对工厂的进一步抽象，在该模式中，我们会定义抽象的Factory，在该抽象类中会定义生成实例的方式，但是在其中使用的都是抽象的Item类，这里可以理解为抽象的零件。因此抽象工厂模式完成的就是构造一个抽象的工厂，该工厂利用抽象的零件构建出抽象的产品。而如果需要将这些都转为具体的，则需要提供具体的零件实现，具体的产品，具体的工厂。这种方式便于多种工厂的管理，同时增加具体的工厂也是非常容易的。如果需要新增新的具体工厂，则只需要编写对应抽象工厂、抽象零件、抽象产品的子类，并实现其中的抽象方法即可。</p><p>该模式的核心思想与TemplateMethod基本一致，都是定义模版之后交由子类实现，只不过在AbstractFactory模式中特定定义了工厂的模版。这里不再提供相关的实例程序。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Technique</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式(1)-简单设计与交给子类</title>
    <link href="/2023/03/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/"/>
    <url>/2023/03/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="iterator">Iterator</h1><h2 id="简介">简介</h2><p>Iterator意为迭代器，Iterator模式通常用于在数据集合中按照顺序遍历集合。在许多程序语言中都有迭代器的相关实现，当然我们也可以自己利用Iterator模式来构造自己的迭代器。</p><p>在Iterator模式中一般有如下角色：</p><ul><li><code>Iterator</code>：该角色代表迭代器，它负责定义相关API，按照顺序遍历元素<ul><li>通常具有<code>hasNext</code>、<code>next</code>方法</li></ul></li><li><code>ConcreteIterator</code>：该角色代表具体的迭代器，它负责实现Iterator角色所定义的API。该角色中包含了遍历集合所必需的信息</li><li><code>Aggregate</code>：该角色代表集合，它其中定义创建Iterator角色的API，该API能够创建出对应的迭代器Iterator</li><li><code>ConcreteAggregate</code>：该角色代表具体的集合，用于实现Aggregate角色所定义的API，具体实现如何进行迭代</li></ul><p>角色之间的关系如下：</p><p><img src="/2023/03/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/Iterator.png" class="" title="Iterator"></p><h2 id="示例程序">示例程序</h2><p>这里我们模拟一个书架类，通过Iterator模式来对书架上的书进行遍历。首先我们可以创建Book类，用于模拟书。Book类仅有一个String类型的name属性，以及相应的get、set、构造方法和toString方法，这里就不进行描述了。</p><p>之后定义<code>Iterator</code>接口，这个接口通常情况下具有<code>hasNext</code>和<code>next</code>方法，用于判断是否有下一个元素以及获取下一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Aggregate</code>接口中定义了<code>iterator</code>方法，主要用于返回相应的迭代器对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们可以定义<code>BookShelf</code>书架类，这个类应该实现<code>Aggregate</code>接口。首先按照类本身的逻辑，<code>BookShelf</code>中需要定义一个数组来保存<code>Book</code>对象，之后还需要提供相关的添加书籍的方法。同时由于实现了<code>Aggregate</code>，需要返回一个迭代器。这里的迭代器对象则是另外定义的一个<code>BookShelfIterator</code>，它实现了<code>Iterator</code>接口。在<code>BookShelfItreator</code>类中，需要实现相关的迭代方法的真实逻辑，包括<code>hasNext</code>以及<code>next</code>。注意这里<code>BookShelfIterator</code>的构造需要传入<code>BookShelf</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookShelf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;Book&gt; books;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookShelf</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.books = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(Book book)</span>&#123;<br>        <span class="hljs-built_in">this</span>.books.add(book);<br>    &#125;<br>    <span class="hljs-keyword">public</span> ArrayList&lt;Book&gt; <span class="hljs-title function_">getBooks</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> books;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BookShelfIterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookShelfIterator</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookShelfIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&#123;<br>    <span class="hljs-keyword">private</span> BookShelf bookShelf;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookShelfIterator</span><span class="hljs-params">(BookShelf bookShelf)</span>&#123;<br>        <span class="hljs-built_in">this</span>.index = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.bookShelf = bookShelf;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> index &lt; bookShelf.getBooks().size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.bookShelf.getBooks().get(index++);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们就可以测试相关的迭代方式是否可用，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIterator</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">BookShelf</span> <span class="hljs-variable">bookShelf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookShelf</span>();<br>    bookShelf.addBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;book1&quot;</span>));<br>    bookShelf.addBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;book2&quot;</span>));<br>    bookShelf.addBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;book3&quot;</span>));<br>    bookShelf.addBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;book4&quot;</span>));<br><br>    <span class="hljs-type">BookShelfIterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> bookShelf.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>        System.out.println(iterator.next());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="说明">说明</h2><p>通过上面的例子可以看到，利用Iterator模式我们完成了一个数组或者集合的遍历。与通过下标index和for循环直接遍历相比，这种方式似乎更加繁琐，但在Iterator模式中，我们的遍历只使用到了Iterator接口中的方法，而不会依赖实际BookShelf的实现。也就是说，在BookShelf中，无论是使用数组，或者其他集合例如LinkedList来管理Book对象，只要BookShelf中的iterator方法能够正确地返回Iterator的实例，上面的while循环就是可以正常工作的，这段测试代码是不用变动的。而测试代码实际上就相当于其他对于BookShelf的调用者，这种仅依赖Iterator的特性使得调用者变得非常方便，因为他无需关心BookShelf的具体实现，只需要拿到一个正确的Iterator实例即可。</p><p>这里也体现了设计模式的一个非常重要的思想，就是优先使用抽象类和接口来进行编程，这样能够弱化类之间的耦合，进而使得类能够更加容易地作为组件被再次利用。</p><h1 id="adapter">Adapter</h1><h2 id="简介-1">简介</h2><p>Adapter意为适配器，它位于实际情况和需求之间，填补两者之间的差异。在程序开发的过程中，经常会存在现有的程序无法直接使用，需要进行适当的变换之后才能够使用的情况。这种用于填补“现有的程序”与“所需的程序”之间差异的设计模式就是Adapter模式。</p><p>Adapter模式也被称为Wrapper模式，即包装器。通过对现有的程序进行包装，使得其能够达到我们需要的效果。Adapter模式主要分为使用继承实现的Adapter以及使用委托实现的Adapter。</p><p>在Adapter模式中，主要有以下角色：</p><ul><li><code>Target</code>：该角色中定义了我们最终需要得到的方法，它需要能够处理我们现有的需求</li><li><code>Client</code>：请求者角色。通常是Main函数，它调用Target角色来使用相关特性。这相当于是客户，是服务的调用者</li><li><code>Adaptee</code>：被适配角色。表示现有的程序，这个程序在我们现有的需求中虽然不能直接使用，但是能够被复用</li><li><code>Adapter</code>：适配角色。Adapter模式的核心角色，连接了Target以及Adaptee，使得Target对于需求的实现能够借助现有的Adaptee</li></ul><p>角色之间的关系如下：</p><img src="/2023/03/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/Adaptor.png" class="" title="Adaptor"><h2 id="示例程序-1">示例程序</h2><p>假设我们需要完成一个Print接口，这个接口中有如下的方法，其中printWeak输出两端加上括号的结果；printStrong输出两端加上星号的结果。这就是我们的需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Print</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而目前我们已经有一个完成了类似功能的Banner类，它的实现如下，它的相关方法能够一定程度上达到我们需要的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Banner</span> &#123;<br>    <span class="hljs-keyword">private</span> String string;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Banner</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">this</span>.string = string;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showWithParen</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;(&quot;</span> + string + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showWithAster</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;*&quot;</span> + string + <span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了实现这个需求，我们需要使用一个中间适配器Adapter，用于连接需求接口print以及已有代码Banner。我们可以定义一个类PrintBanner，它在继承Banner的同时还实现了Print接口，其中print接口的方法实现则直接使用Banner中的实现，进行一层包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintBanner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Banner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Print</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrintBanner</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">super</span>(string);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span> &#123;<br>        showWithParen();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span> &#123;<br>        showWithAster();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们就可以利用如下代码进行测试。在测试代码中，作为使用者，我们只需要使用我们新定义的Print接口和实现类PrintBanner，而不需要关注Banner这个已有的旧代码，就能够达到需要的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Print</span> <span class="hljs-variable">print</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintBanner</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    print.printStrong();<br>    print.printWeak();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这种实现方式就是基于继承实现的Adapter模式。而下面开始介绍基于委托的Adapter模式实现。假设我们现在的需求并不是Print接口，而是一个Printer类，这是一个抽象类，其中也需要具有上面Print接口中的两种方法，抽象类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们同样可以使用一个类来进行适配。我们实现一个PrinterBanner类，它直接继承抽象类Printer，不过在其中存储一个Banner类型的成员变量，而抽象父类的方法实现则调用这个成员变量来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrinterBanner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Printer</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Banner banner;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrinterBanner</span><span class="hljs-params">(String string)</span>&#123;<br>        <span class="hljs-built_in">this</span>.banner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Banner</span>(string);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.banner.showWithParen();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.banner.showWithAster();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样可以使用类似的测试代码进行测试，也是能够达到相同的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Printer</span> <span class="hljs-variable">printer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrinterBanner</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    printer.printStrong();<br>    printer.printWeak();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="说明-1">说明</h2><p>Adapter模式是一个较为简单的设计模式，在日常程序开发的过程中非常常见，常见到很多时候我们往往都忽略了这是一个设计模式。Adapter模式能够帮助我们实现代码的复用，在开发时更加方便。简单来说，就是将我们需要使用的现有类进行包装，无论是以继承的方式还是成员变量的方式，需要达到的目的就是将现有的功能能够帮助到我们目前需求的实现。同时，现有的代码通常是经过了检测和测试的，这也就意味着我们新需求的代码如果出现Bug的时候，进行排查时就可以直接跳过这部分已经接受过检测的代码，减少考虑的范围。</p><p>实际上，Adapter模式更多会作为一种好的编程习惯。如果我们有一个好的编程习惯，对于它的使用往往在不经意间就能够完成。</p><h1 id="template-method">Template Method</h1><h2 id="简介-2">简介</h2><p>TemplateMothod，即模板方法。这种模式提供模版功能，组成模板的方法被定义在父类中，父类提供一个模板方法，在模板方法中按照一定的逻辑进行处理，但是这里使用的是抽象方法，只通过父类的代码是无法知道这些方法最终会进行何种处理，唯一能够知道父类是如何调用这些方法的。抽象方法由子类进行实现，不同的实现也就导致实际处理的不同，不过具体的流程还是按照父类中的定义进行的。</p><p>在Template Method模式中有如下角色：</p><ul><li><code>AbstractClass</code>：抽象类，负责实现模板方法，同时负责声明在模板方法中所使用到的抽象方法。这些抽象方法由子类负责实现</li><li><code>ConcreteClass</code>：具体类，负责具体实现在AbstractClass中定义的抽象方法。而方法的具体实现会在模板方法中被调用</li></ul><p>简单来说，TemplateMethod模式就是在父类中定义处理流程的框架，在子类中实现具体的处理逻辑。</p><h2 id="示例程序-2">示例程序</h2><p>首先准备一个抽象父类<code>AbstractDisplay</code>，其中的核心方法是<code>display</code>。在display中，它首先调用了<code>open</code>方法，然后重复执行五次<code>print</code>方法，最后执行了<code>close</code>方法，不过这些被调用的方法都是抽象方法，等待子类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDisplay</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        open();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            print();<br>        &#125;<br>        close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们实现两个子类来观察不同的运行结果，第一个子类<code>CharDisplay</code>对相关抽象方法有如下的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDisplay</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;&lt;&lt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;H&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个子类<code>StringDisplay</code>对相关抽象方法则实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDisplay</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;+--------+&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;+Template+&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;+--------+&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个子类对抽象方法的实现各不相同，但是最终在<code>display</code>中的执行流程还是一样的，都是按照父类已经定义好的流程进行实现的。可以利用相关测试方法来查看不同的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCharDisplay</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">AbstractDisplay</span> <span class="hljs-variable">display</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharDisplay</span>();<br>    display.display();<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStringDisplay</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">AbstractDisplay</span> <span class="hljs-variable">display</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplay</span>();<br>    display.display();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="说明-2">说明</h2><p>在TemplateMethod模式中，父类的模版方法内部定义了算法或者流程，这样就无需在每个子类内部重复编写算法。这种方式集中在父类内部管理核心流程，保证了关键代码的稳定，而具体的实现由不同的子类来完成，又可以适应多种不同的情况。在该类模式中，父类和子类之间是相互联系的，我们只有参考理解父类中模版方法的流程，才能够很好地在子类中实现相关的抽象方法。</p><h1 id="factory-method">Factory Method</h1><h2 id="简介-3">简介</h2><p>在TemplateMethod模式中，我们在父类中规定处理的流程，而让子类来实现具体的处理。将这种思想应用于实例生成，则是FactoryMethod模式。在FactoryMethod模式中，父类将决定实例生成的流程和方式，但是具体的处理则交给子类来完成，如此，就可以将生成实例的框架和实际负责实例生成的类进行解耦。</p><p>在Factory Method中有如下角色：</p><ul><li><code>Product</code>：产品类，该角色属于框架这一方，属于抽象类。该角色定义了在FactoryMethod模式中生成的实例所需要有的接口</li><li><code>Creator</code>：创建者，同样属于框架这一方，属于抽象类，负责生成Product角色，生成过程可以安排，但是具体的处理由子类决定</li><li><code>ConcreteProduct</code>：继承Product，属于具体的产品</li><li><code>ConcreteCreator</code>：继承Creator，属于具体的创建者</li></ul><h2 id="示例程序-3">示例程序</h2><p>考虑这样的场景，我们使用FactoryMethod模式来完成ID卡的生成。ID卡属于产品Product，我们需要有一个工厂Factory来生成产品。首先定义Product类和Factory类，它们属于框架提供的架构，也就是父类。在Product类中声明产品有一个使用方法，而在Factory中定义了产品的生产流程，关键步骤使用抽象方法，需要由子类进行实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Product <span class="hljs-title function_">create</span><span class="hljs-params">(String owner)</span>&#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> createProduct(owner);<br>        registerProduct(product);<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String owner)</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerProduct</span><span class="hljs-params">(Product product)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们就需要分别它们对应的子类，IDCard以及IDCardFactory。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IDCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> String owner;<br><br>    IDCard(String owner) &#123;<br>        System.out.println(<span class="hljs-string">&quot;generate the ID card of &quot;</span> + owner);<br>        <span class="hljs-built_in">this</span>.owner = owner;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;using the ID card of &quot;</span> + owner);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOwner</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> owner;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>IDCard需要继承Product，并且实现对应的方法。注意这里的构造方法是默认的default作用范围，它的作用范围是本包内，外部是无法调用这个构造方法的。这也就能够一定程度上限制其他外部类的行为，它无法直接new得到对象，而只能通过工厂来创建对象。</p><p>IDCardFactory则需要继承Factory，同样实现对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IDCardFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; owners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Product <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String owner)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IDCard</span>(owner);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerProduct</span><span class="hljs-params">(Product product)</span> &#123;<br>        owners.add(((IDCard) product).getOwner());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就可以书写测试程序了。对于这些功能的使用者也就是我们的测试程序来说，它需要获得一个IDCard的实例，只需要通过工厂IDCardFactory进行创建即可，至于其内部的具体逻辑则不需要关心。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Factory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IDCardFactory</span>();<br>    <span class="hljs-type">Product</span> <span class="hljs-variable">card1</span> <span class="hljs-operator">=</span> factory.create(<span class="hljs-string">&quot;A&quot;</span>);<br>    <span class="hljs-type">Product</span> <span class="hljs-variable">card2</span> <span class="hljs-operator">=</span> factory.create(<span class="hljs-string">&quot;B&quot;</span>);<br>    <span class="hljs-type">Product</span> <span class="hljs-variable">card3</span> <span class="hljs-operator">=</span> factory.create(<span class="hljs-string">&quot;C&quot;</span>);<br>    card1.use();<br>    card2.use();<br>    card3.use();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="说明-3">说明</h2><p>FactoryMethod可以帮助我们对外提供一个简单的获取实例的方式。在一些情况下，某个实例的准备可能需要复杂的过程，但是对于外界来说，可能只需要知道如何能够生成就行。FactoryMethod就能够提供一个分离的方式获取实例。不过在编写具体类的时候，需要结合抽象父类进行理解，否则会对各个抽象方法实际需要完成的工作不够清楚，导致子类中的实现无法达到效果。</p><p>对于Factory中的需要子类实现的方法，我们一般有三种方式来定义。第一种就是直接声明为抽象方法，子类必须实现，否则在编译时会报错。第二种就是在父类中给一个最简单最基础的实现。第三种是默认实现抛出异常，如果在子类中没有实现，则是在执行的以后才会报错。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Technique</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Parquet-格式介绍与在Java中的操作</title>
    <link href="/2023/03/11/Parquet-%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/03/11/Parquet-%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="parquet">Parquet</h1><h2 id="简介">简介</h2><p>Apache Parquet是由Twitter和Cloudera合作开发的列式存储项目，也是Google在2010年发表的Dermel论文中描述的内部列式存储格式的开源实现。与传统的列式存储相比，Parquet最大的特点就是支持嵌套格式数据的列式存储。对于大规模的嵌套格式数据来说，Parquet的原生支持能够减少规则化嵌套数据的开销，提升处理大规模数据的效率。</p><p>Parquet是一种存储格式，它与语言和平台无关，不需要与任何一种数据处理框架绑定。Parquet在大数据处理框架中十分常用，如果说HDFS 是大数据时代文件系统的事实标准的话，Parquet就是大数据时代存储格式的事实标准，有许多组件都支持Parquet存储格式，包括下面的组件：</p><ul><li>查询引擎：Hive、Impala、Pig、Presto、Drill、Tajo、HAWQ、IBM BigSQL</li><li>计算框架：MapReduce、Spark、Cascading、Crunch、Scalding、Kite</li><li>数据模型：Avro、Thrift、Protocol Buffers、POJOs</li></ul><p>parqeut文件默认是无法直接查看的，不过我们可以通过一些工具进行查看。其中一个是<code>parquet-tools</code>,该工具可以利用pip进行下载，下载之后就可以在命令行中查看parquet文件。（还有一种parquet-tools是以jar包形式存在的，但是目前在官方的github项目地址中似乎已经找不到了。）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install parquet-tools -i https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><p>当然我们也可以在JetBrains中下载Plugin Big DataTools，该插件提供了大数据生态的相关工具，其中之一就包含对parquet文件的查看支持。</p><h2 id="数据模型">数据模型</h2><h3 id="schema">Schema</h3><p>要理解Parquet的存储格式，首先需要了解它的数据模型。</p><p>Parquet支持嵌套的数据模型，数据模型可以利用Schema来描述。在Parquet中，一个数据模型的Schema最上层是<code>message</code>，其中可以包含一系列字段。每个字段具有三个属性，分别是重复性（Repetition）、类型（Type）以及名称（Name）。其中字段的类型可以是原子类型，例如int、boolean、string等，也可以是一个group，这就表示这个字段是一个嵌套字段。字段的重复性则可以有下面三种情况：</p><ul><li><code>required</code>：出现有且仅有一次</li><li><code>optional</code>：可以出现0次或者1次</li><li><code>repeated</code>：可以出现0次或者多次</li></ul><p>这样定义的数据模型非常简洁，同时也具有强大的表达能力。一些复杂的数据类型例如Map、List和Set等也可以利用repeated字段+groups来表示，因此也就不需要再额外对这些类型进行单独定义。</p><blockquote><ul><li>Map Schema</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs schema">message ExampleMap &#123;<br>repeated groups Entry &#123;<br>required string key;<br>optional string value;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个数据Schema可以用来表示Map数据结构。在一个Map中可以有多个Entry对象，即键值对。每个Entry中又包含了key和value，其中key是必须的，value是可选的。</p><ul><li>List / Set Schema</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs schema">message ExampleList &#123;<br>repeatd string ListElement;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个数据Schema可以表示List或者Set，这表示字段listElemet可以重复出现。</p></blockquote><p>Parquet中提出以树状层级的形式来组织Schema中的字段，树的每个叶子结点对应一个原子类型字段。如此这个模型就可以同时覆盖嵌套结构数据和扁平结构数据（扁平结构数据只是嵌套结构数据的一种特例）。如下是一个数据Schema的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs schema">message Document &#123;<br>required int64 DocId;<br>optional group Links &#123;<br>repeated int64 Backward;<br>repeated int64 Forward;<br>&#125;<br>repeated group Name &#123;<br>repeated group Language &#123;<br>required string Code;<br>optional string Country;<br>&#125;<br>optional string Url;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个Schema可以表示成下面的树状结构：</p><p>考虑现在存在符合上面Schema的两份数据，数据如下，我们需要将其保存起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs data">--Data 1:<br>DocId: 10<br>Links:<br>Forward: 20<br>Forward: 40<br>Forward: 60<br>Name:<br>Language:<br>Code: &#x27;en-us&#x27;<br>Conutry: &#x27;us&#x27;<br>    Language:<br>        Code: &#x27;en&#x27;<br> Url: &#x27;http://A&#x27;<br>Name:<br>Url: &#x27;http://B&#x27;<br>Name:<br>Language:<br>Code: &#x27;en-gb&#x27;<br>Country: &#x27;gb&#x27;<br><br>--Data 2:<br>DocId: 20<br>Links:<br>Backward: 10<br>Backward: 30<br>Forward: 80<br>Name:<br>Url: &#x27;http://C&#x27;<br></code></pre></td></tr></table></figure><p>如果将这样的数据按行存储成关系型表，我们应该会得到如下的表结果：</p><table><thead><tr class="header"><th>DocId</th><th>Links.Backward</th><th>Links.Forward</th><th>Name.Language.Code</th><th>Name.Language.Country</th><th>Name.Language.Url</th></tr></thead><tbody><tr class="odd"><td>10</td><td></td><td>20</td><td>'en-us'</td><td>'us'</td><td>'http://A'</td></tr><tr class="even"><td>10</td><td></td><td>20</td><td>'en'</td><td></td><td>'http://A'</td></tr><tr class="odd"><td>10</td><td></td><td>20</td><td></td><td></td><td>'http://B'</td></tr><tr class="even"><td>10</td><td></td><td>20</td><td>'en-gb'</td><td>'gb'</td><td></td></tr><tr class="odd"><td>10</td><td></td><td>40</td><td>'en-us'</td><td>'us'</td><td>'http://A'</td></tr><tr class="even"><td>10</td><td></td><td>40</td><td>'en'</td><td></td><td>'http://A'</td></tr><tr class="odd"><td>10</td><td></td><td>40</td><td></td><td></td><td>'http://B'</td></tr><tr class="even"><td>10</td><td></td><td>40</td><td>'en-gb'</td><td>'gb'</td><td></td></tr><tr class="odd"><td>10</td><td></td><td>60</td><td>'en-us'</td><td>'us'</td><td>'http://A'</td></tr><tr class="even"><td>10</td><td></td><td>60</td><td>'en'</td><td></td><td>'http://A'</td></tr><tr class="odd"><td>10</td><td></td><td>60</td><td></td><td></td><td>'http://B'</td></tr><tr class="even"><td>10</td><td></td><td>60</td><td>'en-gb'</td><td>'gb'</td><td></td></tr><tr class="odd"><td>20</td><td>10</td><td></td><td></td><td></td><td>'http://C'</td></tr><tr class="even"><td>20</td><td>30</td><td></td><td></td><td></td><td>'http://C'</td></tr><tr class="odd"><td>20</td><td></td><td>80</td><td></td><td></td><td>'http://C'</td></tr></tbody></table><p>可以看到，为了表示这种嵌套结构，按行存储的关系表必须将所有的嵌套都进行扁平化，因此这张表一共得到了六列六个字段。但是这会导致相关字段的重复存储，造成冗余，同时会有大量字段为空。而Parquet是按列进行存储的，它仅需要存储对应的最小粒度的原子类型字段即可。对应到Schema的树结构，则仅需要在叶子结点上进行存储即可。下面给出Parquet列式存储模型的示意图：</p><img src="/2023/03/11/Parquet-%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C/%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="列式存储示意图"><h3 id="stripingassembly算法">Striping/Assembly算法</h3><p>按照上面Parquet列式存储的示意图，我们进行存储的时候仅存储Value是不够的，因为仅存储Value，我们无法将其还原成原始的嵌套结构。例如在上面的例子中，观察<code>Name.Language.Code</code>中的三个值，两两比较。如果仅存放Value，我们无法确定这两个Code是属于同一个Name的不同Language，还是属于不同Name的不同Language。</p><p>而为了能够在列式存储的同时完整地保留嵌套结构信息，Parquet使用Striping/Assembly算法。具体来说，在进行列式存储的时候，除了存储每一个具体的value，还同时存储其他信息以供嵌套结构的还原。这些其他信息包括两个数据，RepetitionLevel和Definition Level</p><h4 id="repetiton-level">Repetiton Level</h4><p>对于每个Value，它都有对应的一个RepetitionLevel。该值表示在该字段路径上哪个节点进行了重复。考虑Schema的树状结构，从根节点出发到达该字段有一条路径。对于当前值和前一个值来说，分别可以得到两条路径，这两条路径的最后一个公共节点所处的层级数，就是当前值对应的repetitionlevels，则这个值就是对应的层数。简短一些说，就是当前值所在节点和前一个值所在节点的最近的公共父节点所处的层级。</p><p>考虑上面例子中存储的Forward属性，将所有的ForwadValue映射到树形结构中，可以得到如下的路径：</p><p>由于这个例子的树形结构最多只有4层，因此RepetitionLevel的范围对应第一到第三层，值的范围就是0~2。因此对于第一个20，它没有前一个值，所以RepetitionLevel为0。对于40来说，它和第一个值20，最近公共父节点是Links，所在树的层级是1，因此RepetitionLevel为1。对于60来说也是同样的分析。而对于80来说，它与60的最近公共父节点是Document，因此Repetition Level为0。</p><h4 id="definition-level">Definition Level</h4><p>但是仅有RepetitionLevel是不够的，因为repeated和optional类型的存在，它还无法完全保留嵌套结构信息。因为有可能一条记录中的某一列是没有值的，假设我们不记录这样的值，则会导致本该属于下一条记录的值被当作当前记录的值，从而造成数据结构错误。因此对于这种情况我们需要填充一个占位符来表示。</p><p>DefinitionLevel值的含义表示当前字段路径上有多少个optional或repeated的字段实际进行了定义。这个值只对填充的空值有意义。因为如果是非空值，则表示该值路径上的所有可选字段都已经进行了定义，那么这个值总是等于该路径上所有的Option字段总数。</p><p>考虑上面的<code>Name.Language.Code</code>字段，按照顺序以此在一棵树上列出所有的值路径，同时注意填充空值，因此我们可以得到如下的表示。其中有实际值的字段，DefinitionLevel值均为2，这表示前面的Name和Language字段都出现了。而为空的字段，两者路径上的Name都是有定义的，但是Language没有，因此DefinitionLevel的值为1。</p><blockquote><p>这里需要注意的是，实际上空值是不需要存储的，因为按照DefinitionLevel的特性，只要该值小于路径上DefinitionLevel的最大值，则表示当前值就是一个空值</p></blockquote><p>总结来说，为了得到实际的列式存储模型，对于每个字段，我们需要得到对应值的路径，同时需要注意空值的填充。之后按照定义计算RepetitionLevel与DefinitionLevel。最终，我们可以得到上面例子的最终列式存储模型，如下图所示：</p><img src="/2023/03/11/Parquet-%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png" class="" title="存储结构示例"><h2 id="存储格式">存储格式</h2><p>上面介绍了Parquet使用的数据模型，接下来介绍Parquet的存储格式。Parquet文件是以二进制方式存储，不可以直接读取。在Parquet文件中包含该文件的数据和元数据，即文件是自解析的。</p><p>这里首先介绍一些在HDFS文件系统和Parquet文件中的相关概念：</p><ul><li>HDFS块(Block)：它是HDFS上的最小的副本单位，HDFS会把一个Block存储在本地的一个文件并且维护分散在不同的机器上的多个副本，通常情况下一个Block的大小为256M、512M等。</li><li>HDFS文件(File)：一个HDFS的文件，包括数据和元数据，数据分散存储在多个Block中。</li><li>行组(RowGroup)：按照行将数据物理上划分为多个单元，每一个行组包含一定的行数，在一个HDFS文件中至少存储一个行组，Parquet读写的时候会将整个行组缓存在内存中，所以如果每一个行组的大小是由内存的大小决定的，例如记录占用空间比较小的Schema可以在每一个行组中存储更多的行。</li><li>列块(ColumnChunk)：在一个行组中每一列保存在一个列块中，行组中的所有列连续的存储在这个行组文件中。一个列块中的值都是相同类型的，不同的列块可能使用不同的算法进行压缩。</li><li>页(Page)：每一个列块划分为多个页，一个页是最小的编码的单位，在同一个列块的不同页可能使用不同的编码方式。</li></ul><blockquote><p>并行化的基本单元：</p><ul><li>MapReduce：一个MapReduce任务对应一个文件或者一个Row Group</li><li>IO：任务中的IO以Column Chunk为单位读取</li><li>Encoding ：编码以Page为单位</li></ul></blockquote><p>下图展示了Parquet的文件格式：</p><img src="/2023/03/11/Parquet-%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C/Parquet%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" class="" title="Parquet文件格式"><p>一个文件中可以存储多个行组，文件的首位都是该文件的MagicCode，用于校验它是否是一个Parquet文件，Parquet 文件格式是自解析的，采用thrift 格式定义的文件 schema以及其他元数据信息一起存储在文件的末尾。文件的元数据中包括每一个行组的元数据信息和该文件存储数据的Schema信息。读取的时候首先从文件末尾读取文件元数据信息，再在其中找到感兴趣的Column Chunk信息，并依次读取。文件元数据信息放在文件最后是为了方便数据依序一次性写入。</p><p>Parquet 总共有3种类型的元数据：文件元数据、列（块）元数据和 pageheader 元数据。所有元数据都采用 thrift协议存储。每一页的开始都会存储该页的元数据，在Parquet中，有三种类型的页：数据页、字典页和索引页。数据页用于存储当前行组中该列的值，其中就存储了上面我们在数据模型中介绍过的Value、RepetitionLevel和DefinitionLevel。字典页存储该列值的编码字典，每一个列块中最多包含一个字典页，索引页用来存储当前行组下该列的索引。</p><p>在数据类型方面。Parquet只保留了最精简的部分数据类型，以方便存储和读写。对于其他数据类型，可以使用逻辑类型（LogicalTypes）进行扩展，比如：逻辑类型 strings 就映射为带有 UTF8 标识的二进制byte arrays 进行存储。下面是Parquet中的基本数据类型：</p><ul><li><code>BOOLEAN</code>: 1 bit boolean</li><li><code>INT32</code>: 32 bit signed ints</li><li><code>INT64</code>: 64 bit signed ints</li><li><code>INT96</code>: 96 bit signed ints</li><li><code>FLOAT</code>: IEEE 32-bit floating point values</li><li><code>DOUBLE</code>: IEEE 64-bit floating point values</li><li><code>BYTE_ARRAY</code>: arbitrarily long byte arrays</li></ul><p>总结来说，Parquet存储格式关键点有这几个，首先是Schema信息或者说是元信息存放在文件的尾部；其次是对于数据，会首先按照行进行划分成为多个行组<code>Raw Group</code>，每个行组又包含多个ColumnChunk，每一列的数据都存放在<code>Column Chunk</code>中。而每个ColumnChunk中又包含多个Page，每个Page存放一个Value，以及对应的RepetitionLevel以及Definition Level。</p><h2 id="java读写parquet文件">Java读写parquet文件</h2><h3 id="写文件">写文件</h3><p>为了在Java中完成parquet文件的读写，我们需要引入如下依赖，当然这里的版本可以根据需要进行调整。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.parquet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parquet-hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.12.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们首先介绍parquet文件的写入。首先我们需要创建相关的实体类，这里就以上面的Document为例，创建相关的实体类如下，相关get，set，toString，构造方法等没有列出，仅是展示了相关的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span> &#123;<br>    <span class="hljs-keyword">private</span> Long docId;<br>    <span class="hljs-keyword">private</span> Link link;<br>    <span class="hljs-keyword">private</span> Name name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Link</span> &#123;<br>    <span class="hljs-keyword">private</span> Long backward;<br>    <span class="hljs-keyword">private</span> Long forward;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Name</span> &#123;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> Language language;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Language</span> &#123;<br>    <span class="hljs-keyword">private</span> String code;<br>    <span class="hljs-keyword">private</span> String country;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的一点是这里我们在parquetschema中指定了int64，对应的是Long类型。如果类型不对，后续会出现解析错误的报错。</p><p>之后就开始学习如何写入parquet文件。为了写入文件，首先我们需要定义parquet的schema。下面的方法调用相关API进行schema的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> MessageType <span class="hljs-title function_">getDocumentSchema</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注意定义的层级顺序</span><br>    Types.GroupBuilder&lt;GroupType&gt; linksSchemaBuilder = Types.buildGroup(Type.Repetition.OPTIONAL);<br>    linksSchemaBuilder.repeated(PrimitiveType.PrimitiveTypeName.INT64).named(<span class="hljs-string">&quot;backward&quot;</span>)<br>            .repeated(PrimitiveType.PrimitiveTypeName.INT64).named(<span class="hljs-string">&quot;forward&quot;</span>);<br>    <span class="hljs-type">GroupType</span> <span class="hljs-variable">linksSchema</span> <span class="hljs-operator">=</span> linksSchemaBuilder.named(<span class="hljs-string">&quot;links&quot;</span>);<br><br>    Types.GroupBuilder&lt;GroupType&gt; languageSchemaBuilder = Types.buildGroup(Type.Repetition.REPEATED);<br>    languageSchemaBuilder<br>            .required(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()).named(<span class="hljs-string">&quot;code&quot;</span>)<br>            .optional(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()).named(<span class="hljs-string">&quot;country&quot;</span>);<br>    <span class="hljs-type">GroupType</span> <span class="hljs-variable">languageSchema</span> <span class="hljs-operator">=</span> languageSchemaBuilder.named(<span class="hljs-string">&quot;language&quot;</span>);<br><br>    Types.GroupBuilder&lt;GroupType&gt; nameSchemaBuilder = Types.buildGroup(Type.Repetition.REPEATED);<br>    nameSchemaBuilder.optional(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()).named(<span class="hljs-string">&quot;url&quot;</span>);<br>    nameSchemaBuilder.addField(languageSchema);<br>    <span class="hljs-type">GroupType</span> <span class="hljs-variable">nameSchema</span> <span class="hljs-operator">=</span> nameSchemaBuilder.named(<span class="hljs-string">&quot;name&quot;</span>);<br><br>    Types.<span class="hljs-type">MessageTypeBuilder</span> <span class="hljs-variable">documentSchemaBuilder</span> <span class="hljs-operator">=</span> Types.buildMessage();<br>    documentSchemaBuilder.required(PrimitiveType.PrimitiveTypeName.INT64).named(<span class="hljs-string">&quot;docId&quot;</span>);<br>    documentSchemaBuilder.addFields(linksSchema, nameSchema);<br>    <span class="hljs-keyword">return</span> documentSchemaBuilder.named(<span class="hljs-string">&quot;document&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于Schema定义来说，我们最终需要得到的是一个<code>MessageType</code>类型的对象。可以看到上面有我们属性的方法，例如option，repeated，group等，分别用于构造不同类型的字段。需要注意上面方法中如何对嵌套的Schema进行定义。对上面的方法得到的对象进行输出，我们可以得到如下的结果，可以看到与我们之前的介绍是一致的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">message document &#123;<br>  required int64 docId;<br>  optional group links &#123;<br>    repeated int64 backward;<br>    repeated int64 forward;<br>  &#125;<br>  repeated group name &#123;<br>    optional binary url (STRING);<br>    repeated group language &#123;<br>      required binary code (STRING);<br>      optional binary country (STRING);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种构造Schema的方法是调用相关API，但是对于稍微复杂一些的嵌套数据来说，整个定义过程会非常繁琐，于是还有另外一种方式可以可以进行Schema定义。<code>MesspageTypeParser</code>可以通过给定的字符串来解析出对应的MessageType对象，相较于上面一种方法来说，这种方法更加直观，也更加容易使用。当然其中需要注意的就是对于Schema字符串的书写正确性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> MessageType <span class="hljs-title function_">getDocumentSchemaV2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">MessageType</span> <span class="hljs-variable">messageType</span> <span class="hljs-operator">=</span> MessageTypeParser.parseMessageType(<span class="hljs-string">&quot;message document &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  required int64 docId;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  optional group links &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    repeated int64 backward;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    repeated int64 forward;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  repeated group name &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    optional binary url (STRING);\n&quot;</span> +<br>            <span class="hljs-string">&quot;    repeated group language &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      required binary code (STRING);\n&quot;</span> +<br>            <span class="hljs-string">&quot;      optional binary country (STRING);\n&quot;</span> +<br>            <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;&#125;&quot;</span>);<br>    <span class="hljs-keyword">return</span> messageType;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们已经得到了代表Document的Schema信息，之后就可以进入写入环节。写入parquet文件的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(List&lt;Document&gt; documents, String targetPath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 定义schema</span><br>    <span class="hljs-type">MessageType</span> <span class="hljs-variable">documentSchema</span> <span class="hljs-operator">=</span> getDocumentSchema();<br>    <span class="hljs-comment">// 获取写入对象</span><br>    ParquetWriter&lt;Group&gt; parquetWriter = ExampleParquetWriter.builder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(targetPath))<br>            .withWriteMode(ParquetFileWriter.Mode.OVERWRITE)<br>            .withWriterVersion(ParquetProperties.WriterVersion.PARQUET_1_0)<br>            .withCompressionCodec(CompressionCodecName.SNAPPY)<br>            .withType(documentSchema).build();<br>    <span class="hljs-type">SimpleGroupFactory</span> <span class="hljs-variable">simpleGroupFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGroupFactory</span>(documentSchema);<br>    <span class="hljs-keyword">for</span> (Document document : documents) &#123;<br>        <span class="hljs-comment">// 写入数据</span><br>        <span class="hljs-type">Group</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> simpleGroupFactory.newGroup();<br>        group.add(<span class="hljs-string">&quot;docId&quot;</span>, document.getDocId());<br><br>        <span class="hljs-type">Group</span> <span class="hljs-variable">links</span> <span class="hljs-operator">=</span> group.addGroup(<span class="hljs-string">&quot;links&quot;</span>);<br>        links.add(<span class="hljs-string">&quot;backward&quot;</span>, document.getLink().getBackward());<br>        links.add(<span class="hljs-string">&quot;forward&quot;</span>, document.getLink().getForward());<br><br>        <span class="hljs-type">Group</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> group.addGroup(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">Group</span> <span class="hljs-variable">language</span> <span class="hljs-operator">=</span> name.addGroup(<span class="hljs-string">&quot;language&quot;</span>);<br>        language.add(<span class="hljs-string">&quot;code&quot;</span>, document.getName().getLanguage().getCode());<br>        language.add(<span class="hljs-string">&quot;country&quot;</span>, document.getName().getLanguage().getCountry());<br>        name.add(<span class="hljs-string">&quot;url&quot;</span>, document.getName().getUrl());<br><br>        parquetWriter.write(group);<br>    &#125;<br>    parquetWriter.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先需要获取写入对象，之后就可以进行写入了。同样需要注意这里写入的层级关系。之后我们可以调用测试方法，完成写入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWrite</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">MyParquetWriter</span> <span class="hljs-variable">myParquetWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyParquetWriter</span>();<br><br>    <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Document</span>(<span class="hljs-number">10l</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Link</span>(<span class="hljs-number">20l</span>, <span class="hljs-number">30l</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Name</span>(<span class="hljs-string">&quot;http://A&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Language</span>(<span class="hljs-string">&quot;en&quot;</span>, <span class="hljs-string">&quot;us&quot;</span>)));<br>    ArrayList&lt;Document&gt; documents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    documents.add(document);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader().getResource(<span class="hljs-string">&quot;&quot;</span>).getPath();<br><br>    myParquetWriter.write(documents, path + <span class="hljs-string">&quot;document.parquet&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方法之后，就可以在生成的<code>target/test-classes</code>目录下看见生成的<code>document.parquet</code>文件，以及一个校验文件。我们可以使用前面提到的相关工具来查看parquet文件，例如<code>parquet-tools</code>。利用parquet-tools，我们可以查看新生成的文件，效果如下，可以看到的确是写入成功了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">parquet-tools show .\document.parquet<br>+---------+-----------------------------------------------------------------------------+-------------------------------------------------------------------------------------------+<br>|   docId | links                                                                       | name                                                                                      |<br>|---------+-----------------------------------------------------------------------------+-------------------------------------------------------------------------------------------|<br>|      10 | &#123;<span class="hljs-string">&#x27;backward&#x27;</span>: array([20], dtype=int64), <span class="hljs-string">&#x27;forward&#x27;</span>: array([30], dtype=int64)&#125; | [&#123;<span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;http://A&#x27;</span>, <span class="hljs-string">&#x27;language&#x27;</span>: array([&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;country&#x27;</span>: <span class="hljs-string">&#x27;us&#x27;</span>&#125;], dtype=object)&#125;] |<br>+---------+-----------------------------------------------------------------------------+-------------------------------------------------------------------------------------------+<br></code></pre></td></tr></table></figure><h3 id="读文件">读文件</h3><p>读文件的流程则相对简单，核心代码如下，这里可以按照字段名称进行读取，也可以按照偏移量进行读取。对于其中的Group对象，也可以使用<code>getType</code>等方法获取对应的元信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">GroupReadSupport</span> <span class="hljs-variable">readSupport</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupReadSupport</span>();<br>    ParquetReader.Builder&lt;Group&gt; builder = ParquetReader.builder(readSupport, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(path));<br>    ParquetReader&lt;Group&gt; reader = builder.build();<br><br>    <span class="hljs-type">Group</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> ((line = reader.read()) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">docId</span> <span class="hljs-operator">=</span> line.getLong(<span class="hljs-string">&quot;docId&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">Group</span> <span class="hljs-variable">links</span> <span class="hljs-operator">=</span> line.getGroup(<span class="hljs-string">&quot;links&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">Group</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> line.getGroup(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">backward</span> <span class="hljs-operator">=</span> links.getLong(<span class="hljs-string">&quot;backward&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">forward</span> <span class="hljs-operator">=</span> links.getLong(<span class="hljs-string">&quot;forward&quot;</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">Group</span> <span class="hljs-variable">language</span> <span class="hljs-operator">=</span> name.getGroup(<span class="hljs-string">&quot;language&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(language.getBinary(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">0</span>).getBytes());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">country</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(language.getBinary(<span class="hljs-string">&quot;country&quot;</span>, <span class="hljs-number">0</span>).getBytes());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(name.getBinary(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-number">0</span>).getBytes());<br><br>        System.out.println(<span class="hljs-string">&quot;docId: &quot;</span> + docId);<br>        System.out.println(<span class="hljs-string">&quot;links.backward: &quot;</span> + backward);<br>        System.out.println(<span class="hljs-string">&quot;links.forward: &quot;</span> + forward);<br>        System.out.println(<span class="hljs-string">&quot;name.url: &quot;</span> + url);<br>        System.out.println(<span class="hljs-string">&quot;name.language.code: &quot;</span> + code);<br>        System.out.println(<span class="hljs-string">&quot;name.language.country: &quot;</span> + country);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试代码，读取刚才我们生成的parquet文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">MyParquetReader</span> <span class="hljs-variable">myParquetReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyParquetReader</span>();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader().getResource(<span class="hljs-string">&quot;document.parquet&quot;</span>).getPath();<br>    myParquetReader.read(path);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下，同样可以看到是正确读出了其中的内容。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">docId: 10<br>links.backward: 20<br>links.forward: 30<br>name.url: http://A<br>name.language.code: en<br>name.language.country: us<br></code></pre></td></tr></table></figure><h3 id="读取schema">读取Schema</h3><p>我们同样可以读取parquet中处于文件末尾的元信息，然后解析出相关的schema，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readSchema</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Path</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(path);<br>    <span class="hljs-type">ParquetMetadata</span> <span class="hljs-variable">metadata</span> <span class="hljs-operator">=</span> ParquetFileReader.readFooter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(), file);<br>    <span class="hljs-type">MessageType</span> <span class="hljs-variable">schema</span> <span class="hljs-operator">=</span> metadata.getFileMetaData().getSchema();<br><br>    <span class="hljs-comment">//遍历字段</span><br>    <span class="hljs-keyword">for</span> (Type field : schema.getFields()) &#123;<br>        printField(field);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printField</span><span class="hljs-params">(Type field)</span> &#123;<br>    <span class="hljs-keyword">if</span> (field.isPrimitive()) &#123;<br>        <span class="hljs-comment">//获取基本类型字段名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">typeName</span> <span class="hljs-operator">=</span> field.asPrimitiveType().getPrimitiveTypeName().name();<br>        <span class="hljs-type">OriginalType</span> <span class="hljs-variable">originalType</span> <span class="hljs-operator">=</span> field.asPrimitiveType().getOriginalType();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalName</span> <span class="hljs-operator">=</span> originalType != <span class="hljs-literal">null</span> ? originalType.name() : <span class="hljs-string">&quot;&quot;</span>;<br>        System.out.println(field.getName() + <span class="hljs-string">&quot;:&quot;</span> + typeName + <span class="hljs-string">&quot;:&quot;</span> + originalName);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// groupType</span><br>        <span class="hljs-type">GroupType</span> <span class="hljs-variable">groupType</span> <span class="hljs-operator">=</span> field.asGroupType();<br>        <span class="hljs-keyword">for</span> (Type groupTypeField : groupType.getFields()) &#123;<br>            printField(groupTypeField);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，只有当字段Field是基本字段，我们才能得到相关的基本类型信息，否则需要进一步进行字段的获取。因此这里我们使用了一个递归函数进行字段信息的获取。同样借助刚才生成的<code>document.parquet</code>进行测试，可以得到如下的结果输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">docId:INT64:<br>backward:INT64:<br>forward:INT64:<br>url:BINARY:UTF8<br>code:BINARY:UTF8<br>country:BINARY:UTF8<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://helloyoubeautifulthing.net/blog/2021/01/03/parquet-format/">一文讲透大数据列存标准格式- Parquet | Liam's Blog</a></li><li><ahref="https://cloud.tencent.com/developer/article/1757868">Parquet文件存储格式详细解析</a></li><li><a href="https://parquet.apache.org/docs/overview/">Overview |Apache Parquet</a></li><li><ahref="https://blog.csdn.net/baidu_32377671/article/details/117253718">Java方式对Parquet文件进行文件生成和解析</a></li><li><ahref="https://blog.csdn.net/weixin_42532968/article/details/128957062">parquet-tools工具使用</a></li><li><ahref="https://blog.csdn.net/lk2015/article/details/115448391">java解析parquet文件</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Parquet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAX-RS的介绍与使用</title>
    <link href="/2023/03/01/JAX-RS%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/03/01/JAX-RS%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="jax-rs">JAX-RS</h1><h2 id="简介">简介</h2><p>JAX-RS是Java API for RESTful WebService的缩写，它是在Java中实现RESTful API的通用标准，是一组由JavaEE提供的接口和注解。与传统的 servlet模型相比，JAX-RS提供了一种可行的、更为简便、移植性更好的方式来在Java内实现RESTful服务。JAX-RS提供的一些关键功能部件包括：</p><ul><li>一组用于声明资源类及其所支持数据类型的注释</li><li>一组允许应用程序开发者访问运行时上下文的接口</li><li>用于集成定制内容处理程序的可扩展框架</li></ul><p>与JDBC类似，JAX-RS只是定义了在Java中实现RESTfulAPI的一些标准，但是没有自己实现。具体的实现需要依赖于对应的来源，常见的JAX-RS的实现包括下面一些：</p><ul><li>Apache CXF：是一个开源的Web服务框架</li><li>Jersey：由Sun提供的JAX-RS的参考实现框架，注意提出JAX-RS标准的也是Sun</li><li>RESTEasy：JBoss的实现</li><li>Restlet：由Jerome Louvel和Dave Pawson开发，是最早的REST框架</li><li>ApacheWink：是一个处于Apache软件基金会孵化器中的项目，其服务模块实现了JAX-RS规范</li></ul><h2 id="规范内容">规范内容</h2><p>在JavaEE中包含了JAX-RS中主要使用的接口和注解，它们都位于在包<code>javax.ws.rs.*</code>下。JAX-RS提供了一些标注将资源类或者POJO类封装为Web资源，常用的标注包括：</p><ul><li><p><code>@Path</code>：标注资源类或方法的相对路径，如果标注在方法上，则表示具体的请求路径</p></li><li><p><code>@GET, @PUT, @POST, @DELETE</code>：标注方法使用的HTTP请求的类型，分别对应4 种 HTTP 方法，分别用于检索、更新、创建和删除资源的操作。在RESTfulAPI中，请求方式+请求路径才能唯一定义一个API</p><ul><li><p>若要创建资源，应该使用 POST 方法</p></li><li><p>若要检索某个资源，应该使用 GET 方法</p></li><li><p>若要更改资源状态或对其进行更新，应该使用 PUT 方法</p></li><li><p>若要删除某个资源，应该使用 DELETE 方法</p></li></ul></li><li><p><code>@Produces</code>：标注返回的MIME媒体类型，可以使用枚举类来指定，也可以使用字符串同时指定多种返回类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Produces(MediaType.TEXT_PLAIN)</span><br><br><span class="hljs-meta">@Produces(MediaType.APPLICATION_JSON)</span><br><br><span class="hljs-meta">@Produces(&#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;)</span><br></code></pre></td></tr></table></figure></li><li><p><code>@Consumes</code>：标注可接受请求的MIME媒体类型，使用方式和@Produces相同，含义则正好相反</p></li><li><p>Param相关注解：标注方法的参数来自于HTTP请求的不同位置。在方法参数上标注对应注解之后，参数就能够获取到对应的值</p><ul><li><p><code>@PathParam</code>：标识参数来自于URL的路径</p></li><li><p><code>@QueryParam</code>：标识参数来自于URL的查询参数</p></li><li><p><code>@HeaderParam</code>：标识参数来自于HTTP请求的头信息</p></li><li><p><code>@CookieParam</code>：标识参数来自于HTTP请求的Cookie</p></li><li><p><code>@FormParam</code>：获取Post请求中表单中的数据</p></li><li><p><code>@BeanParam</code>：获取请求参数中的数据，并用实体Bean进行封装</p></li></ul></li><li><p><code>@Context</code>：用于解析上下文参数，通过该注解可以获得UriInfo、ServletConfig、ServletContext、HttpServletRequest、HttpServletResponse和HttpHeaders等信息</p></li></ul><h2 id="jersey的使用">Jersey的使用</h2><p>Jersey是JAX-RS的一种实现，下面简单介绍相关的使用方式。</p><p>首先需要创建一个JavaWeb项目，具体创建方式可以参考<ahref="https://evernorif.github.io/2022/10/05/JavaWeb笔记-2-Tomcat的使用/">JavaWeb笔记(2)-Tomcat的使用-EverNorif</a>。创建好Web项目之后，在<code>pom.xml</code>中引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- JAX-RS --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.ws.rs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.ws.rs-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Jersey 2.34 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish.jersey.containers<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jersey-container-servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.34<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish.jersey.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jersey-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.34<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish.jersey.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jersey-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.34<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish.jersey.inject<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jersey-hk2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.34<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后在<code>web.xml</code>中配置如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jersey-serlvet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.glassfish.jersey.servlet.ServletContainer<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置加载资源类 指定资源所在的包路径 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>jersey.config.server.provider.packages<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>com.syh<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jersey-serlvet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/rest/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中这里需要注意两个配置，第一个就是在<code>servlet</code>标签中的init-param中的value，这里需要设置的我们对应类资源的包。另一个是在<code>servlet-mapping</code>中的<code>url-pattern</code>，后续访问时会使用到这个值。</p><p>配置完成之后，就可以写一个简单的资源类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.syh;<br><br><br><span class="hljs-keyword">import</span> javax.ws.rs.*;<br><br><span class="hljs-meta">@Path(&quot;/message&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><br>    <span class="hljs-meta">@GET</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@POST</span><br>    <span class="hljs-meta">@Path(&quot;/&#123;text&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">postMessage</span><span class="hljs-params">(<span class="hljs-meta">@PathParam(&quot;text&quot;)</span> String text)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;post...&quot;</span>);<br>        System.out.println(text);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这表示我们现在有Message的资源，通过Get方法可以进行访问。启动Web项目之后，则可以访问如下的链接：<code>http://localhost:8080/&lt;context-path&gt;/rest/message</code>，就会得到HelloWorld信息。这里的<code>/rest</code>就是在web.xml中的配置，<code>/message</code>则是在资源类中<code>Path</code>注解的值。同时也可以发送对应的post请求：<code>http://localhost:8080/&lt;context-path&gt;/rest/message/&lt;text&gt;</code>，之后在控制台就会输出对应的text的内容</p><h2 id="结合springboot使用">结合SpringBoot使用</h2><p>在开发Web项目时，我们更多会使用SpringBoot。而在SpringBoot中结合使用JAX-RS，能帮助我们更方便的创建RESTful风格的API。在SpringBoot中引入Jersey的依赖要简单许多，可以直接通过starter进行引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jersey<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引入依赖之后，我们可以创建如下的资源类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.syh.resource;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.ws.rs.GET;<br><span class="hljs-keyword">import</span> javax.ws.rs.Path;<br><span class="hljs-keyword">import</span> javax.ws.rs.Produces;<br><span class="hljs-keyword">import</span> javax.ws.rs.QueryParam;<br><span class="hljs-keyword">import</span> javax.ws.rs.core.MediaType;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Path(&quot;message&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageResource</span> &#123;<br><br>    <span class="hljs-meta">@GET</span><br>    <span class="hljs-meta">@Path(&quot;sayHello&quot;)</span><br>    <span class="hljs-meta">@Produces(MediaType.APPLICATION_JSON)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-meta">@QueryParam(&quot;msg&quot;)</span> String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;get hello: &quot;</span> + msg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success:&quot;</span> + msg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中message表示资源路径，sayHello表示访问路径。</p><p>为了在SpringBoot中使用Jersey，我们需要进行相关的配置。Springboot中对Jersey的配置有三种方式：第一种方式创建一个自定义的ResourceConfig；第二种方式，是返回一个ResourceConfig类型的@Bean，第三种方式，配置一组ResourceConfigCustomizer对象。这里我们使用第一种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.syh.config;<br><br><span class="hljs-keyword">import</span> com.syh.resource.MessageResource;<br><span class="hljs-keyword">import</span> org.glassfish.jersey.server.ResourceConfig;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> javax.ws.rs.ApplicationPath;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ApplicationPath(&quot;resource&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JerseyConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JerseyConfiguration</span><span class="hljs-params">()</span>&#123;<br>        register(MessageResource.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先这个配置类继承了<code>ResourceConfig</code>，并且使用<code>@Configuration</code>进行标注。在这个类中我们需要完成资源类的注册，注册后的资源才能够进行访问。Springboot默认把Jersey的根路径映射在/*上；如果要更改默认的根路径设置，对于自定义的ResourceConfig方式来说，可以在类上面添加一个<code>@ApplicationPath</code>注解即可。当然也可以在application.yaml中添加配置来改变项目的根路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jersey:</span><br>    <span class="hljs-attr">application-path:</span> <span class="hljs-string">resource</span><br></code></pre></td></tr></table></figure><p>至此我们就完成了Jersey在SpringBoot中的结合。启动项目之后，可以访问对应的资源，使用链接<code>http://localhost:8080/resource/message/sayHello?msg=hahaha</code>，这样就能够访问到对应的资源，在控制台中也会打印出对应的提示信息。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://zh.wikipedia.org/wiki/JAX-RS">JAX-RS -wikipedia</a></li><li><ahref="https://www.ibm.com/docs/zh/was/9.0.5?topic=applications-getting-started-jax-rs">IBMJAX-RS 入门</a></li><li><ahref="https://rumenz.com/java-topic/jersey-jax-rs-tutorials/index.html">Jersey(JAX-RS) 教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/121645580">SpringBoot2 整合JAX-RS</a></li><li><ahref="https://blog.csdn.net/weixin_44984676/article/details/113783466">Jersey框架入门学习</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JavaEE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAX-RS</tag>
      
      <tag>Jersey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mock与Mockito</title>
    <link href="/2023/02/25/Mock%E4%B8%8EMockito/"/>
    <url>/2023/02/25/Mock%E4%B8%8EMockito/</url>
    
    <content type="html"><![CDATA[<h1 id="mock">Mock</h1><p>在协同开发过程中，我们经常会遇到这样的场景。我们开发了一个类，这个类的功能是依赖于其他服务的接口，或者第三方的功能模块。但是由于是协同开发，可能其他服务的接口此时还没有实现，而我们需要对实现的类进行单元测试，那可能需要等待其他服务的实现。或者是借助的第三方功能模块非常复杂，每次测试都需要比较长的时间，此时单元测试与开发之间体验就会非常割裂。</p><p>Mock就是用来解决上面的问题的。Mock意为模拟，借助Mock我们可以模拟出所需要的对象，并且可以定义这个对象的行为。Mock可以解决如下问题：</p><ul><li><p>解决依赖问题：在测试一个接口或者功能模块的时候，如果这个接口或者功能模块依赖其他接口或者其他模块，且所依赖的接口或功能模块未开发完毕，那么我们可以使用Mock模拟被依赖的接口，完成目标接口的测试</p></li><li><p>模拟复杂业务的接口：依赖一个非常复杂的业务或者第三方接口，可以直接使用Mock来模拟这个复杂的业务接口，定义它能够返回正确的结果</p></li><li><p>单独测试：在对某个类进行测试的时候，可能会涉及到一些RPC的调用，数据库，缓存操作等，这些外部的依赖我们可以将其模拟Mock掉，达到<strong>单独</strong>测试某个类的效果</p></li><li><p>前后端联调：进行前后端分离编程的时候，前端页面开发需要调用后台的接口，但是后台接口还没有开发完成，那么完全可以借助Mock来模拟后台这个接口返回想要的数据</p></li></ul><h1 id="mockito">Mockito</h1><h2 id="简介">简介</h2><p>Mocito是一个功能强大的Java测试框架。通过Mockito可以创建Mock对象，排除外部依赖对被测试类的干扰。Mocito可以模拟对象，模拟方法的返回值，模拟抛出异常等等，同时也会记录这些模拟方法的调用次数、调用顺序等，从而进行校验，断言程序是否按照我们期望的效果运行。</p><p>在Java中主流的Mock测试工具有Mockito、JMock、EasyMock。其中，SpringBoot默认的测试框架就是Mockito。</p><p>在开始使用Mockito之前，需要介绍几个简单的相关概念：</p><ul><li>Mock对象：在调试期间用来作为真实对象的替代，是<strong>被测试对象所依赖的对象</strong></li><li>Mock测试：在测试过程中，对那些不容易构建的对象用一个虚拟对象来代替测试</li><li>Stub：打桩，为Mock对象的方法指定返回值（可抛出异常），即人为定义Mock对象的行为</li><li>Verify：行为验证，验证指定方法调用情况（是否被调用，调用次数等）</li><li>Assert：断言，判断输出效果是否与我们期望一致</li></ul><h2 id="getting-started">Getting Started</h2><p>为了使用Mocito，我们需要在项目中引入相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Mocito相关依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mockito<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mockito-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--单元测试--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于SpringBoot默认使用Mockito作为测试框架，因此如果我们正在开发的是SpringBoot项目，那么可以通过引入下面的starter来引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面简单描述当前的场景，我们现在已经完成了下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> OtherService otherService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(OtherService otherService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.otherService = otherService;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">plus</span><span class="hljs-params">(Integer integer)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + otherService.complexFunc(integer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在我们的Service，实现的核心方法<code>plus</code>完成的是+1操作。但是它还依赖一个其他的Service，这个Service可能会进行很复杂的运算<code>complexFunc</code>。现在我们需要验证的就是这个+1操作能否正确完成，而不需要验证复杂运算是否能够完成。（实际上我们根本不需要知道复杂运算的逻辑）为了测试，我们可以写如下的单元测试代码（这里使用静态引入方便后续的调用）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mockito;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.jupiter.api.Assertions.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.mockito.Mockito.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">plus</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 需要测试MyService MyService依赖OtherService</span><br><br>        <span class="hljs-comment">// mock一个OtherService</span><br>        <span class="hljs-type">OtherService</span> <span class="hljs-variable">mock</span> <span class="hljs-operator">=</span> mock(OtherService.class);<br>        <span class="hljs-comment">// 进行stub 定义mock出来的otherService对象的行为</span><br>        when(mock.complexFunc(any())).thenReturn(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">myService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyService</span>(mock);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> myService.plus(<span class="hljs-number">3</span>);<br><br>        assertEquals(<span class="hljs-number">2</span>, res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在单元测试代码中，我们首先将外部依赖OtherService对象Mock掉，生成了一个mock对象。之后进行stub，人为定义了复杂运算<code>complexFunc()</code>的行为，也就是这一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">when(mock.complexFunc(any())).thenReturn(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这行代码的含义是，当mock对象调用到<code>complexFunc()</code>方法的时候，无论接收什么样的输入即<code>any()</code>，都返回1。有了这个保障，我们就可以执行需要测试的plus方法，由于无论传入任何值，复杂运算返回都是1，因此如果我们的plus方法正确，那么返回的res就必然是2，于是我们就可以这样断言，也就是代码中的最后一行。之后我们运行单元测试，就会显示测试通过。这就显示我们的plus方法中的核心+1确实是正常工作的，至于复杂逻辑，由于我们mock掉了，它能否正常运行我们是没有测试的，不过这也并不是我们需要关心的事情，我们这里需要测试的就是核心的+1能否正常运行。（这里也可以选择运行<code>run with Coverage</code>），这样会同时显示测试代码覆盖率等。</p><h2 id="更多功能">更多功能</h2><h3 id="when-then">when then</h3><p>在上面的demo中，我们已经展示了stub的一种方式，即使用<code>when().thenReturn()</code>来确定Mock对象的方法调用返回值。实际上类似的方式还有下面一些：</p><ul><li><code>thenThrow(Throwable t)</code>：抛出异常</li><li><code>thenAnswer(Answer&lt;?&gt; answer)</code>：对方法返回进行拦截处理</li><li><code>thenCallRealMethod()</code>：调用方法的真实实现</li></ul><p>下面我们将Mock一个List对象，举例各种方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">mockList</span> <span class="hljs-operator">=</span> mock(ArrayList.class);<br><br><span class="hljs-comment">// 设置方法调用返回值</span><br>when(mockList.add(<span class="hljs-string">&quot;me&quot;</span>)).thenReturn(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 设置方法调用抛出异常</span><br>when(mockList.get(<span class="hljs-number">0</span>)).thenThrow(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>());<br><br><span class="hljs-comment">// 打桩 无返回值的方法</span><br>doNothing().when(mockList).clear();<br><br><span class="hljs-comment">// 对方法返回进行拦截处理</span><br>Answer&lt;String&gt; answer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Answer</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">answer</span><span class="hljs-params">(InvocationOnMock invocationOnMock)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">mock</span> <span class="hljs-operator">=</span> (List) invocationOnMock.getMock();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock.size result =&gt; &quot;</span> + mock.size();<br>    &#125;<br>&#125;;<br>when(mockList.get(<span class="hljs-number">1</span>)).thenAnswer(answer);<br></code></pre></td></tr></table></figure><p>如果Mock对象的某个方法没有被打桩的话，那么调用该方法会返回默认值。</p><blockquote><p>在较低版本的Mockito中，是不允许对static和final方法进行stub，不过在3.4.0版本之后可以Mock静态方法和final方法等，相关依赖在<code>mockito-inline</code>中。</p></blockquote><h3 id="行为与执行顺序验证">行为与执行顺序验证</h3><p>在创建了Mock对象之后，它就会记住所有的交互，于是我们就可以选择性的记录我们感兴趣的交互，包括调用了多少次Mock对象的方法，不同方法之间的执行顺序等。</p><p>行为验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 验证方法被调用了一次</span><br>verify(mock).complexFunc(any());<br><span class="hljs-comment">// 验证方法被调用了至少2次</span><br>verify(mock, atLeast(<span class="hljs-number">2</span>)).complexFunc(any());<br><span class="hljs-comment">// 验证方法被调用了最多3次</span><br>verify(mock,atMost(<span class="hljs-number">3</span>)).complexFunc(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 验证方法没有被调用</span><br>verify(mock,never()).complexFunc(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 指定方法调用超时时间</span><br>verify(mock, timeout(<span class="hljs-number">100</span>)).complexFunc(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 指定时间内需要完成的次数</span><br>verify(mock,timeout(<span class="hljs-number">200</span>).atLeastOnce()).complexFunc(any());<br></code></pre></td></tr></table></figure><p>执行顺序验证，需要从Mock对象中创建InOrder对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 验证同一个对象多个方法的执行顺序</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">List</span> <span class="hljs-variable">mockList</span> <span class="hljs-operator">=</span> mock(List.class);<br>mockList.add(<span class="hljs-string">&quot;first&quot;</span>);<br>mockList.add(<span class="hljs-string">&quot;second&quot;</span>);<br><span class="hljs-keyword">final</span> <span class="hljs-type">InOrder</span> <span class="hljs-variable">inOrder</span> <span class="hljs-operator">=</span> inOrder(mockList);<br>inOrder.verify(mockList).add(<span class="hljs-string">&quot;first&quot;</span>);<br>inOrder.verify(mockList).add(<span class="hljs-string">&quot;second&quot;</span>);<br><br><span class="hljs-comment">// 验证多个对象多个方法的执行顺序</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">List</span> <span class="hljs-variable">mockList1</span> <span class="hljs-operator">=</span> mock(List.class);<br><span class="hljs-keyword">final</span> <span class="hljs-type">List</span> <span class="hljs-variable">mockList2</span> <span class="hljs-operator">=</span> mock(List.class);<br>mockList1.get(<span class="hljs-number">0</span>);<br>mockList1.get(<span class="hljs-number">1</span>);<br>mockList2.get(<span class="hljs-number">0</span>);<br>mockList1.get(<span class="hljs-number">2</span>);<br>mockList2.get(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">final</span> <span class="hljs-type">InOrder</span> <span class="hljs-variable">inOrder1</span> <span class="hljs-operator">=</span> inOrder(mockList1, mockList2);<br>inOrder1.verify(mockList1).get(<span class="hljs-number">0</span>);<br>inOrder1.verify(mockList1).get(<span class="hljs-number">2</span>);<br>inOrder1.verify(mockList2).get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="spy监控">Spy监控</h3><p>我们可以为真实的依赖对象创建一个Spy对象。这个对象与上面的Mock对象存在一定的区别。</p><p>Mock对象是对真实对象的完全Mock，我们创建的Mock对象与真实对象无关，我们可以对Mock对象的方法进行打桩，人为指定对应的返回值。而没有打桩的方法，则是默认的返回值。我们可以基于接口、实现类创建Mock对象。</p><p>Spy对象则是对真实对象的部分Mock，它是基于真实对象的。我们同样可以对对应的方法进行打桩。但是没有打桩的方法，走的是真实对象的实现。因此我们只能基于实现类来创建Spy对象，因为否则在调用没有打桩的方法时走真实实现的时候会出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;Object&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>LinkedList&lt;Object&gt; spy = spy(linkedList);<br><br>spy.add(<span class="hljs-string">&quot;one&quot;</span>);<br>spy.add(<span class="hljs-string">&quot;two&quot;</span>);<br><br><span class="hljs-comment">// 对get(0)打桩</span><br>when(spy.get(<span class="hljs-number">0</span>)).thenReturn(<span class="hljs-string">&quot;1_stub&quot;</span>);<br>System.out.println(spy.get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// stub实现：1_stub</span><br>System.out.println(spy.get(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 真实实现：two</span><br></code></pre></td></tr></table></figure><h3 id="注解简化">注解简化</h3><p>在前面的介绍中，我们都是使用<code>mock()</code>或<code>spy()</code>方法来进行Mock对象或Spy对象的创建。事实上我们可以通过相关注解来管理Mock对象的创建。我们可以将外部依赖对象放在成员变量中，然后使用<code>@Mock</code>或者<code>@Spy</code>进行修饰，这就表示我们需要将这个对象创建为Mock对象或Spy对象。注解的使用需要首先开启，即第一步执行下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">MockitoAnnotations.openMocks(<span class="hljs-built_in">this</span>);<br></code></pre></td></tr></table></figure><p>由于每个单元测试方法是单独执行的，并且都需要开启注解，所以我们可以将注解的开启放在所有测试方法的前面，即实现一个<code>setUp</code>方法，其中完成注解功能开启。以下是使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationTest</span> &#123;<br><br>    <span class="hljs-meta">@Mock</span><br>    <span class="hljs-keyword">private</span> OtherService otherService;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span>&#123;<br>        MockitoAnnotations.openMocks(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMyService</span><span class="hljs-params">()</span>&#123;<br>        when(otherService.complexFunc(<span class="hljs-number">1</span>)).thenReturn(<span class="hljs-number">2</span>); <span class="hljs-comment">// stub</span><br>        System.out.println(otherService.complexFunc(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 2</span><br>        System.out.println(otherService.complexFunc(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 0(默认值)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html">Mockito(Mockito 5.1.1 API) (javadoc.io)</a></li><li><ahref="https://juejin.cn/post/7202666869965520952">手把手教你Mockito的使用- 掘金 (juejin.cn)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>Mockito</tag>
      
      <tag>UnitTest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala中的Option</title>
    <link href="/2023/02/22/Scala%E4%B8%AD%E7%9A%84Option/"/>
    <url>/2023/02/22/Scala%E4%B8%AD%E7%9A%84Option/</url>
    
    <content type="html"><![CDATA[<h1 id="空值处理背景">空值处理背景</h1><p>在Java中，空值被定义为<code>null</code>。这是一个特殊的关键字，用来表示某个引用为空。正是因为这只是一个关键字，而不是一个对象，因此用它调用任何方法都是非法的。但是仔细思考，这一点实际上存在不合理的地方，我们明明希望返回的是一个对象，可是返回的却是一个关键字。</p><p>于是在Scala中，使用<code>Option</code>对象来对这一现象进行处理。Option类表示的是那种可能存在，也可能不存在的值，对应到Java中，就是说这个值可能为null。但是由于使用Option进行了一层包装，无论值是否存在，返回的都是一个对象，可以进行方法调用。一个很好的编程习惯是当方法的返回值有可能为null的时候，都使用Option对象来代替。</p><h1 id="option">Option</h1><p>为了使得一切皆对象的目标更加一致，Scala鼓励在变量和函数返回值可能不会引用任何值的时候使用Option类型。在没有值的时候，使用None；在有值的时候，则使用Some来包装这个值。</p><p><code>Option[T]</code>是一个带泛型的类，我们可以将其看作是一个包装了某个值的容器。<code>Some</code>和<code>None</code>都是Option的子类。Some是一个class，表示有值；None是一个object，表示没有值。Some和None都可以调用<code>isEmpty</code>以及<code>get</code>方法：</p><ul><li>在调用isEmpty方法的时候，Some返回false，而None返回true</li><li>在调用get方法的时候，Some返回对应被包装的value，而None会抛出<code>NoSuchElementException</code>错误</li></ul><p>因此我们在接收一个Option对象之后，应该通过调用<code>isEmpty</code>来判断是否为空，然后选择如何处理。通过下面的例子，我们可以更好地理解<code>Option</code>的使用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toInt</span></span>(in: <span class="hljs-type">String</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Some</span>(<span class="hljs-type">Integer</span>.parseInt(in.trim))<br>    &#125; <span class="hljs-keyword">catch</span> &#123;<br>      <span class="hljs-keyword">case</span> e: <span class="hljs-type">NumberFormatException</span> =&gt; <span class="hljs-type">None</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们定义了一个将字符串转化为Int的函数，这个函数的返回值是有可能不存在的，因此我们将返回值定义为Option的形式。如果解析成功，能够返回，那么就使用Some进行包装，否则就返回None。</p><p>要使用这个函数，则需要在使用结果之前进行判断：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> maybeInt = toInt(<span class="hljs-string">&quot;123&quot;</span>)<br><span class="hljs-keyword">if</span>(maybeInt.isEmpty)&#123;<br>  println(<span class="hljs-string">&quot;not a Int&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  println(maybeInt.get)<br>&#125;<br></code></pre></td></tr></table></figure><p>而借助于Scala中强大的模式匹配，我们也可以通过下面的方式来处理：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> maybeInt = toInt(<span class="hljs-string">&quot;xxx&quot;</span>)<br>maybeInt <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(i) =&gt; println(i)<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; println(<span class="hljs-string">&quot;not a Int&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>简单总结Option的使用，就是将我们需要返回的实际值使用Option进行包装，其中泛型指定为对应的类型。当正常返回值的时候，使用Some进行包装，异常的时候则直接返回None。Option类型的值通常作为Scala集合类型操作的返回类型。</p><p>使用Option的好处在于返回了一个统一的对象，无论真实值是否存在，都能够进行方法的调用。在Java中，我们可以利用<code>!= null</code>来进行空值的处理，但是如果一个不小心没有处理到，就很容易出现NullPointException异常，并且出现异常之后，问题排查是一个比较难的问题。另一方面，一个Java方法是否会返回空值无法通过返回值看出来，只能通过看相关文档。而Scala的Option类型可以避免这种情况，使用Option类型就表示这个地方可能返回None。</p><p>Option类型本身还有一些相关的方法，列举如下：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>def get: A</td><td>获取对应的值</td></tr><tr class="even"><td>def getOrElse(B): A</td><td>获取对应的值，如果是None则返回默认值</td></tr><tr class="odd"><td>def isEmpty: Boolean</td><td>检查是否为None，是返回true，否则返回false</td></tr><tr class="even"><td>def isDefined: Boolean</td><td>与上面相反，检查是否为Some。是返回true，否则返回false</td></tr></tbody></table><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://blog.csdn.net/Android_xue/article/details/119972710">Scala中如何优雅的处理Null</a></li><li><a href="https://www.runoob.com/scala/scala-options.html">ScalaOption | 菜鸟教程 (runoob.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sbt构建工具</title>
    <link href="/2023/02/22/sbt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/02/22/sbt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="sbt">sbt</h1><h2 id="简介">简介</h2><p>sbt是一个简单的项目构建工具，类似于Maven。SBT是Simple BuildTool的首字母缩写，而因为我们多用其来构建Scala项目，所以另一种说法是ScalaBuildTool。在当前的情况下，Maven多用于Java项目的构建，而sbt则面向scala项目。</p><p>sbt的官网为<ahref="https://www.scala-sbt.org/index.html">scala-sbt.org</a>，其中很容易找到下载的界面。在下载之前首先需要准备好Java环境。下载好压缩包，之后解压到对应的路径，并配置好相关的环境变量<code>$SBT/bin</code>即可。</p><p>配置好环境变量之后，可以在命令行中输入<code>sbt --version</code>查看当前sbt的版本。</p><h2 id="getting-started">Getting Started</h2><p>安装好了sbt之后，我们就可以构建一个简单的scala项目。sbt构建项目同Maven一样对项目目录有一定的要求。sbt除了会检查在项目根目录下的文件之外，也与Maven一样，会检查以下路径中的文件：</p><ul><li><code>src/main/scala</code>或<code>src/main/java</code>中的源文件</li><li><code>src/test/scala</code>或<code>src/test/java</code>中的测试文件</li><li><code>src/main/resources</code>或<code>src/test/resources</code>中的数据文件</li><li><code>lib</code>中的jar文件</li></ul><p>那么我们现在可以构建如下目录的项目，目录结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">sbt-test<br>- src<br>- main<br>- scala<br>- hello.scala<br></code></pre></td></tr></table></figure><p>在源文件目录下的<code>hello.scala</code>中是一个简单的scalaObject：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) = &#123;<br>        println(<span class="hljs-string">&quot;Hello,sbt!&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在命令行中进入项目目录，执行<code>sbt</code>命令，就会进入到sbt的交互式命令行模式。然后执行<code>run</code>命令，sbt就会自动扫描找到对应的入口方法并执行，像上面的项目，执行的效果就是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sbt:sbt-test&gt; run<br>[info] running Hello <br>Hello,sbt!<br></code></pre></td></tr></table></figure><p>在执行完命令之后，在项目目录下会出现两个新目录，分别是<code>/project</code>和<code>/target</code>。在<code>project</code>目录下会生成一个<code>build.properties</code>文件，其中指定了sbt的版本。修改这个文件中的内容可以强制指定需要使用的sbt版本。虽然sbt在不同的release版本中是基本兼容的，但是在<code>/project/build.properties</code>中设置sbt的版本仍然能够避免一些潜在的混淆情况。</p><h2 id="常用命令">常用命令</h2><p>下面是一些常用的sbt命令：</p><table><thead><tr class="header"><th>命令</th><th>命令功能</th></tr></thead><tbody><tr class="odd"><td><code>clean</code></td><td>删除所有生成的文件 （在 <code>target</code> 目录下）</td></tr><tr class="even"><td><code>compile</code></td><td>编译源文件（在 <code>src/main/scala</code> 和<code>src/main/java</code> 目录下）</td></tr><tr class="odd"><td><code>test</code></td><td>编译和运行所有测试</td></tr><tr class="even"><td><code>console</code></td><td>进入到一个包含所有编译的文件和所有依赖的 classpath 的 Scalashell中</td></tr><tr class="odd"><td><code>run &lt;参数&gt;*</code></td><td>执行项目的 main class</td></tr><tr class="even"><td><code>package</code></td><td>将 <code>src/main/resources</code> 下的文件和<code>src/main/scala</code> 以及 <code>src/main/java</code> 中编译出来的class 文件打包成一个 jar 文件</td></tr><tr class="odd"><td><code>help &lt;命令&gt;</code></td><td>显示指定的命令的详细帮助信息。如果没有指定命令，会显示所有命令的简介</td></tr><tr class="even"><td><code>reload</code></td><td>重新加载构建定义（<code>build.sbt</code>，<code>project/*.scala</code>， <code>project/*.sbt</code>这些文件中定义的内容)。在修改了构建定义文件之后需要重新加载</td></tr></tbody></table><h2 id="构建设置">构建设置</h2><p>在Maven中，我们构建项目的配置会放在根目录的<code>pom.xml</code>文件中。而在sbt中，承担这一角色的是项目根目录下的<code>build.sbt</code>文件。<code>.sbt</code>后缀的文件使用的是兼容Scala的特殊语法。</p><p>在项目的基础目录中存在 <code>build.sbt</code>。而其他的 sbt 文件在<code>project</code> 子目录中。 <code>project</code> 目录中还可以包含<code>.scala</code> 文件，这些文件最后会和 <code>.sbt</code>文件合并共同构成完整的构建设置。</p><p>每个工程实际上都可以对应到一个映射表，这个映射表是众多键值对的集合，这些键值对信息就可以用来描述这个工程。例如我们可以在根目录下的<code>build.sbt</code>文件中输入如下内容：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">name := <span class="hljs-string">&quot;Hello Sbt Project&quot;</span>      <span class="hljs-comment">// 项目名称</span><br><br>organization := <span class="hljs-string">&quot;xxx.xxx.xxx&quot;</span>  <span class="hljs-comment">// 组织名称（包名前缀）</span><br><br>version := <span class="hljs-string">&quot;0.0.1&quot;</span>  <span class="hljs-comment">// 版本号</span><br><br>scalaVersion := <span class="hljs-string">&quot;2.12.1&quot;</span>   <span class="hljs-comment">// 使用的Scala版本号</span><br></code></pre></td></tr></table></figure><p>这就是在settings中指定了项目的名称，版本号等。name和version属性会在项目打包时作为包名的一部分，而organization则会作为包名的前缀。再次进入sbt命令行，可以通过<code>show name</code>来查看当前项目的名称：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sbt:Hello Sbt Project&gt; show name<br>[info] Hello Sbt Project<br></code></pre></td></tr></table></figure><p>同时我们还可以在<code>build.sbt</code>中声明依赖。依赖分为第三方的依赖以及本地jar包的依赖。</p><p>第三方的依赖通常都会提供对应的配置，我们同样可以在<ahref="https://mvnrepository.com/">MavenRepository</a>中找到对应的依赖配置，配置模式如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// resolvers 表示 依赖下载来源</span><br>resolvers += <span class="hljs-string">&quot;xxx&quot;</span> at <span class="hljs-string">&quot;url&quot;</span><br><br>libraryDependencies += <span class="hljs-string">&quot;groupId&quot;</span> % <span class="hljs-string">&quot;artifactId&quot;</span> % <span class="hljs-string">&quot;version&quot;</span> % <span class="hljs-string">&quot;scope&quot;</span><br><br><span class="hljs-comment">// 例如</span><br><span class="hljs-comment">// https://mvnrepository.com/artifact/com.google.code.gson/gson</span><br>libraryDependencies += <span class="hljs-string">&quot;com.google.code.gson&quot;</span> % <span class="hljs-string">&quot;gson&quot;</span> % <span class="hljs-string">&quot;2.9.1&quot;</span><br></code></pre></td></tr></table></figure><p>而本地的依赖我们可以统一将其管理在对应的目录下，例如项目根目录下的<code>/myLib</code>，对应的jar包都放在该目录下，之后在文件中增加如下配置，这里的<code>baseDirectory</code>指的就是项目根目录。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">unmanagedBase := baseDirectory.value / <span class="hljs-string">&quot;myLib&quot;</span><br></code></pre></td></tr></table></figure><p>完成依赖配置之后，就可以运行<code>sbt update</code>命令来进行依赖的下载与配置。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://www.scala-sbt.org/1.x/docs/zh-cn/index.html">Sbt-Docs</a></li><li><ahref="https://www.cnblogs.com/Finley/p/6398446.html">Scala构建工具SBT</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>Scala</tag>
      
      <tag>sbt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gson的相关使用</title>
    <link href="/2023/02/21/Gson%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/02/21/Gson%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="gson">Gson</h1><h2 id="简述">简述</h2><p>Gson是Google提供的一个Java库，它可以用来在Java对象以及Json数据之间进行转换，即可以Java对象转化成一个json的表示形式，也可以将json字符串转化为对应等效的Java对象。</p><h2 id="相关使用">相关使用</h2><p>首先需要引入相关的Maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Gson的解析功能主要是通过Gson对象来完成的。而Gson对象的生成有两种方式，一种是直接new生成一个对象，另一种是通过GsonBuilder来构建一个Gson对象。前者相当于提供一个默认的Gson的对象，而后者可以提供更多的配置，通过调用配置方法来进行设置，最后调用<code>create</code>方法来创建出Gson对象。</p><p>有了Gson对象之后，我们就可以调用其中的核心方法，分别是将对象转化为字符串的<code>toJson()</code>以及将字符串转化为对象的<code>fromJson()</code>。下面是简单的使用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> gson.toJson(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">18</span>));<br>System.out.println(json); <span class="hljs-comment">// &#123;&quot;name&quot;:&quot;xxx&quot;,&quot;age&quot;:18&#125;</span><br><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> gson.fromJson(<span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;xxx\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>, User.class);<br>System.out.println(user.getName()); <span class="hljs-comment">// xxx</span><br>System.out.println(user.getAge()); <span class="hljs-comment">// 18</span><br></code></pre></td></tr></table></figure><p>对于这里转换的类与对象，官方文档中有如下的几点提示：</p><ol type="1"><li>在类中允许使用<code>private</code>的属性，这也是推荐使用的方式</li><li>不需要使用注解来指示包含或者不包含哪些字段，默认会包含当前类以及所有superclass中的所有字段</li><li><code>transient</code>修饰的字段不会被json序列化或者反序列化</li><li>空值的处理逻辑分为<code>toJson</code>和<code>fromJson</code>，默认如下：<ul><li><code>toJson</code>：空值跳过，不输出</li><li><code>fromJson</code>：空值处理为类中的null</li></ul></li><li>编译器创建的字段不会被序列化或者反序列化，这类字段一般是是带<code>$</code>符号的</li></ol><p>数组和集合则可以使用如下的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br>String[] strArr = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> gson.toJson(strArr);<br>System.out.println(json);<br><br>String[] strings = gson.fromJson(<span class="hljs-string">&quot;[\&quot;a\&quot;,\&quot;b\&quot;,\&quot;c\&quot;,\&quot;d\&quot;,\&quot;e\&quot;]&quot;</span>, String[].class);<br><br><span class="hljs-keyword">for</span> (String string : strings) &#123;<br>    System.out.println(string);<br>&#125;<br></code></pre></td></tr></table></figure><p>集合的相关使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><br>Integer[] ints = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>Collection&lt;Integer&gt; lists = Arrays.asList(ints);<br><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> gson.toJson(lists);<br>System.out.println(json);<br><br><span class="hljs-type">Type</span> <span class="hljs-variable">collectionType</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;Collection&lt;Integer&gt;&gt;()&#123;&#125;.getType();<br><span class="hljs-comment">// Collection list1 = gson.fromJson(&quot;[1,2,3,4,5]&quot;, lists.getClass());</span><br><span class="hljs-comment">// 这样使用会直接报错</span><br>Collection&lt;Integer&gt; list2 = gson.fromJson(<span class="hljs-string">&quot;[1,2,3,4,5]&quot;</span>,collectionType);<br></code></pre></td></tr></table></figure><p>注意这里的反序列化中类型Type的指定。由于在Java中存在泛型擦除的特性，我们无法直接通过<code>getClass</code>获取到指定的Class对象，而是需要通过其他方式获取到对应的Type。Type本身是一个接口，无法直接通过new得到，这就需要使用到Gson提供的一个<code>TypeToken</code>工具。这里需要注意的是，TypeToken的构造方法被protected修饰，在IDEA中无法通过智能提示选中，我们需要手动import对应的路径<code>import com.google.gson.reflect.TypeToken;</code></p><p>TypeToken的使用就是上面的一行代码。在TypeToken中提供一个getType()方法，我们需要通过这个方法来获取到Type。但是由于TypeToken的构造方法是protected的，限定了只能由子类来访问。因此我们这里实际上是构造了一个匿名内部类，这个内部类继承了TypeToken，从而能够初始化，然后调用getType()。</p><p>当然不只是集合，在其他使用到泛型的地方，也都需要利用上面类似的方式来进行泛型类型的指定，例如我们构造了一个泛型的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &lt;T&gt;&#123;<br>    T value;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们需要进行json的序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><br><span class="hljs-type">Type</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;Foo&lt;User&gt;&gt;() &#123;&#125;.getType();<br><br>Foo&lt;User&gt; foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">18</span>));<br><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> gson.toJson(foo, type);<br>System.out.println(json);<br><br>Foo&lt;User&gt; foo1 = gson.fromJson(<span class="hljs-string">&quot;&#123;\&quot;value\&quot;:&#123;\&quot;name\&quot;:\&quot;xxx\&quot;,\&quot;age\&quot;:18&#125;&#125;&quot;</span>, type);<br>System.out.println(foo1);<br></code></pre></td></tr></table></figure><p>在Gson中，<code>toJson(obj)</code>在默认情况下会调用<code>obj.getClass()</code>来获取类型信息。但是有时候由于泛型擦除无法获取到对应的类型信息，此时我们可以通过上面的方式来获取到对应的Type，然后直接在方法内部指定。</p><blockquote><p>在Scala中也可以使用Gson，不过在Scala中我们可以直接利用classof来获取对应的类型，包括泛型。</p></blockquote><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://blog.csdn.net/wangmx1993328/article/details/84385548">GoogleGson API 介绍与使用</a></li><li><a href="https://sites.google.com/site/gson/gson-user-guide">GsonUser Guide</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gson</tag>
      
      <tag>Development</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenAPI,Swagger以及相关工具</title>
    <link href="/2023/02/17/OpenAPI-Swagger%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/02/17/OpenAPI-Swagger%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="openapi">OpenAPI</h1><h2 id="简介">简介</h2><p>在日常的项目开发工作中，经常需要完成API的设计，实现和应用等工作。一个好的习惯是在实际进行代码开发之前就将API的相关信息设计好，否则在开发过程中进行API的返工，将会牵连到各方，造成较大的麻烦。这也就是API优先的设计，指的是API先于实现。因此，我们需要使用一个语言无关的方式来描述API的设计。利用API优先的设计，我们可以避免不必要的API改动，提升开发效率。</p><p>OpenAPI就是这样一种规范，它定义一种标准的，与具体编程语言无关的RESTfulAPI的规范。在这种规范下，人类和计算机都能在不借助其他源代码和文档的前提下，理解同一个API的作用。同时由于API文档遵循标准的规范，也会有很多相关的工具来辅助进行工作，例如代码生成工具，文档展示工具等。</p><p>OpenAPI的项目地址为：<ahref="https://github.com/OAI/OpenAPI-Specification">OpenAPI-Github</a></p><h2 id="文档规范">文档规范</h2><p>设计API的过程实际上就是编写OpenAPI文档的过程，最终结果是一个被各方认可的OpenAPI文档。OpenAPI的文档是一个json或者yaml格式的文件，它遵循一定标准的数据结构，其中描述了API的详细信息。一份OpenAPI文档可以是单个文件也可以被拆分为多个文件，可以使用<code>ref</code>来相互使用。推荐将根OpenAPI文档命名为<code>openapi.json</code>或者<code>openapi.yaml</code>。</p><p>下面将介绍在一个OpenAPI文档中存在的所有数据结构。一个对象中可以包含多个字段，每个字段的值可能是某个字面量，也可能是另一个对象，或者对象列表。</p><h3 id="openapi-对象">OpenAPI 对象</h3><ul><li>OpenAPI 对象：是OpenAPI 文档的根对象<ul><li><code>openapi</code>：string类型，必选。标识当前使用的Open API版本号</li><li><code>info</code>：Info对象，必选。提供API相关的元数据</li><li><code>servers</code>：Server对象数组，提供到服务器的连接信息。默认值为<code>url</code>为<code>/</code>的Server对象</li><li><code>paths</code>：Paths对象，必选。描述API的路径和操作</li><li><code>components</code>：Components对象，其中包含多种结构</li><li><code>security</code>：SecutiryRequirement对象数组，声明API使用的安全机制</li><li><code>tags</code>：Tag对象数组，提供一系列标签</li><li><code>externalDocs</code>：ExternalDocumentation对象，是附加的文档</li></ul></li></ul><h3 id="info-对象">Info 对象</h3><ul><li>Info对象：提供API的元数据，这些元数据可能会被呈现在编辑工具或者文档生成工具中<ul><li><code>title</code>：stirng类型，必选。标识应用的名称</li><li><code>description</code>：string类型。对应用的简单描述</li><li><code>termsOfService</code>：string类型，指向服务条款的URL地址</li><li><code>contact</code>：Contact对象，标识对应的联系人信息</li><li><code>license</code>：License对象，标识对应的证书信息</li><li><code>version</code>：string类型，必选。标识API的版本信息</li></ul></li></ul><h3 id="contact-对象">Contact 对象</h3><ul><li>Contact 对象：联系人信息<ul><li><code>name</code>：string类型，联系人名称</li><li><code>url</code>：string类型，联系人信息的URL地址</li><li><code>email</code>：string类型，联系人的email地址</li></ul></li></ul><h3 id="license-对象">License 对象</h3><ul><li>License 对象：证书信息<ul><li><code>name</code>：string类型，必选。证书名称</li><li><code>url</code>：string类型，证书的URL地址</li></ul></li></ul><h3 id="server-对象">Server 对象</h3><ul><li>Server 对象：标识一个服务器对象<ul><li><code>url</code>：string类型，必选。指向目标主机的URL地址，可以使用模版变量<code>&#123;xxx&#125;</code></li><li><code>description</code>：string类型，简单描述</li><li><code>variables</code>：Map类型，KV分别为string和ServerVariable对象。这些值可以用来替换服务器URL地址内的模板参数</li></ul></li></ul><h3 id="server-variable对象">Server Variable对象</h3><ul><li>Server Variable 对象：Server中URL地址模板变量替换的对象<ul><li><code>enum</code>：string数组类型，一组可以枚举的字符串值，表示允许的可替换选项</li><li><code>default</code>：string类型，必选。在没有指定可替换值时的默认值</li><li><code>description</code>：对变量的简单描述</li></ul></li></ul><h3 id="paths-对象">Paths 对象</h3><ul><li>Paths对象：定义各个API的相对路径以及操作，与Server对象中的URL地址组成完整的URL地址<ul><li><code>/&#123;path&#125;</code>：PathItem对象。这里的字段名表示相对路径，值表示对应API的相关信息</li></ul></li></ul><h3 id="path-item-对象">Path Item 对象</h3><ul><li>Path Item 对象：描述对一个路径可执行的有效操作<ul><li><code>$ref</code>：string类型。指定对此路径定义的外部引用。引用的格式也需要满足PathItem的格式</li><li><code>summary</code>：string类型。对该API的简要总结，描述此路径内包含的所有操作</li><li><code>description</code>：string类型。对该API的详细说明字符串</li><li><code>get</code>：Operation 对象。定义适用于此路径的GET操作</li><li><code>put</code>：Operation 对象。定义适用于此路径的PUT操作</li><li><code>post</code>：Operation 对象。定义适用于此路径的POST操作</li><li><code>delete</code>：Operation对象。定义适用于此路径的DELETE操作</li><li><code>options</code>：Operation对象。定义适用于此路径的OPTIONS操作</li><li><code>head</code>：Operation 对象。定义适用于此路径的HEAD操作</li><li><code>patch</code>：Operation 对象。定义适用于此路径的PATCH操作</li><li><code>trace</code>：Operation 对象。定义适用于此路径的TRACE操作</li><li><code>servers</code>：Server对象数组。此处的server也可使用此路径的所有操作</li><li><code>parameters</code>：Parameter对象。可用于此路径下所有操作的参数列表</li></ul></li></ul><h3 id="operation-对象">Operation 对象</h3><ul><li>Operation 对象：描述对路径的某个操作<ul><li><code>tags</code>：string数组。控制API文档的标签列表，用于逻辑上的分组</li><li><code>summary</code>：string类型，对该操作行为进行简单描述</li><li><code>description</code>：string类型，对该操作行为的详细解释</li><li><code>externalDocs</code>：ExternalDocumentation对象。表示附加的外部文档</li><li><code>operationId</code>：string类型。用于表示此操作的唯一字符串，推荐在命名时符合一般的编程命名习惯</li><li><code>parameters</code>：Parameter对象数组。定义可用于此操作的参数列表</li><li><code>requestBody</code>：RequestBody对象。可用于此操作的请求体</li><li><code>responses</code>：Responses对象，必选。定义执行此操作后可能的响应值列表</li><li><code>callbacks</code>：Map[string,Callback对象]。定义可能出现的回调映射</li><li><code>deprecated</code>：boolean类型。标识此操作是否已经被废弃</li><li><code>security</code>：SecurityRequirement对象数组。声明可用于此操作的安全机制</li><li><code>servers</code>：Server对象数组。定义可以用于此操作的额外的Server数组</li></ul></li></ul><h3 id="parameter-对象">Parameter 对象</h3><ul><li>Parameter对象：描述一个操作参数。一个参数的唯一性由name和location的组合来确定<ul><li><code>name</code>：string类型，必选。参数的名称，区分大小写。</li><li><code>in</code>：string类型，必选。表示参数的位置，可选的值有<code>[query, header, path, cookie]</code></li><li><code>description</code>：string类型。对该参数的简短描述</li><li><code>required</code>：boolean类型。表示该参数是否是必选参数</li><li><code>deprecated</code>：boolean类型。表示该参数是否被弃用</li><li><code>allowEmptyValue</code>：boolean类型，设置是否允许传递空参数</li><li><code>style</code>：String类型。描述根据参数值类型的不同如何序列化参数</li><li><code>explode</code>：boolean类型。表示是否对数组内的值或者对象的键值对生成带分隔符的参数值</li><li><code>allowReserved</code>：boolean类型，表示是否不允许使用<code>%</code>编码保留字符</li><li><code>schema</code>：Schema对象，定义适用于此参数的类型结构</li><li><code>example</code>：Any。不同媒体类型的示例</li><li><code>examples</code>：Map[string,Example对象]。不同媒体类型的示例</li></ul></li></ul><h3 id="components-对象">Components 对象</h3><ul><li>Components对象：描述各种文档中的可重用对象。此处定义的组件只有在被其他对象引用后才会产生效果。下面所有Map中value都可以是Reference对象，表示对外部的引用<ul><li><code>schemas</code>：Map[string,Schema]类型。定义可重用的Schema对象</li><li><code>responses</code>：Map[string,Response]类型。定义可重用的Response对象</li><li><code>parameters</code>：Map[string,Parameter]类型。定义可重用的Parameter对象</li><li><code>examples</code>：Map[string,Example]类型。定义可重用的Example对象</li><li><code>requestBodies</code>：Map[string, RequestBody]类型。定义可重用的Request Body对象</li><li><code>headers</code>：Map[string,Header]类型。定义可重用的Header对象</li><li><code>securitySchemes</code>：Map[string, SecurityScheme]类型。定义可重用的Security Scheme对象</li><li><code>links</code>：Map[string, Link]类型。定义可重用的Link对象</li><li><code>callbacks</code>：Map[string,Callback]类型。定义可重用的Callback对象</li></ul></li></ul><h3 id="external-documentation-对象">External Documentation 对象</h3><ul><li>External Documentation 对象：外部资源文档<ul><li><code>description</code>：对引用外部文档的简短描述</li><li><code>url</code>：string类型，必选。表示外部文档的URL地址</li></ul></li></ul><h3 id="request-body-对象">Request Body 对象</h3><ul><li>Request Body 对象：定义请求体<ul><li><code>description</code>：string类型，对请求体的简要描述</li><li><code>content</code>：Map[string, MediaType对象]，必选。表示请求体的内容。key是一个媒体类型，值是对应的示例数据</li><li><code>required</code>：boolean类型。表示请求体是否应该被包含在请求中，默认值为false</li></ul></li></ul><h3 id="media-type-对象">Media Type 对象</h3><ul><li>Media Type 对象：每种媒体类型对象都有相应的结构和示例来进行描述<ul><li><code>schema</code>：Schema对象。定义此媒体类型的结构</li><li><code>example</code>：Any。媒体类型的示例</li><li><code>examples</code>：Map[string, Example对象]。媒体类型的示例</li><li><code>encoding</code>：Map[string,Encoding对象]。属性名与编码信息的映射</li></ul></li></ul><h3 id="encoding-对象">Encoding 对象</h3><ul><li>Encoding 对象：编码定义。一个编码定义仅适用于一个结构属性<ul><li><code>contentType</code>：string类型。描述对具体属性的Content-Type编码</li><li><code>headers</code>：Map[string,Header对象]。提供附加信息的请求头键值对映射</li><li><code>style</code>：string类型。描述一个属性根据它的类型将会被如何序列化</li><li><code>explode</code>：boolean类型。表示是否对数组内的值或者对象的键值对生成带分隔符的参数值</li><li><code>allowReserved</code>：boolean类型，表示是否不允许使用<code>%</code>编码保留字符</li></ul></li></ul><h3 id="responses-对象">Responses 对象</h3><ul><li>Responses 对象：描述一个操作可能发生的响应的响应码与对应的响应体<ul><li><code>defalut</code>：Response对象。用于描述未被明确声明的HTTP响应码的对应响应</li><li><code>HTTP status Code</code>：Response对象。这里的字段名为HTTP状态码，值为对应的响应</li></ul></li></ul><h3 id="response-对象">Response 对象</h3><ul><li>Response 对象：描述单个响应<ul><li><code>description</code>：string类型，必选。对响应的简短描述</li><li><code>headers</code>：Map[string,Header对象]。HTTP头名称和定义的映射</li><li><code>content</code>：Map[string, MediaType对象]。描述预期的响应content</li><li><code>links</code>：Map[string, Link对象]</li></ul></li></ul><h3 id="callback-对象">Callback 对象</h3><ul><li>Callback 对象：描述回调对象<ul><li><code>&#123;expression&#125;</code>：PathItem对象。用于定义回调请求和响应</li></ul></li></ul><h3 id="example-对象">Example 对象</h3><ul><li>Example 对象：示例对象<ul><li><code>summary</code>：string类型。该示例的简单描述</li><li><code>description</code>：string类型。该示例的详细描述</li><li><code>value</code>：Any。</li><li><code>externalValue</code>：string类型</li></ul></li></ul><h3 id="header-对象">Header 对象</h3><ul><li>Header 对象：Header对象与Paramter 对象基本一致。但是有一定的限制<ul><li>name不能被指定</li><li>in不能被指定</li></ul></li></ul><h3 id="tag-对象">Tag 对象</h3><ul><li>Tag 对象：<ul><li><code>name</code>：string类型，必选。Tag的名称</li><li><code>description</code>：string类型。Tag的简短描述</li><li><code>externalDocs</code>：ExternalDocumentation对象。外部文档</li></ul></li></ul><h3 id="reference-对象">Reference 对象</h3><ul><li>Reference 对象：用于引用规范内部或者外部的对象<ul><li><code>$ref</code>：string类型，必选。用于找到引用的对象位置</li></ul></li></ul><h3 id="schema-对象">Schema 对象</h3><ul><li>Schema 对象：用于定义输入和输出的数据类型<ul><li><code>nullable</code>：boolean类型。是否允许发送null值</li><li><code>discriminator</code>：Discriminator对象</li><li><code>readOnly</code>：boolean类型。声明属性是否为readOnly</li><li><code>writeOnly</code>：boolean类型。声明属性是否为writeOnly</li><li><code>xml</code>：XML对象。</li><li><code>externalDocs</code>：External Documentation对象。外部文档</li><li><code>example</code>：Any。示例</li><li><code>deprecated</code>：boolean类型。是否废弃</li></ul></li></ul><h3 id="discriminator-对象">Discriminator 对象</h3><ul><li>Discriminator 对象：用于辅助序列化，反序列化和校验<ul><li><code>propertyName</code>：string类型，必选。在payload中表示discriminator值属性的名称</li><li><code>mapping</code>：Map[string,string]。在payload中值与schema名称的映射</li></ul></li></ul><h3 id="xml-对象">XML 对象</h3><ul><li>XML 对象：为XML模型定义的元数据对象<ul><li><code>name</code>：string类型。</li><li><code>namespace</code>：string类型。命名空间URL</li><li><code>prefix</code>：string类型。name前缀</li><li><code>attribute</code>：boolean类型。</li><li><code>wrapped</code>：boolean类型。</li></ul></li></ul><h3 id="security-scheme-对象">Security Scheme 对象</h3><ul><li>Security Scheme 对象：用于Operation的Security Scheme<ul><li><code>type</code>：string类型，必选。有效值包括<code>[apiKey, http, oauth2, openIdConnect]</code></li><li><code>description</code>：string类型。简单描述</li><li><code>name</code>：string类型，必选。用于header，query或者cookie的参数名称</li><li><code>in</code>：string类型，必选。APIkey的位置。有效值包括<code>[query, header, cookie]</code></li><li><code>scheme</code>：string类型，必选。用于HTTP Auahorizationscheme的名称</li><li><code>bearerFormat</code>：string类型。用于提示客户端所使用的bearertoken的格式</li><li><code>flows</code>：OAuth Flows对象，必选。包含所支持的FlowTypes的配置信息</li><li><code>openIdConnectUrl</code>：string类型，必选。用于发现OAuth2的配置值</li></ul></li></ul><h3 id="oauth-flows-对象">OAuth Flows 对象</h3><ul><li>OAuth Flows 对象：配置支持的OAuth Flow<ul><li><code>implicit</code>：OAuth Flow对象。OAuth Implicitflow的配置</li><li><code>password</code>：OAuth Flow对象。OAuth Resource Owner Passwordflow的配置</li><li><code>clientCredentials</code>：OAuth Flow对象。OAuth ClientCredentials flow的配置</li><li><code>authorizationCode</code>：OAuth Authroization Codeflow的配置</li></ul></li></ul><h3 id="oauth-flow-对象">OAuth Flow 对象</h3><ul><li>OAuth Flow 对象：OAuth Flow的配置详情<ul><li><code>authorizationUrl</code>：string类型，必选。用于此流程的AuthorizationURL</li><li><code>tokenUrl</code>：string类型，必选。用于此流程的Toke URL</li><li><code>refereshUrl</code>：string类型。用于获取refreshtokens的URL</li><li><code>scopes</code>：Map[string, string]，必选。用于OAuth2 SecurityScheme的scope</li></ul></li></ul><h3 id="security-requirement-对象">Security Requirement 对象</h3><ul><li>Security Requirement 对象：列出执行Operation所需的Security Schemes<ul><li><code>&#123;name&#125;</code>：string数组。</li></ul></li></ul><p>上面列举的是OpenAPI文档中允许存在的所有数据结构，在实际编写过程中，通常并不会全部都有。同时纯手工根据规范编写文档是一件比较耗费力气的事情，事实上也有很多可视化的工具能够帮助我们方便地编写API信息，然后导出成对应的<code>json</code>或<code>yaml</code>文档。下面将会介绍相关的工具。</p><h2 id="相关工具">相关工具</h2><p>与OpenAPI相关的工具有很多，涉及到API开发的各个生命周期。在<ahref="https://openapi.tools">OpenAPI.tools</a>网站中可以看到相关的工具，我们通常使用的有以下几类工具：</p><ul><li>OpenAPI的文本编辑器：例如<ahref="https://stoplight.io/studio">Stoplight</a>，它提供一个网页的编辑器帮助我们快速创建OpenAPI文档</li><li>Mock服务器：例如Prism。这是一个Mock服务器，由于使用相同的规范，因此API的消费者无需等待后台实现，而是可以使用随机的数据来进行前端的测试</li><li>代码生成工具：例如<ahref="https://openapi-generator.tech">openapi-generator</a>。由于API使用的是OpenAPI规范，所以可以据此进行代码生成。API的提供者可以用工具来快速生成代码的骨架</li><li>文档生成工具：例如<a href="https://editor.swagger.io">swaggerUI</a>，它可以将我们的文档展示为对应的网页形式，可读性更高</li></ul><p>还有其他相关的工具，包括OpenAPI文档的验证，文档解析，测试等，在需要使用时可以参考上面提到的工具网站。</p><h1 id="swagger">Swagger</h1><h2 id="简介-1">简介</h2><p>Swagger本身是一个API文档的维护组织，后来成为了OpenAPI标准的主要定义者。OpenAPI就是由这个组织定义并贡献开源的。当然除此之外，Swagger也发布过其他标准，例如Swagger2，Swagger3等，而OpenAPI的版本直接从3.0开始。Swagger2的包名为<code>io.swagger</code>，Swagger3的包名为<code>io.swagger.core.v3</code>。</p><p>除此以外，Swagger还提供了一系列工具，用于生成，描述，调用和可视化RESTful风格的Web服务。这些工具用来帮助实现OpenAPI规范，在API生命周期的不同阶段使用。例如有：</p><ul><li>SwaggerEditor：用于在浏览器中编辑OpenAPI规范，并实时预览文档。当然Swagger编辑器除了能够支持OpenAPI规范，还支持其他规范，如Swagger2.0等</li><li>SwaggerUI：从符合OpenAPI规范的描述文件中生成可视化的文档，使用html进行展示，界面优美，效果直观</li><li>Swagger Codegen：从符合OpenAPI规范的描述文件中生成API客户端代码</li></ul><p>除了使用这些工具之外，在日常的工作中，我们主要也会将Swagge集成到项目中进行使用，例如集成到SpringBoot项目中。所以下面就将介绍Swagger相关工具的使用，以及如何在SpringBoot项目中使用Swagger的相关工具。</p><h2 id="springdoc">SpringDoc</h2><h3 id="概念辨析">概念辨析</h3><p>这里首先需要厘清一些相关概念，Swagger提供了相关工具使我们在API开发的各个阶段更加便捷，但是它本身还是单独分离的工具，是不能直接应用在SpringBoot项目当中的。而SpringFox和SpingDoc就是两个项目，帮助我们在SpringBoot项目中集成Swagger服务。</p><p>SpringFox（<a href="https://springfox.github.io/springfox/">SpringFoxby springfox</a>）是 spring社区维护的一个项目（非官方），它能够帮助使用者将 swagger2 集成到 Spring中。常常用于 Spring中帮助开发者生成文档，并可以轻松的在SpringBoot中使用。它支持多种规范，包括Swagger2，Swagger3，OpenAPI3等。但是该项目目前基本已经停止更新了。</p><p>SpringDoc（<a href="https://springdoc.org/">OpenAPI 3 Library forspring-boot (springdoc.org)</a>）也是 spring社区维护的一个项目（非官方），帮助使用者将Swagger3 集成到 Spring中。同样也可以用来在 Spring中帮助开发者生成文档，并可以轻松的在SpringBoot中使用。相比于SpringFox，SpringDoc虽然只支持OpenAPI3，但是SpringDoc项目目前更加活跃，文档也更加全面。因此这里我们直接使用SpringDoc来集成OpenAPI的支持到SpringBoot项目中。</p><p>SpringDoc完成的功能是通过我们的API代码来生成对应的API文档。我们的API是通过类和方法来实现的。在类和方法上标注对应的注解之后，SpringDoc就可以借助扫描对应的注解来生成API文档，当然使用的是OpenAPI的规范。</p><h3 id="getting-started">Getting Started</h3><p>首先在SpringBoot项目的<code>pom.xml</code>文件中增加SpringDoc的依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后可以写一个简单的API接口，如下所示。可以看到在下面的接口中完成了两个方法，分别提供get和post请求的接口，以及对应的参数内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/getHello/&#123;name&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Get Hello %s&quot;</span>, name);<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/postHello/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">postHello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Post Hello %d&quot;</span>, id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后启动项目，我们可以直接访问对应的链接查看效果。默认情况下我们可以通过访问<code>http://server:port/&#123;context-path&#125;/swagger-ui.html</code>来访问UI界面，如下所示。访问地址可以在项目配置文件<code>application.yaml</code>中进行设置，设置项为<code>springdoc.swagger-ui.path</code>。例如<code>springdoc:swagger-ui:path:/api</code>。不过这只是一个映射，最终还是会被重定向到上面的地址。</p><img src="/2023/02/17/OpenAPI-Swagger%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/swagger-ui.png" class="" title="swagger-ui"><p>可以看到SpringDoc自动为我们生成了前端文档的展示页面，其中包括了我们刚才写的两个接口。包括请求方式，请求参数等。同时点开详细信息，还可以直接模拟调用请求，得到返回结果。</p><p>同时SpringDoc还自动生成了OpenAPI的规范文档，分别提供json和yaml两种格式，可以通过下面的链接进行访问：</p><ul><li>json：<code>http://server:port/context-path/v3/api-docs</code></li><li>yaml：<code>http://server:port/context-path/v3/api-docs.yaml</code></li></ul><h3 id="配置以及常用注解">配置以及常用注解</h3><p>从上面快速开始的案例可以看到，只要我们引入了SpringDoc的依赖，不需要额外添加其他的信息，它就能够自动扫描我们的类代码，生成相关的文档以及UI展示。但是这种展示能够提供的信息还是非常简单和有限的，如果需要更加详细的信息，还需要使用对应的配置类以及相关注解。</p><p>首先是配置类的介绍，在配置类中我们可以提供整个项目的相关信息。可以创建如下的类，首先在主类上标注<code>@Configuration</code>，表示这是一个配置类。之后在其中提供一个方法，返回值为<code>OpenAPI</code>类型，并使用<code>@Bean</code>标注方法，将返回值交由Spring管理。我们可以通过OpenAPI对象的各种方法来指定不同的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenAPIConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OpenAPI <span class="hljs-title function_">openApi</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAPI</span>().info(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>()<br>                .title(<span class="hljs-string">&quot;openapi test title&quot;</span>)<br>                .description(<span class="hljs-string">&quot;test description&quot;</span>)<br>                .version(<span class="hljs-string">&quot;1.0.1&quot;</span>)<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是常用注解的介绍。通过在API实现的不同位置上标注对应注解，我们可以为这个API接口提供相关信息，以生成更加详细的接口文档。</p><ul><li><code>@Tag(name="接口类描述")</code>：标注在Controller类上，表明这是一个Controller</li><li><code>@Operation(summary="接口方法描述")</code>：标注在Controller方法上，表明这是一个API</li><li><code>@Parameters(value=&#123;...&#125;)</code>：标注在Controller方法上，用于注明多个参数信息。<ul><li>其中value的值是一个注解数组，每个元素是<code>@Parameter</code>注解</li></ul></li><li><code>@Parameter(description="参数描述")</code>：可以用在上面的<code>@Parameters</code>的value中，也可以直接标注在Controller方法的参数上</li><li><code>@Schema</code>：可以标注在实体类或者实体类的属性上。如果这个实体类被用作请求的返回类型，则会在生成的文档中进行描述</li></ul><p>下面用常用注解来对之前的简单Controller方法进行描述，用作示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Tag(name = &quot;I am a Hello Controller&quot;, description = &quot;Hello, description&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@Operation(summary = &quot;controller function: get Hello&quot;)</span><br>    <span class="hljs-meta">@Parameters(value = &#123;</span><br><span class="hljs-meta">            @Parameter(name = &quot;p-name&quot;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;/getHello/&#123;name&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Get Hello %s&quot;</span>, name);<br>    &#125;<br><br>    <span class="hljs-meta">@Operation(summary = &quot;controller function: post hello&quot;)</span><br>    <span class="hljs-meta">@PostMapping(&quot;/postHello/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">postHello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-meta">@Parameter(name = &quot;p-id&quot;)</span> Integer id)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Post Hello %d&quot;</span>, id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spring-swagger-codegen">Spring Swagger-CodeGen</h2><p>上面我们已经展示了在项目中集成SpringDoc，让其为我们生成对应的API文档以及UI展示。不过一篇详细的文档，它需要我们利用众多的注解来标识，提供足够的注解信息才能生成。这些注解虽然并不是很复杂，但还是比较繁琐。于是，另一种利用Swagger的思想就是先得到一篇API文档，然后通过这个文档直接辅助生成对应的代码。也就是Swagger提供的SwaggerCodegen服务。</p><p>我们可以将SwaggerCodegen服务集成到SpringBoot项目中，这需要使用swagger-codegen-maven-plugin插件。插件的官方地址为<ahref="https://github.com/swagger-api/swagger-codegen">swagger-api/swagger-codegen(github.com)</a>，其中详细描述了各种配置产生。下面开始介绍插件的相关使用。</p><p>为了使用插件，我们在在<code>pom.xml</code>文件中加入如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.swagger.codegen.v3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-codegen-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.36<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>generate<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">inputSpec</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources/api.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">inputSpec</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">language</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">language</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">configOptions</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">sourceFolder</span>&gt;</span>src/gen/java/main<span class="hljs-tag">&lt;/<span class="hljs-name">sourceFolder</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">configOptions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这就引入的对应的插件。然后执行<code>mvm clean complie</code>，Maven就会执行对应的生命周期，上面的插件对应的生成功能也会在过程中执行。执行完毕之后，就会生成对应的代码。但是需要注意的是，这里只会生成对应的代码，并不会引入相关的依赖。在代码中会使用到其他相关的依赖，还需要我们自己手动引入。</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://openapi.apifox.cn">OpenAPI规范-中文版</a></li><li><ahref="https://blog.csdn.net/weixin_42759726/article/details/111850907">SpringBoot整合Swagger3(OpenAPI3)生成接口文档</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>OpenAPI</tag>
      
      <tag>Swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git基础</title>
    <link href="/2023/02/04/Git%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/02/04/Git%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="git基础">Git基础</h1><h2 id="基础概念">基础概念</h2><p>Git是一种开源的分布式版本控制工具，可以有效、高速地处理项目版本管理。Git的整体工作流程可以表示为下图：</p><img src="/2023/02/04/Git%E5%9F%BA%E7%A1%80/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="" title="Git工作流程"><p>图中分别对应到不同的命令，完成不同的功能。</p><ol type="1"><li>clone：从远程仓库中克隆代码到本地仓库</li><li>checkout：切换到本地仓库的某个分支，进行工作</li><li>add：将代码提交到暂存区</li><li>commit：将暂存区中的内容提交到本地仓库</li><li>pull：从远程仓库中抓取内容到本地仓库，并进行合并</li><li>push：将本地仓库中的代码推送到远程仓库</li></ol><h2 id="基本命令">基本命令</h2><h3 id="仓库初始化">仓库初始化</h3><p>首先需要完成Git的下载，Git的下载地址为：<ahref="https://git-scm.com/download">Git - Downloads(git-scm.com)</a>。在安装完成之后，需要设置用户名称和email地址，这也是每次Git提交使用到的用户信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;xxx&quot;<br>git config --global user.email &quot;xxx&quot;<br></code></pre></td></tr></table></figure><p>这两条命令完成的是全局配置的修改，全局配置对应到用户目录下的<code>.gitconfig</code>文件。</p><p>接下来可以在一个新路径下创建仓库repository，使用初始化命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git init<br></code></pre></td></tr></table></figure><p>创建成功后，会在路径下看到隐藏文件夹<code>.git</code>。</p><h3 id="本地仓库操作">本地仓库操作</h3><p>在Git中，存在仓库，暂存区以及工作区的概念。</p><p>Git工作目录下，对于文件的修改都是在工作区中完成的。修改（增删改）后的文件处于工作区，需要先使用add命令将其添加到暂存区中。暂存区相当于提交到仓库之前的缓冲区，其中的内容需要使用commit命令添加到仓库中，此时才算完成了一次提交。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看修改状态（暂存区+工作区）</span><br>git status<br><br><span class="hljs-comment"># 添加文件到暂存区</span><br>git add 文件名|通配符<br>eg: git add .<br><br><span class="hljs-comment"># 提交暂存到本地仓库</span><br>git commit -m <span class="hljs-string">&quot;一些注释message&quot;</span><br><br><span class="hljs-comment"># 查看提交日志</span><br>git <span class="hljs-built_in">log</span> [option]<br> --all: 显示所有分支<br> --pretty=oneline: 将提交信息显示为一行<br> --abbrev-commit: 使得输出的commitId更加简短<br> --graph: 以图的形式显示<br> <br> <span class="hljs-comment"># 查看到已经删除的提交记录</span><br> git reflog<br> <br> <span class="hljs-comment"># 版本回退</span><br> git reset --hard &lt;commitId&gt;<br></code></pre></td></tr></table></figure><p>一些时候，我们会有一些文件不需要纳入Git的管理，例如一些日志文件，临时文件等。我们可以在工作目录下创建一个名为<code>.gitignore</code>的文件，在其中列出需要忽略的文件模式。</p><h3 id="分支">分支</h3><p>几乎所有的版本控制系统都以某种形式支持了分支。通过使用分支，可以将工作从开发主线上分离开来，进行Bug修改，新功能开发等。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看本地分支</span><br>git branch<br><br><span class="hljs-comment"># 创建本地分支</span><br>git branch 分支名称<br><br><span class="hljs-comment"># 切换当前分支</span><br>git checkout 分支名称<br>git checkout -b 分支名称: 切换到一个不存在的分支（创建并切换）<br><br><span class="hljs-comment"># 合并内容到当前分支</span><br>git merge 分支名称<br><br><span class="hljs-comment"># 删除分支</span><br><span class="hljs-comment"># 不能删除当前分支，只能删除其他分支</span><br>git branch -d 分支名称: 删除前进行检查<br>git branch -D 分支名称: 强制删除<br></code></pre></td></tr></table></figure><p>在进行分支合并的时候，可能会出现分支之间的冲突情况，此时是无法完成分支合并的。需要我们手动在本地完成冲突解决之后，才能进行合并。冲突解决分为三步，首先处理文件中冲突的地方，即决定最终文件内容是什么，之后将解决完冲突的文件加入暂存区（add），最后提交到仓库（commit）。</p><h3 id="远程仓库操作">远程仓库操作</h3><p>操作远程仓库有两种方式，一种是先初始化本地库，然后与已创建的远程库进行对接。另一种是直接从远程仓库克隆代码到本地，直接建立联系。</p><p>我们可以通过命令查看远程仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote<br></code></pre></td></tr></table></figure><p>与远程仓库进行对接的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote add &lt;远端名称&gt; &lt;仓库名称&gt;<br>- 远端名称，默认是origin，取决于远端服务器设置<br>- 仓库路径，需要从远端服务器获取<br></code></pre></td></tr></table></figure><p>增加远程仓库之后，我们仍然是先在本地完成相关操作，提交到本地仓库之后，再进行本地仓库和远程仓库之间的操作，主要包括从远程仓库拉取以及推送到远程仓库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 推送到远程仓库</span><br>git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名]]<br>- 如果远端分支名和本地分支相同，则可以只写本地分支<br>- -f表示强制覆盖<br>- --set-upstream表示推送到远端的同时建立起与远端分支的关联关系<br>- 如果当前分支已经和远端分支关联，则可以直接git push<br><br><span class="hljs-comment"># 查看远端分支与本地分支的关联关系</span><br>git branch -vv<br><br><span class="hljs-comment"># 克隆远程仓库到本地</span><br>git <span class="hljs-built_in">clone</span> &lt;远程仓库路径&gt; [本地目录]<br><br><span class="hljs-comment"># 拉取远程仓库内容</span><br><span class="hljs-comment"># 抓取：将远程仓库中的更新都抓取到本地，但是不进行合并</span><br>git fetch [remote name] [branch name]<br>- 不指定远端名称和分支名，则抓取所有分支<br><span class="hljs-comment"># 拉取：将远程仓库的修改拉到本地并自动进行合并，等同于fetch+merge</span><br>git pull [remote name][branch name]<br></code></pre></td></tr></table></figure><p>如果在同一段时间内，不同用户修改了同一个文件上同一行的内容，此时向远程仓库推送的时候会产生合并冲突。此时需要先拉取远程仓库现在的提交，经过合并，在本地解决冲突之后才能推送到远端分支上。推送操作相当于本地分支的内容合并到远程分支上，也需要解决冲突。</p><h1 id="git-workflow">Git workflow</h1><h2 id="参与远端项目">参与远端项目</h2><p>首先明确一个工作环境，目前我们存在Remote远程仓库，Local本地Git以及Risk本地磁盘：</p><ol type="1"><li>首先使用<code>git clone</code>，将远程仓库中的内容克隆到本地</li><li>使用<code>git checkout -b xxx</code>，切换到一个我们新的feature分支上</li><li>进行代码修改，本地磁盘中的代码发生改变</li><li>修改完成之后，可以使用<code>git diff</code>来查看本地磁盘上的代码与本地Git中的区别</li><li>需要将本地磁盘中的代码与本地Git进行同步，则先使用<code>git add</code>添加到暂存区，然后使用<code>git commit</code>提交到本地仓库</li><li>下一步需要将本地Git中的内容同步到远程仓库中，则使用<code>git push origin xxx</code>命令</li></ol><p>一种常见的情况是，我们在修改代码的过程中，发现远端仓库上main代码发生了变化，我们想要让自己的代码修改在变化后的远端代码上仍然可行，于是需要下面的步骤：</p><ol type="1"><li>使用<code>git checkout main</code>切换回main分支</li><li>将变化后的远端代码同步到本地，使用<code>git pull origin main</code></li><li>然后回到我们自己的feature分支上，<code>git checkout xxx</code></li><li>使用<code>git rebase main</code>命令。这表示在当前分支上，先更新变化的main，然后根据当前分支上的commit进行内容修改，中途可能会出现代码冲突，需要手动处理</li><li>之后将合并且更新过的xxx分支代码提交到远端仓库上</li></ol><p>至此，在远端仓库上会存在一个我们自己的feature分支xxx。</p><ol type="1"><li>我们希望这个分支能够合并到项目的main分支中，则需要发起<code>pull request</code>请求</li><li>之后，项目的负责人决定是否合并，如果决定合并，则使用<code>squash and merge</code>。这表示将xxx分支中的内容合并到main分支中，但是只进行一次commit，这个commit中是xxx中的所有变化。squash完成的是commit数量和结构的修改。如果直接merge，则在main中会一次出现很多的commit。</li><li>我们的xxx分支修改内容被合并到了main分支中，就可以在远端仓库中删除对应xxx分支</li><li>之后在本地，使用<code>git branch -d xxx</code>，删除本地的Git分支</li><li>最后再使用<code>git pull origin main</code>，拉取最新合并后的远端代码</li></ol><p>于是一次代码修改提交以及就此完成，我们得到了更新后的最新代码，在此基础上重复该流程，进行下一个功能的开发。</p><h2 id="分支管理">分支管理</h2><p>在进行企业级项目开发的时候，通常需要多人的协作开发，此时需要遵循一定的分支管理模式。GitFlow是其中一种分支管理模式。在GitFlow上有几个生命周期较长的重要分支：</p><ul><li><code>main</code>：main分支，发布分支，其中的commit记录应该是每次发布或者hotfix</li><li><code>dev</code>：开发分支，记录了所有的开发主线，在每次release之前，应当将dev中的内容合并到main当中</li><li><code>feaute</code>：功能分支，每个功能分支都应该从开发分支中生成，开发完成之后合并到开发分支当中</li></ul><p>当然还有一些其他的分支，例如hot-fix，release等。在GitFlow分支管理模式中，对于分支的合并有较为严格的要求。在功能开发的时候，需要从开发分支中生成Feature分支，开发完成之后合并到dev分支当中。main分支的合并权限应当严格控制，只有在进行release的时候才能进行merge。在这种模式下，可以控制发布版本的错误，但是功能的开发到发布会经过较长的时间，因为要经过相对较长的分支合并过程。</p><p>Trunk BasedDevelopment是另外一种分支管理的方式。这种分支管理将main分支看作开发分支和发布分支，具体来说，每次进行功能开发，都是从main分支上生成的，开发完成之后Feature也都直接合并到main分支当中。每次发布也都是发布main分支。这种分支管理方式的风格更加快速，适合持续交付和持续集成。由于发布的是main分支，因此需要始终保证main分支能够随时release，这就要求Feature开发的时候，在每次merge之前都能够保证这次的merge能够release。这种保证通常是通过自动测试和构建工具提供的，在提出PullRequest之后，就能自动对代码进行测试和构建，提供一份测试报告，包括是否通过，覆盖率等。这样快速的开发方式也能=能够保证每次进行代码review的时候不需要大规模的进行。不过核心点也是需要保证main分支上的代码能够随时release。</p><h1 id="常用解决方案">常用解决方案</h1><h2 id="在mac中忽略.ds_store文件">在Mac中忽略.DS_Store文件</h2><p>在Mac下的每个目录中，都会有一个<code>.DS_Store</code>文件。该文件是用来给Mac存储文件夹的显示信息的，其中包含了一些为系统所需要的元数据。但是这个文件通常不是一个项目必备的，也就不需要将其提交到Git中。在Git中忽略某些文件可以使用<code>.gitignore</code>，我们也可以通过在该文件中添加如下内容表示忽略.DS_Store文件，其中<code>**/</code>表示匹配所有的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">**/.DS_Store<br></code></pre></td></tr></table></figure><blockquote><p>其他的相关匹配含义：</p><ul><li><code>#</code>：表示注释</li><li><code>/</code>：匹配项目的根路径</li><li><code>*</code>：匹配任意个字符，但是不会匹配路径分隔符<code>/</code></li><li><code>?</code>：匹配一个任意字符，但是不会匹配路径分隔符<code>/</code></li><li><code>**/</code>：匹配所有的文件夹</li><li><code>/**</code>：匹配文件夹的所有内容</li></ul></blockquote><p>每个项目都有一个<code>.gitignore</code>，在每个项目中都这样配置当然是可行的。但是这样的确过于麻烦。我们可以将其配置到全局中。首先可以通过<code>git config --list</code>来查看目前的全局配置，实际上这个配置对应的就是<code>~/.gitconfig</code>文件中的内容。</p><p>为了完成全局配置，我们需要首先创建一个文件<code>~/.gitignore_global</code>，然后在其中添加和上面相同的内容，然后对Git进行全局设置，让其忽略<code>.gitignore_global</code>中的所有文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global core.excludesfile ~/.gitignore_global<br></code></pre></td></tr></table></figure><p>这样就将配置设置到了全局，而不需要每个项目都设置一遍了。</p><h1 id="参考资料">参考资料</h1><ol type="1"><li><ahref="https://www.bilibili.com/video/BV19e4y1q7JJ">十分钟学会正确的github工作流，和开源作者们使用同一套流程_哔哩哔哩_bilibili</a></li><li><a href="https://docs.github.com/en">GitHub Documentation</a></li><li><ahref="https://orianna-zzo.github.io/sci-tech/2018-01/mac中git忽略.ds_store文件/">Mac中Git忽略.DS_Store文件| ZHENG Zi'ou (orianna-zzo.github.io)</a></li><li><ahref="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">gitflow-workflow</a></li><li><ahref="https://www.atlassian.com/continuous-delivery/continuous-integration/trunk-based-development">trunk-based-development</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的正则表达式</title>
    <link href="/2022/11/17/Java%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/11/17/Java%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="java中的正则表达式">Java中的正则表达式</h1><h2 id="相关类">相关类</h2><p>Java中正则表达式的相关应用主要集中在包<code>java.util.regex</code>中，并且相关的主要类为<code>Pattern</code>和<code>Matcher</code>。</p><ul><li><code>Pattern</code>：Pattern对象是一个正则表达式的编译表示。它不提供公共的构造方法，而是通过一个Pattern的静态方法来获取Pattern对象，该方法接受一个字符串参数，即为对应的正则表达式。</li><li><code>Matcher</code>：Matcher对象则是用来对输入字符串进行匹配操作的。它也不提供公共的构造方法，获取一个Matcher对象需要通过调用Pattern对象的matcher方法来获得。</li></ul><p>在使用过程中，我们通常是通过Pattern的静态方法获取到Pattern对象之后，再通过该对象的matcher方法获取到Matcher对象。之后相关的匹配操作就是通过Matcher对象来完成的。</p><h2 id="常用方法介绍">常用方法介绍</h2><h3 id="是否能匹配">是否能匹配</h3><p>判断给定的字符串能够匹配正则表达式，使用<code>matches</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;a\\d*b&quot;</span>);<br><span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(<span class="hljs-string">&quot;a123b&quot;</span>);<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">matches</span> <span class="hljs-operator">=</span> matcher.matches();<br>System.out.println(matches); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 如果提供的字符串为a123bc,则没有匹配，返回false</span><br></code></pre></td></tr></table></figure><blockquote><p>matches()和lookingAt()方法否用来尝试匹配一个输入序列模式。它们的不同是前者要求整个序列都匹配，而后者不需要整个序列都匹配，但还是需要从第一个字符开始匹配。</p></blockquote><h3 id="捕获匹配项">捕获匹配项</h3><p>在给定的字符串中捕获所有的匹配项。</p><blockquote><p>这里的正则表达式<code>(?&lt;=)</code>，<code>(?=)</code>表示需要匹配对应模式，但是不包含在结果中。在进行模式匹配的时候有很大的作用。</p><p>例如下面的例子中的<code>(?&lt;=a)\d*(?=b)</code>，则表示匹配开头为a，结尾为b，中间为数字的字符串，但是实际匹配的结果只返回中间的数字</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;(?&lt;=a)\\d*(?=b)&quot;</span>);<br><span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(<span class="hljs-string">&quot;a123ba345bb213c&quot;</span>);<br><br><span class="hljs-keyword">while</span> (matcher.find()) &#123;<br>    System.out.println(matcher.group());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">123<br>345<br></code></pre></td></tr></table></figure><p>这里的<code>find()</code>方法调用之后，会偏移到下一个匹配。然后调用<code>group()</code>方法返回当前匹配的值。该过程类似于迭代器，表示迭代匹配并获取结果。</p><h3 id="匹配索引">匹配索引</h3><p>使用start和end可以获得当前匹配的索引。需要结合<code>find</code>方法一起使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;a\\d*b&quot;</span>);<br><span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(<span class="hljs-string">&quot;a123ba345bb213c&quot;</span>);<br><br><span class="hljs-keyword">while</span> (matcher.find())&#123;<br>    System.out.println(<span class="hljs-string">&quot;start =&quot;</span> + matcher.start());<br>    System.out.println(<span class="hljs-string">&quot;end =&quot;</span> + matcher.end());<br>    System.out.println(<span class="hljs-string">&quot;---&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">start =0<br><span class="hljs-section">end =5</span><br><span class="hljs-section">---</span><br>start =5<br><span class="hljs-section">end =10</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h3 id="文本替换">文本替换</h3><p>文本替换表示将匹配项替换为指定的字符串。相关的方法有<code>replaceFirst</code>和<code>replaceAll</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;(?&lt;=a)\\d*(?=b)&quot;</span>);<br><span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(<span class="hljs-string">&quot;a123ba345bb213c&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> matcher.replaceFirst(<span class="hljs-string">&quot;|first|&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">all</span> <span class="hljs-operator">=</span> matcher.replaceAll(<span class="hljs-string">&quot;|all|&quot;</span>);<br>System.out.println(first);<br>System.out.println(all);<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">a|first|ba345bb213c<br>a|all|ba|all|bb213c<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://www.runoob.com/java/java-regular-expressions.html">Java正则表达式 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://c.runoob.com/front-end/854/">正则表达式在线测试 |菜鸟工具 (runoob.com)</a></li><li><ahref="https://blog.csdn.net/vip/article/details/105180654">正则表达式如何表示以某字符开头和结尾但不包含本身的匹配_VIP的博客-CSDN博客</a></li><li><ahref="https://blog.csdn.net/ysyysjbama/article/details/90523599">java正则表达式获取字符串中所有匹配的内容_ysyysjbama的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot笔记(5)-SpringBoot项目部署</title>
    <link href="/2022/11/17/SpringBoot%E7%AC%94%E8%AE%B0-5-SpringBoot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/11/17/SpringBoot%E7%AC%94%E8%AE%B0-5-SpringBoot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot部署">SpringBoot部署</h1><h2 id="部署">部署</h2><p>SpringBoot的部署非常简单，只需要将项目打成jar包之后运行即可。由于SpringBoot中内置了Tomcat，因此也不需要像JavaWeb项目一样依赖于Tomcat。</p><p>不过使用Maven打包之前需要配置下面的打包插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后使用Maven的clean以及package将项目打成jar包，之后使用<code>java -jar</code>运行对应的jar包即可。启动之后还需要配合nginx等相关软件来实现反向代理，将服务接口向外暴露。</p><h2 id="启停脚本">启停脚本</h2><p>在实际部署过程中，我们通常会使用脚本来完成服务的启动和停止，下面是通用的启停脚本。</p><p>启动脚本内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment">#启动后端springboot</span><br><span class="hljs-comment">#配置相关信息</span><br><span class="hljs-built_in">cd</span> /root/java-course<br>APP_NAME=java-course.jar<br><br><span class="hljs-comment">#后台启动jar包并将输出写入日志</span><br><span class="hljs-built_in">nohup</span> java -jar <span class="hljs-variable">$APP_NAME</span> &gt;&gt; logs/start.log 2&gt;&gt;logs/startError.<span class="hljs-built_in">log</span> &amp;<br><br><span class="hljs-comment">#启动nginx</span><br>/usr/local/nginx/sbin/nginx<br><br><span class="hljs-comment"># sleep 10s后判断包含AppName的线程是否存在</span><br><span class="hljs-built_in">sleep</span> 10<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> $(pgrep -f <span class="hljs-variable">$APP_NAME</span>|<span class="hljs-built_in">wc</span> -l) -eq 0<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start Failed&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start Successed&quot;</span><br><span class="hljs-keyword">fi</span><br><br></code></pre></td></tr></table></figure><p>停止脚本内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment">#关闭后端</span><br><span class="hljs-comment">#指定应用名称</span><br>APP_NAME=java-course.jar<br><br><span class="hljs-comment">#找到包含AppName的进程</span><br>PROCESS=`ps -ef|grep <span class="hljs-variable">$APP_NAME</span>|grep -v grep |awk <span class="hljs-string">&#x27;&#123; print $2&#125;&#x27;</span>`<br><br><span class="hljs-comment">#循环停用进程直到成功</span><br><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">kill</span> -9 <span class="hljs-variable">$PROCESS</span> &gt; /dev/null 2&gt;&amp;1<br><span class="hljs-keyword">if</span> [ $? -ne 0 ];<span class="hljs-keyword">then</span><br><span class="hljs-built_in">break</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">continue</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment">#关闭nginx</span><br>/usr/local/nginx/sbin/nginx -s stop<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Stop Successed&quot;</span><br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://cloud.tencent.com/developer/article/1333889#">SpringBoot应用 打包与部署指南 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis笔记(6)-TypeHandler的使用</title>
    <link href="/2022/11/04/MyBatis%E7%AC%94%E8%AE%B0-6-TypeHandler%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/04/MyBatis%E7%AC%94%E8%AE%B0-6-TypeHandler%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="typehandler">TypeHandler</h1><h2 id="简介">简介</h2><p>MyBaits是一个工作在Java程序与数据库之间的框架，因此会涉及到双方的数据结构，那么一定会处理的一个问题就是Java类型与JDBC类型之间的相互转换。在MyBatis中使用类型处理器TypeHandler来完成这一工作。在设置预处理语句（PreparedStatement）中的参数的时候，使用类型处理器来完成Java类型到JDBC类型的转换，为后续存入数据库做准备；在从结果集取出一个值的时候，也会使用类型处理器完成从JDBC类型到Java类型的转换，为形成Java中的实体类做准备。</p><h2 id="自定义typehandler">自定义TypeHandler</h2><p>MyBatis中提供了一些默认的类型处理器，可以完成一些基本类型的转换。不过对于一些比较复杂的转换逻辑，默认提供的类型处理器无法完成功能，则需要我们自定义实现TypeHandler。</p><p>自定义实现TypeHandler有两种方式，一种是实现<code>org.apache.ibatis.type.TypeHandler</code>接口，另一种是继承一个基本的类<code>org.apache.ibatis.type.BaseTypeHandler</code>。两种方式都需要重写其中固定的抽象方法。</p><p>使用自定义TypeHandler的步骤如下：</p><ol type="1"><li>实现自定义TypeHandler，重写其中的抽象方法</li><li>注册自定义TypeHandler</li><li>在Mapper配置文件中使用自定义TypeHandler</li></ol><p>下面通过一个案例来介绍自定义TypeHandler的使用过程。考虑下面的场景，我们有一个实体类<code>Unit</code>，其中有两个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Unit</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String orderStr;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时我们在数据库中有表格<code>test_unit</code>，内容如下：</p><table><thead><tr class="header"><th>id</th><th>order_num</th></tr></thead><tbody><tr class="odd"><td>1</td><td>1</td></tr><tr class="even"><td>2</td><td>2</td></tr><tr class="odd"><td>3</td><td>3</td></tr><tr class="even"><td>4</td><td>4</td></tr></tbody></table><p>我们希望完成上面表格和实体类之间的映射，其中id属性相互映射，<code>orderStr</code>和<code>order_num</code>也相互映射。并且映射规则如下，在数据库的<code>order_num</code>中存放int类型数字，在实体类中<code>orderStr</code>存放String类型字符串，并且1对应A，2对应B，3对应C。</p><p>如果不做任何配置的话直接利用MyBatis完成映射，是无法完成需求的。我们直接查询数据库中的所有数据为实体，得到如下的结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;orderStr&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;orderStr&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;orderStr&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;orderStr&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>id属性能够完成相互映射因此能够查询得到，但是另外一个属性无法完成映射则查询为空。</p><p>接下来我们需要实现自定义TypeHandler，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MappedJdbcTypes(JdbcType.INTEGER)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTypeHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TypeHandler</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// Java-&gt;DataBase</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParameter</span><span class="hljs-params">(PreparedStatement preparedStatement, <span class="hljs-type">int</span> index, String parameter, JdbcType jdbcType)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;A&quot;</span>.equals(parameter)) &#123;<br>            preparedStatement.setInt(index, <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;B&quot;</span>.equals(parameter)) &#123;<br>            preparedStatement.setInt(index, <span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;C&quot;</span>.equals(parameter)) &#123;<br>            preparedStatement.setInt(index, <span class="hljs-number">3</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            preparedStatement.setInt(index, <span class="hljs-number">4</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">numToString</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;C&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;D&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// DataBase-&gt;Java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getResult</span><span class="hljs-params">(ResultSet resultSet, String name)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> numToString(resultSet.getInt(name));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getResult</span><span class="hljs-params">(ResultSet resultSet, <span class="hljs-type">int</span> index)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> numToString(resultSet.getInt(index));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getResult</span><span class="hljs-params">(CallableStatement callableStatement, <span class="hljs-type">int</span> index)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> numToString(callableStatement.getInt(index));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们需要实现TypeHandler接口，指定泛型为String。这里的泛型对应需要转换的Java实体类类型。之后要实现接口中的抽象方法，抽象方法一共有四个，分别为<code>setParameter</code>方法和<code>getResult</code>的三个重载方法。前者完成的是Java类型到JDBC类型的转换，后者完成的是JDBC类型到Java类型的转换。</p><p>在<code>setParameter</code>方法中，我们需要完成的是将Java类型的参数转化成JDBC类型，之后设置在<code>PreparedStatement</code>中。这里我们完成了对应逻辑，首先获取Java类型的参数，对应形参中的<code>parameter</code>，之后利用<code>setInt</code>方法设置了JDBC类型的参数，完成类型转换。</p><p>在<code>getResult</code>方法中，我们需要完成的是从结果集中取得JDBC类型的参数，三种重载方式对应获取方式的不同，获取到参数后进行处理，返回值就是最终转化为的Java类型。这里我们通过<code>getInt</code>方法获得了JDBC类型的参数，之后根据我们的自定义逻辑将其转化为Java类型并返回。</p><blockquote><p>TypeHandler对应处理的两种类型可以通过以下的方法指定：</p><p>Java类型：</p><ul><li>在类型处理器的配置元素（typeHandler 元素）上增加一个<code>javaType</code>属性（比如：<code>javaType="String"</code>）；</li><li>在类型处理器的类上增加一个 <code>@MappedTypes</code>注解指定与其关联的 Java 类型列表。 如果在 <code>javaType</code>属性中也同时指定，则注解上的配置将被忽略。</li></ul><p>JDBC类型：</p><ul><li>在类型处理器的配置元素上增加一个 <code>jdbcType</code>属性（比如：<code>jdbcType="VARCHAR"</code>）；</li><li>在类型处理器的类上增加一个 <code>@MappedJdbcTypes</code>注解指定与其关联的 JDBC 类型列表。 如果在 <code>jdbcType</code>属性中也同时指定，则注解上的配置将被忽略。</li></ul></blockquote><p>之后我们就可以在Mapper配置文件中使用对应的TypeHandler：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.syh.springboot.mapper.UnitMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;unitMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.syh.springboot.bean.Unit&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderStr&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_num&quot;</span> <span class="hljs-attr">typeHandler</span>=<span class="hljs-string">&quot;com.syh.springboot.handler.MyTypeHandler&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUnit&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;unitMap&quot;</span>&gt;</span><br>        select *<br>        from test_unit<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span>&gt;</span><br>        insert into test_unit<br>        values (#&#123;id&#125;, #&#123;orderStr,typeHandler=com.syh.springboot.handler.MyTypeHandler&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里我们在resultMap中设置映射方式，其中指定使用我们自定义的TypeHandler，之后重新执行select操作，可以得到转化后的结果，发现符合我们的逻辑：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[&#123;<span class="hljs-string">&quot;id&quot;</span>:1,<span class="hljs-string">&quot;orderStr&quot;</span>:<span class="hljs-string">&quot;A&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:2,<span class="hljs-string">&quot;orderStr&quot;</span>:<span class="hljs-string">&quot;B&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:3,<span class="hljs-string">&quot;orderStr&quot;</span>:<span class="hljs-string">&quot;C&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:4,<span class="hljs-string">&quot;orderStr&quot;</span>:<span class="hljs-string">&quot;D&quot;</span>&#125;]</span><br></code></pre></td></tr></table></figure><p>同时我们也可以在执行insert的时候完成转换，只需要在<code>#&#123;&#125;</code>中指定使用对应的TypeHandler即可。这样我们直接执行insert，也能够完成符合我们自定义映射逻辑的转换。</p><h2 id="jsontypehandler">JsonTypeHandler</h2><p>在实际场景中，一种常见的映射方式是，在数据库中存放json字符串，而在Java实体类中准备对应的类型，如列表等。此时我们需要自定义TypeHandler来实现相关功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonTypeHandler</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TypeHandler</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Class&lt;T&gt; type;<br><br>    <span class="hljs-comment">// 获取指定的Type</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JsonTypeHandler</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Type argument cannot be null&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.type = type;<br>    &#125;<br><br>    <span class="hljs-comment">// 将Java实体类参数转换为Json字符串，为存入数据库做准备</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">parseJsonString</span><span class="hljs-params">(T parameter)</span> &#123;<br>        <span class="hljs-keyword">if</span> (parameter == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> JSON.toJSONString(parameter);<br>    &#125;<br><br>    <span class="hljs-comment">// 将Json字符串转化为Java实体类</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-title function_">parseJavaObject</span><span class="hljs-params">(String parameter)</span> &#123;<br>        <span class="hljs-keyword">if</span> (parameter == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (parameter.startsWith(<span class="hljs-string">&quot;[&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> (T) JSON.parseArray(parameter, <span class="hljs-built_in">this</span>.type);<br>        &#125;<br>        <span class="hljs-keyword">return</span> JSON.parseObject(parameter, <span class="hljs-built_in">this</span>.type);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParameter</span><span class="hljs-params">(PreparedStatement preparedStatement, <span class="hljs-type">int</span> i, T t, JdbcType jdbcType)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        preparedStatement.setString(i, parseJsonString(t));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getResult</span><span class="hljs-params">(ResultSet resultSet, String s)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> parseJavaObject(resultSet.getString(s));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getResult</span><span class="hljs-params">(ResultSet resultSet, <span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> parseJavaObject(resultSet.getString(i));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getResult</span><span class="hljs-params">(CallableStatement callableStatement, <span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> parseJavaObject(callableStatement.getString(i));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里我们没有指定实际的泛型，在使用的时候，可以通过标签中<code>javaType</code>来指定。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;images&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;images&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">typeHandler</span>=<span class="hljs-string">&quot;com.course.java.handler.JsonTypeHandler&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://blog.csdn.net/u013727805/article/details/114577397">基于fastjson的mybatis自定义类型处理器JsonTypeHanlder代码示例_ty41232X32的博客-CSDN博客_fastjsonmybatis</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot笔记(4)-整合MyBatis访问数据库</title>
    <link href="/2022/11/03/SpringBoot%E7%AC%94%E8%AE%B0-4-%E6%95%B4%E5%90%88MyBatis%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/11/03/SpringBoot%E7%AC%94%E8%AE%B0-4-%E6%95%B4%E5%90%88MyBatis%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库场景">数据库场景</h1><p>在Web开发过程中，经常会使用到数据库，因此需要引入相关依赖。SpringBoot官方提供了一个启动器，对应数据库场景。我们引入下面的启动器，就可以引入数据库相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不过在导入的依赖中，没有导入数据库的驱动。这也能够理解，SpringBoot并不能预见到我们会使用哪种数据库驱动，因此将导入的主动权交给用户。所以接下来我们需要引入数据库驱动，例如MySQL驱动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在引入驱动的时候我们可以查看一下SpringBoot中配置的默认版本是多少，如果需要修改，可以直接指定version，或者重新设置对应的properties。</p><p>SpringBoot完成数据库场景的自动配置，会涉及到下面一些类：</p><ul><li><code>DataSourceAutoConfiguration</code>：完成数据源的自动配置。对应配置项为<code>spring.datasource</code>，底层默认配置的数据库连接池为<code>HikariDataSource</code></li><li><code>DataSourceTransactionManagerAutoConfiguration</code>：完成事务管理器的自动配置</li><li><code>JdbcTemplateAutoConfiguration</code>：完成JdbcTemplate的自动配置。对应配置项为<code>spring.jdbc</code>。完成自动配置后IOC容器中会管理JdbcTemplate组件，可以使用自动注入<code>@Autowired</code>获取</li><li><code>JndiDataSourceAutoConfiguration</code>：完成JDNI的自动配置</li><li><code>XADataSourceAutoConfiguration</code>：完成分布式事务相关配置</li></ul><p>完成启动器引入之后，我们可以在配置项中指定数据库的连接配置，主要完成连接url、用户名、密码和驱动的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/ssm_data</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123123</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>之后可以使用JdbcTemplate来测试是否能够正常工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/testEmp&quot;)</span><br>    <span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from emp where emp_id = 1&quot;</span>;<br>        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPropertyRowMapper</span>&lt;&gt;(Emp.class));<br>        <span class="hljs-keyword">return</span> emp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SpringBoot默认配置的数据库连接池是HikariDataSource，之前我们使用的一直是Druid，这里也可以进行整合。</p><p>SpringBoot中整合第三方技术的有两种常见的方式，一种是自定义方式，手动将对应的类配置到IOC容器中，这样就底层就会使用我们配置的Bean对象；另一种方式是找到对应的场景启动器starter，这种一般是官方或者第三方提供的解决方案。</p><p>第一种方式，利用自定义方式整合Druid。我们需要先添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后在配置类中提供需要被IOC容器管理的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConfigurationProperties(&quot;spring.datasource&quot;)</span><span class="hljs-comment">//复用配置文件的数据源配置</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">druidDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br><br><span class="hljs-comment">//        druidDataSource.setUrl();</span><br><span class="hljs-comment">//        druidDataSource.setUsername();</span><br><span class="hljs-comment">//        druidDataSource.setPassword();</span><br><br>        <span class="hljs-keyword">return</span> druidDataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方式，使用场景启动器。只需要直接引入相关starter即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="mybatis整合">MyBatis整合</h1><h2 id="配置使用">配置使用</h2><p>在SSM中，DAO层我们使用的是MyBatis框架。我们同样可以在SpringBoot中整合MyBatis。由于MyBaits为我们提供了SpringBoot的场景启动器（<ahref="https://github.com/mybatis/spring-boot-starter">GitHub -mybatis/spring-boot-starter: MyBatis integration with SpringBoot</a>），因此我们直接在项目中引入即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引入启动器之后，SpringBoot会帮助我们完成自动配置。包括全局配置文件、SqlSessionFactory、SqlSession等。</p><p>之后，我们需要在<code>application.yaml</code>配置文件中指定相关配置，除了上面的数据库连接配置之外，还需要配置mybatis规则，包括全局配置文件的位置，mapper配置文件的位置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/ssm_data</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123123</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><br><span class="hljs-comment"># MyBatis规则</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">config-location:</span> <span class="hljs-string">classpath:mybatis/mybatis-config.xml</span> <span class="hljs-comment"># 全局配置文件</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mybatis/mapper/*.xml</span> <span class="hljs-comment"># mapper配置文件</span><br></code></pre></td></tr></table></figure><p>这里的全局配置文件<code>mybatis-config.xml</code>我们只需要准备一个基本结构即可，其中的内容都会由SpringBoot自动进行配置，这里也就不需要我们配置了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后我们就可以按照MyBatis中的开发方式进行开发，完成Mapper接口以及对应的Mapper配置文件，这里的Mapper接口需要使用<code>@Mapper</code>注解标识，才能被SpringBoot管理。据此，我们可以实现如下的Mapper接口和Mapper配置文件。</p><p>Mapper接口<code>UserMapper</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Mapper配置文件<code>UserMapper.xml</code>如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.syh.springboot.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--public User getUser(Integer id)--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.springboot.bean.User&quot;</span>&gt;</span><br>        select * from users where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后可以进行测试，按照三层架构应该分成Contorller和Service层，不过这里我们可以全部写在一起。这里IOC容器中管理了对应接口的代理类，我们可以通过自动注入的方式来获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@GetMapping(&quot;getUser&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userMapper.getUser(<span class="hljs-number">3</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以按照以前的方式，在全局配置文件中进行相关配置，也可以直接在配置文件<code>application.yaml</code>中，利用<code>mybatis</code>属性进行配置。我们也可以直接将配置全部写在其中的<code>configuration</code>中，这里面的值就对应全局配置文件中的值。也就是说，我们配置了<code>mybatis.configuration</code>，就不需要再配置MyBatis全局配置文件了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># MyBatis规则</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mybatis/mapper/*.xml</span> <span class="hljs-comment"># mapper配置文件</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>默认没有开启驼峰转换，这里我们使用配置的方式进行开启。</p><p>总结来说，在SpringBoot中使用MyBatis，我们需要经过下面的步骤：</p><ol type="1"><li>导入MyBatis官方提供的启动器starter</li><li>编写Mapper接口，使用<code>@Mapper</code>注解</li><li>编写Mapper配置文件并绑定对应的Mapper接口</li><li>在<code>application.yaml</code>中指定Mapper配置文件所在的位置，在<code>mybatis.configuration</code>配置相关全局信息</li></ol><h2 id="注解使用">注解使用</h2><p>在MyBatis中我们还可以使用注解来完成SQL与方法映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from emp where emp_id=#&#123;id&#125;&quot;)</span><br>    Emp <span class="hljs-title function_">getEmp</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是提供的一种简化方式，当然也可以利用注解和配置文件结合。简单的操作方法就直接写在注解上，如果复杂的就写在配置文件中。</p><blockquote><p>我们的Mapper接口都需要使用<code>@Mapper</code>注解进行标识，不过我们也可以在启动类上使用<code>@MapperScan("com.syh.springboot.mapper")</code>注解，指明对应Mapper所在的包路径，之后对应包下的Mapper接口就可以不标注<code>@Mapper</code>注解了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot笔记(3)-Web开发基本功能</title>
    <link href="/2022/11/03/SpringBoot%E7%AC%94%E8%AE%B0-3-Web%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/"/>
    <url>/2022/11/03/SpringBoot%E7%AC%94%E8%AE%B0-3-Web%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p>利用SpringBoot，我们可以快速开发一个Web项目。不过SpringBoot本身的功能主要在于简化配置，Web项目中一些核心功能还是由SpringMVC来提供。下面的介绍中有很多是对SpringMVC的复习，可以结合SpringMVC的笔记一起学习。</p><h1 id="静态资源">静态资源</h1><h2 id="静态资源存放与访问">静态资源存放与访问</h2><p>在SpringBoot中，静态资源有默认的存放位置，可选的位置有<code>/static</code>、<code>/public</code>、<code>/resources</code>、<code>/META-INF/resources</code>。注意这里的resources路径是指定名称，而不是IDEA项目下的resources。将静态资源放置在对应位置上后，前端访问需要通过<code>项目根路径名/静态资源名称</code>，而不需要在意默认的存放位置。</p><p>上面是默认的存放位置，当然我们也可以在配置文件中指定对应属性来改变静态资源存放的位置。设置之后，原来默认的位置将会失效。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">static-locations:</span> [<span class="hljs-string">classpath:/haha/</span>]<br></code></pre></td></tr></table></figure><p>实际上，上面的属性对应一个String数组，它的默认值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="hljs-string">&quot;classpath:/resources/&quot;</span>, <span class="hljs-string">&quot;classpath:/static/&quot;</span>, <span class="hljs-string">&quot;classpath:/public/&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><p>默认的访问路径是项目根路径+静态资源名称。这个属性也是能够修改的，对应属性值如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">static-path-pattern:</span> <span class="hljs-string">/haha/**</span><br></code></pre></td></tr></table></figure><p>上面属性对应一个String类型的值，默认值为<code>/**</code></p><blockquote><p>这里静态资源的处理模式就是SpringMVC中的模式。</p><p>在SpringMVC中，我们需要在配置文件中开启<code>&lt;mvc:default-servlet-handler&gt;</code>以及<code>&lt;mvc:annotation-driven&gt;</code>，之后所有的请求会先交给<code>DispatcherServlet</code>进行处理，如果无法处理如静态资源，再交给<code>DefaultServlet</code>处理，如果仍然无法处理则响应404页面。</p><p>由于SpringBoot帮助我们简化了配置，因此可以直接使用。</p></blockquote><p>对于一些css和js资源文件，我们可以使用jar的形式引入，我们称之为webjar（<ahref="https://www.webjars.org/">WebJars - Web Libraries inJars</a>）。例如我们可以通过下面的方式来引入jquery：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这些资源也是作为静态资源引入的，可以通过前端访问得到。需要注意，对应的访问地址需要参照依赖jar包中的包路径。</p><h2 id="欢迎页与图标">欢迎页与图标</h2><p>在SpringBoot中，可以设置index.html欢迎页。有两种方式，第一种是静态资源路径下的index.html，不过此时不能配置静态资源的访问路径，否则会导致index.html不能被默认访问。第二种方式是配置一个Controller能够处理<code>/index</code>的请求，因为欢迎页对应的地址就是项目访问路径+/index。</p><p>另一方面，SpringBoot中能够定义网页图标，只需要将图标名称修改为<code>favicon.ico</code>并将其放在静态资源目录下即可。</p><h1 id="请求处理">请求处理</h1><h2 id="请求映射">请求映射</h2><p>请求处理即通过<code>@RequestMapping</code>注解来设置访问路径与处理器对象之间的映射。在这个注解中可以指定method属性来设置访问方法，也可以使用封装了访问属性的注解，包括<code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>，用于匹配不同的访问方式。</p><blockquote><p>在<ahref="https://evernorif.github.io/2022/10/19/SpringMVC笔记-4-SpringMVC中的RESTful与Ajax/">SpringMVC笔记(4)-SpringMVC中的RESTful与Ajax-EverNorif</a>中我们学习过，如果想要在SpringMVC中发送put和delete方式的请求，需要利用到提供的<code>HiddenHttpMethodFilter</code>类，当时我们使用的方式是在<code>web.xml</code>中进行配置。而在SpringBoot中，默认没有开启该功能，我们需要在配置文件中配置开启：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">hiddenmethod:</span><br>      <span class="hljs-attr">filter:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>这种方式是通过在SpringMVC中发送put和delete方式的请求。不过在前后端分离的场景下，有其他方式能够发送对应请求，那么也无需使用到这里的配置。</p></blockquote><h2 id="参数获取">参数获取</h2><p>参数获取使用的大都是SpringMVC中的注解，详细可以参考SpringMVC的相关笔记，这里只是进行一个小总结：</p><ul><li><p><code>@PathVariable</code>：获取路径变量，即在路径占位符中出现的变量，举例来说对应的映射路径为<code>@RequestMapping("/testRest/&#123;id&#125;/&#123;username&#125;")</code></p></li><li><p><code>@RequestParam</code>：获取请求参数，即出现在url中<code>?</code>后面的参数</p></li><li><p><code>@RequestHeader</code>：获取请求头</p></li><li><p><code>@CookieValue</code>：获取Cookie数据</p></li><li><p><code>@RequestBody</code>：获取请求体数据</p></li><li><p><code>@RequestAttribute</code>：获取Request域的数据</p></li><li><p><code>@MatrixVariable</code>：获取矩阵变量数据</p></li></ul><p>这里需要介绍一下矩阵变量。在url中，我们可以在路径中使用<code>;</code>拼接一些参数，例如<code>/cat;name=haha;age=18</code>，这里出现在分号后面的name和age就是矩阵变量，注解<code>@MatrixVariable</code>就是用来获取这些变量的。</p><p>在SpringBoot中默认禁用了矩阵变量的功能，默认会忽略这部分参数。在SpringBoot中，url解析的功能是由类<code>UrlPathHelper</code>来完成的，在自动配置的IOC容器中也会配置该类。矩阵变量的处理对应其中的<code>removeSemicolonContent</code>，将其设置为true表示忽略参数，设置为false则不忽略。不过需要注意的是，矩阵变量必须有url中路径变量才能被解析。</p><p>由于在SpringBoot的自动配置中，如果对应的类已经由用户配置了，那么SpringBoot就不会自动配置而是会使用用户配置的类，因此我们可以利用这一特性来提供一个<code>UrlPathHelper</code>，开启矩阵变量之后，手动配置到IOC容器中。</p><p>有两种方式，第一种是让配置类实现<code>WebMvcConfigurer</code>接口，在其中设置对应的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> &#123;<br><br>        <span class="hljs-type">UrlPathHelper</span> <span class="hljs-variable">urlPathHelper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlPathHelper</span>();<br>        <span class="hljs-comment">// 不移除；后面的内容。矩阵变量功能就可以生效</span><br>        urlPathHelper.setRemoveSemicolonContent(<span class="hljs-literal">false</span>);<br>        configurer.setUrlPathHelper(urlPathHelper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方式是直接在配置类中返回<code>WebMvcConfigurer</code>Bean对象，当然也需要在其中设置对应的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> WebMvcConfigurer <span class="hljs-title function_">webMvcConfigurer</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebMvcConfigurer</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> &#123;<br>                <span class="hljs-type">UrlPathHelper</span> <span class="hljs-variable">urlPathHelper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlPathHelper</span>();<br>                <span class="hljs-comment">// 不移除；后面的内容。矩阵变量功能就可以生效</span><br>                urlPathHelper.setRemoveSemicolonContent(<span class="hljs-literal">false</span>);<br>                configurer.setUrlPathHelper(urlPathHelper);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="响应处理">响应处理</h1><h2 id="返回json数据">返回json数据</h2><p>在SpringMVC中，一个处理器方法可以返回json数据，这也是在前后端分离场景下最常用的做法。在之前的SpringMVC中，返回json数据需要先导入jackson的依赖，开启mvc的注解驱动，之后使用<code>@ResponseBody</code>注解，声明该处理器方法返回的是json数据。</p><p>在SpringBoot中已经帮助我们完成了自动配置，只需要使用对应注解即可。同时返回值可以是String，也可以是对象，系统会自动将其转换为json的格式。</p><h2 id="模板引擎thymeleaf">模板引擎Thymeleaf</h2><p>在SpringMVC中，我们还可以返回一个视图名称，用来表示页面跳转的关系。之前的学习中我们使用的是Thymeleaf模板引擎，我们需要自己配置Thymeleaf视图解析器，在其中指定视图前缀，视图后缀等。</p><p>在SpringBoot中，如果我们想要使用Thymeleaf，非常简单，只需要引入Starter即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过启动器，SpringBoot帮助我们完成了自动配置。其中Thymeleaf的所有配置都在<code>ThymeleafProperties</code>中，配置好了<code>ThymeleafViewResolver</code>，配置好了<code>SpringTemplateEngine</code>，并且默认的视图前缀为<code>classpath:/templates/</code>，视图后缀为<code>.html</code>。所有配置都自动完成，我们只需要直接开发页面即可。</p><h1 id="拦截器">拦截器</h1><p>在SpringMVC中，我们实现拦截器，需要实现<code>HandlerInterceptor</code>接口，重写其中的方法，之后将拦截器注册到IOC容器当中。我们可以在配置文件中使用<code>&lt;mvc:interceptors&gt;</code>标签来注册拦截类，同时可以指定拦截规则。</p><p>在SpringBoot中实现拦截器也是同样的流程，只是其中将拦截器注册到IOC容器中这一过程，我们通过实现<code>WebMvcConfigurer</code>的配置类来完成，实现接口的<code>addInterceptors</code>方法，在其中增加拦截器，并用链式调用指定拦截规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>()) <span class="hljs-comment">// 注册拦截器</span><br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">// 拦截请求路径</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/pet&quot;</span>); <span class="hljs-comment">// 放行请求路径</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意这里<code>/**</code>表示拦截所有请求，包括静态资源。</p></blockquote><h1 id="错误处理">错误处理</h1><p>SpringBoot中有默认的错误处理机制。如果是浏览器错误访问，则会返回一个WhitelabelErrorPage，如果是客户端错误访问，则会返回一个Json响应，其中包含错误、Http状态、异常消息等。默认情况下，提供一个<code>/error</code>路径的视图来作为所有错误的映射。</p><p>同时我们可以自定义错误页，将错误页放在<code>/templates/error/</code>目录下，命名为<code>404.html</code>，<code>4xx.html</code>或者<code>5xx.html</code>。这些错误页将会被自动解析有精确的错误状态码页面就匹配精确，没有就找xx匹配，如果都没有就触发白页。</p><h1 id="文件上传">文件上传</h1><p>SpringMVC中的文件上传和下载可以参考：<ahref="https://evernorif.github.io/2022/10/19/SpringMVC笔记-5-SpringMVC中文件上传和下载/">SpringMVC笔记(5)-SpringMVC中文件上传和下载-EverNorif</a>。其中文件下载有着固定的套路，需要指定返回值为<code>ResponseEntity&lt;byte[]&gt;</code>，然后按照固定流程即可。</p><p>而对于文件上传，上传的文件需要先封装成<code>MultipartFile</code>对象，之后才能进行处理。之前我们需要添加相关依赖<code>commons-fileupload</code>，并且需要在配置文件中配置<code>MultipartFile</code>Bean对象，不过在SpringBoot中，这些同样被自动配置完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(<span class="hljs-meta">@RequestPart(&quot;headerImg&quot;)</span> MultipartFile headerImg,</span><br><span class="hljs-params">                     <span class="hljs-meta">@RequestPart(&quot;photos&quot;)</span> MultipartFile[] photos)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 单文件</span><br>    <span class="hljs-keyword">if</span>(!headerImg.isEmpty())&#123;<br>        <span class="hljs-comment">//保存到文件服务器，OSS服务器</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> headerImg.getOriginalFilename();<br>        headerImg.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/files/&quot;</span>+originalFilename));<br>    &#125;<br><br>    <span class="hljs-comment">// 多文件</span><br>    <span class="hljs-keyword">for</span> (MultipartFile photo : photos) &#123;<br>        <span class="hljs-keyword">if</span>(!photo.isEmpty())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> photo.getOriginalFilename();<br>            photo.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/files/&quot;</span>+originalFilename));<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>文件上传相关的配置类有：</p><ul><li><code>org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration</code></li><li><code>org.springframework.boot.autoconfigure.web.servlet.MultipartProperties</code></li></ul><p>我们可以在配置类中查看有哪些配置项，也可以查看官方文档。例如文件大小相关的配置项如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">10MB</span><br><span class="hljs-attr">spring.servlet.multipart.max-request-size</span>=<span class="hljs-string">100MB</span><br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot笔记(2)-配置文件之yaml</title>
    <link href="/2022/11/03/SpringBoot%E7%AC%94%E8%AE%B0-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%8Byaml/"/>
    <url>/2022/11/03/SpringBoot%E7%AC%94%E8%AE%B0-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%8Byaml/</url>
    
    <content type="html"><![CDATA[<h1 id="yaml">yaml</h1><h2 id="基本语法">基本语法</h2><ol type="1"><li>yaml中的属性以键值对KV的形式构成，形式为<code>key: value</code>，其中冒号后面需要有一个空格</li><li>在yaml中大小写敏感</li><li>使用缩进表示层级关系，缩进只能使用空格</li><li>缩进的空格数目并不重要，相同层级的元素只需要左对齐即可</li><li><code>#</code>表示注释</li><li>字符串不需要增加引号，如果需要增加，则单引号表示原本输出，双引号中的转义符会被转义</li></ol><h2 id="数据类型">数据类型</h2><ol type="1"><li><p>字面量：表示单个不可再分的值，例如数值、字符串、布尔值、日期、空值等，使用键值对的形式指定：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">K:</span> <span class="hljs-string">V</span><br></code></pre></td></tr></table></figure></li><li><p>对象：可以看作是键值对的集合，例如Map集合、对象object等：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 行内写法</span><br><span class="hljs-attr">K:</span> &#123;<span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>, <span class="hljs-attr">k2:</span> <span class="hljs-string">v2</span>, <span class="hljs-attr">k3:</span> <span class="hljs-string">v3</span>&#125;<br><br><span class="hljs-comment"># 多行写法</span><br><span class="hljs-attr">k:</span><br>    <span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">k2:</span> <span class="hljs-string">v2</span><br>    <span class="hljs-attr">k3:</span> <span class="hljs-string">v3</span><br></code></pre></td></tr></table></figure></li><li><p>列表：一组值的集合，例如数组array、列表list等：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 行内写法</span><br><span class="hljs-attr">K:</span> [<span class="hljs-string">v1</span>, <span class="hljs-string">v2</span>, <span class="hljs-string">v3</span>]<br><br><span class="hljs-comment"># 多行写法</span><br><span class="hljs-attr">k:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v3</span><br></code></pre></td></tr></table></figure></li></ol><blockquote><p>在SpringBoot中，我们可以利用<code>@ConfiguratonProperties</code>来将配置文件中的值与实体类进行绑定。自定义的类在绑定的时候一般没有提示，我们可以添加相关依赖来增加提示：（参考：<ahref="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#configuration-metadata-annotation-processor">SpringBoot Reference Documentation</a>）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于上面的依赖只是为了方便我们的开发，因此可以在打包的时候指定排除上面的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><p>SpringBoot中的配置文件有三种形式，分别是<code>application.properties</code>、<code>application.yaml</code>和<code>application.yml</code>，其中<code>.properties</code>的优先级更高。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot笔记(1)-SpringBoot基础入门</title>
    <link href="/2022/11/02/SpringBoot%E7%AC%94%E8%AE%B0-1-SpringBoot%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2022/11/02/SpringBoot%E7%AC%94%E8%AE%B0-1-SpringBoot%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot简介">SpringBoot简介</h1><p>Spring生态众多，它向我们提供了多方面的功能，包括Web开发、数据访问、安全控制、分布式、消息服务、移动开发、批处理等等。这些功能并不是通过某个框架直接提供的，而是由Spring生态中的不同框架提供。例如利用SpringMVC+ Spring Framework我们可以完成基本的Web开发。</p><p>不过有之前SSM开发的的经验，我们可以知道在SSM中，需要编写众多的配置文件，被认为是“配置地狱”。而利用SpringBoot，就能帮助我们快速创建出生产级别的Spring的应用。</p><p>SpringBoot的主要功能在于能够简化配置，整合一系列的技术栈。它的底层还是SpringFramework，但是利用一系列启动器starter，大大简化构建配置。利用SpringBoot，我们可以创建独立Spring应用，自动配置Spring以及第三方功能，同时提供生产级别的监控、健康检查以及外部配置等，并且在SpringBoot中内置了Web服务器，无需额外安装WebServer。总结来说，SpringBoot是整合Spring技术栈的一站式框架，是简化Spring技术栈开发的快速开发脚手架。</p><p>SpringBoot的官方地址如下：<ahref="https://spring.io/projects/spring-boot">Spring Boot</a></p><h1 id="快速开始">快速开始</h1><h2 id="项目启动">项目启动</h2><p>下面我们就快速开发一个SpringBoot项目。首先创建一个Maven工程，在其中引入如下依赖，包括父项目依赖<code>spring-boot-starter-parent</code>以及web开发的启动器<code>spring-boot-starter-web</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后我们创建一个主程序，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MainApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中使用注解<code>@SpringBootApplication</code>标识主程序类，表示这是一个SpringBoot程序，在其中的main方法中调用run方法，启动项目，这也是整个项目的开启。</p><p>之后我们可以编写业务逻辑，在控制层中创建Controller，这里的类位于主程序所在的包下的子包controller中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, SpringBoot!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里控制层组件的书写方式与SpringMVC中相同，使用<code>@RequestMapping</code>来指定映射的url路径，而<code>@RestController</code>是<code>@Controller</code>和<code>@ResponseBody</code>的复合注解，表示该类是控制层的类，并且其中的所有方法的返回值都放在响应体中。</p><p>接下来，我们就可以启动主程序<code>MainApplication</code>中的主方法，整个SpringBoot项目就会启动起来，并且我们访问<code>http://localhost:8080/hello</code>，可以发现浏览器中显示了返回值“Hello,SpringBoot!”。这已经说明我们的SpringBoot项目启动了，相比于SSM已经简单了很多。</p><blockquote><p>我们可以在resources文件夹中创建<code>application.properties</code>文件，其中配置相关属性。例如我们可以在其中配置Tomcat的端口号，只需要在该配置文件中指定<code>server.port=8888</code>即可。事实上，针对SpringBoot所有相关属性都能在这个文件中进行配置，详细配置项地址为<ahref="https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/appendix-application-properties.html#common-application-properties-core">CommonApplication properties (spring.io)</a></p></blockquote><p>可以发现，在之前的JavaWeb项目中，我们创建Web项目需要修改Maven的打包方式为war，但是通过SpringBoot，我们可以直接打包出一个可运行的jar包，之后在服务器上直接运行这个jar包就可以提供服务。不过需要在Maven配置文件中添加下面的插件，打包后直接运行<code>java -jar</code>即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里可能在IDEA中报红，添加上版本号即可。</p><h2 id="在idea中的项目启动">在IDEA中的项目启动</h2><p>在IDEA中，<code>Build Project</code>能够帮助我们构建项目。它可以将项目中的代码编译成字节码文件，在生成的target目录下，会存在classes、generated-sources、generated-test-sources、test-classes等目录。首次点击BulidProject会编译整个项目，包括其中的测试类。之后第二次点击则只会编译修改过的文件。这是普通项目的构建方式。当然我们也可以直接使用main方法启动，默认会查看会进行编译。</p><p>此外，在Maven项目中，我们还可以使用Maven 编译，即Mavencomplie。它也能够完成项目的编译，生成字节码文件。但是同时如果配置了pom中的插件，有对应的功能的话也会生效。不过不会生成jar包。Mavencomplie每次都是重新编译，而不是仅编译修改过的文件。在生成的target目录下，有classes、generated-sources、maven-status目录。在maven-status目录中，有createdFiles.lst和inputFiles，里面是全路径字节码文件和全路径类文件。</p><p>而Mavenpackage也会编译项目，同时会生成jar包。生成的target目录下，有classes、generated-sources、generated-test-sources、maven-archiver、maven-status、surefire-reports、test-classes、jar文件等。同时每次编译也是重新编译。我们配置的spring-boot-maven-plugin提供<code>spring-boot:run</code>启动方式，它会调用Maven的编译打包。</p><p>总结来说，如果是普通的项目，我们可以直接使用main方法启动，默认会进行编译操作。而在SpringBoot项目中，在pom.xml中配置了相关的插件，则建议使用maven来进行启动。可以直接使用<code>spring-boot:run</code>来运行，也可以每次使用<code>maven complie</code>之后运行main方法。</p><h1 id="特性说明">特性说明</h1><h2 id="依赖管理特性">依赖管理特性</h2><p>在之前SSM项目的开发中，我们需要在Maven中手动引入非常多的依赖，并且自己管理相应的版本问题，不过在SpringBoot中，我们却不需要这样做。这是由于SpringBoot的依赖管理特性。我们引入了父项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而这个项目也有自己的父项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个项目<code>spring-boot-dependencies</code>中，有<code>&lt;properties&gt;</code>标签，其中声明了众多属性，并且有对应的属性值，就是开发中常用的依赖版本号，规定了引入依赖的默认版本。因此我们在引入依赖的时候，如果在其中有默认版本号，就可以不写version。</p><p>当然在一些场景下，我们需要特定版本的依赖。此时我们就可以利用Maven的就近原则，在项目的<code>pom.xml</code>中重写属性<code>&lt;properties&gt;</code>，将我们需要的版本在其中重新设置，对默认的版本进行覆盖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>5.1.43<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了父项目之外，我们还引入了场景启动器<code>spring-boot-starter-web</code>，这表示SpringBoot就某种场景下的开发所描述的一组依赖，只要我们引入了对应的starter，在这个场景下的常规依赖都会自动引入。SpringBoot提供给我们的场景启动器有很多（<ahref="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">Developingwith SpringBoot</a>），均以<code>spring-boot-starter-*</code>的形式命名。我们也可以自定构造场景启动器，或者使用第三方场景启动器，此时的推荐命名形式为<code>*-spring-boot-starter</code>。</p><h2 id="自动配置特性">自动配置特性</h2><p>在SSM项目的开发中，我们需要完成众多的配置，包括包扫描、Bean管理、Web配置等等。但是在SpringBoot项目中，已经帮助我们完成了一些基本的配置，例如：</p><ul><li><p>Tomcat的配置：内嵌WebServer，引入Tomcat依赖，配置Tomcat。</p></li><li><p>SpringMVC的配置：引入SpringMVC的全套组件，自动配置SpringMVC常用功能组件。</p></li><li><p>Web常见功能的配置：自动配置Web的常见功能，例如字符编码问题等。</p></li><li><p>组件扫描的配置：</p><ul><li>按照默认的包结构进行组件扫描，默认情况下，从主程序所在的包开始，该包以及其所有子包中的组件都会被扫描，交由IOC容器管理。</li><li>如果想要改变扫描路径，可以使用<code>@SpringBootApplication</code>注解中的<code>scanBasePackages</code>属性指定扫描路径</li><li>也可以使用<code>@ComponentScan</code>来指定扫描路径，不过这个注解不能和<code>@SpringBootApplication</code>一起使用，因此<code>@SpringBootApplication</code>是一个复合注解，等同于<code>@SpringBootConfiguration</code>+<code>@EnableAutoConfiguration</code>+<code>@ComponentScan</code></li></ul></li></ul><p>在上面也提到我们可以通过<code>application.properties</code>配置文件来添加配置。这里的各种配置都拥有默认值，并且配置的值最终会映射到某个类上，成为其中的属性值。这个类也会被Spring管理，我们可以从IOC容器中得到对应的类，然后访问对应的属性。</p><p>在主程序类<code>MainApplication</code>中，我们调用了run方法开启项目。实际上这个方法是有返回值的，返回值是一个IOC容器，类型为<code>ConfigurableApplicationContext</code>。取到IOC容器后，我们可以查看其中管理的Bean对象，发现通过自动配置添加了很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> SpringApplication.run(MainApplication.class, args);<br><br>    String[] names = run.getBeanDefinitionNames();<br>    <span class="hljs-keyword">for</span> (String name : names) &#123;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SpringBoot会默认在底层配置好所有的组件，但是如果用户自己配置了，就以用户配置的优先。用户可以自己提供<code>@Bean</code>来替换底层的组件，也可以通过配置文件设置值的方式修改对应组件的参数。</p><blockquote><p>在开发SpringBoot项目的时候，我们首先需要引入场景依赖，之后可以查看SpringBoot自动配置了哪些组件。在配置文件中设置<code>debug=true</code>，可以开启自动配置报告。之后随着开发过程，判断是否需要修改SpringBoot自动配置的组件，修改的方式可以通过配置文件、也可以自定义替换组件。</p></blockquote><h1 id="底层注解">底层注解</h1><p>SpringBoot在底层帮助我们自动进行了依赖配置，完成自动装配，配置的过程和原理依赖了许多注解。下面介绍一些SpringBoot底层常用的注解。</p><h2 id="configuration-配置类"><span class="citation"data-cites="Configuration">@Configuration</span> 配置类</h2><p>在Spring中，我们可以使用配置文件，基于XML来管理Bean对象。在SpringMVC中，我们也可以使用配置类来代替配置文件，在其中管理IOC容器中的Bean对象。</p><p>我们可以创建自己的配置类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">person1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;me&quot;</span>, <span class="hljs-number">18</span>);<br>        person.setPet(petCat()); <span class="hljs-comment">// Person组件依赖了Pet组件</span><br>        <span class="hljs-keyword">return</span> person;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Bean(&quot;cat&quot;)</span><br>    <span class="hljs-keyword">public</span> Pet <span class="hljs-title function_">petCat</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pet</span>(<span class="hljs-string">&quot;cat&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们使用<code>@Configuration</code>注解标识我们的自定义类，通知SpringBoot这个一个配置类。之后，使用<code>@Bean</code>注解标识其中的方法，该方法所返回对象会被添加到IOC容器中进行管理。默认情况下以方法的名称作为Bean对象的id，方法的返回类型为组件类型。或者可以在<code>@Bean</code>注解中指定value值，表示Bean对象的名称。需要注意的是，配置类本身也是一个组件，交由IOC容器管理。</p><p>在<code>@Configuration</code>注解中，可以指定<code>proxyBeanMethods</code>。它表示代理Bean的方法，接收一个布尔值。默认情况下该值为true，保证多次调用<code>@Bean</code>修饰的方法，返回的组件都是单例的。如果该值为false，则多次调用方法，返回的组件是新创建的。</p><p>该值为true时对应Full模式，在每次方法调用的时候都会检查是否是单例，而该值为false的时候对应Lite模式，不会进行检查，因此可以加速容器的启动过程。一般来说，如果类组件之间没有依赖关系，则可以使用Lite模式来进行加速，如果有依赖关系，则使用Full模式，保证依赖对象是单例的。</p><blockquote><p>在SpringBoot中，我们仍然可以使用<code>@Bean</code>、<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>等注解。这些是Spring的基本注解，在SpringBoot中也并未改变它们原来的功能。</p></blockquote><h2 id="import-组件导入"><span class="citation"data-cites="Import">@Import</span> 组件导入</h2><p><code>@Import</code>注解也能够帮助我们完成组件导入。在其中我们需要给定对应类的Class对象，之后就会在容器中自动创建出对应类型的组件，组件的名称默认为全类名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;Person.class, Pet.class&#125;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="conditional-条件装配"><span class="citation"data-cites="Conditional">@Conditional</span> 条件装配</h2><p>条件装配表示满足某个条件后才进行组件注入。条件装配的基础注解为<code>@Conditional</code>，其下有很多其他条件装配注解，代表不同的条件。例如其中<code>@ConditionalOnMissingBean</code>注解，在其中指定name属性为cat，表示当IOC容器中没有名称为cat的Bean，才能执行组件注入。</p><p>条件装配的注解可以添加在方法上，则只对方法返回的Bean对象是否注解生效，也可以添加在类上，则对类中所有注入的Bean对象生效。</p><h2 id="importresouce-配置文件导入"><span class="citation"data-cites="ImportResouce">@ImportResouce</span> 配置文件导入</h2><p>在Spring中我们可以使用<code>.xml</code>文件来管理Bean对象，在SpringBoot中，我们仍然可以继续复用这些配置文件，只需要利用<code>@ImportResouce</code>注解进行声明，在其中指定对应配置文件的位置即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ImportResource(&quot;classpath:spring.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="configurationproperties-配置绑定"><span class="citation"data-cites="ConfigurationProperties">@ConfigurationProperties</span>配置绑定</h2><p>在利用配置文件的时候，我们希望能够读取properties文件中的内容，并将其封装的JavaBean中，之后通过调用JavaBean的一些方法来获得其中的属性值。在SpringBoot中提供有配置绑定的功能，用于将配置文件中的值绑定到IOC中的Bean对象上。</p><p>假设现在我们的<code>application.properties</code>中有如下两个属性：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">mybook.name</span>=<span class="hljs-string">DeathNote</span><br><span class="hljs-attr">mybook.author</span>=<span class="hljs-string">huangmu</span><br></code></pre></td></tr></table></figure><p>我们创建一个类Book，其中有属性name和author，我们希望能够将Book类交由IOC容器管理，并且将上面这些属性绑定到IOC容器中管理的Book对象上。</p><p>第一种方式：使用<code>@ConfigurationProperties</code>+<code>@Component</code>。</p><p>我们需要在类Book上添加这两个属性，将其交由容器管理，并且指定它对应属性的前缀：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;mybook&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方式：使用<code>@EnableConfigurationProperties</code>+<code>@ConfigurationProperties</code>。</p><p>我们需要在配置类中开启配置绑定功能，并将其注册到容器中。同时仍然需要在Book类上指定对应属性的前缀：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableConfigurationProperties(Book.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;mybook&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>之后通过调用run方法得到IOC容器，再从IOC容器中获取对应Book类型的Bean对象，输入即可发现被绑定上了对应的属性。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础笔记(2)-Python装饰器</title>
    <link href="/2022/10/26/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-2-Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/2022/10/26/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-2-Python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰器">装饰器</h1><h2 id="介绍">介绍</h2><p>Python中的装饰器可以允许其他函数在不需要做任何代码修改的前提下额外增加功能，在函数执行的前后增加新的功能，类似于AOP，面向切面编程。</p><p>在Python中，函数是一等公民，函数可以作为参数、返回值等而存在。考虑如下的场景，我们希望在每个函数调用之前执行日志打印功能，输出当前函数的名称。我们可以通过在每个函数开头增加相关功能，但是过于繁琐也不便于同一管理。我们可以通过定义一个统一的<code>debug</code>函数，它的参数是一个函数func，返回值也是一个函数wrapper。作为返回值的wrapper函数，它调用了参数func，并且在调用前后执行了相关操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() start...&quot;</span>.<span class="hljs-built_in">format</span>(func.__name__))<br>        res = func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() finish...&quot;</span>.<span class="hljs-built_in">format</span>(func.__name__))<br><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">function1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello I am Function1&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><br>function1 = debug(function1) <span class="hljs-comment"># 覆盖函数名达到相同的调用效果，添加功能并保持原函数名不变</span><br>res = function1()<br><span class="hljs-built_in">print</span>(res)<br><br></code></pre></td></tr></table></figure><p>上面的函数的执行结果如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">DEBUG</span>]: <span class="hljs-link">function1() start...</span><br>Hello I am Function1<br>[<span class="hljs-symbol">DEBUG</span>]: <span class="hljs-link">function1() finish...</span><br>1<br></code></pre></td></tr></table></figure><p>上面的操作实际上就是装饰器完成的工作。Python中的装饰器本质上还是一个函数，它的返回值也是一个函数。不过这里我们每次还需要执行<code>function1 = debug(function1)</code>来保持原函数名不变，而Python给我们提供了<code>@</code>语法糖，我们可以使用下面的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@debug</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">function1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello I am Function1&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><br>res = function1()<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>这里的<code>@</code>是装饰器的语法糖，在定义函数的时候使用，可以避免再一次赋值操作，相当于帮助我们执行了<code>function1 = debug(function1)</code>，因此上面代码也能得到相同的输出，实现了函数功能的增强。</p><h2 id="带参数的装饰器">带参数的装饰器</h2><p>在实际的场景中，很多函数都是需要带有参数的。为了实现这种装饰器，我们可以指定装饰器函数<code>wrapper</code>接受和原函数一样的参数，也可以使用可变参数<code>*args</code>和关键字参数<code>**kwargs</code>来匹配任何的函数参数，作用于任意目标函数，提高通用性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() start...&quot;</span>.<span class="hljs-built_in">format</span>(func.__name__))<br>        res = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() finish...&quot;</span>.<span class="hljs-built_in">format</span>(func.__name__))<br><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@debug</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">something</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I say: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(something))<br><br><br>say(<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">DEBUG</span>]: <span class="hljs-link">say() start...</span><br>I say: hello<br>[<span class="hljs-symbol">DEBUG</span>]: <span class="hljs-link">say() finish...</span><br></code></pre></td></tr></table></figure><p>上面的参数是被装饰函数的参数，实际上装饰器函数也能有自己的参数。我们可以增加一层嵌套函数来接收装饰器函数的参数，下面实现的装饰器接收参数times，表示重复调用函数func的次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>(<span class="hljs-params">times</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">outerWrapper</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() start...&quot;</span>.<span class="hljs-built_in">format</span>(func.__name__))<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(times):<br>                func(*args, **kwargs)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() finish...&quot;</span>.<span class="hljs-built_in">format</span>(func.__name__))<br><br>        <span class="hljs-keyword">return</span> wrapper<br><br>    <span class="hljs-keyword">return</span> outerWrapper<br><br><br><span class="hljs-meta">@debug(<span class="hljs-params">times=<span class="hljs-number">3</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">something</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I say: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(something))<br><br><br>say(<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[DEBUG]</span>: <span class="hljs-keyword">say</span>() start...<br>I <span class="hljs-keyword">say</span>: hello<br>I <span class="hljs-keyword">say</span>: hello<br>I <span class="hljs-keyword">say</span>: hello<br><span class="hljs-comment">[DEBUG]</span>: <span class="hljs-keyword">say</span>() finish...<br></code></pre></td></tr></table></figure><blockquote><p>多层装饰器的执行顺序：从上到下依次执行，先执行的后退出，后执行的先退出。</p></blockquote><h2 id="functools.wrap"><span class="citation"data-cites="functools.wrap">@functools.wrap</span></h2><p>如果我们直接利用上面的代码，执行<code>print(say)</code>，得到的输出结果如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">function</span> <span class="hljs-keyword">debug</span>.&lt;locals&gt;.outerWrapper.&lt;locals&gt;.<span class="hljs-keyword">wrapper</span> at <span class="hljs-number">0x000001CA442A05E0</span>&gt;<br></code></pre></td></tr></table></figure><p>可以发现我们原本的say函数信息被装饰器取代了，函数名等函数属性发生了改变。这对结果执行不会产生影响，但是如果在一些场景下，我们需要使用到函数的元信息，那么应该需要能够保留。这可以使用内置装饰器<code>@functools.wrap</code>来实现，它能够帮助我们保留原有函数的名称和函数属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>(<span class="hljs-params">times</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">outerWrapper</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">        @functools.wraps(<span class="hljs-params">func</span>)  </span><span class="hljs-comment"># 保留元信息</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() start...&quot;</span>.<span class="hljs-built_in">format</span>(func.__name__))<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(times):<br>                func(*args, **kwargs)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() finish...&quot;</span>.<span class="hljs-built_in">format</span>(func.__name__))<br><br>        <span class="hljs-keyword">return</span> wrapper<br><br>    <span class="hljs-keyword">return</span> outerWrapper<br><br><br><span class="hljs-meta">@debug(<span class="hljs-params">times=<span class="hljs-number">3</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">something</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I say: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(something))<br><br><br><span class="hljs-built_in">print</span>(say)<br><br></code></pre></td></tr></table></figure><p>此时再执行<code>print(say)</code>，得到的结果就是没有被取代的元信息：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">&lt;<span class="hljs-keyword">function</span> <span class="hljs-title">say</span> at 0x00000237509505E0&gt;<br></code></pre></td></tr></table></figure><h2 id="类装饰器">类装饰器</h2><p>除了利用函数来完成装饰器，我们也可以通过类来实现一个装饰器。类能够实现装饰器的功能，是因为我们可以调用类的实例，实际上就调用到了<code>__call__()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DEBUG</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):<br>        self.func = func<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() start...&quot;</span>.<span class="hljs-built_in">format</span>(self.func.__name__))<br>        self.func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() finish...&quot;</span>.<span class="hljs-built_in">format</span>(self.func.__name__))<br><br><br><span class="hljs-meta">@DEBUG</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">something</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I say: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(something))<br><br><br>say(<span class="hljs-string">&quot;Hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果装饰器需要参数的话，可以通过下面的方法来实现，在<code>__call__()</code>方法中定义内部函数，这里<code>@functools.wraps</code>的用法和之前也是类似的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DEBUG</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, times</span>):<br>        self.times = times<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, func</span>):<br><span class="hljs-meta">        @functools.wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() start...&quot;</span>.<span class="hljs-built_in">format</span>(func.__name__))<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.times):<br>                func(*args, **kwargs)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DEBUG]: &#123;&#125;() finish...&quot;</span>.<span class="hljs-built_in">format</span>(func.__name__))<br><br>        <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@DEBUG(<span class="hljs-params">times=<span class="hljs-number">3</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">something</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I say: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(something))<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://juejin.cn/post/6992410247914586142">Python装饰器，读完这篇你就懂了- 掘金 (juejin.cn)</a></li><li><ahref="https://www.cnblogs.com/tobyqin/p/python-decorator.html">详解Python的装饰器- Toby Qin - 博客园 (cnblogs.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础笔记(1)-Python速览</title>
    <link href="/2022/10/25/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-1-Python%E9%80%9F%E8%A7%88/"/>
    <url>/2022/10/25/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-1-Python%E9%80%9F%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="类型操作">类型操作</h1><p>python3中有六个标准数据类型，分别是Number数字、String字符串、List列表、Tuple元组、Set集合、Dictionary字典。数据类型有可变与不可变之分：</p><ul><li>不可变数据：Number、String、Tuple</li><li>可变数据：List、Dictionary、Set</li></ul><blockquote><p>在参数传递过程中，不可变类型和可变类型有一定的区别：</p><ul><li>如果传递的是不可变类型，则是一个值传递，函数内部的修改不会对实际对象产生影响</li><li>如果是可变类型，则是引用传递，函数内部的修改会对实际对象产生影响</li></ul></blockquote><h2 id="数字number">数字(Number)</h2><p>python3中的数字类型支持int、float、bool、complex（复数）。</p><blockquote><p>可以使用<code>type()</code>内置函数来查询变量所指的对象类型，或者使用<code>isinstance()</code>来判断是否是某种类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">20</span><br><span class="hljs-built_in">type</span>(a) <span class="hljs-comment">#  &lt;class &#x27;int&#x27;&gt;</span><br><span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">int</span>) <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><ul><li><code>type()</code>：只考虑最基本的类型，不会认为子类是一种父类类型</li><li><code>isinstance()</code>：考虑继承，认为子类是一种父类类型</li></ul></blockquote><p>在变量赋值的时候创建Number对象，可以使用del语句删除单个或者多个对象的引用。</p><table><thead><tr class="header"><th>相关数学函数</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>abs(x)</td><td>ceil(x)</td><td>exp(x)</td></tr><tr class="even"><td>fabs(x)</td><td>floor(x)</td><td>log(x)</td></tr><tr class="odd"><td>log10(x)</td><td>max(x1,x2,...)</td><td>min(x1,x2,...)</td></tr><tr class="even"><td>modf(x)</td><td>pow(x, y)</td><td>round(x [,n])</td></tr><tr class="odd"><td>sqrt(x)</td><td></td><td></td></tr></tbody></table><ul><li><code>fabs(x)</code>：返回数字的绝对值</li><li><code>modf(x)</code>：返回x的整数部分与小数部分</li></ul><h2 id="字符串string">字符串(String)</h2><ul><li>反斜杠可以用来转义，使用<code>r</code>可以让反斜杠不发生转义</li><li>按字面意义级联字符串，如<code>"this " "is " "string"</code>会被自动转换为<code>this is string</code></li><li>字符串可以用 <code>+</code>运算符连接在一起，用 <code>*</code>运算符重复。</li><li>Python中的字符串有两种索引方式，从左往右以<code>0</code>开始，从右往左以<code>-1</code>开始</li><li>字符串的截取的语法格式如下：<code>变量[头下标:尾下标:步长]</code></li><li>python字符串不能被改变，不能向一个索引位置赋值</li></ul><p>字符串格式化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1.使用%</span><br><span class="hljs-string">&quot;name: %s and age: %d&quot;</span>% (<span class="hljs-string">&quot;haha&quot;</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 2.使用fomat</span><br><span class="hljs-string">&quot;&#123;name&#125;---&#123;url&#125;&quot;</span>.<span class="hljs-built_in">format</span>(name=<span class="hljs-string">&quot;hahaha&quot;</span>, url=<span class="hljs-string">&quot;hahaha.com&quot;</span>)<br><br><span class="hljs-comment"># 3.f-string</span><br>name = <span class="hljs-string">&quot;haha&quot;</span><br><span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;name&#125;</span>&quot;</span> <span class="hljs-comment"># 变量替换</span><br><span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-number">1</span>+<span class="hljs-number">2</span>&#125;</span>&quot;</span> <span class="hljs-comment"># 表达式计算</span><br></code></pre></td></tr></table></figure><p>字符串常用方法：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>capitalize()</td><td>字符串首字母大写</td></tr><tr class="even"><td>swapcase()</td><td>大写转小写、小写zhuan</td></tr><tr class="odd"><td>count(str, beg=0, end=len(string))</td><td>返回str在字符串里面出现的次数</td></tr><tr class="even"><td>startswith(substr, beg=0, end=len(string))</td><td>检查字符串是否以substr开始，返回布尔值</td></tr><tr class="odd"><td>endswith(suffix, beg=0, end=len(string))</td><td>检查字符串是否以suffix结束，返回布尔值</td></tr><tr class="even"><td>find(str, beg=0, end=len(string))</td><td>检查str是否包含在字符串中，如果找到则返回开始索引，否则返回-1</td></tr><tr class="odd"><td>rfind(str, beg=0, end=len(string))</td><td>与find类似，不过是从右边开始查找</td></tr><tr class="even"><td>index(str, beg=0, end=len(string))</td><td>与find类似，但是如果没有找到会报异常</td></tr><tr class="odd"><td>rindex(str, beg=0, end=len(string))</td><td>与index类似，不过是从右边开始查找</td></tr><tr class="even"><td>join(seq)</td><td>以字符串作为分隔符，对seq进行拼接</td></tr><tr class="odd"><td>len(string)</td><td>返回字符串长度</td></tr><tr class="even"><td>replace(old, new [,max])</td><td>将字符串中的old替换为new，max指定替换的最大次数</td></tr><tr class="odd"><td>split(str="", num=string.count(str))</td><td>以str为分隔符截取字符串，如果num有指定值，则仅截取num+1个子字符串</td></tr><tr class="even"><td>lstrip() / rstrip() / strip()</td><td>删除字符串左边/右边/左右的空格</td></tr></tbody></table><h2 id="列表list">列表(List)</h2><p>增删改查：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-string">&quot;haha&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">True</span>]<br><span class="hljs-comment"># 增</span><br><span class="hljs-built_in">list</span>.append(<span class="hljs-number">456</span>)<br><br><span class="hljs-comment"># 删</span><br><span class="hljs-keyword">del</span> <span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 改</span><br><span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">23</span><br><br><span class="hljs-comment"># 查</span><br><span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># + 号用于组合列表，* 号用于重复列表</span><br></code></pre></td></tr></table></figure><p>列表常用方法：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>list.append(obj)</td><td>在列表末尾添加新的对象</td></tr><tr class="even"><td>list.count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr class="odd"><td>list.extend(seq)</td><td>在列表末尾一次性追加另一个序列中的多个值</td></tr><tr class="even"><td>list.index(obj)</td><td>从列表中找到某个值第一次匹配的索引位置</td></tr><tr class="odd"><td>list.insert(index, obj)</td><td>将对象插入列表</td></tr><tr class="even"><td>list.pop([index = -1])</td><td>移除列表中的元素并返回该值</td></tr><tr class="odd"><td>list.remove(obj)</td><td>移除列表中某个值的第一个匹配项</td></tr><tr class="even"><td>list.reverse()</td><td>列表逆序</td></tr><tr class="odd"><td>list.sort(key=None, reverse=False)</td><td>列表排序</td></tr><tr class="even"><td>list.clear()</td><td>清空列表</td></tr><tr class="odd"><td>list.copy()</td><td>复制列表</td></tr></tbody></table><h2 id="元组tuple">元组(Tuple)</h2><ul><li>可以使用下标索引来访问元组中的值，也可以截取其中的部分元素</li><li>元组中的元素值不允许修改，但是可以对元组进行连接组合</li><li>元组中的元素值不允许删除，但是可以用del语句删除整个元组</li></ul><h2 id="集合set">集合(Set)</h2><ul><li>空集合的创建只能使用<code>set()</code>，因为<code>&#123;&#125;</code>是用来创建空字典的</li></ul><p>集合常用方法：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>add()</td><td>为集合添加元素</td></tr><tr class="even"><td>update()</td><td>为集合添加元素</td></tr><tr class="odd"><td>clear()</td><td>移除集合中的所有元素</td></tr><tr class="even"><td>copy()</td><td>复制集合</td></tr><tr class="odd"><td>union()</td><td>返回两个集合的并集</td></tr><tr class="even"><td>difference()</td><td>返回集合的差集</td></tr><tr class="odd"><td>intersection()</td><td>返回集合的交集</td></tr><tr class="even"><td>symmetric_difference()</td><td>返回两个集合中不重复元素集合</td></tr><tr class="odd"><td>isdisjoint()</td><td>判断两个集合是否包含相同元素</td></tr><tr class="even"><td>issubset()</td><td>判断集合是否为另一个集合的子集</td></tr><tr class="odd"><td>issuperset()</td><td>判断集合是否为另一个集合的超集</td></tr><tr class="even"><td>pop()</td><td>随机移除元素</td></tr><tr class="odd"><td>remove()</td><td>移除指定元素</td></tr><tr class="even"><td>discard()</td><td>删除集合中指定元素</td></tr></tbody></table><h2 id="字典dictionary">字典(Dictionary)</h2><ul><li>键值对中的Key必须是不可变类型，例如数字、字符串、元组</li></ul><p>字典常用方法：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>dict.clear()</td><td>删除字典内所有元素</td></tr><tr class="even"><td>dict.copy()</td><td>返回一个字典的浅复制</td></tr><tr class="odd"><td>dict.fromkeys(seq[, value])</td><td>静态方法。创建一个新字典，以序列seq中的值为key，value为默认值</td></tr><tr class="even"><td>dict.get(key, default=None)</td><td>返回指定Key的值，如果不在则返回默认值</td></tr><tr class="odd"><td>dict.setdefault(key, default=None)</td><td>返回指定Key的值，如果不在则会添加对应的Key并将值设置为default</td></tr><tr class="even"><td>dict.items()</td><td>返回Key-Value集合</td></tr><tr class="odd"><td>dict.keys()</td><td>返回Key集合</td></tr><tr class="even"><td>dict.values()</td><td>返回value集合</td></tr><tr class="odd"><td>dict.update(dict2)</td><td>利用dict2来更新dict</td></tr><tr class="even"><td>dict.pop(key[,default])</td><td>删除Key所对应的值并返回</td></tr><tr class="odd"><td>dict.popitem()</td><td>返回并删除字典中的最后一个键值对</td></tr></tbody></table><h2 id="数据类型转换">数据类型转换</h2><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>int(x [,base])</td><td>将x转换为一个整数，可以指定base进制</td></tr><tr class="even"><td>float(x)</td><td>将x转换为一个浮点数</td></tr><tr class="odd"><td>complex(real [,imag])</td><td>创建一个复数</td></tr><tr class="even"><td>str(x)</td><td>将x转换为字符串</td></tr><tr class="odd"><td>repr(x)</td><td>将x转化为表达式字符串，返回一个对象的String格式</td></tr><tr class="even"><td>eval(str)</td><td>执行字符串中的有效Python表达式并返回一个对象</td></tr><tr class="odd"><td>tuple(s)</td><td>将序列s转换为一个元组</td></tr><tr class="even"><td>list(s)</td><td>将序列s转换为一个列表</td></tr><tr class="odd"><td>set(s)</td><td>将序列s转换为可变集合</td></tr><tr class="even"><td>dict(d)</td><td>创建一个字典，d是键值对元组序列</td></tr><tr class="odd"><td>frozenset(s)</td><td>将s转换为不可变集合</td></tr><tr class="even"><td>chr(x)</td><td>将整数转换为一个字符，对应ASCII码</td></tr><tr class="odd"><td>ord(x)</td><td>将字符转换为对应的ASCII码整数</td></tr><tr class="even"><td>hex(x)</td><td>将一个整数转换为十六进制字符串</td></tr><tr class="odd"><td>oct(x)</td><td>将一个整数转换为八进制字符串</td></tr></tbody></table><h1 id="模块和包">模块和包</h1><p>模块是一个包含所有定义函数和变量的文件，其后缀名为<code>.py</code>。模块可以被其他的程序<code>import</code>引入，以使用该模块中的函数等功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> module1, module2, ...<br></code></pre></td></tr></table></figure><p>一个模块被另一个程序第一次引用的时候，其主程序将被运行。我们可以使用<code>__name__</code>属性来使得程序块仅在模块自身运行时执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 模块自身运行</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 来自其他模块</span><br></code></pre></td></tr></table></figure><blockquote><p>内置的<code>dir()</code>函数可以找到模块内定义的所有名称，以一个字符串列表的形式返回</p></blockquote><p>包是一种管理Python模块命名空间的形式，在包中组织了目录的层级关系。目录只有包含了一个叫做<code>__init__.py</code>的文件才会被认作是一个包，在这个文件中可以包含一些初始化代码等，当然也可以什么都不写。</p><p>注意，如果是使用形如<code>from package import item</code>引入的时候，item既可以是包中的子模块，也可以是包中定义的其他名称，比如函数，类或者变量。如果是使用形如<code>import item.subitem.subsubitem</code>这种形式引入的时候，则除了最后一项，其他的都必须是包，并且最后一项可以是模块或者包，但是不可以是类、函数或者变量的名字。</p><p>当我们引入一个包的时候，会执行它的<code>__init__.py</code>文件，因此在这个文件我们可以定义一些初始化操作。在这个文件中，我们也可以定义一个名称为<code>__all__</code>的列表变量，这样如果我们使用形如<code>from package import *</code>的形式引入的话，就会引入<code>__all__</code>列表变量中定义的相关模块。如果此时<code>__all__</code>没有定义的话，则不会导入包中的任何子模块。不过总结来说，我们还是推荐使用<code>from package import sepcific_submodule</code>这种形式来引入。</p><h1 id="错误和异常">错误和异常</h1><p>异常处理机制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment">#...需要捕获异常的代码块</span><br><span class="hljs-keyword">except</span> RuntimeError <span class="hljs-keyword">as</span> err:<br>    <span class="hljs-comment"># ...有异常时的执行代码</span><br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-comment"># ...有异常时的执行代码</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># ...没有异常时的执行的代码</span><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-comment"># ...最终一定会执行的代码</span><br></code></pre></td></tr></table></figure><p>抛出异常使用<code>raise</code>关键字。我们也可以创建一个新的异常类，它需要直接或者间接继承<code>Exception</code>。</p><h1 id="面向对象">面向对象</h1><h2 id="基础">基础</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    name = <span class="hljs-string">&quot;&quot;</span><br>    age = <span class="hljs-number">18</span><br>    gender = <span class="hljs-string">&quot;man&quot;</span><br>    __weight = <span class="hljs-number">0</span>  <span class="hljs-comment"># 私有属性</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, gender</span>):<br>        self.name = name<br>        self.age = age<br>        self.gender = gender<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Person[name:&#123;name&#125;, age:&#123;age&#125;, gender:&#123;gender&#125;&quot;</span>.<span class="hljs-built_in">format</span>(name=self.name, age=self.age, gender=self.gender))<br></code></pre></td></tr></table></figure><ul><li>构造方法为<code>__init__()</code></li><li>以单下划线开头的属性是protected类型的，以双下划线开头的属性是private类型的</li><li>以双下划线开头和结尾代表Python里的特殊方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    grade = <span class="hljs-number">100</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, gender, grade</span>):<br>        Person.__init__(self, name, age, gender)<br>        self.grade = grade<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am a Student, my grade is &quot;</span> + <span class="hljs-built_in">str</span>(self.grade))<br></code></pre></td></tr></table></figure><ul><li>可以在继承中使用父类的构造函数</li><li>同名重写父类方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Speaker</span>:<br>    name = <span class="hljs-string">&quot;&quot;</span><br>    topic = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, topic</span>):<br>        self.name = name<br>        self.topic = topic<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am a speaker, my topic is &quot;</span> + self.topic)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Me</span>(Student, Speaker):<br>    hobby = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, gender, grade, topic, hobby</span>):<br>        Student.__init__(self, name, age, gender, grade)<br>        Speaker.__init__(self, name, topic)<br>        self.hobby = hobby<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Me, self).say()  <span class="hljs-comment"># 调用父类的方法</span><br></code></pre></td></tr></table></figure><ul><li>直接通过指定多个父类来实现多继承</li><li>如果父类中有相同的方法名，而子类使用的时候没有指定，则Python从继承列表中从左到右搜索</li><li>使用<code>super()</code>来调用父类中的方法</li></ul><p>类属性和方法：</p><ul><li>类的私有属性以两个下划线开头，不能在类的外部被使用或直接访问</li><li>类的私有方法以两个下划线开头，只能在类的内部调用</li></ul><h2 id="特殊方法">特殊方法</h2><p>在Python中，类存在一些特殊方法，即前后均为双下划线的方法。这些特殊方法有着各自的功能。</p><table><thead><tr class="header"><th>专有方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>__new__</code></td><td>创建类实例时会被调用，优先于构造函数执行</td></tr><tr class="even"><td><code>__init__</code></td><td>构造函数</td></tr><tr class="odd"><td><code>__del__</code></td><td>析构函数</td></tr><tr class="even"><td><code>__str__</code></td><td>对象的字符串表示，用于print</td></tr><tr class="odd"><td><code>__repr__</code></td><td>对象的字符串表示，一般用于调试</td></tr><tr class="even"><td><code>__setitem__</code></td><td>按照索引赋值</td></tr><tr class="odd"><td><code>__getitem__</code></td><td>实现通过索引取值</td></tr><tr class="even"><td><code>__len__</code></td><td>获取长度</td></tr><tr class="odd"><td><code>__cmp__</code></td><td>比较运算</td></tr><tr class="even"><td><code>__call__</code></td><td>直接对实例进行调用，就像使用函数一样</td></tr><tr class="odd"><td><code>__add__</code></td><td>加运算，用于运算符重载</td></tr><tr class="even"><td><code>__sub__</code></td><td>减运算，用于运算符重载</td></tr><tr class="odd"><td><code>__mul__</code></td><td>乘运算，用于运算符重载</td></tr><tr class="even"><td><code>__truediv__</code></td><td>除运算，用于运算符重载</td></tr><tr class="odd"><td><code>__mod__</code></td><td>求余运算，用于运算符重载</td></tr><tr class="even"><td><code>__pow__</code></td><td>乘方运算，用于运算符重载</td></tr></tbody></table><ul><li><strong>hasattr()函数</strong></li></ul><p>hasattr()函数用来判断某个类实例对象是否包含指定名称的属性或者方法，用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># hasattr(obj, name)</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.name = <span class="hljs-string">&quot;mm&quot;</span><br>        self.master = <span class="hljs-string">&quot;hh&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">miao</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mmmm...&quot;</span>)<br><br><br>cat = Cat()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(cat, <span class="hljs-string">&quot;name&quot;</span>)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(cat, <span class="hljs-string">&quot;master&quot;</span>)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(cat, <span class="hljs-string">&quot;miao&quot;</span>)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(cat, <span class="hljs-string">&quot;mother&quot;</span>)) <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><ul><li><strong>getattr()函数</strong></li></ul><p>getattr()函数用来获取某个类实例对象中指定属性的值，如果不存在对应属性，则判断是否设定了默认值。如果有则返回默认值，如果没有则报错<code>AttributeError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># getattr(obj, name[, default])</span><br><br>cat = Cat() <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(cat, <span class="hljs-string">&quot;name&quot;</span>)) <span class="hljs-comment"># mm</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(cat, <span class="hljs-string">&quot;master&quot;</span>)) <span class="hljs-comment"># hh</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(cat, <span class="hljs-string">&quot;mother&quot;</span>, <span class="hljs-string">&quot;ww&quot;</span>)) <span class="hljs-comment"># ww</span><br></code></pre></td></tr></table></figure><ul><li><strong>setattr()函数</strong></li></ul><p>setattr()函数可以用来修改实例对象中的属性值，也可以实现为实例对象动态添加属性或者方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># setattr(obj, name, value)</span><br><br>cat = Cat()<br><span class="hljs-comment"># 设置属性值或方法</span><br><span class="hljs-built_in">setattr</span>(cat, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)<br><span class="hljs-built_in">setattr</span>(cat, <span class="hljs-string">&quot;master&quot;</span>, <span class="hljs-string">&quot;456&quot;</span>)<br><span class="hljs-built_in">setattr</span>(cat, <span class="hljs-string">&quot;miao&quot;</span>, <span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xxxxxx...&quot;</span>))<br><br><span class="hljs-comment"># 添加属性或方法</span><br><span class="hljs-built_in">setattr</span>(cat, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-number">789</span>)<br><span class="hljs-built_in">setattr</span>(cat, <span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;run....&quot;</span>))<br></code></pre></td></tr></table></figure><h1 id="迭代器与生成器">迭代器与生成器</h1><h2 id="迭代器">迭代器</h2><p>迭代器是一个可以记住遍历位置的对象，它从集合的第一个元素开始访问，知道所有的元素都被访问结束。迭代器只能往前而不能后退。我们需要利用<code>iter()</code>方法来创建一个迭代器对象，然后使用其中提供的一个<code>next</code>方法来访问下一个元素，我们也可以用常规的for来遍历一个迭代器对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>it = <span class="hljs-built_in">iter</span>(a) <span class="hljs-comment"># 创建迭代器对象</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it)) <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it)) <span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><p>我们也可自己创建一个迭代器，只需要在自定义的类中实现两个方法<code>__iter__()</code>以及<code>__next__()</code>方法：</p><ul><li><code>__iter__()</code>：返回一个迭代器对象，这个对象实现了<code>__next__()</code>方法，并通过<code>StopIteration</code>异常来标识迭代的完成</li><li><code>__next__()</code>：返回下一个值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumbers</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        self.num = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.num &gt; <span class="hljs-number">20</span>:<br>            <span class="hljs-keyword">raise</span> StopIteration<br>        x = self.num<br>        self.num += <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> x<br><br><br>myNumbers = MyNumbers()<br>myIter = <span class="hljs-built_in">iter</span>(myNumbers)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myIter)) <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myIter)) <span class="hljs-comment"># 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---&quot;</span>) <span class="hljs-comment"># ---</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> myIter:<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 1 3 5 ... 17 19</span><br><br></code></pre></td></tr></table></figure><h2 id="生成器">生成器</h2><p>使用了yield的函数被称生成器（Generator）。生成器是一个返回迭代器的函数，只能用于迭代操作，我们可以将生成器理解为一个迭代器。在每次调用生成器的时候，遇到yield函数会暂停并保存当前的运行信息，返回yield的值，直到下一次调用next方法的时候再从当前位置继续运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generateOdd</span>(<span class="hljs-params">n</span>):<br>    a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> a &lt; n:<br>        <span class="hljs-keyword">yield</span> a<br>        a += <span class="hljs-number">2</span><br><br><br>it = generateOdd(<span class="hljs-number">26</span>)  <span class="hljs-comment"># it为一个迭代器，由生成器返回生成</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> it:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><h1 id="依赖生成">依赖生成</h1><p>一个好的习惯是对于每一个Python项目都准备一个对应的虚拟环境，这样可以保证不同项目之间的环境不会产生冲突。在Python中也提供了相关的命令来查看当前的依赖项，下面的命令可以列出当前环境中的依赖项。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip freeze<br></code></pre></td></tr></table></figure><p>不过直接使用该命令可能会输出一些路径信息而非版本信息，此时使用下面的命令可以解决：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip list --format=freeze<br></code></pre></td></tr></table></figure><p>通常情况下，我们会将项目的依赖项以及相关版本都存放在<code>requirements.txt</code>文件当中，此时我们将上面命令的输出进行重定向即可。同时，我们也可以很轻易地通过这个文件进行依赖项的安装，通过下面的命令即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install -r requirements.txt<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://www.runoob.com/python3/python3-tutorial.html">Python3 教程| 菜鸟教程 (runoob.com)</a></li><li><ahref="http://c.biancheng.net/python/special_member/">Python类特殊成员（属性和方法）(biancheng.net)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《知识图谱-概念与技术》读书笔记</title>
    <link href="/2022/10/25/%E3%80%8A%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/25/%E3%80%8A%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="知识图谱基础">知识图谱基础</h1><p>知识图谱的概念最初由Google公司提出，指的是Google公司为了支撑其语义搜索而建立的知识库。而随着及技术的深化，知识图谱已经成为了大数据时代最重要的知识表示方式。它是一种大规模语义网络，包含实体，概念以及它们之间的各种语义关系。</p><p>知识图谱通常以图的形式存在，其中的节点可能代表了实体、概念或者值。实体指的是对象或者实例，是属性赖以存在的基础；概念又被称为类别，代表了一类实体；值即为每个实体的属性值，可以是常见的数值类型，文本类型等。知识图谱中的边可以分为属性、关系。实体和值之间构成属性关系，而关系可以看作是一类特殊的属性，当实体的某个属性值也是实体，则这个属性就是关系。</p><p>与知识图谱相似的概念是传统的知识工程。而相比于传统的语义网络，知识图谱规模巨大并且语义丰富。传统知识工程中，知识获取的环节通常依赖于专家人力来完成，无法做到大规模的要求。而知识图谱的实现通常依赖于大规模的自动化知识获取。随着互联网的兴起，大数据时代的到来，自动化知识获取成为可能。数据、算力和模型的飞速发展也带动了知识图谱的发展。另一方面，高质量的用户生成内容提供了高质量的知识库来源。传统知识工程中知识来源一般是专家学者，而知识图谱的知识来源通常是互联网上的信息。互联网上的信息纷繁杂乱，质量参差不齐，但是包括百科、社区、论坛、问答平台等多种形式在内，互联网上大量高质量内容集中在这些平台上，我们可以通过自动化的方式获取这些高质量知识。</p><p>在知识图谱的生命周期中，通常会涉及到下面的过程：知识图谱的构建，其中我们需要完成对知识的获取；知识图谱的管理，其中我们需要完成对知识进行表示与建模，同时将其存储在合适的管理系统中，完成相关的查询；知识图谱的应用，即让其他的应用场景从知识图谱上受益。接下来就简单介绍相关的过程。</p><h1 id="知识图谱构建">知识图谱构建</h1><h2 id="词汇挖掘与实体识别">词汇挖掘与实体识别</h2><p>从图模型的角度来看，构建知识图谱的第一步是获取图模型中的实体。实体通常使用文本中的词汇或短语来描述，因此我们需要从文本预料中挖掘出尽可能多的高质量词汇，并从这些词汇中筛选出目标知识图谱所需要的实体。前者涉及到的技术包括领域短语挖掘、同义词挖掘和缩略词挖掘等，而后者涉及到的技术包括命名实体识别等。</p><h3 id="领域短语挖掘">领域短语挖掘</h3><p>领域短语挖掘需要解决的问题是从给定的领域语料当中自动挖掘出该领域的高质量短语。它的输入是领域语料，而输出是领域中的高质量短语。一个高质量短语通常独立描述了一个完整的，不可分割的语义单元。短语的质量可以从频率、一致性、信息量和完整性等角度来评估。</p><ul><li>频率：一个高质量短语通常在文本中出现得较为频繁</li><li>一致性：组成短语的单词序列搭配频率要明显高于其他组合</li><li>信息量：高质量短语应该传达一定的信息，表达一定的主题或者概念</li><li>完整性：高质量短语在特定的上下文中式一个完整的语义单元</li></ul><p>早期的领域短语挖掘方法主要式基于规则的。我们针对特定领域手工设计预定义的词性标签规则来识别文档中的高质量名词短语。这种方法存在一定的局限性，它的适用性不高，并且规则定义较为困难，并且难以穷举所有的规则。</p><p>而近年来的短语挖掘方法，更多地基于短语的统计指标，并且又可以分为无监督学习和监督学习两大类方法。</p><p>无监督方法通过计算候选短语的统计指标特征来挖掘领域短语。第一步我们需要通过文本语料生成候选短语，这些候选短语应该是高频的N-Gram（连续N个词序列）。第二步计算候选短语的统计指标特征，如TF-IDF、C-value、NC-value、PMI、左邻字熵、右邻字熵等。第三步，我们利用得到的统计指标计算每个候选短语的质量评分，用来评估短语的质量。第四步则是对所有候选短语按照分数从高到低进行排序，取排名靠前的短语作为最终输出。</p><p>监督方法则是在无监督方法的基础上增加了一些步骤。在监督方法中，我们有一定的标注样本，则可以利用这些标注样本以及对应的统计指标特征来训练一个二元分类器，分类结果即判断该候选短语是否是高质量短语。</p><p>前面的方法都需要计算统计指标特征，常用的统计指标特征有TF-IDF、C-value、NC-value、PMI、左邻字熵、右邻字熵。这里我们只对不同的指标进行定性的了解，而不涉及具体的数学定义。</p><p>TF-IDF，词频-逆文档频率。它通常用来评价一个短语在语料中的重要性。它考虑到一个短语在内部文档以及外部文档的频率。领域词汇应当在内部文档中出现频率较高，而在外部文档中出现频率相对较低。我们利用TF-IDF来挖掘能够有效代表某篇文档特征的短语。</p><p>C-value在词频的基础上考虑了短语的长度以及父子短语对于词频统计的影响，考虑了统计候选短语频率时父短语的重复统计对于短语频次估计所带来的偏差。而NC-value则是在C-value的基础上，额外利用了短语的上下文信息，来挖掘高质量短语。</p><p>PMI刻画了短语组成部分之间的一致性程度。如果两个短语联合出现的概率远大于两者在独立情况下随机共同出现的概率，说明这两个部分共同出现是有意义的，预示着两者应该组成一个有意义的短语。通常利用PMI来挖掘一致性较高，经常一起搭配的短语。</p><p>左邻字熵和右邻自熵表示一个短语左右搭配的丰富程度。一个高质量的短语应该有丰富的左右搭配，而如果一个短语的左右邻字总是一个固定词汇，则这个短语的质量就不高。通常用左邻字熵和右邻自熵来挖掘自由运用程度较高的短语。</p><h3 id="同义词挖掘">同义词挖掘</h3><p>同义词指的是意义相同或者相近的词。在大量的文本中，我们通常会遇到同义词，它们在语义上相近，但是对应的是同一个实体，机器需要能够判别这种同义词，因此，同义词挖掘是需要解决的问题。</p><p>典型的同义词挖掘的方法有基于同义词资源的方法，以及基于模式匹配的方法。前者的同义词资源来源于字典、百科词条等，上面有许多已经整理好的同义词资源，这些资源虽然质量较高，但是收录不完整。后者指的是利用同义词在句子中被提及的文本模式从句子中挖掘同义词，例如常见的模式有“又称”，“也称为”等。利用这些模式从句子中匹配来获取同义词。模式匹配虽然能够较为准确地获取同义词，但是我们无法穷尽所有的模式。</p><p>对于这个问题，自举法是一个较好的解决方案。这是一个迭代循环的过程，我们可以使用事先准备好的模式匹配得到同义词对，然后在语料中搜索同义词对的新模式，来扩充我们的模式，而后循环利用更多的模式从语料中匹配同义词。这种方式虽然可以自动挖掘新模式，但是自动学习获得的新模式质量难以保证。</p><h3 id="命名实体识别">命名实体识别</h3><p>命名实体是一个词或者短语，它能够清楚地标识某一个事务。命名实体识别（NamedEntityRecognition，NER）指的是在文本中定位命名实体的边界，并将其分类到预定义类型的集合中。对于该问题，我们的输入是句子所对应的单词序列，输出一个三元组集合。集合中，每个三元组代表一个命名实体，形式为<code>&lt;开始位置, 结束位置, 实体类型&gt;</code>。</p><p>传统的NER方法主要分为基于规则的方法，监督学习方法和半监督学习方法。</p><p>在句子中，实体出现的模式往往具有一定规律性。基于规则的方法指的是由语言专家指定规则，通过匹配规则和模式来从句子中对实体进行识别。不过同其他基于模式的方式一样，这种方法同样面对模式无法穷尽的问题。而在监督学习方法中，NER被看作是序列标注问题，它使用BIO标注法，为单词序列的每个单词标注不同的类型，其中B表示实体的起始位置、I表示实体的中间或者结束位置、O表示对应字符不是实体。这样我们将NER问题转化成输入文本，输出BIO序列。这种方式从大规模序列标注样本中学习实体标注模式，然后利用学习到的模式对新的句子进行标注。在NER中，另一类典型的半监督方法是自举法，它从少量的标注数据、大量未标注数据开始，通过一些初始模式迭代生成更多的标注数据，然后进行监督学习。</p><p>近年来，深度神经网络被广泛应用于各类自然语言处理任务中。基于深度学习的方法通常将NER问题建模为序列标注问题。深度学习模型接收句子的词向量或者字向量表示作为输入，通过上下文编码器从输入表示中学习。上下文编码器有两种常用的模型结构，卷积神经网络（CNN）和循环神经网络（RNN），前者能够有效地提取输入数据的局部特征，而后者则考虑了句子中前后字符的相互影响。在之后，由标签解码器将经过编码的上下文表示作为输入，输出对应的标签。</p><h2 id="关系抽取">关系抽取</h2><p>在获取了实体之后，我们相当于获取了知识图谱中的节点。而关系抽取则构成了知识图谱的边。关系抽取指的是从给定的句子中抽取实体以及实体之间的关系，即抽取三元组，三元组的形式为<code>&lt;主体, 谓词, 客体&gt;</code>，通常一个三元组表达了主体和客体之间的一层关系。通过NER我们可以找到句子中包含的实体作为主客体，于是需要完成的就是利用句子的信息填充其中关系部分。常用的关系抽取方式包括基于模式的抽取、基于学习的抽取以及开放关系抽取。</p><p>基于模式的关系抽取通过定义语义模式，将模式与文本进行匹配，来事先关系实例的获取。我们可以根据已知的关系，依据其在文本中的表达方式来构造相关模式，进一步通过模式匹配来抽取关系实例，从而完成关系抽取。进一步，基于模式的关系抽取又分为基于字符模式、基于语法模式和基于语义模式。基于字符模式的关系抽取直接将文本直接视为字符序列，将表达特定关系的字符模式表示为一组正则表达式，从而完成关系抽取。基于语法模式的关系抽取则引入文本所包含的语法信息，词性标签等来描述模式，增强模式的表达能管理。基于语义模式的关系抽取则通过引入语义元素，精确地表达模式适配的范围。而为了解决模式无法穷举的问题，同样可以通过自举法来进行自动化的模式获取。</p><p>基于学习的关系抽取主要分为基于监督学习的抽取、基于半监督学习的抽取以及基于远程监督学习的抽取。监督学习的前提是存在大规模的标注数据，但是人工标注成本较高，因此引入半监督学习和远程监督学习。远程监督学习本质上是一种快速构建训练集的方法，它利用外部知识对目标任务实现间接监督。远程监督学习认为，如果一个实体对具有某种关系，那么包含实体对的句子都在某种程度上描述了该实体对之间的关系，据此就可以从大规模知识库中获得对应的数据，实现标注，得到大规模的带标签的自然语言语句。当然，基于远程学习构建的训练集会引入很多噪声，需要利用一些方式来对标注数据进行甄别和筛选。基于深度学习的关系抽取能够自动学习有效特征，但是它需要大量标注数据，因此常与远程学习联合使用，通过大规模标注数据来训练深度学习模型。</p><p>不过主流的关系抽取方法通常需要预定义关系类别，然后才能抽取满足给定关系类别的实体对，本质上完成的还是一个分类任务。但是在现实世界中，关系的种类是复杂多样的，难以穷举。开放关系抽取（OpenIE）则希望直接从自然语言文本中抽取出三元组形式的关系实例，抽取出的关系不限于预定义的关系类型，而是文本中可能出现的所有关系实例。OpenIE更多地可以理解为是一种基于浅层语法分析的文本结构化任务。目前的开放关系抽取系统有TextRunner、ReVerb、Ollie等。</p><h1 id="知识图谱管理">知识图谱管理</h1><p>从文本中获取知识之后，我们需要对这些知识进行有效的管理。知识图谱应用的前提就是对这些知识数据的有效表示和存储。逻辑层面的表示是从人的角度对知识图谱中的数据进行描述，而物理层面的存储则是从计算机的角度对数据进行组织，两者紧密相关，但这里我们更加关注逻辑层面的表示。</p><h2 id="数据模型">数据模型</h2><p>知识图谱的基本表示模型为三元组模型，即<code>&lt;主体, 谓词, 客体&gt;</code>。三元组中的谓词可以是两个实体之间的关系，也可以是一个实体的某种属性，如果是后面的情况，三元组的形式为<code>&lt;主体, 属性, 属性值&gt;</code>。由此，一个知识图谱数据集可以看作是一个三元组的集合。但是基本的三元组模型只讨论了较为简单的二元关系语义，如果需要表达一些相对复杂的语义，如时空信息，多模态知识等，则需要基于三元组扩展为四元组甚至五元组。</p><p>另一种常用的知识图谱模型是图模型。通过预先定义的语义关联，三元组数据可以转化为一个或者多个连通图。而知识图谱一个直观的表达形式也是图模型的形式。三元组中的实体作为图模型中的节点，而关系则作为边，每个具体的谓词则看作是边上的属性，这样就得到了知识图谱中基本的有向图模型。除了有向图外，属性图也是另一种常用的数据模型。属性图中支持节点属性和边属性，则可以简化有向图中对于属性的表达。</p><p>从基本的有向图中衍生出来的，还有带权重的有向图和带概率的有向图。这种模型的出现主要是对应我们在获取知识过程中可能遇到的情况。我们在获取每条关系的时候，可以附加上该关系在语料中被观察到频率，以此来代表该关系的典型性。或者在获取关系的时候，保留该关系的置信度，表达这种关系是真实事实的概率。这样获得的知识，则可以被建模成带概率的有向图。</p><h2 id="查询与检索">查询与检索</h2><p>查询和检索是知识图谱的重要使用方式，也是知识图谱数据管理系统的核心能力之一。国际标准化组织W3C提出了针对知识图谱的标准化查询语言SPARQL，（类比SQL基于关系型数据库）这是一种声明式的结构化查询语言，用户只需要按照定义的语法规则来描述查询的信息，而不需要明确指定实现查询的步骤。其中，SPARQL提供了一套完整的查询操作符，包括选择、排序、聚集等。</p><p>将知识图谱考虑成图结构，我们常用的查询操作可以看作是子图查询。一方面，子图查询匹配返回的结果可能非常多，为了从中找到更有价值的结果，需要进行进一步的处理和筛选。另一方面，常规的子图匹配运算要求查询图中的每个节点映射到图中具有相同标签的节点，此要求过于严格，在实际场景中会丢失很多有意义的匹配。因此，在子图查询上衍生出近似子图查询，意在匹配语义更加丰富的结果。</p><p>除了子图查询外，常见的查询还有路径查询、关键词查询、社团搜索等。路径查询表达了两个实体之间的某种关联关系。关键词查询则返回包括指定关键字的子树或者子图，适用于搜索引擎的场景。实际上包含某个关键字的子树或者子图可能会很多，因此需要从中筛选出满足特定条件的结果。社团结构指的是一组内部互相紧密联系的节点，但是它们与社团之外节点的联系则相对松散。社团搜索包括社团挖掘和社团查询，通常应用在团队推荐、风险控制、犯罪团伙发现等领域。传统的社团搜索一般只考虑结构上的特征，而在知识图谱场景下，应该需要考虑相应的语义信息。</p><h2 id="图数据管理系统">图数据管理系统</h2><p>落地到计算机层面上，知识图谱的存储和管理与图数据管理系统息息相关。知识图谱的应用场景对图数据管理系统提出了新的要求，包括在线查询，离线分析等。在线查询通常服务于实时交互类任务，要求高响应、低延迟，常见的任务有针对实体、属性、关系、子图结构等的查询；而离线分析通常用于批量图分析和处理，要求高吞吐量，常见的任务有基于图结构的计算、基于规则的推理、规则挖掘以及辅助分析等。</p><p>有关图数据管理系统的架构和设计的相关内容不进行展开，这里只介绍一些典型的图数据管理系统。对于通用图数据管理系统的考察通常考虑下面的因素：</p><ul><li>数据是否以原生图的表示形式存在。原生图存储容易实现高效的图数据操作，非原生图则会有性能上的损失</li><li>是否支持低延迟的在线查询</li><li>是否支持数据分片和分布式图数据处理</li><li>是否选择内存为主要存储介质</li><li>是否支持事务</li></ul><p>当前典型的通用图数据管理系统包括Neo4j、GraphEngine、Horton、FlockDB、TinkerGraph、InfiniteGraph、Cayley、Titan、MapReduce、PEGASUS、Pregel、Giraph、GraphLab、GraphChi、GraphX等。</p><p>另一种是专门针对知识图谱的图数据管理系统，主要考察点为性能、易用性和可扩展性。当前的知识图谱专用图数据管理系统包括BitMat、TripleBit、gStore、Trinity.RDF、Stylus等。</p><h1 id="知识图谱应用">知识图谱应用</h1><p>构建知识图谱的最终目的还是落在了应用上，基于知识图谱我们可以发掘多种多样的应用场景。包括数据分析、智慧搜索、智能推荐、人机交互、决策支持等。这里主要关注基于知识图谱的搜索与推荐。搜索与推荐是知识图谱的两类重要应用，也是当前知识图谱落地的重要形态。</p><p>搜索和推荐是互联网时代的两类重要信息服务。从目标来看，这两者都是向用户准确提供其希望获取的对象，例如网页、资料、商品等资源。传统的搜索与推荐模型大都是基于用户的历史行为来产生结果，从用户的历史搜索、点击、购物、浏览等行为中来获得用户行为的统计规律。但是这种方式由于数据匮乏，难以捕捉个体行为背后的动机，只能将群体的行为特征简单移植到个体上，而忽略用户的个性特征。尽管也有一些个性化模型，但也是一定程度上细化了统计模型的适用范围，而没有改变用群体行为来服务个体的本质。</p><p>知识图谱的引入可以提升系统的效果。第一，知识图谱有助于用户画像的完善，丰富对用户以及各类互联网资源的描述；第二，知识图谱能够发掘用户和物品之间的语义关联；第三，知识图谱能够为搜索和推荐提供可解释依据，提高用户采信结果的可能；第四，知识图谱能够为用户信息探索提供认知框架，使得系统能够在满足用户当前搜索和购物需求的同时，合理组织结果，积极拓展当前实体的其他相关信息。</p><p>一次搜索过程应该分为：用户提交查询、系统匹配查询的内容，查询结果经过排序后返回给用户。通常情况下，我们得到的查询结果都会有很多，用户关心的内容很容易淹没在大量结果中，因此，搜索的核心诉求是搜索直达目标。基于知识图谱的实体搜索主要分为四个步骤：搜索意图理解、目标查找、结果呈现以及实体探索。</p><p>搜索意图理解即通过用户提供的搜索关键词或者其他文本形式，来准确定位搜索的目标。根据理解的形式，又可以分为主题分类、语法解析和语义解析等任务。主题分类希望得到查询的主题；语法解析希望得到查询中关键词的词性标注或者语法修饰关系；语义解析则希望得到关键字对应的语义角色，比语法解析更加关注查询关键词之间的语义关联。这里的查询文本通常不符合严格的语法规则，并且查询文本往往是短文本，能够从中获取的上下文信息较少。知识图谱的作用主要体现在能够帮助搜索系统提高对于短文本的理解能力。</p><p>在获取搜索意图之后，就是目标查找过程。这一步只需要根据不同的查询条件生成查询语句，或者使用特定的算法从知识图谱中找到目标实体即可。</p><p>之后的过程是结果呈现，其中又分为结果排序以及结果内容的分类与组织。结果排序的依据可能是结果在知识图谱网络结构中的重要性、实体的流行度、与查询的相关性等。</p><p>实体探索指的是呈现目标实体以外的关联内容，拓展相关内容，以此增加搜索结果的多样性。主要内容包括相关实体发现、实体摘要以及相关实体解释。相关实体发现可以依据知识图谱中图结构的相似程度，包括关系和类型的相关性，也可以依据实体共同出现的程度。实体摘要指的是从文本中获取相关信息，可能的形式有文本摘要和图形化摘要，知识图谱的可视化就是一种很好的图形化摘要。相关实体解释指的是对展现结果的合理解释，这是提高结果可信度和用户体验的关键。基于知识图谱我们可以获取实体之间的某种联系，以此作为解释展现给用户。</p><h1 id="常见知识图谱列表">常见知识图谱列表</h1><p>【以下数据来源于原书<code>P_31</code>《知识图谱：概念与技术》】</p><table style="width:100%;"><thead><tr class="header"><th>知识图谱</th><th>特点</th><th>构建方式</th><th>语言</th><th>类型</th></tr></thead><tbody><tr class="odd"><td>Cyc</td><td>通过人工的方式将上百万条人类常识编码成机器可用的形式，用于智能推断</td><td>人工</td><td>英语</td><td>常识</td></tr><tr class="even"><td>WordNet</td><td>以同义词集合作为基本单元</td><td>人工</td><td>英语</td><td>词汇</td></tr><tr class="odd"><td>ConceptNet</td><td>多语言常识知识库</td><td>自动</td><td>多语言</td><td>常识</td></tr><tr class="even"><td>Freebase</td><td>众包编辑</td><td>半自动</td><td>英语</td><td>百科</td></tr><tr class="odd"><td>GeoNames</td><td>多语言地理位置信息</td><td>半自动</td><td>多语言</td><td>地理</td></tr><tr class="even"><td>DBpedia</td><td>多语言自动构建</td><td>半自动</td><td>多语言</td><td>百科</td></tr><tr class="odd"><td>YAGO</td><td>人工校验，时空维度，多语言</td><td>自动</td><td>多语言</td><td>百科</td></tr><tr class="even"><td>OpenIE</td><td>开放性关系抽取，Never-Ending</td><td>自动</td><td>英语</td><td>文本</td></tr><tr class="odd"><td>BabelNet</td><td>271种语言，自动编辑</td><td>自动</td><td>多语言</td><td>词汇</td></tr><tr class="even"><td>WikiData</td><td>众包编辑</td><td>半自动</td><td>多语言</td><td>百科</td></tr><tr class="odd"><td>Google知识图谱</td><td>规模最大</td><td>自动</td><td>多语言</td><td>总和</td></tr><tr class="even"><td>Probase</td><td>概念规模最大</td><td>自动</td><td>英语</td><td>概念</td></tr><tr class="odd"><td>搜狗知立方</td><td>侧重于娱乐领域</td><td>自动</td><td>汉语</td><td>百科</td></tr><tr class="even"><td>百度知心</td><td>支持百度搜索</td><td>自动</td><td>汉语</td><td>百科</td></tr><tr class="odd"><td>CN-DBpedia</td><td>实时更新，完整的数据/服务接口</td><td>自动</td><td>汉语</td><td>百科</td></tr></tbody></table><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://baike.baidu.com/item/知识图谱：概念与技术/24247324">知识图谱：概念与技术</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>领域</category>
      
      <category>知识图谱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识图谱</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring笔记(5)-SSM项目整合</title>
    <link href="/2022/10/20/Spring%E7%AC%94%E8%AE%B0-5-SSM%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88/"/>
    <url>/2022/10/20/Spring%E7%AC%94%E8%AE%B0-5-SSM%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="ssm整合">SSM整合</h1><p>SSM分别指代三个框架，即表示层的SpringMVC，业务逻辑层的Spring以及数据访问层的MyBatis。SSM整合即完成这三个框架的整合，在其中，Spring起关键整合作用。由于这是一个Web项目，我们还是需要准备Web项目相关环境，引入基础的依赖。然后修改对应配置完成SSM整合的工作。</p><h2 id="spring与springmvc整合">Spring与SpringMVC整合</h2><p>Spring和SpringMVC属于同源，我们完成SSM的整合，要到达的目的是Controller层的Bean对象交给SpringMVC管理，其他对象则交给Spring来管理，即存在两个IOC容器。由于Controller层的对象在初始化的时候，会涉及到Service层的对象，而这两层分别在不同的IOC容器中，初始化时机无法保证同步。因此，我们需要使用<code>ContextLoaderListener</code>监听器来解决相关问题。</p><p>Spring提供了监听器<code>ContextLoaderListener</code>，它实现了<code>ServletContextListener</code>接口，可以监听<code>ServletContext</code>的状态。在Web服务器启动的时候，会读取Spring的配置文件，创建Spring的IOC容器。要使用该监听器，我们需要在<code>web.xml</code>中进行相关配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--监听Spring配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><span class="hljs-comment">&lt;!--自定义Spring配置文件的位置和名称--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果我们没有指定Spring配置文件的位置和名称，那么我们需要使用其默认的位置与名称<code>/WEB-INF/applicationContext.xml</code>。如果指定了，则由我们指定的为准。</p><p>这样，在SSM整合的项目中，我们的<code>web.xml</code>中应该包含Spring的编码过滤器、请求方式的过滤器、SpringMVC的前端控制器、以及Spring配置文件的监听器。这里SpringMVC的前端控制器指定了SpringMVC配置文件的位置，Spring配置文件的监听器指定了Spring配置文件的位置。</p><h2 id="spring与mybatis整合">Spring与MyBatis整合</h2><p>首先我们需要准备Spring与MyBatis整合的相关依赖，具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Mybatis和Spring的整合包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>简单回顾MyBatis的工作原理，在MyBatis中，涉及到核心配置文件，Mapper接口以及对应的Mapper配置文件。在使用的时候，我们需要通过核心配置文件获取输入流，然后新建一个<code>SqlSessionFactoryBuilder</code>对象，结合输入流来获取<code>SqlSessionFactory</code>工厂对象，再通过工厂对象创建出<code>SqlSession</code>对象，最终通过<code>SqlSession</code>对象的getMapper方法，得到相应Mapper接口对应的实现类对象。</p><p>整合MyBatis和Spring，我们需要在Spring的配置文件中配置SqlSessionFactory的工厂Bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置用于创建SqlSessionFactory的工厂Bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置MyBatis配置文件的路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--设置数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--设置映射文件的路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>SqlSessionFactoryBean</code>是一个FactoryBean，它提供的对象为<code>SqlSessionFactory</code>类型的对象，这也就是IOC容器中管理的实际Bean对象。在其中我们可以通过属性设置MyBatis核心配置文件的路径。</p><p>当然我们也可以不设置，而是在内部将MyBatis核心配置文件中所有相关配置都进行配置，每个属性都可以找到对应的标签进行设置。这里的<code>mapperLocations</code>用于设置映射文件的路径。默认映射文件和Mapper接口所在路径一致，如果我们也是按照这种方式存放，则不需要设置该属性。</p><p>我们也可以设置Mapper接口的扫描配置。这是mybatis-spring依赖提供的类，可以将指定包下所有Mapper接口创建动态代理，并将这些动态代理作为IOC容器的Bean管理，这样我们就可以直接获取到Mapper接口的实现类对象。当然这里需要满足接口和配置文件在同一个包路径下，且将basePackage属性设置为对应的包路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置Mapper接口的扫描配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.syh.mvc.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>MyBatis</tag>
      
      <tag>SpringMVC</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC笔记(6)-拦截器,异常解析器与配置类</title>
    <link href="/2022/10/20/SpringMVC%E7%AC%94%E8%AE%B0-6-%E6%8B%A6%E6%88%AA%E5%99%A8-%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%99%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%B1%BB/"/>
    <url>/2022/10/20/SpringMVC%E7%AC%94%E8%AE%B0-6-%E6%8B%A6%E6%88%AA%E5%99%A8-%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%99%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="拦截器">拦截器</h1><h2 id="介绍">介绍</h2><p>在SpringMVC中，拦截器主要用来拦截控制器方法的执行。它可以在控制器方法执行前后等位置执行相关的代码。</p><blockquote><p>在前面我们还提到过过滤器filter的概念。过滤器指的是在浏览器和DispatcherServlet之间的过滤操作，浏览器发送的请求需要先经过过滤器操作，然后再由DispatcherServlet进行处理。</p></blockquote><p>SpringMVC中拦截器通过实现接口<code>HandlerInterceptor</code>来实现，在其中一共有三个方法需要进行重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;preHandle...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;postHandle...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;afterCompletion&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现了拦截器相关代码后，我们需要在SpringMVC中的配置文件中配置该拦截器，才能进行使用。具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置拦截器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.mvc.interceptor.MyInterceptor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p>拦截器的配置使用<code>&lt;mvc:interceptors&gt;</code>，在其中我们可以指定对应的bean，对应我们的拦截器类。当然除了使用<code>bean</code>标签指定对应类，也可以在外面定义一个Bean，然后在这里使用<code>&lt;ref&gt;</code>标签指定对应Bean。这种配置方式直接指定了对应的类。这种配置方式会对所有的请求进行拦截。</p><p>在<code>&lt;mvc:interceptors&gt;</code>标签中，我们还可以使用<code>&lt;interceptor&gt;</code>标签，其中可以指定更加细节的配置，包括处理请求路径，需要排除的路径，使用的拦截器类等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/dontWantToSee&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.mvc.interceptor.MyInterceptor&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>这里的<code>/**</code>表示匹配所有请求，而<code>/*</code>则表示仅匹配单层目录。</p></blockquote><h2 id="handlerinterceptor">HandlerInterceptor</h2><p>我们的拦截器需要实现<code>HandlerInterceptor</code>接口，其中的接口方法有一共有三个：</p><ul><li><code>public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code>：在控制器方法执行之前执行preHandle，返回值为一个布尔类型的值，表示是否放行。如果返回true，则表示放行该请求，如果返回false，则表示拦截该请求。</li><li><code>public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</code>：在控制器方法执行之后执行postHandle方法。</li><li><code>public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</code>：在处理完视图和模型数据以及渲染视图完毕之后，执行afterCompletion方法。</li></ul><h2 id="拦截器的执行顺序">拦截器的执行顺序</h2><p>单个拦截器的执行顺序为：preHandler() -&gt; postHandle() -&gt;控制器方法 -&gt;afterCompletion()。而如果配置了多个拦截器，则拦截器的执行顺序与其在SpringMVC配置文件中的配置顺序有关。</p><p>如果每个拦截器的preHandle()方法都返回true，那么每个拦截器的方法都会执行，preHandle()方法按照配置的顺序执行，而postHandle()和afterCompletion()方法会按照配置顺序的逆序执行。</p><img src="/2022/10/20/SpringMVC%E7%AC%94%E8%AE%B0-6-%E6%8B%A6%E6%88%AA%E5%99%A8-%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%99%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%B1%BB/%E5%A4%9A%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8%E9%A1%BA%E5%BA%8F1.png" class="" title="多个拦截器顺序1"><p>如果其中有一个拦截器的preHandle()方法返回了false，则后续的所有拦截器方法都不会执行，控制器方法也不会执行。而对于前面的拦截器，它们的preHandle()方法仍然是顺序执行，postHandle()方法都不执行，但是afterCompletion()方法会逆序执行。</p><img src="/2022/10/20/SpringMVC%E7%AC%94%E8%AE%B0-6-%E6%8B%A6%E6%88%AA%E5%99%A8-%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%99%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%B1%BB/%E5%A4%9A%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8%E9%A1%BA%E5%BA%8F2.png" class="" title="多个拦截器顺序2"><h1 id="异常处理器">异常处理器</h1><p>SpringMVC中的异常处理器用于处理控制器方法执行过程中所出现的异常，对应的接口为<code>HandlerExceptionResolver</code>。通过异常处理器，我们可以在出现异常的时候跳转到相应页面，提高用户体验。</p><p>对于该接口，在SpringMVC中提供了两个实现类，分别是<code>DefaultHandlerExceptionResolver</code>以及<code>SimpleMappingExceptionResolver</code>，其中默认的异常处理器即SpringMVC中默认使用的，而<code>SimpleMapplingExceptionResolver</code>则是自定义的异常处理器，我们可以利用注解配置来使用。在SpringMVC配置文件中配置如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置异常处理器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--指定不同异常相应的跳转页面--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionMappings&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--将异常信息在请求域中共享，对应键值对的key名称为这里value的值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionAttribute&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ex&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>其中我们可以在exceptionMappings属性中指定不同异常对应的跳转页面，这里的error为视图的名称。我们也可以利用exceptionAttribute属性将异常信息在请求域中共享，并指定对应的key名称。</p><p>我们也可以创建自己的类用作异常处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorController</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler(ArithmeticException.class)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">handlerArithmeticException</span><span class="hljs-params">(Model model, Exception ex)</span> &#123;<br>        model.addAttribute(<span class="hljs-string">&quot;ex&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们利用<code>@ControllerAdvice</code>注解将当前类标识为异常处理的组件，其中的方法用于处理不同的异常，并用<code>@ExceptionHandler</code>标识该方法需要处理的异常。在形参中，我们可以利用Exception类型来承接当前处理中出现的异常对象。</p><h1 id="springmvc中的配置类">SpringMVC中的配置类</h1><p>在SpringMVC中，我们用到的配置文件有项目配置文件<code>web.xml</code>，SpringMVC的配置文件<code>springMVC.xml</code>，后续还可能会用到Spring的配置文件<code>spring.xml</code>。我们可以使用配置文件，也可以用配置类来代替这些配置文件。</p><p>在Servlet3.0环境中，容器会在类路径中查找实现了<code>javax.servlet.ServletContainerInitializer</code>接口的类，如果找到的话，就会利用这个类来配置Servlet容器。Spring中提供了这个接口的实现类，名称为<code>SpringServletContainerInitializer</code>。这个类会查找实现了<code>WebApplicationInitializer</code>的类，实际配置的任务交由它来完成。Spring3.2中提供了该接口的一个基础实现，名称为<code>AbstractAnnotationConfigDispatcherServletInitializer</code>。因此，我们只需要实现自己的类来继承该类，容器会自动发现然后利用它来配置Servlet上下文。</p><p>我们实现的类对应配置文件<code>web.xml</code>。在<code>web.xml</code>中，我们会配置Spring的相关信息，配置SpringMVC的相关信息，配置前端控制器DispatcherServlet的映射规则url-pattern以及过滤器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebInit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 指定Spring的配置类</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;SpringConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 指定SpringMVC的配置类</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;SpringMVCConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 指定DispatcherServlet的映射规则，即url-pattern</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 添加过滤器</span><br>    <span class="hljs-keyword">protected</span> Filter[] getServletFilters() &#123;<br>        <span class="hljs-type">CharacterEncodingFilter</span> <span class="hljs-variable">encodingFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharacterEncodingFilter</span>();<br>        encodingFilter.setEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        encodingFilter.setForceEncoding(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">HiddenHttpMethodFilter</span> <span class="hljs-variable">hiddenHttpMethodFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HiddenHttpMethodFilter</span>();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring的配置类SpringConfig对应Spring的配置文件。在SSM整合之后，Spring的配置信息书写在此类中。</p><p>SpringMVC的配置类SpringMVCConfig对应SpringMVC的配置文件。在SpringVC的配置文件中，我们一般会完成扫描组件、视图解析器、默认Servlet配置、MVC注解驱动、视图控制器、文件上传解析器、拦截器、异常解析器等功能，这些功能都可以在接口<code>WebMvcConfigurer</code>中找到相应的方法，我们的配置类也需要实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">// 标识为配置类</span><br><span class="hljs-meta">@ComponentScan(&quot;com.syh.mvc&quot;)</span> <span class="hljs-comment">// 组件扫描</span><br><span class="hljs-meta">@EnableWebMvc</span> <span class="hljs-comment">// 开启MVC注解驱动</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMVCConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 使用默认的Servlet处理静态资源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span> &#123;<br>        configurer.enable();<br>    &#125;<br><br>    <span class="hljs-comment">// 配置文件上传解析器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CommonsMultipartResolver <span class="hljs-title function_">multipartResolver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonsMultipartResolver</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 配置视图控制器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>        registry.addViewController(<span class="hljs-string">&quot;/&quot;</span>).setViewName(<span class="hljs-string">&quot;index&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 配置异常映射</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureHandlerExceptionResolvers</span><span class="hljs-params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> &#123;<br>        <span class="hljs-type">SimpleMappingExceptionResolver</span> <span class="hljs-variable">exceptionResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleMappingExceptionResolver</span>();<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">// 设置异常映射</span><br>        properties.setProperty(<span class="hljs-string">&quot;java.lang.ArithmeticException&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>);<br>        exceptionResolver.setExceptionMappings(properties);<br>        <span class="hljs-comment">// 设置共享异常的Key</span><br>        exceptionResolver.setExceptionAttribute(<span class="hljs-string">&quot;ex&quot;</span>);<br>        resolvers.add(exceptionResolver);<br>    &#125;<br><br>    <span class="hljs-comment">// 生成视图解析器，这里需要注入模板引擎，所以还需要配置模板引擎</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ViewResolver <span class="hljs-title function_">viewResolver</span><span class="hljs-params">(SpringTemplateEngine templateEngine)</span> &#123;<br>        <span class="hljs-type">ThymeleafViewResolver</span> <span class="hljs-variable">viewResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThymeleafViewResolver</span>();<br>        viewResolver.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        viewResolver.setTemplateEngine(templateEngine);<br><br>        <span class="hljs-keyword">return</span> viewResolver;<br>    &#125;<br><br>    <span class="hljs-comment">// 生成模板引擎，这里需要注入模板解析器，所有还需要配置模板解析器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SpringTemplateEngine <span class="hljs-title function_">templateEngine</span><span class="hljs-params">(ITemplateResolver templateResolver)</span> &#123;<br>        <span class="hljs-type">SpringTemplateEngine</span> <span class="hljs-variable">templateEngine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringTemplateEngine</span>();<br>        templateEngine.setTemplateResolver(templateResolver);<br><br>        <span class="hljs-keyword">return</span> templateEngine;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ITemplateResolver <span class="hljs-title function_">templateResolver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">webApplicationContext</span> <span class="hljs-operator">=</span> ContextLoader.getCurrentWebApplicationContext();<br>        <span class="hljs-type">ServletContextTemplateResolver</span> <span class="hljs-variable">templateResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletContextTemplateResolver</span>(webApplicationContext.getServletContext());<br>        templateResolver.setPrefix(<span class="hljs-string">&quot;/WEB_INF/templates/&quot;</span>);<br>        templateResolver.setSuffix(<span class="hljs-string">&quot;.html&quot;</span>);<br>        templateResolver.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        templateResolver.setTemplateMode(TemplateMode.HTML);<br><br>        <span class="hljs-keyword">return</span> templateResolver;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里我们使用到了<code>@Bean</code>注解。这个注解用来标识方法，则被标识的方法的返回值将被作为Bean管理，Bean的id默认为方法的方法名。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC笔记(5)-SpringMVC中文件上传和下载</title>
    <link href="/2022/10/19/SpringMVC%E7%AC%94%E8%AE%B0-5-SpringMVC%E4%B8%AD%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
    <url>/2022/10/19/SpringMVC%E7%AC%94%E8%AE%B0-5-SpringMVC%E4%B8%AD%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="文件下载">文件下载</h1><p>文件下载有较为固定的套路，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testDownLoad&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-type">byte</span>[]&gt; testDownLoad(HttpSession session) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 获取ServletContext对象</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> session.getServletContext();<br>    <span class="hljs-comment">// 获取服务器中文件的真实路径</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">realPath</span> <span class="hljs-operator">=</span> servletContext.getRealPath(<span class="hljs-string">&quot;/img/test.png&quot;</span>);<br>    <span class="hljs-comment">// 创建输入流，并将其读入字节数组中</span><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(realPath);<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[fileInputStream.available()];<br>    fileInputStream.read(bytes);<br>    <span class="hljs-comment">// 创建HttpHeaders对象设置响应头信息</span><br>    MultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>();<br>    headers.add(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=test.png&quot;</span>);<br>    <span class="hljs-comment">// 设置响应状态码</span><br>    <span class="hljs-type">HttpStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> HttpStatus.OK;<br>    <span class="hljs-comment">// 创建ResponseEntity对象</span><br>    ResponseEntity&lt;<span class="hljs-type">byte</span>[]&gt; responseEntity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;&gt;(bytes, headers, status);<br>    <span class="hljs-comment">// 关闭输入流</span><br>    fileInputStream.close();<br><br>    <span class="hljs-keyword">return</span> responseEntity;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们的返回值类型为<code>ResponseEntity</code>，它表示响应到浏览器的完整的响应报文。</p><p>我们首先需要获取到ServletContext对象，然后获取对应文件的真实路径。这个真实路径实际上就是拼接上当前项目的对应路径。我们将需要文件放在<code>webapp</code>目录下。获取真实路径并读取后，得到字节数组，之后就是创建ResponseEntity对象。在此之前还需要响应头以及响应状态码，在响应头中我们设置了下载方式以及下载文件的名称，响应状态码则为200OK。</p><h1 id="文件上传">文件上传</h1><p>在SpringMVC中，对上传的文件都需要封装成<code>MultipartFile</code>对象进行处理，我们后续的处理也是基于此类对象的。因此，我们需要先完成相关配置，让上传的文件能够被封装成该对象。</p><p>首先需要添加相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后在SpringMVC的配置文件中添加相关配置，这里的id固定为<code>multipartResolver</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>之后我们就可以基于MutipartFile对象完成文件上传功能了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testUpload&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testUpload</span><span class="hljs-params">(MultipartFile file, HttpSession session)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 获取上传文件的文件名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br><br>    <span class="hljs-comment">// 获取服务器中目录的路径并进行创建</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> session.getServletContext();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">imgPath</span> <span class="hljs-operator">=</span> servletContext.getRealPath(<span class="hljs-string">&quot;img&quot;</span>);<br>    <span class="hljs-type">File</span> <span class="hljs-variable">imgDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(imgPath);<br>    <span class="hljs-keyword">if</span> (!imgDir.exists()) &#123;<br>        imgDir.mkdir();<br>    &#125;<br>    <span class="hljs-comment">// 最终保存的文件路径</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">finalPath</span> <span class="hljs-operator">=</span> imgPath + File.separator + filename;<br>    <span class="hljs-comment">// 实现上传功能</span><br>    file.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(finalPath));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意，这里MultipartFile形参的名称需要和上传文件参数中所指定的名称相同，具体来说，需要和下面的name属性相匹配：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果需要处理文件重名问题，我们可以随机获取一个不会重复的名称来替换原本的文件名，可以使用如下的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取后缀名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">suffixName</span> <span class="hljs-operator">=</span> filename.substring(filename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><span class="hljs-comment">// 重新命名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">newName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + suffixName;<br></code></pre></td></tr></table></figure><blockquote><p>UUID，全称为Universally UniqueIdentifier，通用唯一标识码。它的作用是让分布式系统中的所有元素都能有唯一的标识符，UUID保证对同一时空中的所有资源唯一。我们这里调用Java中UUID的接口，获得一个唯一标识，来解决文件重名的问题。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC笔记(4)-SpringMVC中的RESTful与Ajax</title>
    <link href="/2022/10/19/SpringMVC%E7%AC%94%E8%AE%B0-4-SpringMVC%E4%B8%AD%E7%9A%84RESTful%E4%B8%8EAjax/"/>
    <url>/2022/10/19/SpringMVC%E7%AC%94%E8%AE%B0-4-SpringMVC%E4%B8%AD%E7%9A%84RESTful%E4%B8%8EAjax/</url>
    
    <content type="html"><![CDATA[<h1 id="restful">RESTful</h1><h2 id="简介">简介</h2><p>RESTful是一种网络应用程序的设计风格和开发方式。REST全称为RepresentationalStateTransfer，表现层资源状态转移。在这种风格下，一切皆资源。它将服务器看作由很多离散的资源组成，每个资源是服务器上一个可命名的抽象概念，我们可以通过一个路径访问。而我们对于资源的操作，可能有增删改查等，则对应到HTTP协议中不同的请求方式。</p><p>简单来说，我们通过路径来表示我们需要访问的资源，而通过请求方式来表示对一个资源的不同操作。前面我们也提到，REST风格中，将传统意义上的参数用路径来表示，也符合其利用路径表示资源的思想。在HTTP协议中，我们可以使用的请求方式包括：GET获取资源、POST新建资源、PUT更新资源、DELETE删除资源，结合不同路径来决定操作含义：</p><table><thead><tr class="header"><th>操作</th><th>传统方式</th><th>REST风格</th></tr></thead><tbody><tr class="odd"><td>查询</td><td>/getUserById?id=1</td><td>get: /user/1</td></tr><tr class="even"><td>保存</td><td>/saveUser</td><td>post: /user</td></tr><tr class="odd"><td>删除</td><td>/deleteUser?id=1</td><td>delete: /user/1</td></tr><tr class="even"><td>更新</td><td>/updateUser</td><td>put: /user</td></tr></tbody></table><h2 id="hiddenhttpmethodfilter">HiddenHttpMethodFilter</h2><p>浏览器仅支持发送get和post的请求，如果要想要在SpringMVC中发送put和delete方式的请求，需要利用它提供的HiddenHttpMethodFilter类。这是SpringMVC提供的一个类，可以帮助我们将POST请求转换为DELETE或者PUT请求。</p><p>要使用它，我们需要先在<code>web.xml</code>中注册<code>HiddenHttpMethodFilter</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置SpringMVC HiddenHttpMethodFilter--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意，一般情况下我们也配置了SpringMVC的编码过滤器<code>CharacterEncodingFilter</code>，编码过滤器应该要配置在所有过滤器的前面。</p></blockquote><p>要想经过<code>HiddenHttpMethodFilter</code>的请求，我们需要符合它的规则：</p><ol type="1"><li>当前请求的请求方式必须为POST</li><li>当前请求必须传输请求参数<code>_method</code>，该参数的值为需要被转换为的请求方式，如<code>put</code>、<code>delete</code>等</li></ol><p>例如我们可以在前端设置下面的表单，这样实际传输的时候，会得到一个put请求方式的请求：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/user&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_method&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;put&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;修改用户信息&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="静态资源">静态资源</h1><p>回顾前面的操作，我们在SpringMVC的配置文件中配置了前端处理器<code>DispatcherServlet</code>，并且配置了它能够处理的请求路径为<code>/</code>，希望它能够匹配所有请求路径。但是在Tomcat的<code>web.xml</code>中，也配置了一个Servlet，它的url-pattern也是<code>/</code>，具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>listings<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到，我们配置的SpringMVC前端控制器<code>DispatcherServlet</code>与Tomcat中的默认配置器<code>DefaultServlet</code>配置的url-pattern相同，我们工程中的配置会覆盖掉Tomcat中的配置，也就是说所有的请求都会经过<code>DispatcherServlet</code>来处理。但是在Tomcat中，静态资源是通过<code>DefaultServlet</code>来处理的，而我们配置的前端控制器无法处理静态资源，因此我们在使用到静态资源的时候应该做相应的配置，需要在SpringMVC的配置文件中增加如下的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>上面配置包括配置默认的Servlet，以及开启注解驱动。如果我们只配置了<code>default-server-handler</code>，则所有请求都会交给<code>DefaultServlet</code>来处理；而如果我们同时配置了注解驱动<code>annotation-driven</code>，那么所有的请求先交给<code>DispatcherServlet</code>处理，如果处理不了，例如静态资源等，则再交给<code>DefaultServlet</code>处理。</p><h1 id="ajax">AJAX</h1><p>ajax是一种重要的异步请求技术，SpringMVC中也提供了处理ajax的相关方法。我们主要关注的就是SpringMVC如何获取ajax请求中的参数，以及如果向前端响应相关数据，下面我们将分别介绍。</p><h2 id="获取json请求参数">获取json请求参数</h2><p>这里首先介绍axios携带参数的方式。axios在发送请求的时候，如果需要携带参数则可以指定使用参数<code>params</code>或<code>data</code>，它们两者有所区别：</p><ul><li><code>params</code>：表示以<code>name1=value1&amp;name2=value2</code>的方式发送请求参数，不管使用的方式是get还是post，请求参数会被拼接到请求地址后。此种方式的参数可以通过<code>request.getParameter()</code>来获取，也可以用SpringMVC封装后形参的方式获取（见<ahref="https://evernorif.github.io/2022/10/17/SpringMVC笔记-2-RequestMapping与请求参数获取/">SpringMVC笔记(2)-<spanclass="citation"data-cites="RequestMapping与请求参数获取">@RequestMapping与请求参数获取</span>- EverNorif</a>）</li><li><code>data</code>：表示以json格式发送请求参数，请求参数会被保存到请求报文的请求体中，传输到服务器。这类参数的获取需要先获取请求体中的数据，这会是一个json字符串，处理字符串的过程可以通过jar包，也可以通过SpringMVC的封装</li></ul><p>这里我们主要关注后者，即如果获取json格式的数据。这部分数据以json的格式被保存在请求体中，我们无法通过前面的方式获取。而SpringMVC为我提供了方式来获取请求体信息，即<code>@RequestBody</code>注解。将该注解标注在字符串形参上，则该参数的内容即为请求体中的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestBody&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String requestBody)</span> &#123;<br>    System.out.println(requestBody);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的方式，我们实际上已经可以获取到请求体中的json字符串，后面需要做的就是对json字符串进行解析。这一步我们可以使用现成的包来完成，例如fastJson等，但是SpringMVC也帮我们进行了一步封装，我们只需要指定承接RequestBody形参的类型不同，SpringMVC会自动帮我们进行转换，包括json转换为Map，json转换为实体类等。</p><p>要想开启对应的功能，我们需要先引入jackson的相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在SpringMVC的配置文件中开启mvc的注解驱动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>之后，我们只需要指定承接对象的类型即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 转化为Map对象</span><br><span class="hljs-meta">@RequestMapping(&quot;/testRequestBodyToMap&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestBodyToMap</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Map&lt;String, Object&gt; map)</span> &#123;<br>    System.out.println(map);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 转化为对应的实体类对象</span><br><span class="hljs-meta">@RequestMapping(&quot;/testRequestBodyToUser&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestBodyToUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br>    System.out.println(user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="返回json数据">返回json数据</h2><p>在前面的项目中，我们写的每个控制器方法返回的都是一个视图，要么是字符串表示对应的视图名称，要么是ModelAndView对象，总之最后达到的都是页面跳转的方式。而在实际的场景中，我们的控制器方法更多的是作为一个数据的提供API，需要返回数据而不是网页。</p><p>类似JavaWeb中提到的，我们可以设置返回值为void，然后利用<code>Response</code>对象获取到字符输出流，然后向其中写入我们需要返回的数据，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testResponseWriter&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testResponseWriter</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    response.getWriter().print(<span class="hljs-string">&quot;hello, I am data.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是通过字符输出流实现的数据返回，实际上SpringMVC也给提供了相关注解来简化操作，即<code>@ResponseBody</code>。该注解用于标识控制器方法，表示将该方法的返回值作为响应报文的响应体响应到浏览器。此时的字符串返回值不再是表示视图名称，而是直接作为返回数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testResponseBody&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testResponseBody</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello, I am data.&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际场景中，我们一般会以json格式向前端返回数据。通过上面的方式我们已经可以向前端返回数据了，所以我们只需要将需要返回的数据转化为json字符串的格式，然后向前端返回即可。转化为json字符串的工作可以通过现有的包来完成。当然，在SpringMVC中，<code>@ResponseBody</code>也帮我们进行了多一步的封装。我们可以在控制器方法中指定字符串之外的类型，在返回给前端的时候，会自动转化为json的格式。</p><p>当然如果要开启这个功能，也需要导入jackson的依赖，然后开启mvc的注解驱动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 响应集合类数据</span><br><span class="hljs-meta">@RequestMapping(&quot;/testReturnList&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">testReturnList</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;data1&quot;</span>, <span class="hljs-string">&quot;data2&quot;</span>, <span class="hljs-string">&quot;data3&quot;</span>);<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br><br><span class="hljs-comment">// 响应实体类数据</span><br><span class="hljs-meta">@RequestMapping(&quot;/testReturnUser&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">testReturnUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">admin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">123</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>    <span class="hljs-keyword">return</span> admin;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>@RestController</code>：这个注解是SpringMVC提供的一个复合注解，标识在控制器的类上，相当于为类添加了<code>@Controller</code>注解，同时为其中的每个方法都添加了<code>@ResponseBody</code>注解</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC笔记(3)-域对象数据共享与视图</title>
    <link href="/2022/10/17/SpringMVC%E7%AC%94%E8%AE%B0-3-%E5%9F%9F%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E4%B8%8E%E8%A7%86%E5%9B%BE/"/>
    <url>/2022/10/17/SpringMVC%E7%AC%94%E8%AE%B0-3-%E5%9F%9F%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E4%B8%8E%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="向域中共享数据">向域中共享数据</h1><p>在SpringMVC中，我们可以在程序中向域中共享数据。共有三种域，分别是Request域、Session域以及Application域。Request域的有效区域在一个Request请求中；Session域的有效区域在浏览器和服务器的一次连接中，对应一个Session；Application域的有效区域在服务器启动后，对应一次服务器的启动。</p><p>在域中共享数据，可以实现动态数据的效果。视图获取到域中的数据然后进行展示。在Thymeleaf中，我们可以访问到不同域中的数据，通过<code>$&#123;&#125;</code>表达式即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Success<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Success<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>Request域：<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>Session域：<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;session.info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>Application域：<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;application.info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="request域">Request域</h2><p>向Request域中共享数据有很多种方式，下面分别进行介绍。</p><p>第一种方式是通过ServletAPI的方式，调用setAttribute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestScope1&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestScope</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>    request.setAttribute(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;HttpServletRequest&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方式是使用ModelAndView方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestScope2&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">testRequestScope</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>    <span class="hljs-comment">// 向Request域中共享数据</span><br>    modelAndView.addObject(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;ModelAndView&quot;</span>);<br>    <span class="hljs-comment">// 设置视图，实现页面跳转</span><br>    modelAndView.setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br>    <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式也是SpringMVC推荐使用的方式。ModelAndView结合了Model和View的功能，Model主要用于向请求域中共享数据，而View主要用来设置视图，实现页面跳转。注意这里控制器方法的返回值，我们说控制器方法要返回一个视图。前面我们都是通过返回视图名称字符串的形式，实际上最终底层返回的都是ModelAndView。</p><p>第三种方式是通过Model、Map或者ModelMap来向Request域对象中共享数据。这三者联系紧密，这里一并进行说明。</p><p>利用Model：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestScope3&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestScope</span><span class="hljs-params">(Model model)</span> &#123;<br>    model.addAttribute(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;Model&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestScope4&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestScope</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span> &#123;<br>    map.put(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;Map&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用ModelMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestScope5&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestScope</span><span class="hljs-params">(ModelMap modelMap)</span> &#123;<br>    modelMap.addAttribute(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;ModelMap&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，Model、ModelMap、Map类型的参数，本质上都是BindingAwareModelMap类型，它们之间存在继承或实现的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BindingAwareModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ExtendedModelMap</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendedModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ModelMap</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Model</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Model</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, Object&gt;;<br></code></pre></td></tr></table></figure><h2 id="session域">Session域</h2><p>向Session域中共享数据可以通过HttpSession相关API来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testSessionScope&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testSessionScope</span><span class="hljs-params">(HttpSession session)</span> &#123;<br>    session.setAttribute(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;SessionInfo&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="application域">Application域</h2><p>向Application域中共享数据可以通过HttpSession相关API来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testApplicationScope&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testApplicationScope</span><span class="hljs-params">(HttpSession session)</span> &#123;<br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> session.getServletContext();<br>    application.setAttribute(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;ApplicationInfo&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="视图">视图</h1><p>SpringMVC中的视图View，这是一个接口，主要作用是数据渲染，将模型Model中的数据展示给用户。SpringMVC中视图默认有转发视图和重定向视图。</p><p>当控制器方法中所设置的视图名称没有任何前缀的时候，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，对应的视图名称会拼接前缀和后缀。我们使用了Thymeleaf，在SpringMVC配置文件中配置了对应的视图解析器，解析后得到ThymeleafView。最后是通过转发的方式实现跳转。</p><p>SpringMVC中默认的转发视图是<code>InternalResourceView</code>。当控制器方法中所设置的视图名称前缀为<code>forward:</code>时，SpringMVC会创建InternalResourceView视图，此时视图名称不会被SpringMVC配置文件中所设置的视图解析器所解析，而是会将前缀去掉，剩余部分作为最终路径转发。</p><p>SpringMVC中默认的重定向视图是<code>RedirectView</code>。当控制器方法中所设置的视图名称前缀为<code>redirect:</code>时，SpringMVC会创建RedirectView视图，此时视图名称不会被SpringMVC配置文件所配置的视图视图解析器所解析，而是会将前缀去掉，剩余部分作为最终路径进行重定向。</p><blockquote><p>如果控制器方法只用来实现页面跳转，即只设置了视图名称而没有其他操作时，我们可以用<code>view-controller</code>标签来代替，在SpringMVC配置文件中添加如下内容，可以理解为基于XML的请求映射：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testView&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-controller</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，path用来设置处理的请求地址，view-name用来设置请求地址所对应的视图名称。</p><p>但是需要注意的时，当SpringMVC中设置了任何一个view-controller，其他基于注解的控制器方法对应的请求映射将会失效，此时需要在配置文件中开启基于注解的驱动，利用如下标签即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC笔记(2)-@RequestMapping与请求参数获取</title>
    <link href="/2022/10/17/SpringMVC%E7%AC%94%E8%AE%B0-2-RequestMapping%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96/"/>
    <url>/2022/10/17/SpringMVC%E7%AC%94%E8%AE%B0-2-RequestMapping%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="requestmapping注解"><span class="citation"data-cites="RequestMapping注解">@RequestMapping注解</span></h1><h2 id="介绍">介绍</h2><p>在控制器方法中，我们会使用<code>@RequestMapping</code>注解来说明该方法匹配的请求路径，该注解的功能也就是将请求和处理请求的控制器方法进行关联，建立起映射关系。SpringMVC接收到指定的请求之后，就会在映射关系中找到对应的控制器方法来处理这个请求。</p><p><code>@RequestMapping</code>注解可以用来标识一个类，也可以用来标识一个方法</p><ul><li>标识类：设置请求路径的初始信息</li><li>标识方法：设置请求路径的具体信息</li></ul><p>如果一个控制器被该注解标识了，那么它的方法对应的实际完整路径应该要加上类注解中的路径。</p><h2 id="属性">属性</h2><p>下面介绍<code>@RequestMapping</code>中的相关属性。</p><p>首先是value属性。<code>@RequestMapping</code>注解的value属性用来指定匹配的请求地址。这是一个字符串数组，表示该请求方法能够匹配多个请求地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&#123;&quot;/test1&quot;,&quot;/test2&quot;&#125;)</span><br></code></pre></td></tr></table></figure><p>method属性表示通过请求的请求方式来进行匹配。这是一个RequestMethod类型的数组，表示该请求方法能够匹配的请求对应的请求方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(</span><br><span class="hljs-meta">    value = &quot;test&quot;, </span><br><span class="hljs-meta">    method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></table></figure><blockquote><p>结合请求方式的不同，SpringMVC中提供了一系列基于<code>@RequestMapping</code>的派生注解，用来处理不同的请求，如下所示，基本都能见名知义：</p><ul><li>处理get请求：<code>@GetMapping</code></li><li>处理post请求：<code>@PostMapping</code></li><li>处理put请求：<code>@PutMapping</code></li><li>处理delete请求：<code>@DeleteMapping</code></li></ul></blockquote><p>params属性表示通过请求的请求参数来匹配请求。这是一个字符串类型的数组，其中每一个字符串都是一个表达式。浏览器发送的请求，只有当它的参数满足params属性中全部表达式时，才能被响应。表达式主要有如下四种：</p><ol type="1"><li><code>param</code>：请求必须携带param参数</li><li><code>!param</code>：请求不能携带param参数</li><li><code>param=value</code>：请求必须携带param参数，并且值必须为value</li><li><code>param!=value</code>：请求可以不携带param参数，如果携带值那么值不能为value</li></ol><p>例如下面的例子，能够被响应的请求，应该满足参数必须携带username，不能携带password，必须携带age且值为18，可以携带email，如果携带了值不能为<code>haha@haha.com</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(</span><br><span class="hljs-meta">    value = &quot;/test&quot;,</span><br><span class="hljs-meta">    params = &#123;&quot;username&quot;, &quot;!password&quot;, &quot;age=18&quot;, &quot;email!=haha@haha.com&quot;&#125;</span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></table></figure><p>headers属性和params属性基本类似，它通过请求的请求头信息来匹配。该属性也是一个字符串类型的数组，也可以通过上面相同的四种表达式来决定约束条件。</p><blockquote><p>SpringMVC支持ant风格的路径，具体如下：</p><ul><li><code>?</code>：表示任意的单个字符</li><li><code>*</code>：表示任意的0个或者多个字符，但是不能跨目录层级</li><li><code>**</code>：表示任意层数的任意目录</li></ul><p>但是在使用的过程中需要注意，在url中，<code>?</code>是请求链接和参数的分隔符，不能被匹配；<code>/</code>表示一层新的目录，不能被匹配。</p></blockquote><h2 id="路径占位符">路径占位符</h2><p>SpringMVC同样支持路径的占位符，简单来说就是通过参数形式解析链接中的值。这种方式在获取REST方式的请求参数时非常方便。REST方式的请求中会将请求参数作为路径的一部分，举例来说，我们利用可以结合参数访问如下请求<code>/testRest?id=123&amp;username=root</code>，这也是我们一开始接触的方式，即路径与参数分离，而采用REST方式的话，请求可能就是<code>/testRest/123/root</code>。</p><p>通过路径的占位符，我们可以获取REST方式请求中的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRest</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id, <span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String name)</span> &#123;<br>    System.out.println(id);<br>    System.out.println(name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 访问/testRest/123/root</span><br><span class="hljs-comment">// 输出123 root</span><br></code></pre></td></tr></table></figure><p>在路径中设置占位符之后，我们需要获取对应的值。通过注解<code>@PathVariable</code>，我们可以将路径中参数与形参进行绑定，之后就可以在代码中使用。我们可以在注解中指定要匹配路径中的哪一部分，如果没有指定，则默认按照形参名来匹配。</p><blockquote><p>注意这里我们获取的不是实际意义上的参数，只是解析了路径中的内容作为我们的参数，实际意义上的参数还是指的整个链接中<code>?</code>后面的内容，这也是我们后面要介绍的内容。</p></blockquote><h1 id="请求参数获取">请求参数获取</h1><h2 id="参数获取">参数获取</h2><p>下面我们介绍在SpringMVC中如何获取请求参数。主要指的是利用<code>&amp;</code>拼接的参数，即get请求携带参数的样式。如果是post请求，请求体中的参数如果满足形式与get请求参数相同，也能够被解析。</p><h3 id="通过servletapi获取">通过ServletAPI获取</h3><p>在JavaWeb中我们可以通过ServletAPI来获取请求参数，这里自然也可以。要使用相关对象，我们可以在控制器方法中增加对应类型的形参，如下所示。此时，<code>HttpServletRequest</code>类型的参数就表示封装了当前请求请求报文的对象，然后我们就可以通过对应方法获取到对应参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam1&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testParam1</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;id&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>    System.out.println(id);<br>    System.out.println(username);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过形参获取">通过形参获取</h3><p>SpringMVC既然是对Servlet进行封装，那么自然是提供了更加方便的方式来获取请求参数。我们可以在控制器方法的形参位置，设置和请求参数同名的形参。这样当浏览器发送请求，匹配到对应方法的时候，在DispathcerServlet中就会将请求参数赋值给相应的形参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam2&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testParam2</span><span class="hljs-params">(Integer id, <span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String name)</span> &#123;<br>    System.out.println(id);<br>    System.out.println(name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，我们可以通过设置同名形参来获取对应请求参数，而通过<code>@RequestParam</code>注解，我们可以指定更多的映射方式。</p><p><code>@RequestParam</code>注解可以为请求参数和控制器方法的形参创建映射，其中一共有三个属性：</p><ul><li><code>value</code>：指定为该形参赋值的请求参数名称</li><li><code>required</code>：设置是否必须传输此请求参数，默认值为true</li><li><code>defaultValue</code>：设置该参数的默认值，如果没有传递或者传递为<code>""</code>时，则使用该默认参数值</li></ul><p>注意这里，只有当没有设置defaultValue并且required指定为true的时候，不携带对应参数才会报错400。</p><blockquote><p>如果请求参数含有多个同名的参数，我们可以在形参中设置字符串数组或者字符串类型的形参来接收这些参数：</p><ul><li>如果使用了字符串数组类型的形参，那么数组中包含了每一个数据</li><li>如果使用了字符串类型的形参，那么该字符串的值为每个数据之间使用逗号拼接的结果</li></ul></blockquote><p>除了获取请求参数，我们也可以通过类似的方法来获取请求头信息或者是Cookie数据。相关功能对应不同的注解，相关注解如下：</p><ul><li><code>@RequestHeader</code>：为请求头信息和控制器方法形参创建映射关系</li><li><code>@CookieValue</code>：为Cookei数据和控制器方法形参创建映射</li></ul><p>注解的使用方式与<code>@RequestParam</code>基本相同，这里就不再多进行描述。</p><h3 id="通过实体类获取">通过实体类获取</h3><p>在请求参数过多的时候，如果全部写在形参中会非常繁琐。我们可以在控制器方法的形参位置设置一个实体类类型的形参，这样如果请求参数和实体类的属性名能够匹配的话，DispatcherServlet就会调用属性的set方法为其赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam3&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testParam3</span><span class="hljs-params">(User user)</span> &#123;<br>    System.out.println(user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="乱码问题解决">乱码问题解决</h2><p>如果我们的是通过链接中参数进行传递，则不会出现中文乱码问题。但是如果我们的参数是通过post请求的请求体进行传递的，则会出现乱码问题。</p><p>乱码问题的解决也非常简单，只需要在<code>web.xml</code>中配置SpringMVC提供的编码过滤器<code>CharacterEncodingFilter</code>即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置SpringMVC的编码过滤器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意，SpringMVC处理编码的过滤器一定要配置在其他过滤器的前面，否则是没有效果的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC笔记(1)-SpringMVC简介与快速开始</title>
    <link href="/2022/10/16/SpringMVC%E7%AC%94%E8%AE%B0-1-SpringMVC%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
    <url>/2022/10/16/SpringMVC%E7%AC%94%E8%AE%B0-1-SpringMVC%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍">介绍</h1><p>在前面JavaWeb章节，我们介绍了MVC的软件结构思想。按照这种思想，可以将软件按照模型、视图、控制器来进行划分。用户通过视图层发送请求到服务器，在服务器端，请求被Contorller接收，Controller调用相应的Model层来处理请求，处理完毕后将结果返回到Controller中，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器。</p><p>同时我们也介绍了三层架构，这是一种对MVC模式进行实现的方式。其中的表现层包含了MVC中的View和Controller。SpringMVC就是一款表示层的框架。</p><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目。SpringMVC是Spring为表示层开发提供的一整套完备的解决方案。它是Spring家族原生的产品，因此可以与IOC容器等基础设施进行无缝对接；同时它封装了原生的Servler，通过功能强大的前端控制器DispatcherServlet来对请求和响应进行统一处理；此外，还具有其他的优点，包括代码简洁、组件化程度高即插即用、性能优异等等。</p><h1 id="快速开始">快速开始</h1><p>下面我们进行SpringMVC的快速开始。首先我们需要创建一个MavenWeb工程，具体步骤在JavaWeb章节中有说明（<ahref="https://evernorif.github.io/2022/10/05/JavaWeb笔记-2-Tomcat的使用/">JavaWeb笔记(2)-Tomcat的使用-EverNorif</a>），包括修改<code>packaging</code>属性为<code>war</code>，补齐相关项目结构等。</p><p>之后，我们需要引入下面的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringMVC--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--日志--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Servlet-API--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Spring5与Thymeleaf整合--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>在依赖中，我们用到了Spring和Thymeleaf的整合。</p><p>Thymeleaf 是一款用于渲染 XML/XHTML/HTML5内容的模板引擎。它的模板文件后缀为<code>.html</code>，可以直接被浏览器打开。Thymeleaf使用一些特定的语法标签来表示不同的含义，但是并不会破坏html结构。如果在离线情况下打开，则浏览器会忽略未定义的Thymeleaf标签属性，展示模板的静态页面效果；如果通过Web应用程序访问，则会动态替换掉其中的静态内容，使页面动态显示，达到动静结合的效果。Thymeleaf也是SpringBoot官方推荐的模板引擎。</p><p>Thymeleaf的相关内容可以后面的参考内容。</p></blockquote><p>之后，我们需要配置<code>web.xml</code>，在其中注册SpringMVC的前端控制器DispatcherServlet以及相关信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置SpringMVC的前端控制器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>SpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--固定为contextConfigLocation--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-comment">&lt;!--配置能够处理的请求路径--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>SpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<code>web.xml</code>中，我们首先需要配置SpringMVC的前端控制器，使用<code>servlet</code>标签，对应的类为<code>DispatcherServlet</code>，这是SpringMVC中封装的类，用于对浏览器发送的请求进行统一的处理。然后还需要配置该类能够处理的请求路径，使用<code>servlet-mapping</code>标签，对应路径下的请求都将经过我们配置的控制器来处理。</p><p>在配置<code>DispatcherServlet</code>的时候，我们可以通过初始化参数指定Spring配置文件的位置和名称，即这里的<code>init-param</code>标签。由于SpringMVC也是需要使用到IOC容器，因此也会对应到一个Spring的配置文件。如果没有配置，则我们需要将对应的配置文件创建在固定的位置，并且命名也是固定的。创建的位置固定为<code>WEB-INF</code>目录下，名称固定为<code>&lt;servlet-name&gt;-servlet.xml</code>，像这里默认应该创建为<code>SpringMVC-servlet.xml</code>。这里我们通过初始化参数指定的位置，因此不需要按照默认情况。</p><p>这里我们还设置了<code>load-on-startup</code>值为1，表示在服务器启动的时候进行Servlet的初始化。默认情况是第一次访问到的时候才初始化，但是由于SpringMVC中DispatcherServlet的初始化涉及到的资源比较丰富，因此推荐它的初始化时机提前。</p><p>在配置处理请求路径的时候，我们可以使用<code>/</code>和<code>/*</code>来代表匹配所有资源，但是还是略有区别。<code>/</code>所匹配的请求可以是目录、后缀等，但是不能匹配<code>.jsp</code>请求路径的请求，<code>.jsp</code>的请求通过的是Tomcat配置中的Servlet处理，而不是<code>DispathcerServlet</code>。而如果是<code>/*</code>，则能够匹配所有请求，包括<code>.jsp</code>的请求路径。</p><p>在SpringMVC中，<code>DispathcerServlet</code>对浏览器发送的请求进行了统一的处理，但是这更像是一种所有请求都需要经过的预处理，而对应具体的请求有不同的处理逻辑，因此需要创建处理具体请求的类，即Controller层中的相应类，或者是请求控制器，而请求控制器中的每一个处理请求的方法则称为控制器方法。</p><p>创建如下测试类，用注解<code>@Contorller</code>进行标识：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了将类交由IOC容器管理，我们还需要创建Spring配置文件，也就是前面在配置路径中提到的<code>springMVC.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.syh.mvc&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--配置Thymeleaf视图解析器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateEngine&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateResolver&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!--视图前缀--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br>                    <span class="hljs-comment">&lt;!--视图后缀--&gt;</span> <br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.html&quot;</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;HTML5&quot;</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在其中配置了基于注解的自动扫描，以及配置了Thymeleaf视图解析器。这里配置了视图前缀和视图后缀，后续我们的Thymeleaf的模板文件都会写在<code>/WEB-INF/templates</code>目录下，且后缀名为<code>.html</code>。</p><p>之后我们在请求控制器<code>HelloContorller</code>中增加如下的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 设置视图名称</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;target&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里利用<code>@RequestMapping</code>注解标识了对应访问路径，即对该路径的访问会经过这个方法，返回值为视图名称。视图名称需要对应到一个html页面，对应方式需要结合前面配置的视图前缀和视图后缀，在视图名称前后分别添加配置的前后缀，就是对应的页面路径。这里即为<code>/WEB-INF/templates/index.html</code>以及<code>/WEB-INF/templates/target.html</code>。那么接下来在<code>WEB-INF/templates</code>目录下分别创建了<code>index.html</code>以及<code>target.html</code>页面，在其中添加了相应的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>index<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>index.html<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/hello&#125;&quot;</span>&gt;</span>HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>target<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello Success<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>由于这里使用了Thymeleaf的相关标签，所以我们引入对应的约束来辅助我们进行编写。当然不引入也没有关系。</p></blockquote><p>之后我们可以启动服务器Tomcat进行测试。默认情况下，我们是无法通过浏览器链接直接访问到<code>WEB-INF</code>下的资源，但是这里我们可以通过访问<code>/</code>和<code>/hello</code>看到对应的显示效果。</p><p>总结来说，上面的流程大概分为下面的步骤：</p><ol type="1"><li>浏览器向服务器发送请求，如果请求地址符合前端控制器配置的<code>url-pattern</code>，则该请求就会被前端控制器<code>DispatcherServlet</code>处理。</li><li>前端控制器会读取SpringMVC的配置文件，扫描IOC容器中的组件并找到控制器，即使用<code>@Controller</code>注解标注的类。</li><li>之后，将请求地址与控制器的方法上<code>@RequestMapping</code>注解的value属性进行匹配，如果匹配成功，则就由该方法来处理请求。</li><li>处理请求的方法需要返回一个视图，这里返回了一个字符串类型的视图名称。</li><li>该视图名称会被视图解析器进行解析，加上视图前缀和后缀组成视图的路径。</li><li>然后Thymeleaf对找到的视图进行渲染，最终返回到视图所对应的页面上。</li></ol><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="http://c.biancheng.net/spring_boot/thymeleaf.html">Thymeleaf教程（10分钟入门）(biancheng.net)</a></li><li><ahref="https://zhuanlan.zhihu.com/p/163391278">Thymeleaf从入门到精通 -知乎 (zhihu.com)</a></li><li><a href="https://www.thymeleaf.org/documentation.html">Documentation- Thymeleaf</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring笔记(4)-JdbcTemplate与声明式事务</title>
    <link href="/2022/10/15/Spring%E7%AC%94%E8%AE%B0-4-JdbcTemplate%E4%B8%8E%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/10/15/Spring%E7%AC%94%E8%AE%B0-4-JdbcTemplate%E4%B8%8E%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="jdbctemplate">JdbcTemplate</h1><h2 id="环境准备">环境准备</h2><p>在Spring框架中，对JDBC进行了一定程度的封装，使用JdbcTemplate来实现对数据库的操作。我们在这里进行简单的介绍。</p><p>在Spring的基础依赖上，我们需要引入下面的相关依赖，其中除了基础的context，还需要导入持久层相关依赖以及测试相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Spring Framework--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Spring 持久层相关依赖--&gt;</span><br><span class="hljs-comment">&lt;!--Spring在与持久化层技术进行整合是，需要使用orm、jdbc、tx三个jar包--&gt;</span><br><span class="hljs-comment">&lt;!--通过导入orm，通过Maven的依赖传递将其他两个包进行导入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Spring 测试相关依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--数据源依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后，我们创建<code>jdbc.properties</code>文件，在其中完成连接数据库的基本信息：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">123123</span><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/ssm_data</span><br><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>然后创建Spring的配置文件，在其中我们首先需要导入外部属性文件，在其中配置数据源之后，配置JdbcTemplate。JdbcTemplate是Spring提供的交由IOC管理的类，我们只需要在其中配置数据源即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入外部属性文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--配置数据源--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--配置JdbcTemplate--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--装配数据源--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以使用<code>@Test</code>测试接口来进行方法测试，不过这里我们使用Spring整合junit的方式进行相关测试。我们可以创建一个测试类，利用相关注解标注之后，就可以直接获取IOC容器中的Bean对象，而不需要像前面一样先获取ApplicationContext，在getBean获取对象。我们创建测试类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:jdbcContext.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTemplateTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(jdbcTemplate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中我们使用到的接口如下：</p><ul><li><code>@RunWith</code>：在其中给定<code>SpringJunit4ClassRuner.class</code>，指定当前测试类在Spring的测试环境中执行，测试可以通过注入的方式直接获取IOC容器中的Bean</li><li><code>@ContextConfiguration</code>：设置Spring测试环境的对应配置环境</li><li><code>@Autowired</code>：通过自动装配来获取相关Bean对象</li></ul><p>这样，我们类中的测试方法可以直接使用成员对象<code>jdbcTemplate</code>，并且这个对象就是我们在配置文件中配置的对应对象。</p><blockquote><p>Spring整合junit主要是通过注解完成的，不过随着版本不同，整合使用的注解也有所不同。</p></blockquote><h2 id="基本操作">基本操作</h2><p>下面我们测试JdbcTemplate的相关操作。</p><p>增删改操作通过update方法，在sql字符串中，我们可以通过<code>?</code>来作为占位符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-comment">// 测试增加功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// schema(id, username, password, age, gender, email)</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into users values(null, ?, ?, ?, ?, ?)&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jdbcTemplate.update(sql, <span class="hljs-string">&quot;jdbcMan&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&quot;女&quot;</span>, <span class="hljs-string">&quot;hello@haha.com&quot;</span>);<br>    System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以查询一条数据为实体类对象，也可以查询多条数据，或者查询值，只需要指定对应的转换类型即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-comment">// 查询一条数据为一个实体类对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectOneLine</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from users where id = ?&quot;</span>;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class), <span class="hljs-number">3</span>);<br>    System.out.println(user);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-comment">// 查询多条数据为一个List集合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectList</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from users&quot;</span>;<br>    List&lt;User&gt; resList = jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));<br>    resList.forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-comment">// 查询一个具体的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectCount</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select count(*) from users&quot;</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class);<br>    System.out.println(count);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="声明式事务">声明式事务</h1><h2 id="背景介绍">背景介绍</h2><p>数据库中的事务操作，对应到Java代码中，可以看作一个try-catch-finally的执行逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> ...;<br><br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">// 开启事务，关闭事务的自动提交</span><br>   conn.setAutoCommit(<span class="hljs-literal">false</span>); <br>    <br>    <span class="hljs-comment">// 事务的核心操作...</span><br>    <br>    <span class="hljs-comment">// 提交事务</span><br>    conn.commit();<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    <span class="hljs-comment">// 事务回滚</span><br>    conn.rollBack();<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在实际场景中，一般不会出现SQL执行错误的逻辑，更多的情况是因为业务逻辑不符合而需要回滚。如果不做任何处理，这种SQL代码能够执行，但是不符合逻辑。因此我们需要在数据库中设置一些限制，如数据类型等，或者在代码中检查业务逻辑，如果不符合则手动抛出运行时异常。</p></blockquote><p>我们想要在代码中应用事务，就可以采用上面的逻辑。但是事务的基本框架都是一样的，如果每次都让程序员来写这一套代码，则会导致很大程度的代码冗余，代码的复用性不高。</p><p>我们可以通过AOP的思想，将事务的提交框架抽取出来，进行相关的封装，而让程序员能更多地关注核心操作即事务的核心逻辑。完成封装之后，我们能够提高开发效率并消除冗余代码。</p><p>要完成代码的抽取，我们可以通过代理模式来实现，或者利用Spring中的AOP相关注解配置或者XML来实现。这种实现为编程式实现。而实际上，由于事务操作的常用性，Spring已经给我们实现了相关的功能，我们只需要使用相关的注解或者XML，就能够达到效果，这种实现称之为声明式实现。声明式实现指的是通过配置让框架来帮我们实现功能。</p><h2 id="基于注解的声明式事务">基于注解的声明式事务</h2><h3 id="环境准备-1">环境准备</h3><p>我们需要模拟一个购书的场景。这里我们准备相关的数据库表<code>books</code>和<code>customers</code>，分别表示书店书目以及顾客：</p><table><thead><tr class="header"><th>book_id</th><th>book_name</th><th>book_price</th><th>book_inventory</th></tr></thead><tbody><tr class="odd"><td>1</td><td>A</td><td>50</td><td>3</td></tr><tr class="even"><td>2</td><td>B</td><td>100</td><td>2</td></tr></tbody></table><table><thead><tr class="header"><th>customer_id</th><th>customer_name</th><th>customer_balance</th></tr></thead><tbody><tr class="odd"><td>1</td><td>admin</td><td>60</td></tr></tbody></table><blockquote><p>这里的库存和余额均设置为<code>int unsigned</code>类型，表示该值不能为负，符合我们的业务逻辑。</p></blockquote><p>然后利用三层架构的思想创建不同的类。</p><p>Contorller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookService bookService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buyBook</span><span class="hljs-params">(Integer customerId, Integer bookId)</span>&#123;<br>        bookService.buyBook(customerId, bookId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookDao bookDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buyBook</span><span class="hljs-params">(Integer customerId, Integer bookId)</span> &#123;<br>        <span class="hljs-comment">// 查询图书价格</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> bookDao.getPriceByBookId(bookId);<br><br>        <span class="hljs-comment">// 减少图书库存</span><br>        bookDao.declineInventory(bookId, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 扣减用户余额</span><br>        bookDao.declineBalance(customerId, price);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dao：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getPriceByBookId</span><span class="hljs-params">(Integer bookId)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select book_price from books where book_id = ?&quot;</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class, bookId);<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">declineInventory</span><span class="hljs-params">(Integer bookId, <span class="hljs-type">int</span> declineNum)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update books set book_inventory = book_inventory - ? where book_id = ?&quot;</span>;<br>        jdbcTemplate.update(sql, declineNum, bookId);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">declineBalance</span><span class="hljs-params">(Integer customerId, <span class="hljs-type">int</span> declineNum)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update customers set customer_balance = customer_balance - ? where customer_id = ?&quot;</span>;<br>        jdbcTemplate.update(sql, declineNum, customerId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:jdbcContext.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookTransTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookController bookController;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBuyBook</span><span class="hljs-params">()</span> &#123;<br>        bookController.buyBook(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的购买事务过程分为三个步骤，查询图书价格，减少图书库存以及扣减用户余额。但是此时并没有任何事务处理的保证，此时的每个SQL都是作为单独的事务进行执行的。如果要使用Spring中提供的声明式事务，我们可以使用<code>@Transactional</code>注解。</p><h3 id="注解使用">注解使用</h3><p>要使用相关注解，我们首先需要在Spring的配置文件中添加相关配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--事务管理器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的配置中，我们首先配置了事务管理器的Bean，对应类<code>DataSourceTransactionManager</code>，之后使用标签<code>tx:annotation-driven</code>开启事务的注解驱动，其中指定对应的事务管理器为我们之前配置的Bean。</p><p>之后，我们找到需要处理事务的Service层buyBook方法，在方法上增加<code>@Transactional</code>注解，这样就可以将整个方法处理成事务进行执行了。如果此时我们让客户1购买书2，会发现余额不够而无法购买，由于事务回滚，数据库中不会发生改变。</p><h2 id="事务属性">事务属性</h2><p>在<code>@Transactional</code>注解中可以设置相关属性，下面进行介绍。</p><ol type="1"><li><code>readOnley</code>：只读属性。可以设置为true或者为false。对于一个查询操作来说，如果将其设置为只读，就能够明确告诉数据库这个操作不涉及写操作，数据库就能够针对查询操作来进行优化</li><li><code>timeout</code>：设置超时时间。如果超时则进行回滚</li><li>回滚策略：可以设置因为什么而回滚或者不因为什么而回滚<ul><li><code>rollbackFor</code>：给定一个对应类型的对象</li><li><code>rollbackForClassName</code>：设置一个字符串类型的全类名</li><li><code>noRollbackFor</code>：给定一个对应类型的对象</li><li><code>noRollbackForClassName</code>：设置一个字符串类型的全类名</li></ul></li><li><code>isolation</code>：事务隔离级别<ul><li><code>Isolation.DEFAULT</code>：使用数据库默认的隔离级别</li><li><code>Isolation.READ_UNCOMMITTED</code>：读未提交</li><li><code>Isolation.READ_COMMITED</code>：读以提交</li><li><code>Isolation.REPEATABLE_READ</code>：可重复读</li><li><code>Isolation.SERIALIZABLE</code>：串行化</li></ul></li><li><code>propagation</code>：事务传播属性，描述的是事务A中需要执行事务B，事务B是开启一个新的事务还是利用事务A的事务。该属性配置在事务B上<ul><li><code>Propagation.REQUIRED</code>：如果当前线程上已经有开启的事务可用，则就在该事务中运行</li><li><code>Propagation.REQUIRES_NEW</code>：无论当前线程上是否有已经开启的事务，都要开启新的事务</li></ul></li></ol><h2 id="基于xml的声明式事务">基于XML的声明式事务</h2><p>在Spring中，同样可以通过XML来配置声明式事务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--事务管理器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--配置事务通知--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--配置具体的事务方法--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;get*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRES_NEW&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置事务通知和切入点表达式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(* com.syh.spring.trans.BookService.* (..))&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先我们还是需要配置事务管理器Bean对象，之后利用<code>tx:advice</code>标签来配置事务通知，其中需要使用到之前配置的事务管理器Bean对象。在事务通知中，我们需要针对不同的方法，指定不同的事务属性，即注解中的值。然后利用<code>aop:config</code>标签配置事务通知所应用的位置，即指定对应的事务通知以及对应的切入点表达式。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring笔记(3)-代理模式与面向切面编程AOP</title>
    <link href="/2022/10/14/Spring%E7%AC%94%E8%AE%B0-3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8BAOP/"/>
    <url>/2022/10/14/Spring%E7%AC%94%E8%AE%B0-3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8BAOP/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式">代理模式</h1><h2 id="场景分析">场景分析</h2><p>在介绍AOP之前，我们需要先了解一下代理模式。考虑以下场景，我们现在需要实现一个计算器的功能，那么我们会先生命一个<code>Calculator</code>接口，在其中声明需要实现的方法，包括加减乘除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后，我们为<code>Calculator</code>接口创建一个实现类<code>CalculatorImp</code>，在其中完成对应的方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i + j;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i - j;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i * j;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i / j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们完成了一个简单的计算功能。但是这时候我们想要在每个方法执行的前后都增加日志输出功能，一种实现方法就是在每个方法的最开始和最后增加输出代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行开始&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i + j;<br>        System.out.println(<span class="hljs-string">&quot;执行结束&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 其他方法类似省略</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式的确能够完成需求，但是较为繁琐。在这个需求中，我们的核心代码是加减乘除的实现，日志功能算非核心代码。这种实现方式一些弊端：</p><ol type="1"><li>首先需要重复书写很多非核心业务</li><li>其次这些代码对核心业务功能干扰，导致我们在开发核心业务的时候容易被分散精力</li><li>同时这些功能虽然功能相同，但是分散在各个业务方法中，不利于统一维护</li></ol><p>我们可以通过解耦的方式来将附加的非业务功能从业务功能中抽取出来，将非业务功能和业务功能分开管理。分析场景我们发现，这里的非业务代码包裹了业务代码，无法通过传统的继承方式进行抽取。我们可以通过代理模式来解决这个问题。</p><p>简单来说，代理模式的作用就是通过提供一个代理类来对我们目标类进行包装。我们在调用目标方法的时候，不需要直接对目标方法进行调用，而是通过代理类间接调用。这样，我们可以将非业务代码抽离到代理类中，而让目标类专注于核心代码的实现。这种方式可以减少对目标方法的打扰，同时使得附加功能能够在一起，便于统一维护。</p><h2 id="静态代理">静态代理</h2><p>在静态代理中，一个代理类对应一个目标类。我们可以创建一个代理类，将目标类中的方法进行包装。由于代理类需要提供目标类中的相关方法，所以两个类需要实现相同的接口。</p><p>对于上面的场景，我们可以创建一个静态代理类，实现Calculator接口并对目标类的方法进行包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorStaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">private</span> Calculator target; <span class="hljs-comment">// 一个代理类对应一个目标类</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CalculatorStaticProxy</span><span class="hljs-params">(Calculator target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeInvoke</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;计算开始&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterInvoke</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;计算结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        beforeInvoke();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> target.add(i, j);<br>        afterInvoke();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他方法类似省略</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们只需要创建一个代理类，然后通过代理类执行相关的方法即可。虽然静态代理实现了一定程度的解耦，但是灵活性不高。于是有了后续的动态代理技术。</p><h2 id="动态代理">动态代理</h2><p>动态代理并不像静态代理一样将代码全部写死，而是在代码运行的过程中，让JDK动态创建每个类对应的代理类。动态创建则会涉及到反射的使用，并且在JDK中，给我们提供了代理相关的API供我们使用。</p><p>我们实现一个代理工厂类，我们给它提供目标类，然后由它产生一个代理类，该代理对应的目标类即为我们给定的目标类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> Object target; <span class="hljs-comment">// 目标类</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyFactory</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> target.getClass().getClassLoader(); <span class="hljs-comment">// 代理类需要使用的类加载器</span><br>        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); <span class="hljs-comment">// 代理类需要实现的接口</span><br>        <span class="hljs-comment">// 代理类需要如何实现目标方法</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[日志]: 计算开始,方法名称为 &quot;</span> + method.getName() + <span class="hljs-string">&quot;参数为 &quot;</span> + Arrays.toString(args));<br>                    result = method.invoke(target, args); <span class="hljs-comment">// 调用目标类的方法</span><br>                    System.out.println(<span class="hljs-string">&quot;[日志]: 计算结束,方法名称为 &quot;</span> + method.getName());<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                    System.out.println(<span class="hljs-string">&quot;[日志]: 计算异常,方法名称为 &quot;</span> + method.getName());<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[日志]: 方法执行完毕,方法名称为 &quot;</span> + method.getName());<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的重要方法是<code>getProxy()</code>，在其中我们需要返回目标类的代理类对象，使用了反射包下的<code>newProxyInstance()</code>方法，用于创建一个代理实例。其中需要提供三个参数，如下：</p><ul><li><code>classLodar</code>：指定加载动态生成的代理类需要的类加载器，可以与使用目标类的类加载器，一般是应用程序类加载器</li><li><code>interfaces</code>：指定代理类需要实现的接口，需要与目标对象接口一致，我们可以通过目标对象进行获取</li><li><code>invocationHandler</code>：设置代理类中的抽象方法如何重写，在其中需要描述与target相同的方法，在代理对象中该如何实现。</li></ul><p><code>invocationHandler</code>是一个函数式接口，其中只有一个方法<code>invoke</code>需要实现，函数签名如下。其中的实现关键在于如何安排执行方式，目标类的方法调用对应<code>method.invoke(target, args)</code>，我们可以在核心方法的前后，try-catch-finally块中的对应位置添加非核心代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable<br></code></pre></td></tr></table></figure><ul><li><code>proxy</code>：代理对象</li><li><code>method</code>：代理对象需要实现的方法，即其中需要重写的方法</li><li><code>args</code>：method所对应方法的参数</li></ul><p>有了代理工厂类，我们就可以很容易得到目标类的代理类，然后调用代理类的相关方法，达到效果。在这里的测试代码中，我们需要对getProxy获取到的代理类进行类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">proxyFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CalculatorImp</span>());<br><span class="hljs-type">Calculator</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Calculator) proxyFactory.getProxy();<br>proxy.div(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h1 id="基于注解的aop">基于注解的AOP</h1><h2 id="aop简介">AOP简介</h2><p>AOP，全称为Aspect OrientedProgramming，意为面向切面编程。这是一种编程思想，是对面向对象的一种补充和完善。利用面向切面编程，我们可以通过预编译方式和动态代理方式，在不修改源代码的情况下下给程序动态添加额外的功能，即在不修改源代码的情况下对其进行功能扩展。</p><p>回顾上面的方式，我们的核心代码在Calculator实现类中，我们没有修改它的源代码，但是使用代理的方式扩展了日志打印功能。</p><p>下面介绍AOP相关的一些概念：</p><ol type="1"><li>横切关注点：从方法中抽取出来的一类非核心业务。在一个项目中，我们可以使用多个横切关注点对相关方法进行多方面的增强</li><li>通知方法：一个横切关注点上需要完成的工作需要使用一个方法来实现，这样的方法叫做通知方法</li><li>切面类：对通知方法进行管理，封装通知方法的类称为切面类</li><li>目标对象：被代理的对象称为目标对象，里面实现的是核心业务逻辑</li><li>代理对象：将通知方法应用在目标对象上，据此创建出的代理对象</li><li>连接点：被抽取出来的通知方法在原方法中的位置，可能是在方法执行前后，或者异常结束，最终结束等位置</li><li>切入点：定位连接点的方式。</li></ol><p>AOP的流程可以总结如下：从目标对象中抽取非核心业务代码，即横切关注点，将其封装在类中，即切面类。每一个横切关注点对应一个方法，即通知方法，也就是非核心业务代码。抽取之后还需要完成与核心方法的结合，对应的结合位置为连接点，而连接点择需要利用切入点的方式来定位。</p><p>通过AOP，一方面，我们可以简化代码，将方法中位置固定且重复出现的代码抽取出来，让核心方法更加专注于自己功能的实现；另一方面，我们可以实现代码增强，将特定功能封装到切面类中，看哪里有需要就使用，使用了切面逻辑的方法就被增强了。</p><h2 id="注解使用">注解使用</h2><p>在Spring中，可以基于注解来使用AOP。具体来说，使用的是AspectJ注解层。AspectJ是AOP思想的一种实现，AspectJ本质上是静态代理，它将代理逻辑混入目标类编译得到的字节码文件中。具体实现层中又分为动态代理或cglib。</p><ul><li>动态代理：这是JDK原生的实现方式，需要被代理的目标类必须要实现某个接口，而代理类需要和目标类实现相同的接口。最终生成的代理类com.sum.proxy包下，类名为$porxy+数字，与目标类实现相同的接口</li><li>cglib：通过继承目标类来实现代理，不需要目标类实现接口。最终生成的代理类会继承目标类，并且和目标类在相同的包下</li></ul><p>Spring中的核心还是IOC，要使用AOP，我们首先还是需要引入IOC相关的依赖，同时引入下面的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们对上面计算器的场景重新进行实现。现在仍然有<code>Calculator</code>接口以及<code>CalculatorImp</code>实现类，在实现类中，只有最基本的功能实现，即核心代码。日志相关的代码并不在其中实现。不过这里实现类我们要使用<code>@Component</code>注解进行配置，将其交给IOC容器进行管理。</p><p>之后，创建切面类，并在里面实现相关通知方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 标识为切面类</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 交由IOC容器管理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>    <span class="hljs-comment">// 标识通知方法，并指定位置</span><br>    <span class="hljs-meta">@Before(&quot;execution(public int com.syh.spring.aop.Calculator.add(int, int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法开始之前&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，我们利用<code>@Aspect</code>标注表明这个类是一个切面类，然后利用<code>@Component</code>表示当前类要交给IOC容器管理。我们通过<code>@Before</code>标注指明对应方法是一个通知方法。这里的<code>@Before</code>注解表示通知方法的对应位置为方法执行之前，后续还会介绍其他位置的对应注解。注解中的值为切入点表达式，定位通知方法执行的位置。这里表示该通知方法要在add方法执行前执行。</p><p>之后，我们创建Spring的配置文件，首先配置扫描标签配合注解管理Bean，然后使用<code>aspectj-autoproxy</code>来开启基于注解的AOP功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.syh.spring.aop&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>至此，我们已经完成了基本的配置，测试代码如下。这里我们需要通过IOC容器来获取到代理类。我们并不知道由Spring生成的代理类的真实类型，但是我们知道它一定是实现了<code>Calculator</code>接口的，因此可以通过接口类型来访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAOP</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;aopContext.xml&quot;</span>);<br>    <span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> context.getBean(Calculator.class);<br>    calculator.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，虽然前面我们将<code>CalculatorImp</code>类交给了IOC容器进行管理，但是不能直接通过该类进行获取，会直接报错<code>NoSuchBeanDefinitionException</code>。AOP中通过代理方式实现，实际上IOC中管理的是对应的代理类。</p></blockquote><p>上面的代码已经能够达到相应的效果，在add方法执行之前，输出了对应的日志信息。</p><h2 id="通知方法">通知方法</h2><p>根据通知方法的位置不同，有如下的通知类型：</p><ol type="1"><li>前置通知：使用<code>@Before</code>注解进行标识，在目标方法执行前执行</li><li>返回通知：使用<code>@AfterRunning</code>注解进行标识，在目标方法正常退出后执行</li><li>异常通知：使用<code>@AfterThrowing</code>注解进行标识，在目标方法异常介结束后执行，对应catch代码块功能</li><li>后置通知：使用<code>@After</code>注解进行标识，在目标方法最终结束后执行，对应finally代码块功能</li><li>环绕通知：使用<code>@Around</code>注解进行标识，使用try-catch-finally结构围绕整个被代理的目标方法，定义了代理目标方法的全流程</li></ol><blockquote><p>通知的执行顺序为前置通知 -&gt; 目标操作 -&gt; 返回通知或异常通知-&gt; 后置通知，与正常try-catch-finally的执行逻辑类似。</p></blockquote><p>在通知方法中，我们可以获取连接点的相关信息，包括目标方法的签名信息，参数，返回值等。</p><p>要想获取连接点信息，我们需要在通知方法的参数位置设置<code>JoinPoint</code>类型的形参，然后通过该参数获取相关信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@After(&quot;pointCut()&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterMethod</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>    <span class="hljs-comment">// 获取连接点的签名信息</span><br>    <span class="hljs-type">Signature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> joinPoint.getSignature();<br>    System.out.println(<span class="hljs-string">&quot;方法名称: &quot;</span> + signature.getName());<br>    System.out.println(<span class="hljs-string">&quot;参数列表: &quot;</span> + Arrays.toString(joinPoint.getArgs()));<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>@AfterReturning</code>中可以指定属性returning，并在形参列表中指定对应的参数，接收目标方法的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;result&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturningMethod</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;方法名称: &quot;</span> + joinPoint.getSignature().getName());<br>    System.out.println(<span class="hljs-string">&quot;返回结果为: &quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>@AfterThrowing</code>中，也可以通过类似的方式，指定属性throwing来接收目标方法的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;exception&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowingMethod</span><span class="hljs-params">(Throwable exception)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;执行过程中遇见异常: &quot;</span> + exception);<br>&#125;<br></code></pre></td></tr></table></figure><p>环绕通知相当于动态代理的手动实现，我们可以在其中实现相关的逻辑。一般情况下是使用try-catch-finally进行包裹：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;pointCut()&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">aroundMethod</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">args</span> <span class="hljs-operator">=</span> Arrays.toString(joinPoint.getArgs());<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;对象方法执行前&quot;</span>);<br>        result = joinPoint.proceed();<br>        System.out.println(<span class="hljs-string">&quot;对象方法正常返回后&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>        throwable.printStackTrace();<br>        System.out.println(<span class="hljs-string">&quot;对象方法出现异常&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;对象方法执行完毕&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的核心步骤在于目标方法的执行，即<code>joinPoint.proceed()</code>。注意这里的方法需要有返回值，目标方法的返回值一定要返回给外界调用者。</p><h2 id="切入点">切入点</h2><p>在目标方法的注解中，需要提供切入点表达式，表明该通知方法要在哪些被代理的方法前后执行。切入点表达式语法如下，在括号中，需要提供方法的签名描述，让Spring能够找到对应的一个或者多个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(...)<br><span class="hljs-comment">// 举例</span><br><span class="hljs-meta">@Before(&quot;execution(* com.syh.spring.aop.Calculator.*(..))&quot;)</span><br></code></pre></td></tr></table></figure><ol type="1"><li>可以使用<code>*</code>代替修饰符+返回值，表示不限（注意是两者一起被代替，而不是其中一个）</li><li>如果要明确指定一个返回类型，必须同时写明权限修饰符</li><li>在包名的部分，一个<code>*</code>只能代表层次结构中的一层</li><li>在包名的部分，使用<code>*..</code>表示包名任意，包的层次深度任意</li><li>在类名或方法名部分，可以整体使用<code>*</code>代替，表示类名或方法名任意</li><li>在类名后方法名部分，可以用<code>*</code>代替类名或方法名的一部分，用于部分匹配</li><li>在参数列表部分，使用<code>(..)</code>表示参数列表任意</li><li>在参数列表部分，使用<code>(int,..)</code>表示参数列表应该以一个int类型的参数开头</li><li>基本数据类型与对应的包装类类型是不一致的，不能相互匹配</li></ol><p>切入点表达式比较冗长，重复书写较为麻烦。但是Spring中提供了切入点表达式的重用。我们只需要对切入表达式进行声明，后续直接使用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明</span><br><span class="hljs-meta">@Pointcut(&quot;execution(* com.syh.spring.aop.Calculator.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointCut</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-meta">@Before(&quot;pointCut()&quot;)</span><br><span class="hljs-meta">@Before(&quot;com.syh.spring.aop.LogAspect.pointCut()&quot;)</span><br></code></pre></td></tr></table></figure><p>声明好的切入点表达式既可以在本地方法中使用，也可以在其他切面类中进行使用，因为我们的切入点表达式是标记在方法上的，要访问切入点表达式，只需要找到对应的方法即可。</p><h2 id="切面的优先级">切面的优先级</h2><p>如果相同的目标方法上同时存在多个切面类，那么会存在切面的优先级。切面执行的优先级控制切面的内外嵌套顺序，如果切面类的优先级更高，则该切面类会先执行，后退出。</p><p>我们可以使用<code>@Order</code>注解来控制切面的优先级，其中需要提供一个整数，整数值越小表示优先级越高，默认值为<code>INT_MAX</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Order(1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基于xml的aop">基于XML的AOP</h1><p>上面我们是使用了基于注解实现的AOP，同样我们也可以基于XML来使用AOP。主要在配置文件中进行完成，主要标签为<code>aop:config</code>。此时不需要开启基于注解的AOP，即<code>aop:aspectj-autoproxy</code>标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置切面类--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logAspect&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.syh.spring.aop.Calculator.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;beforeMethod&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCut&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterMethod&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCut&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterReturningMethod&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCut&quot;</span> <span class="hljs-attr">returning</span>=<span class="hljs-string">&quot;result&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterThrowingMethod&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCut&quot;</span> <span class="hljs-attr">throwing</span>=<span class="hljs-string">&quot;exception&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;aroundMethod&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCut&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在config标签中进行切面类的配置，一个<code>aspect</code>对应一个切面类。其中的ref属性对应Bean对象的引用，由于我们通过注解将类对象交给了IOC进行管理，这里会提供logAspect的Bean对象id。这里的order属性对应优先级的设置。</p><p>之后通过不同的子标签设置不同的通知方法，与注解类似，也是需要指定方法，切入点，如果是returning或者thowing，则还需要指定对应接收的形参。这里的切入点可以使用<code>pointcut-ref</code>，也可以使用<code>pointcut</code>，前者对应一个定义好的切入点，后者则是提供切入点表达式。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring笔记(2)-IOC之基于注解管理Bean</title>
    <link href="/2022/10/14/Spring%E7%AC%94%E8%AE%B0-2-IOC%E4%B9%8B%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%AE%A1%E7%90%86Bean/"/>
    <url>/2022/10/14/Spring%E7%AC%94%E8%AE%B0-2-IOC%E4%B9%8B%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%AE%A1%E7%90%86Bean/</url>
    
    <content type="html"><![CDATA[<h1 id="注解介绍">注解介绍</h1><p>之前我们介绍了基于XML配置文件来管理Bean，在Spring中，还可以通过注解来完成Bean的管理。注解本身并不能执行，它只是完成标记功能，框架在检测到注解标记的位置之后，针对不同的注解来执行具体的操作。Spring为了指导程序员在哪些地方进行了标注，则需要通过扫描的方式来进行检测，然后根据注解进行后续操作。</p><p>Spring中提供有四种相关的注解：</p><ul><li><code>@Component</code>：将类标识为普通组件</li><li><code>@Controller</code>：将类标识为控制层组件</li><li><code>@Service</code>：将类标识为业务层组件</li><li><code>@Repository</code>：将类标识为持久层组件</li></ul><p>实际上，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>这三个注解只是在<code>@Component</code>的基础上重新命名得到的注解，对于Spring来说，它们完成的功能都是相同的，都是标识当前类交由IOC进行管理，但是我们在使用的时候不能随便使用，应当利用好注解的名称来提升代码的可读性。</p><p>基于注解的Bean管理，我们只需要在需要交给IOC管理的实体类上增加对应注解，如下所示。需要注意不能标识在接口上，因为接口也不能交给IOC管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shop</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> Integer count;<br>    <br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后在配置文件中开启扫描，利用<code>component-scan</code>标签，并指定其中的包名。这样，Spring就会扫描对应包下的所有类，如果有对应注解，则将该类进行管理。后续我们也可以从IOC容器中获取到相关的对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.syh.spring.bean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>通过注解配置的Bean对象，默认的id为类名的小驼峰形式，当然我们也可以在注解的value指定，这样对应的id就会使用我们指定的id：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;shopBean&quot;)</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="注解扫描">注解扫描</h1><p>在配置文件中进行开启注解扫描需要使用到<code>component-scan</code>标签，最基本的扫描方式就是指定基础的包名。除此之外，我们还可以指定要排除哪些组件或者只扫描哪些组件。</p><p>首先是指定要排除的组件。使用<code>exclude-filter</code>标签来指定排除规则，其中的type属性可以指定排除规则的类型，express属性指定对应全类名，在express中，也可以使用逗号来分隔多个内容。</p><ul><li>type为annotation，表示根据注解排除。expression中设置要排除的注解的全类名</li><li>type为assignable，表示根据类型排除。expression中设置要排除的类型的全类名</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.syh.spring.bean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;assignable&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Shop&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后是指定仅扫描哪些组件。使用<code>include-filter</code>标签来指定包含规则，其中type属性也是指定包含规则的类型，express属性指定对应全类名。注意，这里必须额外指定<code>component-scan</code>标签中的<code>use-defult-filters</code>属性为false，即关闭默认扫描规则。默认扫描规则是扫描指定包上的所有类。如果没有关闭，则还是扫描所有类，没有起到仅扫描的作用。</p><ul><li>type为annotation，表示根据注解包含。expression中设置要包含的注解的全类名</li><li>type为assignable，表示根据类型包含。expression中设置要包含的类型的全类名</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.syh.spring.bean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Component&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;assignable&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Shop&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的两类标签可以多次使用，但是不能同时使用。即可以有多个排除，或者多个包含，但是不能既使用排除、又使用包含。虽然语法上没有问题，但是无法达到我们所需的效果。</p><h1 id="基于注解的自动装配">基于注解的自动装配</h1><p>基于注解管理Bean的方式中，也提供自动装配的功能。对应注解为<code>@Autowired</code>，使用该注解即可完成自动装配。该注解能够标识的位置有以下三种：</p><ul><li>标识在成员变量上，此时不需要设置成员变量的set方法</li><li>标识在set方法上</li><li>标识在成员变量的有参构造</li></ul><p><code>@Autowired</code>注解的工作流程会涉及到byType以及byName，对应自动装配的工作流程如下：</p><img src="/2022/10/14/Spring%E7%AC%94%E8%AE%B0-2-IOC%E4%B9%8B%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%AE%A1%E7%90%86Bean/%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%B5%81%E7%A8%8B.png" class="" title="注解自动装配流程"><p><code>@Qualifier</code>注解是提供匹配id的一个注解，我们可以在其中设置属性名希望匹配的id名称。</p><p>首先根据所需要组件的类型到IOC容器中进行查找，如果能够找到唯一的Bean，就直接进行装配；如果完全找不到对应的类型，则装配失败。如果匹配到的Bean不止一个，则根据id进行匹配。如果配置了<code>@Qualifier</code>注解，则匹配的id为注解中的名称，如果没有配置，则按照属性名称进行匹配。如果能够匹配到，则执行装配，否则，则装配失败。</p><blockquote><p>基于注解的自动装配，如果装配失败，都会报错<code>NoSuchBeanDefinitionException</code>。而基于XML的自动装配，如果装配失败，则使用的是默认值。</p><p>实际上该行为是由<code>@Autowired</code>中的属性<code>required</code>来指定的，它的默认值为true，表示自动装配无法找到对应的Bean的时候会装配失败，抛出错误。如果将该值设置为false的时候，如果装配失败，则使用默认值。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring笔记(1)-IOC之基于XML管理Bean</title>
    <link href="/2022/10/13/Spring%E7%AC%94%E8%AE%B0-1-IOC%E4%B9%8B%E5%9F%BA%E4%BA%8EXML%E7%AE%A1%E7%90%86Bean/"/>
    <url>/2022/10/13/Spring%E7%AC%94%E8%AE%B0-1-IOC%E4%B9%8B%E5%9F%BA%E4%BA%8EXML%E7%AE%A1%E7%90%86Bean/</url>
    
    <content type="html"><![CDATA[<h1 id="spring-简介">Spring 简介</h1><p>Spring是Java的以一种应用程序开发框架，因其性能优秀，易于测试，重用性高而被众多Java开发者欢迎。它是一个轻量级的框架，可以用于开发任何的Java应用程序。Spring的官方网站如下：<ahref="https://spring.io/">Spring | Home</a></p><p>Spring家族生态中包括一系列项目（<ahref="https://spring.io/projects">Spring |Projects</a>），这些项目均以SpringFramework框架为基础，可以将其视为Spring基础设施。</p><p>Spring Framework具有如下特性：</p><ol type="1"><li>非侵入式：使用SpringFramework开发应用程序的时候，Spring对应用程序本身结构的影响非常小，对功能性组件只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能够将组件结构进一步简化，使得应用程序变得结构清晰，简洁优雅。</li><li>控制反转：指的是IOC，Inversion ofControl。我们将资源的控制交由Spring来管理。</li><li>面向切面编程：指的是AOP，Aspect OrientedProgramming，在不修改源代码的基础上增强代码功能。</li><li>IOC容器：IOC容器包含并管理组件对象的生命周期，组件受到容器化的管理，对程序员屏蔽了组件创建过程中的大量细节，极大降低了使用门槛，大幅度提高了开发效率。</li><li>声明式：我们仅需使用一些声明，就可以让框架代为实现一些功能，降低了复杂度</li><li>一站式：在IOC和AOP的基础上，可以整合各种企业应用的开源框架以及优秀的第三方类库，并且Spring生态中的项目覆盖领域也即为广泛，能够满足大部分的需求。</li></ol><p>上面的特性可能听起来比较抽象，随着后续的学习，我们会渐渐理解对应的含义。</p><h1 id="ioc">IOC</h1><h2 id="介绍">介绍</h2><p>IOC，全称为Inversion ofControl，意为控制反转。在传统的程序开发中，我们会使用到很多实体类，如果需要使用到某个类的对象时，我们会直接使用new进行生成，这是正向控制的思想。而控制反转指的是将获取资源的方式进行反转，我们将类交由容器来进行管理，在需要使用的时候，由容器将资源进行主动推送，我们不需要知道容器是如何创建资源对象的，只需要接收资源即可。</p><p>Spring中的IOC容器是IOC思想的一种落地实现。我们将IOC容器中管理的类称为组件，也称为Bean。我们将类交由IOC容器进行管理，后续需要获取对应的Bean对象时，也需要从IOC容器中获取。由IOC容器来管理对象的生命周期，我们只需要在需要的时候获取资源即可。</p><p>Spring中，IOC容器的相关继承体系如下，选取了一些重要接口和类进行展示：</p><img src="/2022/10/13/Spring%E7%AC%94%E8%AE%B0-1-IOC%E4%B9%8B%E5%9F%BA%E4%BA%8EXML%E7%AE%A1%E7%90%86Bean/IOC%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" class="" title="IOC继承体系"><ul><li><code>BeanFactory</code>：这是IOC容器的基本实现，是Spring内部使用的接口，面向Spring内部，一般不提供给开发人员使用。</li><li><code>ApplicationContext</code>：BeanFactory的子接口，提供了更多的高级特性。面向Spring的使用者，几乎在所有的场合，我们都是使用ApplicationContext而非更底层的BeanFactory。</li><li><code>ConfigurableApplicationContext</code>：ApplicationFactory的子接口，相比于ApplicationFactory，扩展了更多特性，包括容器启动、刷新、关闭等方法。</li></ul><p>主要用到的实现类如下：</p><ul><li><code>ClassPathXmlApplicationContext</code>：通过读取类路径下XML格式的配置文件来创建IOC容器对象</li><li><code>FileSystemXmlApplicationContext</code>：通过文件系统读取XML格式的配置文件来创建IOC容器对象</li><li><code>WebApplicationContext</code>：专门为Web应用准备，基于Web环境创建IOC容器对象，并将对象引入ServletContext域中</li></ul><p>在上面的实现类中，我们一般使用<code>ClassPathXmlApplicationContext</code>较多，因为在不同环境中文件系统路径不一定对应，使用类路径便于程序的移植。</p><h2 id="快速开始">快速开始</h2><p>首先创建一个Maven工程，然后引入相关依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Spring Framework--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后我们创建一个实体类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello Spring!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要访问该类，调用其中的sayHello方法，在传统方式下，我们会手动new一个HelloWord对象，然后调用其中的sayHello方法。但是在IOC思想下，我们需要将实体类交由IOC容器进行管理，然后从IOC容器中获取对应对象。</p><p>在Spring中，通过XML配置文件进行IOC容器的配置，因此我们需要在<code>resources</code>目录下创建配置文件。选择<code>new -&gt; XML Configuration File -&gt; Spring Config</code>，配置文件的名称无具体要求，这里我们命名为<code>applicationContext.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloworld&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.HelloWorld&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在其中，我们配置了需要交给IOC容器管理的类，包括它的ID以及对应的全类名。然后可以测试代码如下，运行发现能够正常完成功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-type">HelloWorld</span> <span class="hljs-variable">helloWorld</span> <span class="hljs-operator">=</span> (HelloWorld) context.getBean(<span class="hljs-string">&quot;helloworld&quot;</span>);<br>helloWorld.sayHello();<br></code></pre></td></tr></table></figure><p>上面的代码中，我们首先需要创建一个IOC容器，创建容器需要使用XML配置文件，因此给定对应的文件位置。之后，我们通过<code>getBean</code>方法获得到对应的对象之后，进行强制转换，之后就可以得到对应的类了。然后调用相应的方法，即可达到效果。</p><blockquote><p>从上面的过程中，我们可以发现，我们只创建了IOC容器，而我们需要的HelloWorld对象则是从IOC容器中进行获取的。中间的过程实际上是由Spring框架帮助我们完成的，通过getBean方法，IOC容器能够知道我们需要哪个类对象，找到对应Class对象后可以通过反射进行创建，之后返回给用户。并且Spring返回给我们的对象，默认是单例的。</p><p>Spring底层默认通过反射技术调用组件类的无参构造来创建组件对象，因此需要保证组件类有一个无参构造。如果没有无参构造，则会抛出异常<code>BeanCreationException</code>。</p></blockquote><h1 id="基于xml管理bean">基于XML管理Bean</h1><h2 id="bean对象的获取">Bean对象的获取</h2><p>前面我们通过id进行Bean对象的获取，实际上还有其他的方式进行对象的获取，这里进行相关说明。我们在配置文件中有如下Bean对象的说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloworld&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.HelloWorld&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>方式一：通过id进行获取</strong></p><p>id属性指定了Bean的唯一标识，所以根据bean标签的id属性可以唯一获取到对应的组件对象，这种方式获取到的是Object对象，还需要进行类型的强转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HelloWorld</span> <span class="hljs-variable">helloWorld</span> <span class="hljs-operator">=</span> (HelloWorld) context.getBean(<span class="hljs-string">&quot;helloworld&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>方式二：通过类型进行获取</strong></p><p>我们也可以通过类的类型进行获取。一般来说，在一个配置文件中，一种类型的Bean对象只会存在一个，因此我们能够根据类型获取到对应的对象。这种情况下，不需要进行类型的强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HelloWorld</span> <span class="hljs-variable">helloWorld</span> <span class="hljs-operator">=</span> context.getBean(HelloWorld.class);<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，根据类型类型获取Bean时，要求IOC容器中有且只有一个类型匹配的Bean。但是这不是说配置文件中同一个Class只能出现一次，在id不同的情况下可以出现多次。这种方式一般是为了获取多例对象，可以但是没有必要，因为后续我们会有其他方式获取多例。</p></blockquote><p><strong>方式三：通过id和类型进行获取</strong></p><p>结合id和类型进行获取，这种情况下，不需要进行类型的强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HelloWorld</span> <span class="hljs-variable">helloWorld</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;helloworld&quot;</span>, HelloWorld.class);<br></code></pre></td></tr></table></figure><p>我们通常情况下会使用方式二来获取Bean对象。如果组件实现了接口或者继承了父类，我们可以通过接口类型和父类类型来获取该Bean对象，但是前提都是我们能够找到的Bean对象唯一。而实际上，根据类型来获取Bean对象的时候，在满足Bean唯一性的前提下，只要满足<code>对象.instanceof(指定的Class对象)</code>返回为true，则认为与类型匹配，则能够获取。</p><h2 id="依赖注入">依赖注入</h2><p>在入门案例中，我们的实体类是没有成员变量的。而如果有成员变量的话，我们需要为其进行赋值。在Spring中，对象初始化时成员变量的赋值，需要通过依赖注入来完成。对于不同类型的成员变量，注入的方式也有所不同。</p><p>我们首先准备下面的实体类<code>Reader</code>，便于后续的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reader</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面省略了构造方法、get，set方法、toString方法等。注意这里一定要有一个空参构造。后续可能会在这个类中增加其他的成员变量进行测试，同时会添加对应的get，set方法，修改toString方法，后面就不再进行说明了。</p><p>我们的测试方法如下，如果直接配置，没有指定对应的属性，那么输出中，成员变量都是null。后续我们将说明不同类型成员变量的赋值方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> context.getBean(Reader.class);<br>System.out.println(reader);<br></code></pre></td></tr></table></figure><h3 id="set方法注入">set方法注入</h3><p>利用set方法，我们可以设置类中属性的值，对应格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>利用<code>property</code>标签来进行属性的赋值，其中<code>name</code>指定属性的名称，<code>value</code>指定属性值。目前演示的是字面量的初始化。这里的value即可以以属性的方式给定，也可以以子标签的形式给定。</p><blockquote><p>特殊值处理：</p><ul><li>null值</li></ul><p>null值的给定不能直接通过“null”来设置，需要使用对应的标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">null</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">null</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>特殊字符串：</li></ul><p>在XML文件中有一些特殊字符不能直接写在字符串中，例如大于小于号等。如果我们需要赋值这样的特殊字符串，可以通过XML实体的方式进行转义，也可以利用CDATA节的方式进行赋值。</p><p>第一种方式使用XML实体，例如小于号对应的XML实体为<code>&amp;lt;</code>，大于号对应的XML实体为<code>&amp;gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;<span class="hljs-symbol">&amp;lt;</span> 张三 <span class="hljs-symbol">&amp;gt;</span>&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>第二种方式使用CDATA节，这是XML中的一种特殊标签，形式为<code>![CDATA[...]]</code>，在其中写的内容会被原样解析：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>&lt;![CDATA[&lt; 张三 &gt;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="构造器注入">构造器注入</h3><p>如果我们的类中有构造器，我们也可以直接在bean中指定构造器的参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>默认情况下按照顺序给参数进行赋值。在<code>constructor-arg</code>标签中还有两个属性可以进一步描述构造器参数：</p><ul><li><code>index</code>：指定参数所在位置的索引，从0开始</li><li><code>name</code>：指定参数的名称</li></ul><h3 id="类类型赋值">类类型赋值</h3><p>前面的属性均为字面量的赋值，下面介绍类类型的赋值。我们先增加一个类<code>Book</code>，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer isbn;<br>    <span class="hljs-keyword">private</span> String bookName;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在<code>Reader</code>中添加对应的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reader</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Book readingBook;<br>&#125;<br></code></pre></td></tr></table></figure><p>为类类型赋值有三种方式，分别是引用外部已声明的Bean，引用内部Bean以及使用级联方式。</p><p><strong>方式一：引用外部Bean</strong></p><p>要引用外部已经声明的Bean，那么我们需要首先声明一个Bean对象，然后再使用<code>ref</code>进行引用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Book&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isbn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;98211234&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;一本好书&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;readingBook&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;book&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>方式二：引用内部Bean</strong></p><p>引用内部Bean即在一个Bean的内部声明另一个Bean。内部Bean只能用于给属性赋值，不能在外部通过IOC容器进行获取，因此可以省略id属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;readingBook&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Book&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isbn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;98211234&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;一本好书&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>方式三：级联方式</strong></p><p>使用级联方式，我们需要依次为类的属性进行赋值。注意这种方式一定要先引用某个bean为属性赋值，之后才能使用级联方式更新属性。相比之下这种方式用的并不是很多。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Book&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isbn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;98211234&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;一本好书&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;readingBook&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;book&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;readingBook.isbn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;98211235&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;readingBook.bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;二本好书&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="数组类型赋值">数组类型赋值</h3><p>在<code>Reader</code>类中添加对应的数组成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reader</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Book readingBook;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] borrowingBookIds;<br>&#125;<br></code></pre></td></tr></table></figure><p>在bean标签中，我们可以使用<code>array</code>标签为数组类型进行赋值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;readingBook&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;book&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;borrowingBookIds&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="列表类型赋值">列表类型赋值</h3><p>在<code>Reader</code>类中添加对应的列表成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reader</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Book readingBook;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] borrowingBookIds;<br>    <span class="hljs-keyword">private</span> List&lt;Book&gt; returningBooks;<br>&#125;<br></code></pre></td></tr></table></figure><p>与数组类型类似，在bean标签中，我们可以通过<code>list</code>标签为列表类型进行赋值，下面的配置文件中省略了其他不相关的赋值语句。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Book&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isbn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;book-1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Book&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isbn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;book-2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Book&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isbn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;book-3&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--其他配置...--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;returningBooks&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;book1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;book2&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;book3&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>另一种方式是将list对象定义在外部，然后通过ref进行引用。但是在配置文件中，我们不能直接使用list标签，而需要引入util的约束，使用<code>util:list</code>标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookList&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;book1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;book2&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;book3&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--其他配置...--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;returningBooks&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bookList&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果需要为Set集合类型赋值，只需要将上面的list标签改为set标签即可。</p></blockquote><h3 id="map类型赋值">Map类型赋值</h3><p>在<code>Reader</code>类中添加对应的Map成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reader</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Book readingBook;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] borrowingBookIds;<br>    <span class="hljs-keyword">private</span> List&lt;Book&gt; returningBooks;<br>    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap;<br>&#125;<br></code></pre></td></tr></table></figure><p>类比上面的操作，我们也可以通过bean标签中的<code>map</code>标签来对Map成员变量进行赋值。在<code>map</code>标签中还需要指定<code>entry</code>子标签，其中需要指定key，value属性，或者使用对应的子标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--其他配置...--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookMap&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;AM&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;book1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>PM<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;book3&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>类似的，我们也可以将Map定义在外部，然后通过ref进行引用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">util:map</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookMap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;AM&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;book1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;PM&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;book2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">util:map</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--其他配置...--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookMap&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bookMap&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="p命名空间">p命名空间</h3><p>我们可以引入p命名空间，之后就可以通过属性的方式为bean的各个属性赋值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;readerP&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">p:id</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;李四&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">p:readingBook-ref</span>=<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-attr">p:bookMap-ref</span>=<span class="hljs-string">&quot;bookMap&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="外部属性文件引入">外部属性文件引入</h3><p>在配置文件中，我们还可以引入属性文件，之后就可以使用对应的属性文件了。</p><p>例如在<code>resources</code>目录下，还存在一个外部属性文件<code>jdbc.properties</code>，其中记录了数据库连接的相关数据：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.user</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">123123</span><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/ssm_data</span><br><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>要想使用该外部属性文件，我们需要在配置文件中进行引入才能使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入外部属性文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="自动装配">自动装配</h2><p>在依赖注入小节，我们通过手动指定的方式，为每个属性进行了初始值的指定。不过在Spring中，提供了一种自动装配的机制，为我们完成ref的自动匹配。自动装配可以帮助我们解决ref的赋值，它指的是根据指定的策略，在IOC容器中匹配某个bean，自动为bean中的类类型的属性或者接口类型的属性进行赋值。</p><p>自动装配对应bean标签中的<code>autowire</code>属性，默认情况下不开启自动装配。我们常用的自动装配属性有两种<code>byType</code>和<code>byName</code>。</p><p><code>byType</code>表示根据要赋值属性的类型，在IOC容器中匹配某个Bean然后为属性赋值。</p><ul><li>如果通过类型没有找到任何一个匹配的Bean，则不装配，使用默认值。如果没有默认值则为null。</li><li>如果通过类型找到了多个类型匹配的Bean，则会抛出异常<code>NoUniqueBeanDefinitionException</code></li></ul><p>例如下面的配置文件，Reader对象的readingBook需要一个Book类型的对象，而在IOC中正好有一个对应的Bean，那么就执行自动装配。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Book&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isbn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;算术&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果我们输出获取到的Reader对象，内容如下所示。可以发现除了readingBook，其中泛型含有Book类型的列表和Map也进行了匹配。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Reader&#123;<span class="hljs-attribute">id</span>=123, <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attribute">readingBook</span>=Book&#123;<span class="hljs-attribute">isbn</span>=123456, <span class="hljs-attribute">bookName</span>=<span class="hljs-string">&#x27;算术&#x27;</span>&#125;, <br><span class="hljs-attribute">borrowingBookIds</span>=<span class="hljs-literal">null</span>, returningBooks=[Book&#123;<span class="hljs-attribute">isbn</span>=123456, <span class="hljs-attribute">bookName</span>=<span class="hljs-string">&#x27;算术&#x27;</span>&#125;],<br>bookMap=&#123;<span class="hljs-attribute">book</span>=Book&#123;<span class="hljs-attribute">isbn</span>=123456, <span class="hljs-attribute">bookName</span>=<span class="hljs-string">&#x27;算术&#x27;</span>&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><p><code>byName</code>表示在IOC以要赋值属性的名称为目标检索其他Bean的id，如果匹配到id与属性名相同，则为属性进行赋值。</p><ul><li>如果通过属性名匹配id找不到任何一个Bean，则不装配，使用默认值。</li><li>在<code>byName</code>情况下不会出现匹配到多个Bean的情况，因为如果匹配到了多个Bean，意味着这些Bean的id属性是相同的，而配置文件中不允许id属性值有重复，会直接抛出<code>Configuration problem</code>异常。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reader&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Reader&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;readingBook&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Book&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isbn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;算术&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">util:map</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookMap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;AM&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Book&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isbn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;book-1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;PM&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Book&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isbn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;book-2&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">util:map</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出如下，发现其中Map也可以按照名称进行相应的匹配。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Reader&#123;<span class="hljs-attribute">id</span>=123, <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attribute">readingBook</span>=Book&#123;<span class="hljs-attribute">isbn</span>=123456, <span class="hljs-attribute">bookName</span>=<span class="hljs-string">&#x27;算术&#x27;</span>&#125;, <br><span class="hljs-attribute">borrowingBookIds</span>=<span class="hljs-literal">null</span>, <span class="hljs-attribute">returningBooks</span>=<span class="hljs-literal">null</span>, <br>bookMap=&#123;<span class="hljs-attribute">AM</span>=Book&#123;<span class="hljs-attribute">isbn</span>=123, <span class="hljs-attribute">bookName</span>=<span class="hljs-string">&#x27;book-1&#x27;</span>&#125;, <span class="hljs-attribute">PM</span>=Book&#123;<span class="hljs-attribute">isbn</span>=456, <span class="hljs-attribute">bookName</span>=<span class="hljs-string">&#x27;book-2&#x27;</span>&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><h1 id="bean对象">Bean对象</h1><h2 id="作用域与生命周期">作用域与生命周期</h2><p>前面我们说到Spring中IOC容器给我们提供的默认是单例对象，这是由bean标签中的scope属性来进行控制的。scope的可选值有以下两种：</p><ul><li><code>singleton</code>：默认取值，单例对象。表示在IOC容器中，这个Bean对象始终为单例，在IOC容器初始化的时候就进行创建。</li><li><code>prototype</code>：多例，表示在IOC容器中，这个Bean对象有多个实例，在获取对应Bean对象的时候才创建对象。</li></ul><p>Bean的具体生命周期如下：</p><ol type="1"><li>Bean对象创建（反射调用无参构造）</li><li>给Bean对象设置属性</li><li>Bean对象初始化之前的操作（由Bean的后置处理器负责）</li><li>Bean对象初始化操作（指定Bean的初始化方法）</li><li>Bean对象初始化之后的操作（由Bean的后置处理器赋值）</li><li>Bean对象准备就绪，可以使用</li><li>Bean对象销毁操作（指定Bean的销毁方法）</li><li>IOC容器关闭</li></ol><p>针对上面的生命周期，我们可以创建一个类来进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Life</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;2.给Bean对象设置属性&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    Life() &#123;<br>        System.out.println(<span class="hljs-string">&quot;1.Bean对象创建&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;4.Bean对象初始化操作&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;7.Bean对象销毁操作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在配置文件中，我们需要将该类配置为Bean，并且指定初始化方法以及销毁方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;life&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.Life&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initMethod&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroyMethod&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;life&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后模拟使用Bean对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;lifeContext.xml&quot;</span>);<br><span class="hljs-type">Life</span> <span class="hljs-variable">life</span> <span class="hljs-operator">=</span> context.getBean(Life.class);<br>System.out.println(<span class="hljs-string">&quot;6.Bean对象准备就绪，可以使用&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.<span class="hljs-keyword">Bean对象创建</span><br><span class="hljs-keyword"></span><span class="hljs-number">2</span>.给<span class="hljs-keyword">Bean对象设置属性</span><br><span class="hljs-keyword"></span><span class="hljs-number">4</span>.<span class="hljs-keyword">Bean对象初始化操作</span><br><span class="hljs-keyword"></span><span class="hljs-number">6</span>.<span class="hljs-keyword">Bean对象准备就绪，可以使用</span><br></code></pre></td></tr></table></figure><p>这是因为我们使用的是<code>ApplicationContext</code>，其中并没有提供IOC容器的关闭功能。我们可以改用<code>ConfigurableApplicationContext</code>，然后调用对应的close方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;lifeContext.xml&quot;</span>);<br><span class="hljs-type">Life</span> <span class="hljs-variable">life</span> <span class="hljs-operator">=</span> context.getBean(Life.class);<br>System.out.println(<span class="hljs-string">&quot;6.Bean对象准备就绪，可以使用&quot;</span>);<br>context.close();<br></code></pre></td></tr></table></figure><p>得到如下的输出：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.<span class="hljs-keyword">Bean对象创建</span><br><span class="hljs-keyword"></span><span class="hljs-number">2</span>.给<span class="hljs-keyword">Bean对象设置属性</span><br><span class="hljs-keyword"></span><span class="hljs-number">4</span>.<span class="hljs-keyword">Bean对象初始化操作</span><br><span class="hljs-keyword"></span><span class="hljs-number">6</span>.<span class="hljs-keyword">Bean对象准备就绪，可以使用</span><br><span class="hljs-keyword"></span><span class="hljs-number">7</span>.<span class="hljs-keyword">Bean对象销毁操作</span><br></code></pre></td></tr></table></figure><p>目前我们还有Bean对象初始化前后的操作没有测试。这两个阶段由Bean的后置处理器负责。我们需要创建一个类实现<code>BeanPostProcessor</code>接口，实现其中的对应方法，然后配置到IOC容器当中。需要注意的是，Bean的后置处理器不是单独针对某一个Bean生效，而是针对IOC容器中的所有Bean对象。</p><p>首先创建类，实现对应接口，重写其中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;3.Bean对象初始化之前的操作&quot;</span>);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;5.Bean对象初始化之后的操作&quot;</span>);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将其配置到配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBeanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.syh.spring.bean.MyBeanPostProcessor&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>重新执行测试方法，输出如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.<span class="hljs-keyword">Bean对象创建</span><br><span class="hljs-keyword"></span><span class="hljs-number">2</span>.给<span class="hljs-keyword">Bean对象设置属性</span><br><span class="hljs-keyword"></span><span class="hljs-number">3</span>.<span class="hljs-keyword">Bean对象初始化之前的操作</span><br><span class="hljs-keyword"></span><span class="hljs-number">4</span>.<span class="hljs-keyword">Bean对象初始化操作</span><br><span class="hljs-keyword"></span><span class="hljs-number">5</span>.<span class="hljs-keyword">Bean对象初始化之后的操作</span><br><span class="hljs-keyword"></span><span class="hljs-number">6</span>.<span class="hljs-keyword">Bean对象准备就绪，可以使用</span><br><span class="hljs-keyword"></span><span class="hljs-number">7</span>.<span class="hljs-keyword">Bean对象销毁操作</span><br></code></pre></td></tr></table></figure><blockquote><p>上面的演示使用的是默认scope，即单例对象。如果配置的是多例，则销毁阶段不由IOC容器管理。</p></blockquote><h2 id="factorybean">FactoryBean</h2><p>我们首先考虑一个简单的工厂模式，我们有一个工厂类<code>BookFactory</code>，如果我们要获得<code>Book</code>对象，那么首先需要获取工厂类对象。在IOC思想指导下，我们应该将这个工厂类也交由IOC进行管理，因此全流程就变成了我们从IOC容器中获取工厂类对象，然后再由工厂类对象获得对应的需求类。</p><p>在SpringIOC中，针对工厂模式的管理提供一种<code>FactoryBean</code>的机制。通过这种机制，我们可以直接从IOC容器中获取到需求类，也就是这里例子中的<code>Book</code>对象，而不需要先获取工厂类，再获取需求类。</p><p><code>FactoryBean</code>是一个接口，我们的工厂类可以实现其中的方法，然后将其配置在配置文件中。例如下面，我们实现了一个简单的<code>BookFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;Book&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> Book.class;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中需要实现三个方法：</p><ul><li><code>getObject</code>：提供一个对象交给IOC容器管理</li><li><code>getObjectType</code>：设置所提供对象的类型</li><li><code>isSingleton</code>：所提供的对象是否是单例</li></ul><p>将其正常配置在配置文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;bookFactory&quot;</span> class=<span class="hljs-string">&quot;com.syh.spring.bean.BookFactory&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>从下面的测试方法中，我们可以看到我们获取到的直接是Book对象而非BookFactory对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;factoryContext.xml&quot;</span>);<br><span class="hljs-type">Book</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context.getBean(Book.class);<br>System.out.println(bean);<br></code></pre></td></tr></table></figure><p>总结来说，<code>FactoryBean</code>这是Spring提供的一种整合第三方框架的常用机制。与普通的Bean不同，如果我们配置了FactoryBean类型的Bean，在获取Bean的时候，得到的并不是在配置文件中class属性对应的类对象，而是getObject方法的返回值。通过这种机制，Spring向程序员屏蔽了复杂的组件创建过程和细节，只提供了最简洁的使用。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis笔记(5)-代码生成与分页插件</title>
    <link href="/2022/10/12/MyBatis%E7%AC%94%E8%AE%B0-5-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"/>
    <url>/2022/10/12/MyBatis%E7%AC%94%E8%AE%B0-5-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="代码生成">代码生成</h1><p>在前面的过程中，我们都是按照一定的流程来使用MyBatis的。我们首先会创建数据库表，然后自己按照规范来书写实体类，Mapper接口以及对应的映射文件。这个过程要遵循一定的规范。</p><p>实际上，我们可以利用MyBatis的代码生成器插件来进行代码生成。具体来说，我们在数据库中准备好了数据表之后，可以利用生成器根据数据库表来生成其他必要资源，包括Java实体类、Mapper接口以及Mapper映射文件。下面就简单记录代码生成器的使用。</p><p>首先我们需要创建一个Maven项目，然后在其中添加必要的依赖和插件，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--MyBatis核心--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Junit测试--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--MySQL驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--log4j日志--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--控制Maven在构建过程中的相关配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--构建过程中需要用到的插件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--具体插件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--插件的依赖--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--生成器的核心依赖--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--MySQL驱动--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二步需要创建MyBatis的核心配置文件。由于核心配置文件不是由生成器生成的，这里直接按照正常流程创建即可。</p><p>第三步需要创建生成器的配置文件，文件名称必须是<code>generatorConfig.xml</code>，其中的内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 数据库的连接信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/ssm_data&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123123&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- javaBean的生成策略--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.syh.bean&quot;</span></span><br><span class="hljs-tag">                            <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.syh.mapper&quot;</span></span><br><span class="hljs-tag">                         <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\resources&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Mapper接口的生成策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span></span><br><span class="hljs-tag">                             <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.syh.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 逆向分析的表 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span><br>        <span class="hljs-comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;User&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在<code>context</code>标签中需要指定<code>targetRuntime</code>，表示执行使用生成器的版本，可选值为<code>MyBatis3Simple | MyBatis3</code><ul><li><code>MyBatis3Simple</code>：简易版生成器，生成的接口中只有基本的CRUD操作</li><li><code>MyBatis3</code>：完整版生成器，生成的接口中拥有大量的方法，基本上涵盖了对单表的所有操作</li></ul></li><li>之后我们需要指定数据的连接信息、实体类，映射文件以及Mapper接口的生成策略，在其中指定目标包以及目标路径</li><li>然后指定我们的目标数据来源表，以及生成出来的实体类的类名</li></ul><p>完成上面的准备操作后，执行Maven插件的<code>mybatis-genrator</code></p><img src="/2022/10/12/MyBatis%E7%AC%94%E8%AE%B0-5-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/mybatis-generator.png" class="" title="mybatis-generator"><p>生成完毕后可以发现在工程项目中已经出现了对应的实体类，Mapper接口以及映射文件等。</p><img src="/2022/10/12/MyBatis%E7%AC%94%E8%AE%B0-5-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6.png" class="" title="生成文件"><h1 id="分页插件">分页插件</h1><p>在前端列表展示功能中，经常会遇到分页功能的实现。可以考虑常见的分页导航栏，在最底端有首页、上一页、xxx页、下一页、末页等超链接，在每一个页面这些链接对应的实际URL都不同，需要动态变化。我们可以通过SQL中的关键字limit，以及一些条件判断来完成对应的功能，但是较为复杂。对于这种通用的功能，我们可以使用分页插件来完成对应的效果，下面就介绍分页插件的使用。</p><p>首先我们需要在Maven工程中添加依赖，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--分页插件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在MyBatis的核心配置文件中设置插件，之后就可以进行使用了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先我们准备一个查询所有记录的方法，并实现映射文件中对应的SQL语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- List&lt;User&gt; getUserList()--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>    select *<br>    from users<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>正常情况下，我们调用方法得到的输出是数据库中全部的记录。但是开启分页功能之后，就只会输出当前页的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">PageHelper.startPage(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 开启分页功能</span><br>List&lt;User&gt; userList = userMapper.getUserList();<br>userList.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>输出如下，这里设置了开启分页，并设置当前页码（从1开始）以及每页的大小。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">User&#123;<span class="hljs-attribute">id</span>=6, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;<br>User&#123;<span class="hljs-attribute">id</span>=7, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;<br>User&#123;<span class="hljs-attribute">id</span>=8, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;<br>User&#123;<span class="hljs-attribute">id</span>=9, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>上面<code>startPage</code>方法实际上是有一个返回对象的，返回的就是当前页面的信息，我们可以输出其中的内容进行查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Page&lt;Object&gt; page = PageHelper.startPage(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>List&lt;User&gt; userList = userMapper.getUserList();<br>System.out.println(page);<br></code></pre></td></tr></table></figure><p>输出信息如下，可以看到该页面更加详细的信息，包括页码数，单页的项目总数，开始行，结束行，总数，页数等等。中括号<code>[]</code>中保存的正是当前页面中的所有内容。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Page&#123;<span class="hljs-attribute">count</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">pageNum</span>=2, <span class="hljs-attribute">pageSize</span>=4, <span class="hljs-attribute">startRow</span>=4, <span class="hljs-attribute">endRow</span>=8, <span class="hljs-attribute">total</span>=10, <span class="hljs-attribute">pages</span>=3, <span class="hljs-attribute">reasonable</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">pageSizeZero</span>=<span class="hljs-literal">false</span>&#125;<br>[User&#123;<span class="hljs-attribute">id</span>=6, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;, User&#123;<span class="hljs-attribute">id</span>=7, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;, User&#123;<span class="hljs-attribute">id</span>=8, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;, User&#123;<span class="hljs-attribute">id</span>=9, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure><p>我们还可以利用一个PageInfo对象来获取分页相关的其他数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Page&lt;Object&gt; page = PageHelper.startPage(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>List&lt;User&gt; userList = userMapper.getUserList();<br>PageInfo&lt;User&gt; userPageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>&lt;&gt;(userList, <span class="hljs-number">2</span>);<br>System.out.println(userPageInfo);<br></code></pre></td></tr></table></figure><p>在上面我们给定其中导航栏中的页码数，输出内容如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs routeros">PageInfo&#123;<br><span class="hljs-attribute">pageNum</span>=2, <span class="hljs-attribute">pageSize</span>=4, <span class="hljs-attribute">size</span>=4, <span class="hljs-attribute">startRow</span>=5, <span class="hljs-attribute">endRow</span>=8, <span class="hljs-attribute">total</span>=10, <span class="hljs-attribute">pages</span>=3,<br>list=<br>Page&#123;<span class="hljs-attribute">count</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">pageNum</span>=2, <span class="hljs-attribute">pageSize</span>=4, <span class="hljs-attribute">startRow</span>=4, <span class="hljs-attribute">endRow</span>=8, <span class="hljs-attribute">total</span>=10, <span class="hljs-attribute">pages</span>=3, <span class="hljs-attribute">reasonable</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">pageSizeZero</span>=<span class="hljs-literal">false</span>&#125;<br>[User&#123;<span class="hljs-attribute">id</span>=6, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;, <br>User&#123;<span class="hljs-attribute">id</span>=7, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;, <br>User&#123;<span class="hljs-attribute">id</span>=8, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;, <br>User&#123;<span class="hljs-attribute">id</span>=9, <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-attribute">age</span>=0, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">email</span>=<span class="hljs-string">&#x27;null&#x27;</span>&#125;], <br><span class="hljs-attribute">prePage</span>=1, <br><span class="hljs-attribute">nextPage</span>=3, <br><span class="hljs-attribute">isFirstPage</span>=<span class="hljs-literal">false</span>, <br><span class="hljs-attribute">isLastPage</span>=<span class="hljs-literal">false</span>,<br><span class="hljs-attribute">hasPreviousPage</span>=<span class="hljs-literal">true</span>, <br><span class="hljs-attribute">hasNextPage</span>=<span class="hljs-literal">true</span>, <br><span class="hljs-attribute">navigatePages</span>=2, <br><span class="hljs-attribute">navigateFirstPage</span>=1,<br><span class="hljs-attribute">navigateLastPage</span>=2,<br>navigatepageNums=[1, 2]&#125;<br></code></pre></td></tr></table></figure><p>其中包括该页以及导航的更多信息：</p><ul><li><code>pageNum</code>：当前页的页码</li><li><code>pageSize</code>：每页显示的条数</li><li><code>size</code>：当前页显示的真实条数</li><li><code>startRow</code>：开始行</li><li><code>endRow</code>：结束行</li><li><code>total</code>：总记录数</li><li><code>pages</code>：总页数</li><li><code>list</code>：当前页的实际内容</li><li><code>prePage</code>：上一页的页码</li><li><code>nextPage</code>：下一页的页码</li><li><code>isFirstPage</code>：当前页是否为第一页</li><li><code>isLastPage</code>：当前页是否为最后一页</li><li><code>hasPreviousPage</code>：是否有前一页</li><li><code>hasNextPage</code>：是否有下一页</li><li><code>navigatePages</code>：导航分页的页码数</li><li><code>navigateFirstPage</code>：导航分页的首页</li><li><code>navigateLastPage</code>：导航分页的末页</li><li><code>navigatepageNums</code>：导航分页的页码</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis笔记(4)-动态SQL与缓存</title>
    <link href="/2022/10/11/MyBatis%E7%AC%94%E8%AE%B0-4-%E5%8A%A8%E6%80%81SQL%E4%B8%8E%E7%BC%93%E5%AD%98/"/>
    <url>/2022/10/11/MyBatis%E7%AC%94%E8%AE%B0-4-%E5%8A%A8%E6%80%81SQL%E4%B8%8E%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="动态sql">动态SQL</h1><p>在前面，我们学习了MyBatis的获取参数的功能，通过获取参数可以实现SQL的动态变化。在MyBatis中，还提供一种根据特定条件动态拼接SQL语句的功能，利用不同功能的标签，来动态拼接SQL语句。</p><h2 id="if">if</h2><p>if标签中我们可以指定test条件，这是一个条件表达式，如果表达式的结果为true，则会将标签中的内容进行拼接，反之则不会拼接。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpListByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpListByMoreTJ&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>    select * from emp where 1=1<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empId != &#x27;&#x27; and empId != null&quot;</span>&gt;</span><br>        and emp_id = #&#123;empId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != &#x27;&#x27; and empName != null&quot;</span>&gt;</span><br>        and emp_name = #&#123;empName&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意这里的test中，表达式之间的与和或的关系使用<code>and</code>和<code>or</code>来表示</p><blockquote><p>上面的SQL语句拼接，每个条件都有可能不成立，就导致都无法进行拼接。但是where后面一定需要根据</p></blockquote><h2 id="where">where</h2><p>上面的示例中，我们使用<code>where 1=1</code>来避免全部条件不匹配时的SQL语句错误问题，不过在MyBatis中也提供了where标签来实现相应的功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpListByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpListByMoreTJ&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>    select * from emp <br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empId != &#x27;&#x27; and empId != null&quot;</span>&gt;</span><br>            emp_id = #&#123;empId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != &#x27;&#x27; and empName != null&quot;</span>&gt;</span><br>            and emp_name = #&#123;empName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>where标签一般和if标签结合使用，它可以达到以下的效果：</p><ol type="1"><li>如果where标签中的if条件都不满足，则where标签不会添加where关键字</li><li>如果where标签中的if条件满足，则where标签会自动添加where关键字，并且会将条件最前方多余的and去除，但是不能去除条件后方多余的and</li></ol><h2 id="trim">trim</h2><p>前面的where可以用于动态添加where关键字以及去除条件最前面多余的关键字，而trim标签可以提供更多的功能，用于删除或添加内容。</p><p>trim标签的常用属性如下：</p><ul><li><code>prefix</code>：在trim标签包裹内容的前面添加某些内容</li><li><code>prefixOverrides</code>：在trim标签包裹内容的前面删除某些内容</li><li><code>suffix</code>：在trim标签包裹内容的后面添加某些内容</li><li><code>suffixOverrides</code>：在trim标签包裹内容的后面删除某些内容</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpListByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpListByMoreTJ&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>    select * from emp <br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prifix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;and&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empId != &#x27;&#x27; and empId != null&quot;</span>&gt;</span><br>            emp_id = #&#123;empId&#125; and<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != &#x27;&#x27; and empName != null&quot;</span>&gt;</span><br>            emp_name = #&#123;empName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的动态SQL语句，可以自动添加where关键字，并删除最后多余的and关键字。</p><h2 id="choosewhenotherwise">choose，when，otherwise</h2><p>choose、when、otherwise标签三者通常结合使用，表示在多选一的情况。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpListByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpListByMoreTJ&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>    select * from emp <br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empId != &#x27;&#x27; and empId != null&quot;</span>&gt;</span><br>                emp_id = #&#123;empId&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != &#x27;&#x27; and empName != null&quot;</span>&gt;</span><br>                emp_name = #&#123;empName&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span>   <br>            <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>                1 = 1<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="foreach">foreach</h2><p>foreach可以用来进行集合的展开，在批量操作中非常好用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int insertEmps(List&lt;Emp&gt; emps);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmps&quot;</span>&gt;</span><br>    insert into emp values<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        (null,#&#123;emp.empName&#125;,#&#123;emp.deptId&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--int deleteEmpByArray(int[] eids);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteEmpByArray&quot;</span>&gt;</span><br>    delete from emp where<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;eids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>        eid = #&#123;eid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--int deleteEmpByArray(int[] eids);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteEmpByArray&quot;</span>&gt;</span><br>    delete from emp <br>    where emp_id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;eids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;eid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里的分隔符前后会自动添加空格。</p><h2 id="sql片段">sql片段</h2><p>SQL片段对应<code>sql</code>标签，它用来记录一段公共的SQL片段，在需要使用的地方，通过include标签进行引入即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empColumns&quot;</span>&gt;</span><br>    emp_id, emp_name, dept_id<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br>select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;empColumns&quot;</span>/&gt;</span> from emp<br></code></pre></td></tr></table></figure><h1 id="缓存">缓存</h1><p>MyBatis中存在缓存机制，分为一级和二级缓存。同时MyBatis中也提供了整合第三方缓存的功能。</p><h2 id="一级缓存">一级缓存</h2><p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存。下次查询相同的数据，则会直接命中缓存，不需要从数据库重新访问。不过会有一些情况使得一级缓存失效：</p><ol type="1"><li>不同的SqlSession对应不同的一级缓存</li><li>使用了同一个SqlSession，但是查询条件不同，无法命中缓存</li><li>同一个SqlSession的两次查询期间执行了增删改操作，导致缓存与数据库不一致，缓存失效</li><li>同一个SqlSession的两次查询期间手动清空了缓存，调用了SqlSession的<code>clearCache()</code>方法</li></ol><h2 id="二级缓存">二级缓存</h2><p>二级缓存是SqlSessionFactory级别的，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存。</p><p>二级缓存开启的条件如下：</p><ol type="1"><li>在核心配置文件中，设置全局配置属性<code>cacheEnabled</code>为true，当然它的默认值就是true</li><li>在映射文件中设置标签<code>&lt;cache/&gt;</code></li><li>二级缓存在SqlSession关闭或提交后有效，一级缓存对应的SqlSession关闭或提交后，才会存入二级缓存中</li><li>查询的数据所对应的实体类类型必须要实现序列化接口（与后面的只读属性有关）</li></ol><p>如果两次查询之间执行了任意的增删改操作，会使得一级和二级缓存同时失效。在查询的时候，优先查询二级缓存，然后再查询一级缓存，最后查询数据库。</p><p>在映射文件的<code>&lt;cache/&gt;</code>标签中可以设置二级缓存的相关属性：</p><ol type="1"><li><code>eviction</code>：缓存回收策略，可选值如下，默认值为<code>LRU</code><ul><li><code>LRU</code>：最近最少使用策略</li><li><code>FIFO</code>：先进先出策略</li><li><code>SOFT</code>：软引用</li><li><code>WEAK</code>：弱引用</li></ul></li><li><code>flushInterval</code>：表示缓存刷新间隔，单位为ms。默认情况没有设置，表示没有刷新间隔，在调用语句的时候刷新</li><li><code>size</code>：表示引用数目，为正整数。代表缓存最多可以存储对象的个数，如果设置的过大容易导致内存溢出</li><li><code>readOnly</code>：表示是否只读，可选值为<code>true|false</code>，默认值为<code>false</code><ul><li><code>true</code>：只读缓存。在缓存命中的时候会给所有调用者返回缓存对象的相同示例，因此这些对象不能被修改。这种情况下性能更优。</li><li><code>false</code>：读写缓存。在缓存命中的时候返回缓存对象的拷贝，因此需要对象实现序列化。这种情况下的性能差一些，但是更加安全。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis笔记(3)-自定义映射resultMap</title>
    <link href="/2022/10/11/MyBatis%E7%AC%94%E8%AE%B0-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%98%A0%E5%B0%84resultMap/"/>
    <url>/2022/10/11/MyBatis%E7%AC%94%E8%AE%B0-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%98%A0%E5%B0%84resultMap/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>在前面的select标签当中，我们提到一定要指定resultType或者resultMap。前面我们一直使用的都是resultType，接下来就来介绍resultMap的使用。</p><p>无论是resultType还是resultMap，它们完成的工作都是确定如何将查询得到的一行数据与Java中的实体类完成映射。在前面的环境中，我们数据库中的users表有如下的表结构：</p><table><thead><tr class="header"><th>id</th><th>username</th><th>password</th><th>age</th><th>gender</th><th>email</th></tr></thead><tbody></tbody></table><p>而我们的实体类User中的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String email;<br>    <br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 省略了构造方法、get set方法、toString方法等</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到的是，表中的字段和实体类中的属性是可以对应上的。（注意这里关于成员变量以及属性的区分）默认属性名和字段名保持一致的话，可以完成映射，因此我们前面一直使用的都是resultType直接指定实体类。而resultMap为自定义映射，解决的是一些属性和字段没有保持一致，或者一些多对一，一对多的映射情况。接下来就进行相关的说明。</p><p>这里说明后续的数据库环境。在数据库中新建了两张表，分别是员工表以及部门表，其中员工表中的字段dept_id表示员工所处的部门，部门表的主键。</p><p>员工表<code>emp</code>中的字段如下，同时准备了一些测试数据：</p><table><thead><tr class="header"><th>emp_id</th><th>emp_name</th><th>dept_id</th></tr></thead><tbody><tr class="odd"><td>1</td><td>甲</td><td>1</td></tr><tr class="even"><td>2</td><td>乙</td><td>2</td></tr><tr class="odd"><td>3</td><td>丙</td><td>2</td></tr><tr class="even"><td>4</td><td>丁</td><td>1</td></tr></tbody></table><p>部门表<code>dept</code>中的字段如下：</p><table><thead><tr class="header"><th>dept_id</th><th>dept_name</th></tr></thead><tbody><tr class="odd"><td>1</td><td>A</td></tr><tr class="even"><td>2</td><td>B</td></tr></tbody></table><h1 id="resultmap使用">resultMap使用</h1><h2 id="字段和属性映射">字段和属性映射</h2><p>在Java中，我们一般遵循的是驼峰命名法，而在数据库中，我们一般使用下划线。这样就可能出现字段和属性无法对应的问题。</p><p>例如现在我们需要查询员工中的数据，我们准备了一个员工的实体类如下，其中的命名遵循的是驼峰命名法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Emp</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> empId;<br>    <span class="hljs-keyword">private</span> String empName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> deptId;<br>    <br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 省略相关方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们写一个简单的接口，按照员工id来查询该员工的信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Emp getEmpById(@Param(&quot;id&quot;) int empId)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.Emp&quot;</span>&gt;</span><br>    select *<br>    from emp<br>    where emp_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行测试方法，发现输出为null。但是实际上我们能够查询到数据的，这实际上就是因为表中的字段名和实体类的属性名没有对应上，我们查出来的一行，它的字段名是<code>emp_id, emp_name, dept_id</code>，而我们的属性名则是<code>empId, empName, deptId</code>，无法对应，因此查出为null。</p><p>解决这个问题有两种方式，第一种是在核心配置文件中开启下划线到驼峰的转换设置，如下所示，这样就可以开启下划线方式与驼峰方式命名之间的对应，二者能够对应上了，也就可以查出结果来了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二种方式则是使用resultMap。我们在映射文件中先定义一个resultMap，然后在其中指定属性与字段的对应关系，如下所示。最后在select标签中指定使用对应的resultMap，这样也可以查出结果。这种解决方案同样是给出了对应关系，告诉MyBatis该如何完成对应，因此可以查出结果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.syh.bean.Emp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Emp getEmpById(@Param(&quot;id&quot;) int empId)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empMap&quot;</span>&gt;</span><br>    select *<br>    from emp<br>    where emp_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在resultMap标签中，使用了id属性以及type属性：</p><ul><li>id：表示自定义映射的唯一标识</li><li>type：表示查询的数据需要映射到的实体类的类型</li></ul><p>在子标签中，我们使用到了id标签以及result标签，还有property，column属性：</p><ul><li>id 标签：设置主键的对应关系</li><li>result 标签：设置普通字段的映射关系</li><li>property 属性：设置映射关系中实体类的属性名</li><li>column 属性：设置映射关系中表的字段名</li></ul><p>后面我们还会用到association标签以及collection标签，分别解决多对一和一对多的映射关系。</p><h2 id="多对一映射处理">多对一映射处理</h2><p>多对一的关系指的是数据库中表的关系。例如在我们目前的环境中，多个员工对应一个部门，就是一种多对一的关系。我们稍微修改一下实体类的设计，使其能够对应我们的关系。</p><p>修改后的<code>Emp</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Emp</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> empId;<br>    <span class="hljs-keyword">private</span> String empName;<br>    <span class="hljs-keyword">private</span> Dept dept; <span class="hljs-comment">// 一个员工对应一个部门</span><br>    <br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 省略相关方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改后的<code>Dept</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dept</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> deptId;<br>    <span class="hljs-keyword">private</span> String deptName;<br>    <span class="hljs-keyword">private</span> List&lt;Emp&gt; empList; <span class="hljs-comment">// 一个部门对应多个员工</span><br>    <br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 省略相关方法    </span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们目前希望完成的查询同样是查询一个员工的信息，可以写出如下的查询语句（这里开启了全局的下划线转驼峰的设置）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Emp getEmpById(@Param(&quot;id&quot;) int empId)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.Emp&quot;</span>&gt;</span><br>    select *<br>    from emp<br>    left join dept on emp.dept_id = dept.dept_id<br>    where emp.emp_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是经过测试输出后，我们发现输出结果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Emp&#123;<span class="hljs-attribute">empId</span>=1, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;甲&#x27;</span>, <span class="hljs-attribute">dept</span>=<span class="hljs-literal">null</span>&#125;<br></code></pre></td></tr></table></figure><p>其中emp相关的属性确实正确的返回了，但是部门信息没有返回。分析原因，同样是MyBatis无法根据现有的信息找到对应关系，查询结果中的字段分别为<code>emp_id, emp_name, emp.dept_id, dept.dept_id, dept_name</code>，能够对应的字段只有emp_id和emp_name，所以也就只有这两个属性能够对应上。</p><p>解决多对一映射问题的方法有三种，分别是级联方式，association标签以及分步查询，下面分别进行介绍。</p><h3 id="级联方式">级联方式</h3><p>使用级联方式，就是让我们在resultMap中指定相关的对应关系。如果存在类之间的级联，使用<code>.</code>来表示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.syh.bean.Emp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept.deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept.deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Emp getEmpById(@Param(&quot;id&quot;) int empId)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empMap&quot;</span>&gt;</span><br>    select *<br>    from emp<br>    left join dept on emp.dept_id = dept.dept_id<br>    where emp.emp_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>查出结果如下，发现可以查出对应的部门信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Emp&#123;<span class="hljs-attribute">empId</span>=1, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;甲&#x27;</span>, <span class="hljs-attribute">dept</span>=Dept&#123;<span class="hljs-attribute">deptId</span>=1, <span class="hljs-attribute">deptName</span>=<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-attribute">empList</span>=<span class="hljs-literal">null</span>&#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="association">association</h3><p>第二种方式是使用resultMap下的子标签association，在其中指定对应的信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.syh.bean.Emp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.syh.bean.Dept&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Emp getEmpById(@Param(&quot;id&quot;) int empId)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empMap&quot;</span>&gt;</span><br>    select *<br>    from emp<br>    left join dept on emp.dept_id = dept.dept_id<br>    where emp.emp_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>association标签是用来设置多对一的映射关系的，其中的<code>property</code>表示需要映射的实体类中的属性，<code>javaType</code>表示要映射成为哪个类。在association子标签中，同样有id以及result子标签，表示主键以及普通字段。</p><h3 id="分步查询">分步查询</h3><p>分步查询则将这个问题分成两个步骤来进行解决。这个问题可以拆解成两步完成，第一步先查出员工的部门id，第二步则是根据员工所对应的部门id查询部门信息。</p><p>首先第一步，查询员工的信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empMapStep&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.syh.bean.Emp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.syh.mapper.DeptMapper.getDeptById&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Emp getEmpByIdStep(@Param(&quot;id&quot;) int empId)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByIdStep&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empMapStep&quot;</span>&gt;</span><br>    select *<br>    from emp<br>    where emp_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里，association中设置的<code>select</code>表示下一步需要指定的操作，<code>column</code>表示提供给它的参数。这里下一步操作即调用对应的接口，这里的操作应该是根据部门id来查询部门的相关信息，因此接下来就实现第二步操作。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Dept getDeptById(@Param(&quot;id&quot;) int dept_id)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getDeptById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.Dept&quot;</span>&gt;</span><br>    select *<br>    from dept<br>    where dept_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最终查询的输出如下，可以看到是能够正常查询得到结果的，并且是进行了分步的查询：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">39</span>,<span class="hljs-number">378</span> ==&gt;  Preparing: select * from emp where emp_id = ? (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">39</span>,<span class="hljs-number">414</span> ==&gt; Parameters: <span class="hljs-number">1</span>(Integer) (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">39</span>,<span class="hljs-number">441</span> ====&gt;  Preparing: select * from dept where dept_id = ? (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">39</span>,<span class="hljs-number">442</span> ====&gt; Parameters: <span class="hljs-number">1</span>(Integer) (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">39</span>,<span class="hljs-number">444</span> &lt;====      Total: <span class="hljs-number">1</span> (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">39</span>,<span class="hljs-number">446</span> &lt;==      Total: <span class="hljs-number">1</span> (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">Emp</span>&#123;empId=<span class="hljs-number">1</span>, empName=&#x27;甲&#x27;, dept=Dept&#123;deptId=<span class="hljs-number">1</span>, deptName=&#x27;A&#x27;, empList=null&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="一对多映射处理">一对多映射处理</h2><p>上面的情况中，多个员工对应一个部门是多对一的情况，那么反过来就是一对多的情况。反映的需求当中，现在我们希望实现根据部门id来查询部门以及部门中员工的信息。在Dept实体类中，存在一个Emp列表，直接查询是无法得到结果的，因此还是需要使用自定义映射来解决。解决问题的方式有两种，分别是使用collection标签和分步查询。</p><h3 id="collection">collection</h3><p>使用resultMap中的collection标签可以解决一对多映射处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deptMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.syh.bean.Dept&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;com.syh.bean.Emp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Dept getDeptEmpById(@Param(&quot;id&quot;) int dept_id)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getDeptEmpById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;deptMap&quot;</span>&gt;</span><br>    select *<br>    from dept<br>    join emp on dept.dept_id = emp.dept_id<br>    where dept.dept_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在collection标签中，我们需要指定property属性，以及集合中元素的类型<code>ofType</code>，内部子标签id以及result，则同样代表了主键以及普通字段的映射。</p><p>测试输出结果如下，发现可以正常得到结果。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Dept&#123;<span class="hljs-attribute">deptId</span>=1, <span class="hljs-attribute">deptName</span>=<span class="hljs-string">&#x27;A&#x27;</span>, empList=[Emp&#123;<span class="hljs-attribute">empId</span>=1, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;甲&#x27;</span>, <span class="hljs-attribute">dept</span>=<span class="hljs-literal">null</span>&#125;, Emp&#123;<span class="hljs-attribute">empId</span>=4, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;丁&#x27;</span>, <span class="hljs-attribute">dept</span>=<span class="hljs-literal">null</span>&#125;]&#125;<br></code></pre></td></tr></table></figure><p>其中每个Emp的部门显示为null也是因为我们没有在collection中指定对应关系。</p><h3 id="分步查询-1">分步查询</h3><p>第二种方式是分步查询。这个问题也可以拆分成两个步骤，第一步查询出部门的相关信息，得到部门id；第二步根据部门id来查询员工信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deptMapStep&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.syh.bean.Dept&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empList&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.syh.mapper.EmpMapper.getEmpByDeptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Dept getDeptEmpByIdStep(@Param(&quot;id&quot;) int dept_id)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getDeptEmpByIdStep&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;deptMapStep&quot;</span>&gt;</span><br>    select *<br>    from dept<br>    where dept_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里在collection标签中，同样需要指定<code>select</code>表示下一步的操作，<code>column</code>表示传递过去的参数。下一步是根据部门id来查询员工信息，则可以用下面的操作来完成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpByDeptId(@Param(&quot;id&quot;) int deptId)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByDeptId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.Emp&quot;</span>&gt;</span><br>    select *<br>    from emp<br>    where dept_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（这里的方法返回类型，定义成<code>List&lt;Emp&gt;</code>还是<code>Emp</code>，都能够得到正确的结果，不过按照场景，定义成列表更加符合逻辑）</p><p>之后进行测试，可以得到下面的输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">22</span>:<span class="hljs-number">01</span>,<span class="hljs-number">439</span> ==&gt;  Preparing: select * from dept where dept_id = ? (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">22</span>:<span class="hljs-number">01</span>,<span class="hljs-number">474</span> ==&gt; Parameters: <span class="hljs-number">1</span>(Integer) (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">22</span>:<span class="hljs-number">01</span>,<span class="hljs-number">498</span> ====&gt;  Preparing: select * from emp where dept_id = ? (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">22</span>:<span class="hljs-number">01</span>,<span class="hljs-number">499</span> ====&gt; Parameters: <span class="hljs-number">1</span>(Integer) (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">22</span>:<span class="hljs-number">01</span>,<span class="hljs-number">502</span> &lt;====      Total: <span class="hljs-number">2</span> (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">22</span>:<span class="hljs-number">01</span>,<span class="hljs-number">504</span> &lt;==      Total: <span class="hljs-number">1</span> (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">Dept</span>&#123;deptId=<span class="hljs-number">1</span>, deptName=&#x27;A&#x27;, empList=[Emp&#123;empId=<span class="hljs-number">1</span>, empName=&#x27;甲&#x27;, dept=null&#125;, Emp&#123;empId=<span class="hljs-number">4</span>, empName=&#x27;丁&#x27;, dept=null&#125;]&#125;<br></code></pre></td></tr></table></figure><p>可以发现确实查询到了正确的结果，并且使用了分步查询。</p><h2 id="延迟加载">延迟加载</h2><p>在多对一和一对多的映射处理中，我们都使用到了分步查询来解决。分步查询的优点在于可以实现延迟加载。延迟加载指的是可以完成按需加载，当前获取的数据是什么，就执行相应的SQL，而不需要全部执行。</p><p>开启延迟加载需要在核心配置文件中开启全局配置信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;aggressiveLazyLoading&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>lazyLoadingEnabled</code>：延迟加载的全局配置。当设置为true时，所有的关联对象都会延迟加载</li><li><code>aggressiveLazyLoading</code>：加载属性的策略。当设置为true的时候，任何方法的调用都会加载该对象的所有属性。否则按需加载。默认值为<code>false</code></li></ul><p>如果测试代码中，我们只访问部门的id，而不需要访问部门的员工列表，则它会进行按需加载。测试代码和输出分别如下，可以看到其中只访问了部门的id，只执行了第一步的SQL语句。</p><p>关键测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DeptMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(DeptMapper.class);<br><span class="hljs-type">Dept</span> <span class="hljs-variable">deptEmpById</span> <span class="hljs-operator">=</span> mapper.getDeptEmpByIdStep(<span class="hljs-number">1</span>);<br>System.out.println(deptEmpById.getDeptName());<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">25</span>,<span class="hljs-number">743</span> ==&gt;  Preparing: select * from dept where dept_id = ? (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">25</span>,<span class="hljs-number">772</span> ==&gt; Parameters: <span class="hljs-number">1</span>(Integer) (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">25</span>,<span class="hljs-number">841</span> &lt;==      Total: <span class="hljs-number">1</span> (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">A</span><br></code></pre></td></tr></table></figure><p>上面的配置是全局配置信息，对全局生效。实际上每个collection或者association标签也有自己的按需加载的开关，即标签中的<code>fetchType</code>属性。该属性可选的取值有两种，分别是<code>lazy</code>延迟加载，以及<code>eager</code>立即加载，默认取值为<code>lazy</code>。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis笔记(2)-参数获取以及使用举例</title>
    <link href="/2022/10/11/MyBatis%E7%AC%94%E8%AE%B0-2-%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B/"/>
    <url>/2022/10/11/MyBatis%E7%AC%94%E8%AE%B0-2-%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="参数值获取">参数值获取</h1><p>在之前的SQL书写中，我们都是直接将SQL写死在映射文件中，但是实际应用中，我们的SQL是动态变化的，体现在我们可能需要获取一些相关参数，然后拼接在SQL中。MyBatis也给我们提供了参数值获取的方式。</p><p>在MyBatis中，参数值获取的方式分为两种，<code>$&#123;&#125;</code>以及<code>#&#123;&#125;</code></p><ul><li><code>$&#123;&#125;</code>：使用字符串拼接的方式拼接SQL，如果使用字符串类型或者日期类型字段，则需要手动增加单引号</li><li><code>#&#123;&#125;</code>：使用占位符赋值的方式拼接SQL，如果使用字符串类型或者日期类型字段，则会自动添加单引号</li></ul><p>根据参数类型和个数的不同，我们访问参数的方式也不同，下面分别进行说明。</p><h2 id="单个参数访问">单个参数访问</h2><p>如果Mapper接口中的方法传入的是单个字面量类型，则可以直接使用<code>$&#123;&#125;</code>或者<code>#&#123;&#125;</code>进行访问，括号中写任何内容都是可以访问到的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- User getUserByName(String name)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>    select *<br>    from users<br>    where username = #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="多个参数访问">多个参数访问</h2><p>如果Mapper接口中的方法传入的是多个字面量类型，则MyBatis会以两种方式进行管理，具体来说，是将这些参数按照顺序保存在Map中。</p><ul><li>第一种方式中Map的Key为arg0、arg1、...；Value为对应位置的参数</li><li>第二种方式中Map的Key为param1、param2、...；Value为对应位置的参数</li></ul><p>在访问对应参数的使用，我们在括号中可以通过Key来访问到对应的参数。使用第一种方式的<code>arg0,arg1</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserByAgeAndGender(int age, char gender)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByAgeAndGender&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>    select *<br>    from users<br>    where age = #&#123;arg0&#125;<br>    and gender = #&#123;arg1&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者使用第二种方式的<code>param1,param2</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserByAgeAndGender(int age, char gender)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByAgeAndGender&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>    select *<br>    from users<br>    where age = #&#123;param1&#125;<br>    and gender = #&#123;param2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>两种Key可以进行混用，但是并不推荐这种方式，容易混淆。</p><p>上面的方式是由MyBatis将多个参数保存成了一个Map，实际上我们要传入多个参数的时候，也可以自己将其包装成一个Map，之后只需要访问Map的Key就可以获取到相对应的值。</p><p>在映射文件中的定义如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserByMapInfo(Map&lt;String, Object&gt; info)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByMapInfo&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>    select *<br>    from users<br>    where username = #&#123;username&#125;<br>    and age = #&#123;age&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.getUserByMapInfo(map);<br></code></pre></td></tr></table></figure><h2 id="实体类访问">实体类访问</h2><p>如果Mapper接口中的方法参数为一个实体类对象的时候，我们可以通过访问属性名来访问对应的成员变量值，然后进行拼接。</p><blockquote><p>注意这里属性和成员变量的区别：</p><ul><li>成员变量与定义有关，是我们直接写在类内部的</li><li>属性则与get和set方法有关，将方法中的get和set去除，并将首字母小写得到的就是属性名</li></ul><p>如果按照规范为每个成员变量设置get和set方法，那么属性名和成员变量的名称应该是对应相同的。</p></blockquote><p>这里的User实体类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String email;<br>    <br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 省略了构造方法、get set方法、toString方法等</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在映射文件中定义如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserByUser(User user)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>    select *<br>    from users<br>    where username = #&#123;username&#125;<br>    and password = #&#123;password&#125;<br>    and age = #&#123;age&#125;<br>    and gender = #&#123;gender&#125;<br>    and email = #&#123;email&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="使用param表示参数">使用@Param表示参数</h2><p>还有一种方式是我们可以通过注解的方式来表示Mapper中的方法接口，在注解中指定我们希望它的访问方式，后续在SQL中我们就能够通过对应的方式来访问参数了。</p><p>在接口中我们定义如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">getUserByIdAndName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user_id&quot;)</span> <span class="hljs-type">int</span> id,<span class="hljs-meta">@Param(&quot;user_name&quot;)</span> String username)</span>;<br></code></pre></td></tr></table></figure><p>在映射文件中，我们可以通过<code>user_id</code>和<code>user_name</code>来访问对应的内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserByIdAndName(@Param(&quot;user_id&quot;) int id,@Param(&quot;user_name&quot;) String username);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByIdAndName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>    select *<br>    from users<br>    where id = #&#123;user_id&#125;<br>    and username = #&#123;user_name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>在这种情况下，MyBatis也是使用了两种方式来保存参数：</p><ul><li>第一种方式中Map的Key为我们设置的参数；Value为对应位置的参数</li><li>第二种方式中Map的Key为param1、param2、...；Value为对应位置的参数</li></ul></blockquote><p>最终我们推荐都是使用@Param来表示参数，这样也无需考虑多种情况的不同，都使用统一的方式进行访问。</p><h1 id="查询功能举例">查询功能举例</h1><p>下面我们可以利用参数值获取功能来完成一些查询功能：</p><h2 id="查询一个实体类对象">查询一个实体类对象</h2><p>根据用户名称查询用户信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- User getUserByName(String name)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>    select *<br>    from users<br>    where username = #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="查询一个list集合">查询一个List集合</h2><p>查询用户信息成为一个List集合：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- List&lt;User&gt; getUserList()--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>    select *<br>    from users<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="查询单个数据">查询单个数据</h2><p>查询单个数据指的是查询得到一个int值或者其他字面量，例如这里查询用户的总数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int getSumOfUsers()--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getSumOfUsers&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    select count(*)<br>    from users<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面需要设置返回类型，我们可以写全类名<code>java.lang.Integer</code>，但是在MyBatis中提供了相应的类型别名，例如<code>java.lang.Integer</code>的别名为<code>int</code>或者<code>integer</code>，<code>int</code>的别名为<code>_int</code>或者<code>_integer</code>，<code>Map</code>的别名为<code>map</code>，<code>List</code>的别名为<code>list</code>。注意这里设置的是别名，别名是不区分大小写的。</p><p>相关的别名参数可以在官方文档中查询得到<ahref="https://mybatis.net.cn/configuration.html#typeAliases">配置_MyBatis|类型别名</a></p><h2 id="查询单个记录为map">查询单个记录为Map</h2><p>我们也可以将一条记录查询成为Map类型，对应Map的Key就是表格中的字段名，Value就是对应的值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserToMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    select *<br>    from users<br>    where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>指的注意的是，这里查询出的结果中，如果有字段的值为null，是不会保存到结果Map中的，但是如果是查询单个记录为实体类，那么对应的值上是会保存null的。</p><h2 id="查询多条记录为map">查询多条记录为Map</h2><p>查询多条记录为Map有两种方式。</p><p>第一种方式是将每一条记录都查询成一个Map，然后将多个Map放入List队列中。如下面所示，注意接口的返回值类型以及标签中的<code>resultType</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Map&lt;String, Object&gt;&gt; getUsersToMap()--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUsersToMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    select *<br>    from users<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二种方式是返回一个Map，Map的Value又是一个Map。这种情况下则需要设置这个大Map的Key是什么，这也就是下面注解<code>@MapKey</code>的作用，其中的值为表中的字段名。同样注意下面的接口返回值类型以及标签中的<code>resultType</code>：</p><p>接口方法说明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapKey(&quot;id&quot;)</span><br>Map&lt;String, Object&gt; <span class="hljs-title function_">getAllUserToMap</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>映射文件中的语句如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap()--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUserToMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    select *<br>    from users<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>查询结果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&#123;<br>2=&#123;<span class="hljs-attribute">password</span>=123456, <span class="hljs-attribute">gender</span>=男, <span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">age</span>=23, <span class="hljs-attribute">email</span>=654321@haha.com, <span class="hljs-attribute">username</span>=root&#125;,<br>3=&#123;<span class="hljs-attribute">password</span>=normal, <span class="hljs-attribute">gender</span>=男, <span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">age</span>=2, <span class="hljs-attribute">email</span>=333333@haha.com, <span class="hljs-attribute">username</span>=normal&#125;,<br>4=&#123;<span class="hljs-attribute">password</span>=123123, <span class="hljs-attribute">gender</span>=女, <span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">age</span>=18, <span class="hljs-attribute">email</span>=123456@haha.com, <span class="hljs-attribute">username</span>=admin&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="特殊sql">特殊SQL</h1><p>上面的SQL中，我们获取参数使用的都是<code>#&#123;&#125;</code>，采用占位符的方式拼接。我们大多数情况使用的的确是这种方式，但是也有一些情况下我们需要使用字符串拼接的操作，或者其他的特殊操作，下面就进行相关说明。</p><blockquote><p>主要需要注意的问题就是<code>#&#123;&#125;</code>使用占位符，如果传入字符串的话会自动添加引号，而<code>$&#123;&#125;</code>直接使用字符串拼接，不会进行引号的添加。在使用过程中，注意这点就可以解决很多问题</p></blockquote><h2 id="模糊查询">模糊查询</h2><p>下面我们要完成一个模糊查询的功能，查找用户名中含有对应字符的用户。由于我们需要使用到<code>%,_</code>等占位符，因此在SQL查询语句中要直接写字符串，但是考虑到<code>#&#123;&#125;</code>的方式会增加引号，因此不能直接使用，不过我们可以通过其他方式进行完成，如下所示：</p><p>使用字符拼接：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getUsersLike(@Param(&quot;likeStr&quot;) String likeStr)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUsersLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>    select *<br>    from users<br>    where username like &#x27;%$&#123;likeStr&#125;%&#x27;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当然还有其他方式也能够完成对应操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">select * from users<br>where username like concat(&#x27;%&#x27;, #&#123;likeStr&#125;, &#x27;%&#x27;)<br>// 或者<br>select * from users<br>where username like &quot;%&quot;#&#123;likeStr&#125;&quot;%&quot;<br></code></pre></td></tr></table></figure><h2 id="批量删除">批量删除</h2><p>在批量删除功能中，我们可以传入一个以逗号<code>,</code>分隔的id列表，然后直接拼接到括号当中，使用<code>$&#123;&#125;</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int deleteBatch(@Param(&quot;ids&quot;) String ids)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteBatch&quot;</span>&gt;</span><br>    delete from users where id in ($&#123;ids&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里不能使用占位符，因为占位符会自动添加引号，导致格式错误。</p><h2 id="动态设置表名称">动态设置表名称</h2><p>动态设置表名称表示我们需要传入需要查询的表名称，这部分也是只能使用字符串拼接来完成的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getAllUserFrom(@Param(&quot;tableName&quot;) String tableName)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUserFrom&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>    select * from $&#123;tableName&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="获取自增主键">获取自增主键</h2><p>获取自增主键描述的是下面的功能。假如我们向表中添加了一个User，其中的id列是被设置为自增主键。在添加完成之后，我们希望能够获得刚刚添加的这个User对应的自增主键的值。</p><p>在MyBatis中为我们提供了相应的功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int insertUserAndGetId(@Param(&quot;user&quot;) User user)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUserAndGetId&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    insert into users<br>    values (null, #&#123;user.username&#125;, #&#123;user.password&#125;, #&#123;user.age&#125;, #&#123;user.gender&#125;, #&#123;user.email&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，我们需要在标签中增加<code>useGeneratedKeys</code>以及<code>keyProperty</code></p><ul><li><code>useGeneratedKeys</code>：是否使用自增的主键</li><li><code>keyProperty</code>：需要将自增主键的值设置到User对象的哪个属性</li></ul><p>由于insert语句的返回值只能是受影响的行数，所以只能通过其他的方式来得到自增主键值。MyBatis会将当前插入行对应的自增主键设置到我们的实体类中，设置的属性则由<code>keyProperty</code>来指定。像上面的例子，在插入这条记录之后，对应的自增主键的值会被设置到User类中的id上。</p><p>我们可以进行测试，关键测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">36</span>, <span class="hljs-string">&quot;女&quot;</span>, <span class="hljs-string">&quot;test@haha.com&quot;</span>);<br>userMapper.insertUserAndGetId(user);<br>System.out.println(user.getId());<br></code></pre></td></tr></table></figure><p>输出结果如下，可以看到我们现在获取user的id属性，它已经被设置为自增的主键值了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">16</span>:<span class="hljs-number">18</span>:<span class="hljs-number">39</span>,<span class="hljs-number">173</span> ==&gt;  Preparing: insert into users values (null, ?, ?, ?, ?, ?) (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">16</span>:<span class="hljs-number">18</span>:<span class="hljs-number">39</span>,<span class="hljs-number">204</span> ==&gt; Parameters: test(String), test(String), <span class="hljs-number">36</span>(Integer), 女(String), test@haha.com(String) (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">DEBUG</span> <span class="hljs-number">10</span>-<span class="hljs-number">11</span> <span class="hljs-number">16</span>:<span class="hljs-number">18</span>:<span class="hljs-number">39</span>,<span class="hljs-number">220</span> &lt;==    Updates: <span class="hljs-number">1</span> (BaseJdbcLogger.java:<span class="hljs-number">137</span>) <br><span class="hljs-attribute">5</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis笔记(1)-MyBatis快速开始</title>
    <link href="/2022/10/09/MyBatis%E7%AC%94%E8%AE%B0-1-MyBatis%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
    <url>/2022/10/09/MyBatis%E7%AC%94%E8%AE%B0-1-MyBatis%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="快速开始">快速开始</h1><h2 id="简介">简介</h2><p>MyBatis最初来源于Apache的开源项目iBatis，后续迁移到Google之后，更名为MyBatis，在后续的包名中，我们还可以看到iBatis的踪迹。</p><p>MyBatis是一个基于Java的持久层框架，它支持定制化SQL，存储过程以及高级映射。它避免了几乎所有的JDBC代码，手动拼接参数，结果集获取等操作，而是使用简单的XML或者注解来对应配置和映射，将接口与Java中的普通Java对象（PlainOld Java Objects）映射成数据库中的记录。</p><p>MyBatis的下载地址在此：<ahref="https://github.com/mybatis/mybatis-3">mybatis/mybatis-3: MyBatisSQL mapper framework for Java (github.com)</a></p><p>持久层技术除了MyBatis还有很多，各个框架各有特点。</p><ul><li>对于JDBC，SQL会夹杂在Java代码中，导致耦合度高，维护不方便，需要频繁修改源代码；并且代码冗长，开发效率低</li><li>对于Hibernate和JPA，它的操作简便，开发效率高，但是程序中无法直接使用复杂的SQL，并且内部自动产生的SQL不容易做特殊优化。这是一个基于全映射的全自动框架，如果一个实体类有大量字段，在进行映射的时候会比较困难，并且其中反射操作太多，会导致数据库性能下降</li><li>对于MyBatis，它是一个轻量级，性能出色的持久层框架，在其中SQL与Java代码分离，分工明确。Java代码专注业务，SQL语句专注数据逻辑。虽然开发效率稍低于Hibernate，但是在接受范围内</li></ul><h2 id="入门案例">入门案例</h2><p>下面我们通过一个入门案例来快速学习MyBatis的使用。其中部分配置文件的内容可以参考：<ahref="https://mybatis.net.cn/getting-started.html">入门_MyBatis中文网</a></p><p>首先我们准备相关的数据库测试环境。这里我们在本地的MySQL数据库中创建一个表格users，其中的字段分别有<code>id</code>、<code>username</code>、<code>password</code>、<code>age</code>、<code>gender</code>、<code>email</code>。</p><p>之后我们来添加相关依赖，除了MyBaits的依赖项，还包括其他一些相关的辅助依赖，需要注意的是这些依赖并不是MyBaits必须的，而是方便我们进行项目的开发。依赖项如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--MyBatis核心--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--Junit测试--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--MySQL驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--log4j日志--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中log4j日志的使用还需要配合配置文件<code>log4j.xml</code>。我们需要将配置文件放在resources目录下，其中的内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">log4j</span>:configuration <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;log4j.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">log4j:configuration</span> <span class="hljs-attr">xmlns:log4j</span>=<span class="hljs-string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Encoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ConversionPattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.ibatis&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;info&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">log4j:configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在实际使用MyBatis之前，我们先简单了解一下它的工作原理。对于持久层，我们希望它能够完成通过Java语言来操作数据库，包括增删该查操作，同时关联Java对象与数据库中的表，同时完成SQL语句的查询。</p><p>在MyBatis中，一个实体类对应一张表，类的属性对应表的不同字段，表中的一行数据对应实体类的对象。我们需要两个重要的配置文件，一个是核心配置文件，用来准备数据库连接环境所需要的相关信息，另一个是映射文件。在MyBatis中，我们期望的操作通过Mapper接口的形式来提供，我们需要创建Mapper接口，在接口中声明我们需要的操作，然后一个Mapper接口对应一个映射文件，在映射文件中，我们会给接口的每一个方法准备对应的SQL语句，这样就实现了SQL语句与Java代码的分离。在Java代码中，MyBatis会为我们的接口生成对应的实现类，在调用接口中的方法时，MyBatis会找到映射文件中对应的SQL语句进行执行，并将结果返回。</p><p>那么我们先创建核心配置文件，在官方文档中提供了如下模板。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们对其进行相应的修改，主要修改驱动类、连接、用户名、密码等。这里映射文件引入路径与实际情况有关。</p><blockquote><p>注意这里的核心配置文件的名称没有强制要求，我们习惯上将其命名为<code>mybaits-config.xml</code>。核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息，存放位置为resources目录。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置链接数据库的环境--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/ssm_data&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123123&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入映射文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>前面我们提到，在MyBatis中，数据库中的一张表会对应一个实体类，同时会对应一个Mapper接口，而一个Mapper接口又会对应一个映射文件，那么接下来我们就要完成这些资源的准备。</p><p>先创建对应的实体类，这里我们的表为user，可以创建一个实体类User，其中的属性就是表中的字段。将实体类中的相关方法都进行实现，包括无参构造，有参构造，属性的getter和setter方法，toString方法等。</p><p>之后创建Mapper接口。在接口中，我们声明的方法后续都可以进行使用。这里我们声明一个insert方法，用于向表格中插入一条记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们需要创建映射文件，映射文件也放在resources目录下。我们同样可以参考官方文档中映射文件的书写方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBlog&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>    select * from Blog where id = #&#123;id&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在映射文件中，我们需要先指定其中的namespace，这表示该映射文件与哪个Mapper接口对应。然后，我们需要指定每个接口方法对应的SQL语句，例如这里的接口中的insertUser方法，它对应的SQL语句如下所示，使用了insert标签进行包裹，并且标签的id属性指定为insertUser。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.syh.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--int insertUser()--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>        insert into users values(null, &#x27;admin&#x27;, &#x27;123123&#x27;, 18, &#x27;女&#x27;, &#x27;123456@haha.com&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>一般情况下，我们将映射文件命名为<code>表所对应的实体类类名+Mapper.xml</code>，表示一个映射文件对应一个实体类，对应一张表的操作。</p><p>MyBatis中可以面向接口操作数据，但是其中要保证两个一致：</p><ol type="1"><li>Mapper接口中的全类名和映射文件的namespace保持一致</li><li>Mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li></ol></blockquote><p>至此，我们就已经做好了准备工作，可以书写方法进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取MyBatis的核心配置文件</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br><span class="hljs-comment">// 创建SqlSessionFactoryBuilder对象</span><br><span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br><span class="hljs-comment">// 获得SqlSessionFactory</span><br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(inputStream);<br><span class="hljs-comment">// 创建SqlSession对象</span><br><span class="hljs-comment">// 如果使用无参构造，则需要进行事务的手动提交和回滚</span><br><span class="hljs-comment">// 如果使用带参构造，给定true则表示自动事务提交</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 通过代理模式创建UserMapper接口的代理实现类对象</span><br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br><span class="hljs-comment">// 调用接口中的方法，这样就可以通过全类名找到映射文件，通过方法名匹配SQL标签，执行标签中的SQL语句</span><br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.insertUser();<br><span class="hljs-comment">// sqlSession.commit();</span><br>System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + result);<br></code></pre></td></tr></table></figure><h2 id="其他操作">其他操作</h2><p>上面我们提供了简单的插入操作，当然我们还可以提供其他简单的增删查改的操作。增加操作的时候，需要在接口中声明对应的方法，同时在映射文件中指定对应的标签以及标签内的SQL语句。</p><p>在接口中分别增加删除操作、修改操作、查询一行以及查询多行的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 增加一条记录</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 删除一条记录</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 更新一条记录</span><br><br>    User <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 查询一条记录</span><br><br>    List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 查询多条记录</span><br>&#125;<br></code></pre></td></tr></table></figure><p>映射文件中需要提供对应的SQL语句，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.syh.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--int insertUser()--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>        insert into users<br>        values (null, &#x27;admin&#x27;, &#x27;123123&#x27;, 18, &#x27;女&#x27;, &#x27;123456@haha.com&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- int deleteUser()--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span>&gt;</span><br>        delete<br>        from users<br>        where id = 1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- int updateUser()--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span>&gt;</span><br>        update users<br>        set password = &#x27;normal&#x27;<br>        where username = &#x27;normal&#x27;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- User getUser()--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>        select *<br>        from users<br>        where id = 3<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- List&lt;User&gt; getUserList()--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><br>        select *<br>        from users<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在查询操作select中，我们需要指定属性resultType或者resultMap，用来设置实体类和数据库表中记录的映射关系。两种映射只能设置其中一种：</p><ul><li><p>resultType：设置结果类型，即处理的数据要转换为的Java类型（一行数据需要转化为的类型）</p></li><li><p>resultMap：自定义映射，处理多对一或一对多的映射关系，或字段名和属性名不一致的情况</p></li></ul><h1 id="核心配置文件">核心配置文件</h1><p>在入门案例中，我们使用的核心配置文件中只有一些最基本的内容，完整的核心配置文件，其中还提供了其他相关的标签，这里进行相关说明。</p><p>在核心配置文件中提供有多种标签，但是这些标签必须按照固定的顺序进行书写，具体顺序如下：<code>properties</code>、<code>settings</code>、<code>typeAliases</code>、<code>typeHandlers</code>、<code>objectFactory</code>、<code>objectWrapperFactory</code>、<code>reflectorFactory</code>、<code>plugins</code>、<code>environments</code>、<code>databaseIdProvider</code>、<code>mappers</code>。这里先介绍一些常见的标签，其他标签后续使用到的时候再进行介绍。</p><h2 id="properties">properties</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>properties</code>标签允许我们引入配置文件。在引入过后，properties文件中的值可以在核心配置文件中进行使用，使用<code>$&#123;key&#125;</code>的方式来访问value。</p><h2 id="typealiases">typeAliases</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;abc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAlias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.syh.bean.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAlias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.syh.bean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>typeAlias</code>标签允许我们设置类型的别名。</p><p>基本的使用方式是在type中提供需要设置别名的类型，同时在alias中提供别名。如果不设置该属性，则该类型会使用默认的别名，即该类型的类名，这里默认的别名就是User，不过类名不区分大小写。</p><p>另一种方式是以包的形式引入别名，在name中提供包的路径。该包下的所有类型都会被设置默认的类型别名，即类名且不区分大小写</p><h2 id="environments">environments</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<code>environments</code>标签中会配置项目的环境，其中可以配置多个环境，但是生效的只会有一个，由default属性来指定。</p><p>具体的环境由标签<code>environment</code>来指定。在该标签中，我们需要设置事务管理方式以及数据源。</p><p>事务管理方式对应标签<code>transactionManager</code>，其中的需要提供type属性。type属性只有两个可选值，分别是JDBC和MANAGED：</p><ul><li>JDBC：表示当前环境中，执行SQL时使用的是JDBC中原生的事务管理方式，事务的提交或者回滚需要手动处理</li><li>MANAGED：表示MyBatis被管理，例如Spring等</li></ul><p>数据源的配置对应标签<code>dataSource</code>，其中需要提供数据源的属性type，可选值有POOLED、UNPOOLED以及JNDI：</p><ul><li>POOLED：表示使用数据库连接池来缓存数据库连接</li><li>UNPOOLED：表示不使用数据库连接池</li><li>JNDI：表示使用上下文中的数据源</li></ul><p>同时数据源中还需要配置连接数据库的驱动、连接地址、用户名和密码等。</p><h2 id="mappers">mappers</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.syh.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>mappers</code>标签中引入对应的映射文件。我们可以通过<code>mapper</code>标签的方式引入单个映射文件，在resource属性中指定对应的路径。另一种方式是以包为单位引入映射文件，使用<code>package</code>标签。引入后，包下所有的映射文件都会被引入，不过使用包引入需要满足下面的要求：</p><ol type="1"><li>Mapper接口所在的包要和映射文件所在的包一致</li><li>Mapper接口要和映射文件的名称一致</li></ol><blockquote><p>所在的包一致，即目录结构相同。在IDEA中，则表现为在resouces目录下创建对应的目录结构来存放映射文件。在项目加载之后，java目录和resources目录下的内容会被放在同一个目录下。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>SSM</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb笔记(8)-Ajax异步技术,FastJson</title>
    <link href="/2022/10/08/JavaWeb%E7%AC%94%E8%AE%B0-8-Ajax%E5%BC%82%E6%AD%A5%E6%8A%80%E6%9C%AF-FastJson/"/>
    <url>/2022/10/08/JavaWeb%E7%AC%94%E8%AE%B0-8-Ajax%E5%BC%82%E6%AD%A5%E6%8A%80%E6%9C%AF-FastJson/</url>
    
    <content type="html"><![CDATA[<h1 id="ajax">Ajax</h1><p>Ajax，全称为Asynchronous JavaScript AndXML，表示的异步的JavaScript和XML。通过Ajax，我们可以从前端给服务器发送请求，服务器将数据直接响应返回给浏览器。并且这种交互是异步的，可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页。</p><p>Ajax的使用大体遵守如下的步骤，这里用一个简单代码块进行展示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建核心对象</span><br><span class="hljs-keyword">var</span> xhttp;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-title class_">XMLHttpRequest</span>()) &#123;<br>    xhttp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>&#125; <span class="hljs-keyword">else</span>&#123;<br>    xhttp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveObject</span>(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 2. 发送请求</span><br>xhttp.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://localhost:8080/xxx&quot;</span>);<br>xhttp.<span class="hljs-title function_">send</span>();<br><br><span class="hljs-comment">// 3. 获取响应</span><br>xhttp.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">responseText</span>)<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>axios对于原生的Ajax进行封装，可以帮助我们简化书写。axios的官方网站为<ahref="https://www.axios-http.cn/">Axios 中文文档 | Axios 中文网</a></p><p>axios的使用如下，首先需要引入相关的js文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后就可以直接书写相关代码了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// get请求</span><br><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">method</span>:<span class="hljs-string">&quot;get&quot;</span>,<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http://localhost:8080/xxx?username=yyy&quot;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resp</span>)&#123;<br>    <span class="hljs-title function_">alert</span>(resp.<span class="hljs-property">data</span>);<br>&#125;)<br><br><span class="hljs-comment">// post请求</span><br><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">method</span>:<span class="hljs-string">&quot;post&quot;</span>,<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http://localhost:8080/xxx&quot;</span>,<br>    <span class="hljs-attr">data</span>:<span class="hljs-string">&quot;username=yyy&quot;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resp</span>)&#123;<br>    <span class="hljs-title function_">alert</span>(resp.<span class="hljs-property">data</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="fastjson">FastJson</h1><p>FastJson是阿里巴巴提供的一个由Java语言编写的高性能，功能完善的Json库，它可以实现Java对象与Json字符串的相互转换。</p><p>使用Fastjson，首先需要进行依赖导入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.62<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后调用其中的方法即可，分为Java对象转成json字符串以及字符串转化成Java对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java对象转化成Json字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">jsonStr</span> <span class="hljs-operator">=</span> JSON.toJSONString(obj);<br><br><span class="hljs-comment">// Json字符串转化成Java对象</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> JSON.parseObject(jsonStr, User.class);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb笔记(7)-Filter与Listener</title>
    <link href="/2022/10/08/JavaWeb%E7%AC%94%E8%AE%B0-7-Filter%E4%B8%8EListener/"/>
    <url>/2022/10/08/JavaWeb%E7%AC%94%E8%AE%B0-7-Filter%E4%B8%8EListener/</url>
    
    <content type="html"><![CDATA[<h1 id="filter">Filter</h1><h2 id="概述">概述</h2><p>Filter，过滤器，或者称为拦截器，它可以将对资源的请求进行拦截，统一处理之后再放行，进行后续的请求。这使得Filter能够完成一些通用的操作，例如权限控制、统一编码处理、敏感字符处理等操作。</p><p>Filter的使用也是接口的实现。首先需要定义类，实现Filter接口，重写其中的方法。其中重要的方法是<code>doFilter</code>，它表示当前过滤器需要执行的逻辑。之后利用注解来配置Filter拦截资源的路径。放行方法为<code>filterChain.doFilter(servletRequest, servletResponse)</code>，如果不执行，则表示当前访问被阻止，无法访问后续资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        System.out.println(<span class="hljs-string">&quot;do filter...&quot;</span>);<br>        filterChain.doFilter(servletRequest, servletResponse); <span class="hljs-comment">// 放行</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Filter的执行流程如下图所示：</p><img src="/2022/10/08/JavaWeb%E7%AC%94%E8%AE%B0-7-Filter%E4%B8%8EListener/Filter%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class="" title="Filter执行流程"><p>浏览器向某个URL发起请求，如果该URL对应的资源上配置了Filter，执行完Filter放行前逻辑后，进行放行，访问对应的资源，之后返回Filter，执行放行后的逻辑，最终得到response的响应。可以将放行操作理解为一个方法调用，调用了后续资源访问的方法。</p><h2 id="使用细节">使用细节</h2><p>在使用Filter的时候，需要配置对应的资源拦截路径，与Servlet的路径设置类似，这里的路径配置也有如下四种方式：</p><ul><li>拦截具体的资源：<code>/index.jsp</code>，访问index.jsp的时候会被拦截</li><li>目录拦截：<code>/user/*</code>，访问/user下的所有资源时会被拦截</li><li>后缀名拦截：<code>*.jsp</code>，访问后缀名为jsp的资源时，会被拦截</li><li>拦截所有：<code>/*</code>，访问所有资源都会被拦截</li></ul><p>我们也可以连续使用多个拦截器，形成Filter的链。既然形成了链，就会有执行顺序的区分。默认情况下，会按照过滤器类名的字符串自然顺序进行排序，决定调用Filter的先后顺序。</p><h1 id="listener">Listener</h1><p>Listener表示监听器，也是JavaWeb的三大组件之一。监听器会监听application、session以及request三个对象的创建、销毁、属性修改动作，在对应动作发生的时候，会触发响应的代码执行。</p><blockquote><p>request、session都可以代表一个域，而application则是ServletContext类型的对象，它代表整个Web应用。在服务器启动的时候，Tomcat会自动创建该对象，在服务器关闭的时候则会自动销毁该对象。</p></blockquote><p>JavaWeb中提供了8个监听器（接口），分别监听不同的层次对象的不同动作，在接口中会提供不同的方法，对应不同的动作。使用后还需要<code>@WebListener</code>进行配置。</p><table><thead><tr class="header"><th>监听器分类</th><th>监听器名称</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>ServletContext监听</td><td>ServletContextListener</td><td>监听ServletContext对象的创建和销毁</td></tr><tr class="even"><td></td><td>ServletContextAttributeListener</td><td>监听ServletContext对象中属性的增删改</td></tr><tr class="odd"><td>Session监听</td><td>HttpSessionListener</td><td>监听Session对象的创建和销毁</td></tr><tr class="even"><td></td><td>HttpSessionAttributeListener</td><td>监听Session对象中属性的增删改</td></tr><tr class="odd"><td></td><td>HttpSessionBindingListener</td><td>监听对象与Session的绑定与解除</td></tr><tr class="even"><td></td><td>HttpSessionActivationListener</td><td>监听Session的激活</td></tr><tr class="odd"><td>Request监听</td><td>ServletRequestListener</td><td>监听Request对象的创建和销毁</td></tr><tr class="even"><td></td><td>ServletRequestAttributeListener</td><td>监听Request对象中属性的增删改</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb笔记(6)-会话技术中的Cookie与Session</title>
    <link href="/2022/10/07/JavaWeb%E7%AC%94%E8%AE%B0-6-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%E4%B8%AD%E7%9A%84Cookie%E4%B8%8ESession/"/>
    <url>/2022/10/07/JavaWeb%E7%AC%94%E8%AE%B0-6-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%E4%B8%AD%E7%9A%84Cookie%E4%B8%8ESession/</url>
    
    <content type="html"><![CDATA[<h1 id="cookie">Cookie</h1><h2 id="基本使用">基本使用</h2><p>Cookie是一种客户端的会话技术，它将数据保存在客户端中，以后的每次请求都会携带Cookie数据进行访问。Cookie可以看成是一个存储信息的集合，其中的信息以键值对形式存放，Cookie存放在浏览器端。对于Cookie的使用，我们主要需要关注的是获取Cookie，获取以及设置Cookie中的内容。</p><ul><li><code>Cookie cookie = new Cookie("key", "value")</code>：创建Cookie对象并设置数据</li><li><code>response.addCookie(cookie);</code>：发送Cookie到客户端，需要使用response对象</li><li><code>Cookie[] cookies = request.getCookies();</code>：获取客户端携带的所有Cookie，需要使用request对象</li><li><code>cookie.getName()</code>：获取cookie的key</li><li><code>cookie.getValue()</code>：获取cookie的value</li><li><code>cookie.setMaxAge(int seconds)</code>：设置cookie的过期时间，如果设置为0，则表示删除对应Cookie</li></ul><blockquote><p>在Cookie中是不能直接存储中文的，如果需要存储中文，则需要进行转码，将中文转码之后进行存储，需要使用的时候再进行转换得到中文结果。例如可以使用URLEncoder进行转码。</p></blockquote><h2 id="原理">原理</h2><p>Cookie的实现原理是基于Http协议的，其中会涉及到协议中两个请求头信息，响应头中的set-cookie以及请求头中的cookie。</p><p>浏览器第一次发送请求到服务器，服务器创建Cookie对象并进行数据设置，返回响应的时候，在响应头的set-cookie进行设置，表示添加的Cookie内容，浏览器接收到响应之后，就会将其中的内容保存到浏览器的Cookie中，后续继续发送请求的时候，会携带浏览器的Cookie，设置在请求头中的cookie字段，服务器通过获取Cookie，就可以维持用户的状态。</p><blockquote><p>在浏览器中查看Cookie的方法：</p><p>第一种方法在浏览器的设置中查看，在Cookie和网站权限中可以查看所有站点的Cookies。</p><p>第二种方法是利用浏览器的控制台程序，选择Application，在其中的Storage模块中，可以查看当前网页存储的Cookies。</p></blockquote><h1 id="session">Session</h1><h2 id="基本使用-1">基本使用</h2><p>Session是一种服务端会话跟踪技术，它选择将数据保存在服务端。相比于Cookie来说，存储在服务端的数据更加安全。</p><p>在JavaEE中提供了HttpSession接口，用来实现一次会话的多次请求之间的数据共享功能，它的主要方法如下：</p><ul><li><code>HttpSession session = request.getSession()</code>：获取Session对象，需要使用到request对象</li><li><code>void setAttribute(String name, Object o)</code>：将值存储到session域中</li><li><code>Object getAttribute(String name)</code>：根据key来获取值</li><li><code>void removeAttribute(String name)</code>：根据key，删除键值对</li><li><code>void invalidate()</code>：销毁该Session</li></ul><h2 id="原理-1">原理</h2><p>Session的底层也是基于Cookie实现的。在浏览器和服务器的一次会话中，使用的是同一个Session，而另一个会话使用的是另一个Session。在服务器第一次获取Session对象的时候，该对象会有一个唯一的标识id，在完成其他动作，返回响应的时候，在响应头中会添加一个set-cookie，其中设置的session的id，这样在浏览器端实际上保存了此次会话中对应的SessionID，后续的所有请求它都会带上这个Cookie，而服务器端也就能够知道这个会话应该使用哪个Session。</p><p>在服务器正常关闭和启动的过程中，Session中的数据是可以被保存下来的。在服务器正常关闭之后，Tomcat会自动将Session中的数据写入磁盘的文件中，再次启动服务器后，则会将对应的数据从文件进行加载。</p><p>在默认情况下，Session会有超时时间，30分钟后自动销毁，具体时间可以Tomcat配置文件中进行设置，当然我们也可以调用Session对象的invalidate方法进行销毁，在前面的操作中也有提到。</p><blockquote><p>Cookie vs Session：Cookie 和Session都能够用来完成一次会话中多次请求之间的数据共享，不过它们在许多方面都有所区别</p><ul><li>在存储位置上：Cookie将数据存储在客户端，Session则将数据存储在服务端</li><li>在安全性上：Cookie不安全，Session安全</li><li>在数据大小上：Cookie最大3kb，而Session无大小限制，但是一般也不应该设置得过大，影响服务器性能</li><li>在服务器性能上：Cookie不会占用服务器资源，而Session会占用服务器资源</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb笔记(5)-MVC模式与三层架构</title>
    <link href="/2022/10/07/JavaWeb%E7%AC%94%E8%AE%B0-5-MVC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/10/07/JavaWeb%E7%AC%94%E8%AE%B0-5-MVC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="mvc模式">MVC模式</h1><p>MVC是一种分层开发的模式，如名字所示，分成了三个部分，分别是M、V和C：</p><ul><li>M：Model，指业务模型，用来处理业务</li><li>V：View，指视图，用来完成界面展示</li><li>C：Controller，指控制器，用来处理请求，分别调用模型和视图</li></ul><img src="/2022/10/07/JavaWeb%E7%AC%94%E8%AE%B0-5-MVC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/MVC%E6%A8%A1%E5%BC%8F.png" class="" title="MVC模式"><p>在MVC模式中，控制器用来接收浏览器发送来的请求，然后调用业务模型来获取数据，例如从数据库查询数据等；控制器获取到数据之后，再交由视图来进行数据展示。</p><h1 id="三层架构">三层架构</h1><p>三层架构则是将我们的项目分成三个层面，分别是表现层、业务逻辑层以及数据访问层：</p><img src="/2022/10/07/JavaWeb%E7%AC%94%E8%AE%B0-5-MVC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" class="" title="三层架构"><ul><li>数据访问层：一般命名为dao或者mapper（dao，data accessobject），用来对数据库进行CRUD的基本操作</li><li>业务逻辑层：一般命名为service，用来对业务逻辑进行封装，组合数据访问层中的基本功能，形成复杂的业务逻辑功能</li><li>表现层：一般命名为controller或者web，用来接收请求，封装数据，并调用业务逻辑层，响应数据。</li></ul><p>浏览器发送请求，由表现层中的控制器进行请求接收，然后调用业务逻辑层的方法进行业务逻辑处理，而业务逻辑层方法会调用数据访问层中的方法进行数据操作，依次返回到表现层。</p><p>MVC模式是一种指导思想，而三层架构是对MVC模式进行实现。我们可以按照三层架构的要求将不同层的代码写在不同的包下，每一层里功能职责单一，提高代码的可读性以及可维护性。</p><blockquote><p>经典的三层架构，也对应到我们后续学习路线中的不同框架，这些框架都是对不同层进行的封装，例如表现层框架SpringMVC、业务逻辑层框架Spring，数据访问层框架MyBatis。</p><p>SSM（SpringMVC+Spring+MyBatis）是目前市场上最流行的开发web项目的框架，它由SpringMVC、Spring、MyBatis整合而成。SpringMVC框架负责接收浏览器发送的请求，并响应浏览器数据；Spring框架使用其核心IOC思想管理服务器中各个组件，使用AOP思想面向切面编程，在不改变源码的基础上实现功能增强；MyBatis框架封装JDBC，负责访问数据库，完成持久化操作。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb笔记(4)-JSP简述</title>
    <link href="/2022/10/07/JavaWeb%E7%AC%94%E8%AE%B0-4-JSP%E7%AE%80%E8%BF%B0/"/>
    <url>/2022/10/07/JavaWeb%E7%AC%94%E8%AE%B0-4-JSP%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="jsp">JSP</h1><h2 id="概述">概述</h2><p>JSP，全称为Java ServerPages，即Java服务端页面。这是一种动态网页技术，在里面我们既可以定义HTML、JS、CSS等静态内容，还可以定义Java代码的动态内容。可以认为JSP= HTML +Java。我们可以认为JSP使得我们可以在代码中定义可以执行的Java代码。</p><p>使用JSP，首先需要导入相关的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在新建的Web项目中，webapp下新建后缀名为<code>.jsp</code>的文件，在其中写入以下代码，其中HTML部分即为正常的HTML代码，而Java部分的代码使用标签<code>&lt;% %&gt;</code>进行包裹。在访问对应链接后，页面上会出现对应内容，在控制台上也会输出对应内容。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;html&gt;<br>    &lt;head&gt;<br>        &lt;title&gt;Title&lt;/title&gt;<br>    &lt;/head&gt;<br>    &lt;body&gt;<br>        &lt;h1&gt;JSP,Hello World&lt;/h1&gt;<br>        &lt;%<br>        System.out.println(<span class="hljs-string">&quot;hello,jsp~&quot;</span>);<br>        %&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="原理">原理</h2><p>在JSP出现之前，我们可以通过Servlet中的response对象获取到输出流对应，然后利用write方法向其中写入html代码，同时结合Java代码处理的逻辑进行数据处理，最后返回相应的结合了数据与页面的html内容。这种方式的缺点非常明显，就是十分不方便。我们需要手动进行html字符串的拼接，书写繁多的write语句，整体的可读性和便利性都不高。</p><p>而JSP技术在此基础上进行改进，JSP本质上还是一个Servlet。浏览器第一次访问jsp页面的时候，Tomcat会将对应的<code>.jsp</code>文件转化为一个Servlet，然后再将这个Servlet编译成对应的字节码文件，执行该字节码文件，向外提供服务。</p><p>这个生成的Servlet类继承了<code>HttpJspBase</code>，间接继承了<code>HttpServlet</code>。生成的Servlet类中，一个重要方法为<code>_jspService()</code>，它就是每次访问jsp的时候自动执行的方式。而在这个方法中，会将我们之前在JSP中书写的html代码都使用<code>out.write()</code>进行写入，而Java代码则原封不动放入。也就是说，JSP自动帮助我们完成了字符串拼接工作，一定程度上提高了便利性。</p><h2 id="jsp脚本">JSP脚本</h2><p>JSP脚本就是我们在JSP页面中定义的Java代码，这些代码需要利用对应的标签进行包裹。之前我们使用的是最普通的标签，<code>&lt;% %&gt;</code>，实际上JSP一共提供了三类脚本标签。</p><p><code>&lt;% ... %&gt;</code>：被该标签包裹的Java代码，会直接原封不动的放入<code>_jspService()</code>方法中。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<br>System.out.println(<span class="hljs-string">&quot;jsp...&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>%&gt;<br></code></pre></td></tr></table></figure><p><code>&lt;%= ... %&gt;</code>：被该标签包裹的内容，会被放入<code>out.print()</code>方法中，作为参数传入，一般可以用来进行数据的展示。例如下面的代码，假设局部变量str的值为"Hello"，则最终会在页面中展示一个被<code>&lt;h1&gt;</code>包裹的Hello。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;h1&gt;&lt;%=str%&gt;&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p><code>&lt;%! ... %&gt;</code>：被该标签包裹的内容，会被放在<code>_jspService()</code>方法之外，被类直接包含，作为类的成员变量或者是成员方法。</p><h2 id="缺点">缺点</h2><p>JSP虽然一定程度上解决了直接使用Servlet返回html代码的复杂性问题，但是它自己也有不少的缺点：</p><ol type="1"><li>书写起来虽然不用大量的write，但是Java代码与HTML结合的方式书写起来也比较复杂</li><li>JSP中的Java代码需要使用标签进行包裹，并且一个代码块还可以继续进行拆分，可读性也并不是很高</li><li>复杂度较高：JSP的运行需要依赖于各种环境，包括JRE、JSP容器、JavaEE等等</li><li>对内存和磁盘的占用率高，JSP会自动生成<code>.java</code>和<code>.class</code>文件，对内存和磁盘进行占用</li></ol><p>由于JSP的种种缺点，它已经渐渐地退出了历史舞台，后续的开发使用的更多是前后端分离的方式，使用HTML+Ajax来进行替代。JSP更多的是技术发展过程中出现的产物。</p><p>首先第一阶段，我们直接使用Servlet进行代码编写，既编写Java业务逻辑代码，又使用write进行html代码拼接。</p><p>到了第二阶段，随着技术的发展出现了JSP，JSP帮助我们简化了html代码的拼接，但是由于需要在JSP中嵌套Java代码，可读性和可维护性等还是有所欠缺。</p><p>第三阶段，则是结合使用Servlet和JSP，两者各有分工，Servlet只用来进行逻辑处理和数据封装，而JSP用来获取数据和进行数据展示，而为了提高可维护性，不直接在JSP中写Java代码，使用EL表达式或者JSTL标签来进行简化。这一阶段，我们的做法是在Servlet中将请求转发到JSP中进行显示后，将页面返回。</p><p>到了第四阶段，则已经放弃了JSP，使用Servlet来进行后端逻辑代码开发，使用HTML进行数据展示。这种模式下，需要我们能够进行动态数据展示，则需要ajax技术的参与。这部分的内容会在后续进行说明。</p><blockquote><p>EL表达式与JSTL标签：</p><p>EL表达式，全称为ExpressionLanguage，可以用来简化JSP页面内的Java代码。它的主要作用是获取数据，从域对象中获取数据，然后将数据展示在页面上，语法即为<code>$&#123;expression&#125;</code>，获取域中存储的对应内容。</p><p>JSTL标签，全称为Jsp Standarded TagLibray，也可以用来简化JSP页面中的Java代码，具体来说是使用标签进行取代。常见的标签有<code>&lt;c:if&gt;</code>、<code>&lt;c:forEach&gt;</code>等</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb笔记(3)-Servlet的介绍与使用</title>
    <link href="/2022/10/06/JavaWeb%E7%AC%94%E8%AE%B0-3-Servlet%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/06/JavaWeb%E7%AC%94%E8%AE%B0-3-Servlet%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="servlet">Servlet</h1><h2 id="简介">简介</h2><p>前面我们看到的页面都是静态的，任何用户访问到的内容都是相同的，但是实际场景中更多的动态的内容。而Servlet则是JavaWeb中最为核心的内容，它是Java提供的一门动态web资源开发技术。使用Servlet就可以完成动态的效果。</p><p>Servlet是JavaEE规范之一，也就是一个接口。我们使用Servlet，就是需要定义类来实现Servlet接口，并由Web服务器来运行Servlet。下面我们通过一个案例来快速入门Servlet。</p><p>首先，我们需要创建Maven Web项目，在项目中导入Servlet依赖api：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后，我们新建一个类，实现Servlet接口，并实现接口中的所有方法。其中，运行的核心方法是service方法。之后在类上使用注解来指定对应访问URL，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletHelloWorld</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;Servlet Hello World~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们就可以启动Tomcat服务，通过浏览器访问对应的路径<code>http://localhost:8080/LearningWeb_war/hello</code>，发现在IDEA控制台上输出了对应的内容，"ServletHello World~"。</p><p>通过上面的小案例，我们可以对Servlet的执行流程进行一个学习。</p><p>首先浏览器发出<code>http://localhost:8080/LearningWeb_war/hello</code>的请求，从请求中可以解析出三部分内容，分别是：</p><ul><li><code>localhost:8080</code>：找到对应的服务器应用</li><li><code>LearningWeb_war</code>：找到Tomcat上对应的项目</li><li><code>hello</code>：找到需要访问的项目中对应的Servlet类</li></ul><p>找到对应的类之后，Tomcat服务器就会为这个类创建一个实例对象，然后调用对象中的service方法。service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互。</p><h2 id="生命周期与方法介绍">生命周期与方法介绍</h2><p>对象的生命周期指的是一个对象从被创建到被销毁的整个过程。Servlet运行在Tomact服务器中，它的对象生命周期主要分为四个阶段：加载和实例化、初始化、请求处理、服务终止。</p><ol type="1"><li>加载和实例化：默认情况下，当Servlet对象被第一次访问的时候，由容器来创建Servlet对象</li><li>初始化：在Servlet实例化之后，容器调用它的<code>init()</code>方法来进行对象的初始化，完成一些相关工作，如加载配置文件、创建连接等。该方法只会调用一次</li><li>请求处理：每次请求Servlet的时候，容器都会调用该对象的<code>service()</code>方法，对请求进行处理</li><li>服务终止：当需要释放内存或者关闭容器，容器就会调用Servlet实例的<code>destroy()</code>方法完成资源的释放。调用之后，容器释放Servlet实例，由Java的垃圾回收器进行回收</li></ol><blockquote><p>默认情况下，Servlet对象会在第一次访问的时候被容器创建。不过有时候一些Servlet的创建比较耗时，我们可以将创建过程提前到服务器启动的时候，配置方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/hello&quot;, loadOnStartup = 1)</span><br></code></pre></td></tr></table></figure><p>在注解中增加参数<code>loadOnStratup</code>，它的取值有下面两种情况：</p><ul><li>负整数：表示第一次访问时创建Servlet对象</li><li>0或者正整数：服务器启动的时候创建Servlet对象，数字越小优先级越高</li></ul></blockquote><p>在Servlet的生命周期中，涉及到了Servlet接口中的init、service、destroy方法，而接口中需要实现的一共有五个方法，这里一并进行说明：</p><ul><li><code>void init(ServletConfig config)</code>：初始化方法，在Servlet被创建的时候执行，只会执行一次</li><li><code>void service(ServletRequest req, ServletResponse res)</code>：提供服务方法，每次Servlet被访问，都会调用该方法</li><li><code>void destroy()</code>：在Servlet被销毁的时候执行该方法，完成一些资源释放的工作</li><li><code>String getServletInfo()</code>：用来返回Servlet的相关信息，返回一个String字符串</li><li><code>ServletConfig getServletConfig()</code>：用来返回ServletConfig对象</li></ul><h2 id="servlet继承体系与httpservlet">Servlet继承体系与HttpServlet</h2><p>上面的Servlet类的实现，都是通过实现Servlet接口来完成的，我们需要实现接口中的五个方法，虽然能够完成要求，但是编写起来还是比较繁琐。在实际项目中，我们集中关注的更多是service方法，因此可以使用更加简单的方式来进行Servlet对象的完成。</p><p>在Servlet继承体系中，Servlet是顶层的根接口，GenericServlet实现了Servlet，是它的抽象实现类，而HttpServlet又继承了GenericServlet，是一种对HTTP协议封装的Servlet实现类。由于我们对Web进行开发，都是针对HTTP协议的，因此我们可以通过继承<code>HttpServlet</code>来更加方便的实现相关类的编写。我们需要做的就是继承HttpServlet，覆盖其中相应的方法即可，常用的方法是<code>doGet</code>方法以及<code>doPost</code>方法，分别处理不同的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/httpdemo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServletDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;get...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;post...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后可以访问<code>localhost:8080/LearningWeb_war/httpdemo</code>，这是get请求，也可以使用网页中使用下面的表单进行post请求，表单部分内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;httpdemo&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>这里的action可以写<code>httpdemo</code>，也可以写全，为<code>/LearningWeb_war/httpdemo</code></li></ul><h2 id="urlpatterns配置">urlPatterns配置</h2><p>前面我们一直在使用<code>WebServlet</code>注解来配置我们的Servlet类，其中一个非常重要的参数就是<code>urlPatterns</code>，它决定了通过何种URL能够访问到对应的Servlet类。一个Servlet可以配置多个urlPattern，它以字符串数组的形式传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPattern = &#123;&quot;/demo1&quot;, &quot;/demo2&quot;&#125;)</span><br></code></pre></td></tr></table></figure><p>urlPatterns配置规则主要分为四种，分别是精确匹配、目录匹配、拓展名匹配以及任意匹配</p><p>精确匹配：直接在urlPattern中写好唯一的URL，对应访问路径。</p><p>目录匹配：针对目录的访问都可以访问到该Servlet。例如下面的路径，只要是针对user目录的访问都可以访问到该Servlet，例如<code>/user/aaa</code>，<code>/user/bbb</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPattern = &quot;/user/*&quot;)</span><br></code></pre></td></tr></table></figure><p>扩展名匹配：利用扩展名来匹配。注意这里不能以<code>/</code>开头。下面的路径，只要是最后扩展名为<code>.me</code>的访问都可以访问到该Servle，例如<code>/aa.me</code>，<code>/bb.me</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPattern = &quot;*.me&quot;)</span><br></code></pre></td></tr></table></figure><p>任意匹配：任意的访问都可以匹配。主要方式有如下两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPattern = &quot;/&quot;)</span><br><span class="hljs-meta">@WebServlet(urlPattern = &quot;/*&quot;)</span><br></code></pre></td></tr></table></figure><p>这里需要注意<code>/</code>与<code>/*</code>的区别：</p><ol type="1"><li>当我们的项目中有Servlet配置了<code>/</code>，它会覆盖掉Tomcat中的DefalutServlet，当其他的urlPattern都匹配不上，就会匹配这个Servlet</li><li>Tomcat的DefalutServlet是用来处理静态资源的。如果我们配置了<code>/</code>，它会把默认的DefalutServlet覆盖掉，这样就在请求静态资源的时候就没有走Tomcat默认的Servlet，而是走了我们自定义的Servlet，最终就会导致静态资源无法访问</li><li>当我们的项目中有Servlet配置了<code>/*</code>，它表示匹配任意访问路径</li></ol><p>urlPattern在匹配的时候有优先级之分，越精确的匹配优先级越高，大体优先级如下：精确匹配&gt; 目录匹配 &gt; 扩展名匹配 &gt; <code>/*</code> &gt;<code>/</code></p><blockquote><ul><li>补充：XML配置Servlet</li></ul><p>上面我们都是使用注解的方式来配置Servlet，但是这是从Servlet3.0版本之后才支持的，在此之前Servlet的配置只支持XML方式。</p><p>利用XML配置Servlet分为两步，第一步是正常编写Servlet类，当然这里不需要无法进行注解配置，第二步是在<code>web.xml</code>中配置该Servlet，配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Servlet 全类名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- servlet的名称，名字任意--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--servlet的类全名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.web.test.MyHttpServletDemo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Servlet 访问路径 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- servlet的名称，要和上面的名称一致--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- servlet的访问路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/test<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><hr /><p>在前面的service方法中，参数列表还提供了两个参数，分别是ServletRequest对象以及ServletResponse对象，分别对应请求对象以及响应对象，这两个对象分别可以实现对浏览器响应的以及回复的处理，接下来就来进行相关的介绍。</p><h1 id="request">Request</h1><h2 id="简介-1">简介</h2><p>Request允许我们获取请求数据。浏览器发送的HTTP请求到达后台服务器Tomcat，Tomcat则会将请求中的数据进行解析，包括请求行、请求头和请求体。解析的结果存入一个对象中，即Requset对象，而我们就可以从Request对象中获取请求的相关参数。</p><p>Requset的继承体系如下，其中我们需要重点关注也是平常使用最多的是其中的HttpServletRequest接口。</p><img src="/2022/10/06/JavaWeb%E7%AC%94%E8%AE%B0-3-Servlet%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/Request%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" class="" title="Request继承体系"><h2 id="请求解析">请求解析</h2><p>根据HTTP协议，请求数据总共分为三个部分，分别是请求行，请求头和请求体。对于这三部分的内容，HttpRequest中都提供了相关的方法来进行获取。</p><p>请求行数据获取：请求行包含三个内容，分别是请求方式、请求资源路径、HTTP协议以及版本，相关的API如下：（举例：<code>get http://localhost:8080/LearningWeb_war/httpdemo</code>）</p><ul><li><code>String getMethod()</code>：获取请求方式（<code>GET</code>）</li><li><code>String getContextPath()</code>：获取虚拟目录，即项目访问路径（<code>/LearningWeb_war</code>）</li><li><code>StringBuffer getRequestURL()</code>：获取URL，即统一资源定位符（<code>http://localhost:8080/LearningWeb_war/httpdemo</code>）</li><li><code>String getRequestURI()</code>：获取URI，就统一资源标识符（<code>/LearningWeb_war/httpdemo</code>）</li><li><code>String getQueryString()</code>：获取请求参数，在GET方式下拼接在请求链接中的参数（<code>username=123&amp;password=345</code>）</li></ul><p>请求头数据获取：请求头中的数据都是以键值对的形式存在的</p><ul><li><code>String getHeader(String name)</code>：传入请求头中的key，返回对应的value，例如我们可以通过<code>req.getHeader('user-agent')</code>来获取浏览器的版本信息</li></ul><p>请求体数据获取：在使用get方式的时候，请求体是没有数据的，而post请求会将自己的参数存放在请求体中。对于请求体的数据，Request对象提供了两种方式进行获取，分别对应字节输入流和字符输入流</p><ul><li><code>ServletInputStream getInputStream()</code>：获取字节输入流</li><li><code>BufferedReader getReader()</code>：获取字符输入流</li></ul><blockquote><p>这里的输入流对象是通过Request对象来获取的，当请求完成之后，Request对象也会被销毁，之后输入流对象也会自动关闭，也不需要我们手动关闭流</p></blockquote><h2 id="参数获取">参数获取</h2><p>在解析HTTP请求的时候，最主要的一个工作就是解析其中的相关请求参数。</p><p>在实际场景中，我们面对最多的就是get请求和post请求。我们知道，get请求的请求参数被拼接在URL中，我们通过<code>getQueryString()</code>方法可以获取到拼接之后的字符串；post请求的请求参数在请求体中，我们通过<code>getReader()</code>获取字符输入流，也可以得到请求参数。对于这两种情况，我们都可以获得到所有请求参数的原始字符串，经过例如字符串split等处理，就可以得到所需的请求参数。这种方式虽然能够解决需求，但是还是比较麻烦，而Request对象也提供了一种比较方便的方式来获取请求参数，并且统一了get与post请求的参数获取。</p><p>前端传来的参数可以看成组成了一个Map，Request对象为我们提供了如下方法：</p><ul><li><code>Map&lt;String, String[]&gt; getParameterMap()</code>：获取所有参数组成的Map集合</li><li><code>String[] getParameterValues(String name)</code>：根据名称获取参数值数组</li><li><code>String getParameter(String name)</code>：根据名称获取单个参数值</li></ul><p>上面的方法可以解析get的参数，以及post请求体中类似于<code>username=123&amp;password=456</code>这样的参数，但是无法解析json等的数据。</p><blockquote><p>参数中文乱码问题：如果参数中有中文，可能出现中文乱码问题。乱码问题出现的根本原因在于编码与解码所用的字符集不一致。Tomcat8以后使用UTF-8来进行编解码，对于post请求出现的中文问题，只需要在请求前设置编码格式相符合即可，而对于get请求的中文问题，Tomcat8之后已经得到解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">req.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote><h2 id="请求转发">请求转发</h2><p>请求转发（forward）是一种在服务器内部的资源跳转方式。举例来说，浏览器发送一个请求给服务器，服务器中的资源A接收到请求，资源A处理完请求后将请求发送给资源B，资源B处理完成之后再将结果响应给浏览器。其中请求从资源A到资源B的过程就叫做请求转发。</p><p>请求转发有如下特点：</p><ol type="1"><li>浏览器地址栏的路径不发生变化</li><li>只能转发到当前服务器的内部资源，不能从一个服务器通过请求转发到另一个服务器</li><li>一次请求，可以在转发资源之间使用Request对象共享数据</li></ol><p>在Servlet中，可以用下面的方式实现请求转发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">req.getRequestDispatcher(<span class="hljs-string">&quot;目标资源路径&quot;</span>).forward(req, resp)<br></code></pre></td></tr></table></figure><p>在请求转发的过程中，资源之间可以使用Request对象完成数据共享，需要使用到Request对象提供的三个方法：</p><ul><li><code>void setAttribute(String name, Object o)</code>：将键值对数据存储到Request对象域中</li><li><code>Object getAttribute(String name)</code>：根据key来获取值</li><li><code>void removeAttribute(String name)</code>：根据key来删除键值对</li></ul><h1 id="response">Response</h1><h2 id="简介-2">简介</h2><p>Response允许我们设置响应数据。在我们接受到HTTP请求后，完成相关的业务处理，后台就需要将结果即业务数据返回给前端。我们将响应数据封装到Response对象中，后台服务器Tomcat就会解析Response对象，按照响应行+响应头+响应体的格式拼接出最终响应，浏览器解析结果，得到展示内容。</p><p>与Request相同，Response也有类似的继承体系，我们也是重点关注其中的HttpServletResponse接口。</p><img src="/2022/10/06/JavaWeb%E7%AC%94%E8%AE%B0-3-Servlet%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/Reponse%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" class="" title="Reponse继承体系"><h2 id="响应设置">响应设置</h2><p>HTTP的响应数据同样分成了三部分，分别是响应行、响应头和响应体。对于这三部分的数据，Response都提供了对应的方法来进行设置。</p><p>在响应行中，比较常用的就是设置响应状态码，对应的方法如下：</p><ul><li><code>void setStatus(int sc)</code>：设置响应状态码</li></ul><p>Response的响应行也是由键值对构成的，对应的设置方法如下：</p><ul><li><code>void setHeader(String name, String value)</code>：设置响应头键值对</li></ul><p>响应体中的内容，则是通过字符或者字节输入流的方式进行写入，相关方法如下。获取到输入流之后，利用write方法进行写入，这里同样不需要手动关闭流。</p><ul><li><code>PrintWriter getWriter()</code>：获取字符输出流</li><li><code>ServletOutputStream getOutputStream()</code>：获取字节输出流</li></ul><blockquote><p>写入内容除了可以普通的纯文本，也可以是html代码。但是返回html的话，要想在浏览器中显示，需要注意设置响应的数据格式以及数据的编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote><h2 id="请求重定向">请求重定向</h2><p>Response重定向（redirect），是一种资源跳转方式。举例来说，浏览器发送请求给服务器之后，服务器中对应的资源A接收到请求。此时资源A无法处理该请求，则会给浏览器响应一个302的状态码以及一个访问其他资源的路径location，浏览器接收到响应状态302，就会重新发送请求到location对应的访问地址去访问资源B，资源B接收到请求之后进行处理，并最终给浏览器响应结果。</p><p>重定向具有如下特点：</p><ol type="1"><li>浏览器地址栏路径发生变化</li><li>可以重定向到任何位置的资源，包括服务器内部以及外部的资源</li><li>两次请求之间不能使用Resquest对象来进行资源共享</li></ol><p>在Servlet中，可以用下面的方式来实现重定向，只需要返回302状态码以及对应location位置即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.setStatus(<span class="hljs-number">302</span>);<br>resp.setHeader(<span class="hljs-string">&quot;location&quot;</span>, <span class="hljs-string">&quot;目标资源的访问路径&quot;</span>);<br><span class="hljs-comment">// 上面的两行代码也可以进行简化</span><br>resp.sendRedirect(<span class="hljs-string">&quot;目标资源的访问路径&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb笔记(2)-Tomcat的使用</title>
    <link href="/2022/10/05/JavaWeb%E7%AC%94%E8%AE%B0-2-Tomcat%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/05/JavaWeb%E7%AC%94%E8%AE%B0-2-Tomcat%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="tomcat">Tomcat</h1><h2 id="简介">简介</h2><p>在介绍Tomcat之前，我们需要先了解Web服务器的概念。Web服务器是一个应用程序，它对HTTP协议的操作进行了封装，使得程序员无需直接对协议进行操作，从而让Web开发更加便捷。Web服务器软件被安装在服务器端，后续我们可以将自己写的Web项目部署到服务器软件中，当Web服务器软件启动后，就可以直接通过浏览器来访问对应的页面。Tomcat就是一种服务器软件，当然它也只是其中的一种，还有很多其他的服务器软件，而这里我们先学习的是Tomcat。</p><p>Tomcat是Apache软件基金会的一个核心项目，是一个开源的轻量级Web服务器，支持Servlet，JSP等少量JavaEE规范。Tomcat又被称为Web容器、Servlet容器，Servlet需要依赖Tomcat才能够运行。</p><blockquote><p>JavaEE规范：JavaEE，Java EnterpriseEdition，Java企业版，指的是Java企业级开发的技术规范总和，包含了13项技术规范，JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、JavaIDL、JTS、JTA、JavaMail、JAF。</p></blockquote><h2 id="基本使用">基本使用</h2><p>那么接下来先了解Tomcat的基本使用。</p><p>首先是下载与安装。Tomcat的下载可以从官网<ahref="https://tomcat.apache.org/">Apache Tomcat® -Welcome!</a>直接进行，根据实际情况选择对应的版本，下载完成后得到压缩包，解压到对应目录即可。</p><p>下载完成之后可以启动服务，服务启动只需要执行对应命令即可，命令位置为<code>bin/startup</code>。启动成功之后会弹出新的黑窗口，我们可以访问localhost:8080，就可以看到Tomcat默认的内容。关闭Tomcat服务可以通过<code>bin\shutdown</code>命令来进行正常关闭。</p><p>Tomcat的相关配置文件在<code>conf</code>目录下，其中启动端口号默认为8080，配置信息在<code>conf/server.xml</code>下。</p><p>利用Tomcat进行项目部署也非常简单，只需要将我们的项目放置到<code>webapps</code>目录下即可。但是随着项目的增大，项目的资源越来越多，项目的拷贝过程也会比较长，因此我们一般情况是使用war包的形式来进行项目传输。我们一般会将JavaWeb项目打包成<code>war</code>包的形式，然后将其放置到<code>webapps</code>目录下，Tomcat会自动进行<code>war</code>包的解压。</p><h2 id="利用idea进行开发">利用IDEA进行开发</h2><p>我们首先了解一下Web项目的结构，可以分成开发中的项目以及可以部署的项目，这两种项目的结构有所差别。</p><p>开发中的项目，其结构如下：</p><ul><li><code>src</code>：源码文件<ul><li><code>main</code>：主目录<ul><li><code>java</code>：java代码</li><li><code>resources</code>：资源文件</li><li><code>webapp</code>：Web项目的特有目录<ul><li><code>html</code>：html文件目录，允许自定义名称</li><li><code>WEB-INF</code>：Web项目核心目录，不允许修改名称<ul><li><code>web.xml</code>：Web项目配置文件</li></ul></li></ul></li></ul></li><li><code>test</code>：测试目录</li></ul></li><li><code>pom.xml</code>：maven依赖配置</li></ul><p>开发完成可以部署的项目，其结构如下：</p><ul><li><code>html</code>：html文件目录</li><li><code>WEB-INF</code>：Web项目核心目录<ul><li><code>classes</code>：Java字节码文件</li><li><code>lib</code>：项目所需的jar包</li><li><code>web.xml</code>：Web项目配置文件</li></ul></li></ul><p>我们可以通过maven的package打包命令将项目进行打包，编译后的Java字节码文件和resource的资源文件，会被放到<code>WEB-INF</code>下的<code>classes</code>目录下，<code>pom.xml</code>中依赖的jar包会被放入<code>WEB-INF</code>下的lib目录中。</p><p>接下来我们需要在IDEA中创建一个Maven Web项目，步骤如下：</p><ol type="1"><li>正常创建Maven项目</li><li>修改<code>pom.xml</code>中的项目打包方式为war，该项完整格式为<code>&lt;packaging&gt;war&lt;/packaging&gt;</code></li><li>补齐MavenWeb项目中缺少的webapp目录结构，可以手动补齐，也可以通过IDEA的提示进行补齐（<code>File</code>-&gt; <code>Project Structure</code> -&gt;<code>Facets</code>，选择项目后增加<code>webapp</code>以及<code>web.xml</code>）</li></ol><p>一般情况下，我们在IDEA中完成项目部署后，可以通过普通方法来完成项目部署。即利用maven将项目打包成war包的形式，然后放置到Tomcat的对应webapps目录下就可以完成部署。但是这种方式在进行项目调试的时候比较麻烦，我们可以将Tomcat集成到IDEA中，方便我们进行开发。在IDEA中集成使用Tomcat有两种方式，第一种是集成本地Tomcat，另一种是使用TomcatMaven插件。</p><p>第一种方式，集成本地Tomcat，需要修改启动配置，即<code>Run/Debug Configurations</code>，在其中找到TomcatServer，然后指定本地的Tomcat具体路径<code>Application server</code>，然后将我们的项目添加到Tomcat中，在<code>Deployment</code>中进行添加，选择<code>Artifact</code>并找到我们的项目即可。后续就可以直接运行了。</p><blockquote><p>我们可以通过测试页面来查看是否部署成功。在webapp下写一个简单的html页面。在webapp下的html会按照目录层次映射到路由层次，例如存在html文件<code>webapp/haha/test.html</code>，那么在项目部署完成之后，就可以通过<code>localhost:8080/项目名称/haha/test.html</code>访问到对应的内容。</p></blockquote><p>启动配置：</p><img src="/2022/10/05/JavaWeb%E7%AC%94%E8%AE%B0-2-Tomcat%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%AD%A5%E9%AA%A41.png" class="" title="步骤1"><p>项目添加：</p><img src="/2022/10/05/JavaWeb%E7%AC%94%E8%AE%B0-2-Tomcat%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%AD%A5%E9%AA%A42.png" class="" title="步骤2"><p>第二种方式，采用TomcatMaven插件。它使用Maven中的Tomcat插件来进行项目部署，首先需要在pom.xml中添加Tomcat插件，然后使用MavenHelper插件快速启动项目，右键 -&gt; <code>Run Maven</code> -&gt;<code>tomcat7:run</code>即可启动项目。（这种方式下，TomcatMaven插件的版本会受到限制）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Tomcat插件 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb笔记(1)-JavaWeb概述与JDBC</title>
    <link href="/2022/10/04/JavaWeb%E7%AC%94%E8%AE%B0-1-JavaWeb%E6%A6%82%E8%BF%B0%E4%B8%8EJDBC/"/>
    <url>/2022/10/04/JavaWeb%E7%AC%94%E8%AE%B0-1-JavaWeb%E6%A6%82%E8%BF%B0%E4%B8%8EJDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="javaweb-概述">JavaWeb 概述</h1><p>JavaWeb，就是使用Java技术栈来解决Web互联网领域相关问题的技术栈，简单来说就是利用Java来搭建网站。而搭建网站大体的框架可以分成三部分，前端页面，后端程序以及数据库，而JavaWeb部分也就主要由这三部分组成。前端页面的知识主要包括前端三大件，相关框架等；数据库的知识主要指的是利用Java程序来连接数据库，相关知识点有JDBC等；后端程序即JavaWeb程序，为内容核心，包括Tomcat、Servlet、JSP等，后续会展开详细说明。</p><h1 id="jdbc">JDBC</h1><h2 id="简介">简介</h2><p>JDBC，全称为Java DataBaseConnectivity，Java数据库连接。它是Java语言用来操作关系型数据库的一套API，是由sun公司定义的一套标准接口，而它的实现类，这里也称作驱动，则由各个数据库公司来提供，这样达到的效果就是利用同一套Java代码，就可以操作不同的关系型数据库，只需要变更底层的数据库驱动即可。</p><ul><li>JDBC是由sun公司定义的一套操作关系型数据库的规则，也即接口</li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包</li><li>程序员利用JDBC进行编程，而真正指定的底层代码是驱动jar包中的相关类</li></ul><h2 id="快速入门">快速入门</h2><p>利用JDBC访问数据库的操作基本上可以分成下面的步骤，我们通过一个快速入门程序来进行说明。当然在书写程序之前，我们需要准备好相关的数据库驱动jar包，并将其引入到项目中</p><blockquote><p>数据库驱动jar包可以利用<a href="https://mvnrepository.com/">MavenRepository: Search/Browse/Explore(mvnrepository.com)</a>下载。之后将其引入项目，在项目目录下新建lib目录，将驱动jar包加入该目录下方便管理，然后将其添加为library，对应<code>Add as Library</code>，之后需要选定作用范围，视情况而选择</p></blockquote><p>JDBC的大体使用框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 反射注册驱动(新版本无需此步)</span><br><span class="hljs-comment">// Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><br><span class="hljs-comment">// 2. 获取连接</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/web_test&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;******&quot;</span>;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br><span class="hljs-comment">// 3. 定义SQL</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from paints&quot;</span>;<br><br><span class="hljs-comment">// 4. 获取执行SQL的对象 Statement</span><br><span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br><br><span class="hljs-comment">// 5. 执行SQL</span><br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery(sql);<br><br><span class="hljs-comment">// 6. 结果处理</span><br><span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;书名&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;作者&quot;</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">isbn</span> <span class="hljs-operator">=</span> resultSet.getLong(<span class="hljs-string">&quot;ISBN&quot;</span>);<br>    System.out.println(book + <span class="hljs-string">&quot;\t&quot;</span> + author + <span class="hljs-string">&quot;\t&quot;</span> + isbn);<br>&#125;<br><br><span class="hljs-comment">// 7. 资源释放</span><br>resultSet.close();<br>statement.close();<br>connection.close();<br></code></pre></td></tr></table></figure><blockquote><p>通过这个快速入门代码，我们也可以看出JDBC的一些缺点，例如硬编码，包括注册驱动、获取连接、用户名、密码、SQL语句等都需要写在代码中，不够灵活；例如操作繁琐，它需要我们手动设置参数，手动封装结果集等等，比较麻烦。后面我们会学习一些优秀的框架，它们可以用来简化JDBC的开发。</p></blockquote><h2 id="api详解">API详解</h2><h3 id="drivermanager">DriverManager</h3><p>DriverManager即驱动管理类，这是一个工具类，提供了许多静态方法。我们主要利用其中的<code>getConnection</code>来获取数据库连接，完整的方法包括了三个必要的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String url, String user, String password)</span> <span class="hljs-keyword">throws</span> SQLException<br></code></pre></td></tr></table></figure><ul><li>url：连接路径<ul><li>路径语法如下：<code>jdbc:mysql://域名:端口号/数据库名称?参数键值对1&amp;参数键值对2...</code></li></ul></li><li>user：用户名</li><li>password：密码</li></ul><h3 id="connection">Connection</h3><p>Connection即数据库连接对象，它主要的作用包括获取执行SQL的对象Statement，以及进行事务的管理。</p><p>通过Connection对象的<code>createStatement()</code>方法可以获取执行SQL的对象（后面会提到又分为普通的Statement对象以及防止SQL注入的PreparedStatement等），相关的SQL语句都需要通过Statement对象来进行执行。</p><p>Connection对象同样还负责事务管理，主要通过下面的三个方法来完成：</p><ul><li><code>setAutoCommit()</code>：设置事务提交模式，如果是希望手动管理事务，则需要将自动提交事务设置为false</li><li><code>commit()</code>：事务提交</li><li><code>rollback()</code>：事务回滚</li></ul><p>在JDBC程序中，事务管理一般都与异常处理机制配合使用，如果在事务执行的过程中有异常出现，就执行事务回滚操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 已经获得Connection对象，conn</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 开启事务</span><br>    conn.setAutoCommit(<span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-comment">// 事务相关操作...</span><br>    <br>    <span class="hljs-comment">// 事务提交</span><br>    conn.commit();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    <span class="hljs-comment">// 事务回滚</span><br>    conn.rollback();<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="statement">Statement</h3><p>Statement对象，它的作用就是用来执行SQL语句。对象可以调用的方法有很多，分别对应了不同类型的SQL语句：</p><ul><li>执行DDL、DML语句：返回结果表示影响的行数</li><li>执行DQL语句：返回ResultSet对象，是对查询结果的封装</li></ul><h3 id="preparedstatement">PreparedStatement</h3><p>PreparedStatement相比Statement，它完成的是预编译SQL语句并执行，可以防止SQL注入问题。每一个PreparedStatement对象都对应一个事先写好的SQL，这个SQL描述了后续执行的一系列SQL语句的模式，其中利用?进行占位，并利用程序说明对应位置的对应参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SQL模式</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from user where username = ? and password = ?&quot;</span>;<br><br><span class="hljs-comment">// 获取PreparedStatement对象</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br><br><span class="hljs-comment">// 设置对应位置的对应值，按照顺序index从1开始</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123123&quot;</span>;<br>preparedStatement.setString(<span class="hljs-number">1</span>, name);<br>preparedStatement.setString(<span class="hljs-number">2</span>, pwd);<br><br><span class="hljs-comment">// sql执行</span><br>preparedStatement.executeQuery();<br></code></pre></td></tr></table></figure><ul><li>PreparedStatement防止SQL注入的原理主要是将特殊字符进行转移，防止字符串拼接时导致的逻辑错误</li><li>另一方面，由于每一个PreparedStatement对象后续执行的都是相同模式的SQL语句，因此它可以完成SQL的预编译，提高性能。当然这个功能需要在连接的时候设置键值对参数来开启预编译功能<code>useServerPrepStmts=true</code></li></ul><h3 id="resultset">ResultSet</h3><p>ResultSet对象，它是Java对SQL查询语句返回结果的封装，它有如下两类重要方法：</p><ul><li><code>boolean next()</code>：<ul><li>判断当前行是否为有效行，并进行行光标的移动</li></ul></li><li><code>xxx getXxx(arg)</code>：<ul><li>表示从当前行获取相应的列数据</li><li>xxx表示当前列的类型</li><li>arg表示传入参数，可以是列的整型index编号（从1开始），也可以是列的String名称</li></ul></li></ul><p>可以将ResultSet看作是一个对行的迭代器，它的相关遍历操作有下面的模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 已经获得ResultSet对象，名称为res</span><br><span class="hljs-keyword">while</span>(res.next())&#123;<br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> res.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> res.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>    <span class="hljs-comment">// 其他相关操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据库连接池">数据库连接池</h2><p>如果我们每次进行相关查询都创建一个新的Connection对象，使用完毕之后就将其销毁，那么性能就会因为连接对象的重复创建和销毁而大大消耗。池化则是一种很好的资源管理方式，数据库连接池就是用来实现Connection对象复用的池化技术。</p><p>Java官方提供了数据库连接池的标准接口<code>DataSource</code>，其他第三方组织实现这个接口，来提供数据库连接池的相关功能。接口中定义的获取连接的方法如下，前面我们是通过DriverManager来获取Connection对象，而更好的方法则是通过数据库连接池来获取Connection对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>常见的数据库连接池有DBCP、C3P0、Druid等，其中Druid连接池是阿里巴巴开源的数据库连接池项目，它的功能强大，性能优秀，是比较好的数据库连接池之一。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程笔记(9)-多线程补充</title>
    <link href="/2022/10/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A1%A5%E5%85%85/"/>
    <url>/2022/10/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="threadlocal">ThreadLocal</h1><h2 id="概述">概述</h2><p>Java中提供ThreadLcoal，用来实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题。它能够达到<strong>线程内的资源共享，线程间的资源隔离</strong>的效果。ThreadLocal提供的变量在多线程环境下访问时能保证各个线程的变量相对独立于其他线程内的变量，分配在堆内的TLAB（本地线程分配缓冲，ThreadLocal Allocation Buffer）中。</p><p>在每个线程需要自己单独实例，实例需要在线程内的多个方法中共享，但又不希望多线程共享的时候，我们可以使用ThreadLocal。</p><p>ThreadLocal的常用方法：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>ThreadLocal&lt;&gt;()</td><td>创建 ThreadLocal 对象</td></tr><tr class="even"><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr class="odd"><td>public void set( T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr class="even"><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr class="odd"><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><p>应用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Utils</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Resource&gt; resource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Resource <span class="hljs-title function_">getResource</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (resource.get() == <span class="hljs-literal">null</span>) &#123;<br>                resource.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>());<br>            &#125;<br>            <span class="hljs-keyword">return</span> resource.get();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> Utils.getResource();<br>                log.debug(resource.toString());<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下，这里每个线程都调用了Util的同一个静态方法获取资源，但是得到的资源是各不相同的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">15</span>:<span class="hljs-number">03</span>:<span class="hljs-number">58.973</span> <span class="hljs-selector-attr">[Thread-4]</span> c<span class="hljs-selector-class">.ThreadTest</span> - ThreadTest<span class="hljs-variable">$Resource</span>@<span class="hljs-number">60</span>cbadfa<br><span class="hljs-number">15</span>:<span class="hljs-number">03</span>:<span class="hljs-number">58.973</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.ThreadTest</span> - ThreadTest<span class="hljs-variable">$Resource</span>@a0bfb89<br><span class="hljs-number">15</span>:<span class="hljs-number">03</span>:<span class="hljs-number">58.973</span> <span class="hljs-selector-attr">[Thread-2]</span> c<span class="hljs-selector-class">.ThreadTest</span> - ThreadTest<span class="hljs-variable">$Resource</span>@<span class="hljs-number">6</span>c279cc0<br><span class="hljs-number">15</span>:<span class="hljs-number">03</span>:<span class="hljs-number">58.973</span> <span class="hljs-selector-attr">[Thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - ThreadTest<span class="hljs-variable">$Resource</span>@<span class="hljs-number">136</span>eca69<br><span class="hljs-number">15</span>:<span class="hljs-number">03</span>:<span class="hljs-number">58.973</span> <span class="hljs-selector-attr">[Thread-3]</span> c<span class="hljs-selector-class">.ThreadTest</span> - ThreadTest<span class="hljs-variable">$Resource</span>@<span class="hljs-number">5</span>bf5ce32<br></code></pre></td></tr></table></figure><h2 id="原理">原理</h2><p>在每个线程内有一个ThreadLocalMap类型的成员变量，用来存储资源对象。真正起到线程隔离作用的是这个ThreadLocalMap，而ThreadLocal起到的作用是用来关联ThreadLocalMap和实际对象：</p><ul><li>调用set方法，就是以ThreadLocal自己作为key，资源对象作为value，放入当前线程的ThreadLocalMap集合中</li><li>调用get方法，就是以ThreadLocal自己作为key，到当前线程中查找关联的资源值</li><li>调用remove方法，就是以ThreadLocal自己作为key，移除当前线程关联的资源值</li></ul><p>在ThreadLocalMap中，key即ThreadLocal被设计为弱引用。有如下的原因：</p><ol type="1"><li>Thread可能需要长时间运行，例如线程池中的线程。如果我们的key不再使用，我们希望能够释放掉它的内存。如果使用强引用，那么就无法释放掉这个key对应的内存空间，即使除了ThreadLocalMap的其他地方都没有引用这个key</li><li>虽然key是弱引用，但是value仍然是强引用。GC能够让key的内存释放，但是后续还需要根据key是否为null来进一步释放值的内存，释放时机如下：<ul><li>获取key的时候发现key为null</li><li>set key的时候，使用启发式扫描，清除临近的nullkey，启发次数与元素个数，是否发现null key有关</li><li>调用remove的时候，相当于手动移除，这也是最推荐的一种方式</li></ul></li></ol><blockquote><p>但是一般在使用的时候，我们会将ThreadLocal作为静态变量，这样key就始终保持引用，无法被释放，对应的value也会始终占用空间，导致内存泄漏的问题</p></blockquote><p>ThreadLocalMap是ThreadLocal的内部类，它没有实现Map接口，而是用独立的方式实现了Map的功能，内部的Entry也是独立实现。</p><p>关于Entry，它继承了WeakReference，其中的key是弱引用，并且限制只能使用ThreadLocal作为key。key为null意味着key不再被引用，Entry也可以从table中清除。关于Map，当元素个数大于等于长度的一般，进行扩容，扩容到原来的两倍。进行元素的添加的时候，使用开放定址法来解决冲突，使用的探测序列为线性序列。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程笔记(8)-多线程设计模式</title>
    <link href="/2022/09/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程设计模式">多线程设计模式</h1><h2 id="两阶段终止">两阶段终止</h2><p>目的：在线程t1中优雅地终止线程t2，即不是粗暴地直接终止线程t2，而是可以让线程t2能够处理一些善后工作，然后再进行终止</p><p>错误思路：</p><ul><li>使用线程对象的stop停止线程：stop方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li><li><code>System.exit(int)</code>：目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul><p>流程分析：</p><img src="/2022/09/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2.png" class="" title="两阶段终止"><p>考虑线程t2在进行while(true)的循环，每次判断打断标记是否为真，如果为真，则进行一些后事的处理，然后break退出循环；如果为假，则可以进行睡眠，防止CPU占用达到100%。</p><p>考虑线程t2被打断的时机，可能是在执行while循环普通代码即运行状态下被打断的，此时打断标记被设置为true，下一次循环中进行判断并退出。也可能是在sleep中即阻塞状态下被打断的，此时打断标记会被清除，需要重新设置打断标记，才能在下次循环中进行判断并退出。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread monitor;<br><br>    <span class="hljs-comment">// 启动线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">currentThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> currentThread.isInterrupted();<br>                <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;执行普通代码&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    currentThread.interrupt(); <span class="hljs-comment">// 重新设置打断标记</span><br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;monitor&quot;</span>);<br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">// 停止线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="保护性暂停">保护性暂停</h2><p>目的：GuardedSuspension，实现一个线程等待另一个线程的执行结果，同时提供超时参数（等待和产生关系一一对应）</p><p>分析：</p><p>一个线程的结果需要传递到另一个线程，让这两个线程关联同一个GuardedObject。线程t1需要结果，因此需要等待相关条件；线程t2产生结果，结果产生之后，通知t1。同时需要实现超时效果，则需要在每次等待前后计算当前等待了多长时间，并与提供的超时时间进行比较，决定是跳出循环还是继续等待。</p><blockquote><p>join的实现就是类似。</p></blockquote><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-comment">// millis表示超时时间</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">// 等待开始的时间</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">timePassed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 已经经历的时间</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> millis - timePassed; <span class="hljs-comment">// 此次需要等待的时间</span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 已经超时</span><br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.wait(waitTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                timePassed = System.currentTimeMillis() - begin; <span class="hljs-comment">// 计算已经经历的时间</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-built_in">this</span>.response = response;<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生产者消费者">生产者消费者</h2><p>说明：</p><ul><li>与前面保护性暂停中的GuardObject不同，这种模式不需要产生结果与消费结果一一对应</li><li>生产者仅负责产生数据，不关心数据该如何处理；而消费者专心处理结果数据</li><li>消息队列用来平衡生产和消费的线程资源</li><li>消息队列有容量限制，满时不会再加入数据，空时不会再消耗数据</li></ul><blockquote><p>JDK中的各种阻塞队列即采用该模式</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 消息队列集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity; <span class="hljs-comment">// 队列容量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取消息</span><br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-comment">// 队列为空则需要等待</span><br>            <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 从队列的头部获取消息返回</span><br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> list.removeFirst();<br>            list.notifyAll();<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 存入消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Message message)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-comment">// 队列满则需要等待</span><br>            <span class="hljs-keyword">while</span> (list.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 加入队列的尾部</span><br>            list.addLast(message);<br>            list.notifyAll();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> Object value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(<span class="hljs-type">int</span> id, Object value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="交替输出">交替输出</h2><p>目的：控制多个线程的输出顺序</p><p>分析：利用标志位来判断当前哪个线程能够输出</p><p>示例代码：3个线程交替输出a，b，c</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlternateOutput</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">OutputHelper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputHelper</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            helper.print(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            helper.print(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            helper.print(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputHelper</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNum;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">OutputHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> loopNum)</span> &#123;<br>            <span class="hljs-built_in">this</span>.flag = flag;<br>            <span class="hljs-built_in">this</span>.loopNum = loopNum;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> waitFlag, <span class="hljs-type">int</span> nextFlag)</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNum; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    <span class="hljs-keyword">while</span> (flag != waitFlag) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-built_in">this</span>.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    System.out.print(str);<br>                    flag = nextFlag;<br>                    <span class="hljs-built_in">this</span>.notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程笔记(7)-常用并发工具类的使用</title>
    <link href="/2022/09/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-7-%E5%B8%B8%E7%94%A8%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-7-%E5%B8%B8%E7%94%A8%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="reentrantlock">ReentrantLock</h1><h2 id="概述">概述</h2><p>ReentrantLock，可重入锁，即支持一个线程对资源的重复加锁。ReentrantLock实现的锁与synchronized非常类似，但是也是有一些区别，大体如下：</p><ul><li><p>在锁的实现方面：synchronzied是JVM实现的，源码使用C++编写，而ReentrantLock是JDK实现，源码使用Java编写</p></li><li><p>在使用方面：ReentrantLock实现了Lock接口，需要手动解锁，synchronized执行完代码块之后会自动解锁</p></li><li><p>可中断：ReentrantLock可中断，但是synchronized不行</p></li><li><p>公平锁：公平锁指的是多个线程在等待同一个锁的时候，必须按照申请锁的时间顺序来依次获得锁。ReentrantLock支持设置公平锁，而synchronzied中的锁的非公平的</p></li><li><p>锁超时：ReentrantLock在获取锁的时候可以设置超时时间，而synchronized会一直等待</p></li><li><p>等待队列：ReentrantLock可以提供多个Condition等待队列，而synchronized只有一个等待队列</p></li></ul><blockquote><p>非公平锁指的是阻塞队列内公平，阻塞队列外非公平。事实上，公平的锁机制往往没有非公平的效率更高，公平锁能够减少饥饿发生的概率，等待越久的请求越能够得到优先满足</p></blockquote><h2 id="使用">使用</h2><h3 id="lock操作">lock操作</h3><p>基本使用，ReentrantLock实现了Lock接口，提供了其中的相关操作。</p><ul><li>构造方法：<code>ReentrantLock lock = new ReentrantLock()</code></li><li>加锁：<code>public void lock()</code><ul><li>如果锁没有被占用，则将锁中计数state设置为1</li><li>如果执行锁重入，则令计数state增加1</li><li>如果锁被其他线程占用，则阻塞在锁上</li></ul></li><li>解锁：<code>public void unlock()</code><ul><li>如果当前线程是该锁的持有者，则保持计数递减</li><li>如果计数为0，则表示锁被释放</li><li>如果当前线程不是该锁的持有者，则抛出异常</li></ul></li><li>可打断：<code>public void lockInterruptibly()</code><ul><li>如果没有竞争，则获取对象锁</li><li>如果有竞争，则加入阻塞队列，但是可以被其他线程打断</li></ul></li><li>锁超时：<ul><li><code>public boolean tryLock()</code>：尝试获取锁，获取到返回true，获取不到直接放弃，不进入阻塞队列</li><li><code>public boolean tryLock(long timeout, TimeUnit unit)</code>：在给定时间内获取锁，获取不到就退出</li></ul></li></ul><h3 id="公平锁">公平锁</h3><p>公平锁与非公平锁在Reentrant中，主要区别在于其中同步器的实现。公平锁对应的同步器为<code>FairSync</code>，而非公平锁对应的同步器为<code>NonfairSync</code>，Reentrant默认是非公平锁，如果给构造方法提供<code>true</code>的布尔值，则可以生成公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定是否是公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><br><span class="hljs-comment">// 默认是非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>公平锁和非公平锁的主要区别在于获取锁的逻辑。对于非公平锁来说，只需要CAS设置同步状态成功，就表示当前线程获取了锁。而对于公平锁来说，在进行获取锁之前，需要加入同步队列中，并检查当前节点是否有前驱节点，如果没有才能继续获取锁，否则需要等待前驱节点对应的线程获取并释放锁之后，才能继续获取锁</p><h1 id="reentrantreadwritelock">ReentrantReadWriteLock</h1><h2 id="概述-1">概述</h2><p>前面提到的ReentrantLock排他锁，指的是在同一个时刻只允许有一个线程进行访问。</p><p>但是我们经常会遇到的一种情况是读写锁，读写锁允许读-读并发，在同一时刻允许多个读线程访问，但是在写线程访问的时候，所有的读线程和其他写线程均被阻塞。具体来说，读写锁维护了一对锁，分别是读锁和写锁。读锁是共享锁，写锁是独占锁。通过分离读锁和写锁，提高了并发性。</p><p>ReentrantReadWriteLock是Java并发包中提供的一个读写锁的实现，它实现了读写锁接口ReadWriteLock，该接口中有两个抽象方法<code>readLock()</code>和<code>writeLock()</code>，分别返回读锁和写锁。</p><h2 id="使用-1">使用</h2><p>ReentrantReadWriteLock的使用分为读锁和写锁，分别在不同情况下进行使用。这里同样可以设置公平和非公平锁，只需要在构造方法中指定<code>true</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rw.readLock();<br>ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rw.writeLock();<br></code></pre></td></tr></table></figure><p>在使用的时候需要注意：</p><ul><li>读锁不支持条件变量</li><li>重入时不支持锁升级：持有读锁的线程不能继续获取写锁，需要先释放读锁，然后再去获取写锁</li><li>重入时支持锁降级：持有写锁的线程可以继续获取读锁</li></ul><blockquote><p>ReentrantReadWriteLock内部的读锁和写锁使用的是同一个Sync同步器，原理与ReentrantLock相比没有太多特殊之处。读写锁共用一个state，其中写锁使用state的低16位，而读锁使用state的高16位</p></blockquote><p>除去接口方法获取读锁和写锁之外，ReentrantReadWriteLock还提供了一些便于外界监控其内部工作状态的方法，如下所示：</p><table><thead><tr class="header"><th>方法名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>int getReadLockCount()</td><td>返回当前读锁被获取的次数，重入次数重复计算</td></tr><tr class="even"><td>int getReadHoldCount()</td><td>返回当前线程获取读锁的次数，重入次数重复计算</td></tr><tr class="odd"><td>boolean isWriteLocked()</td><td>判断写锁是否被获取</td></tr><tr class="even"><td>int getWriteHoldCount()</td><td>返回当前写锁被获取的次数</td></tr></tbody></table><h1 id="stampedlock">StampedLock</h1><p>StampedLock也是一种读写锁，它的目的是进一步优化读的性能。和它的名字呼应，在使用StampedLock的时候，使用读锁和写锁都必须配合戳来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StampedLcok</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br><span class="hljs-comment">// 读锁的使用</span><br><span class="hljs-type">long</span> <span class="hljs-variable">r_stamp</span> <span class="hljs-operator">=</span> lock.readLock();<br>lock.unlockRead(r_stamp);<br><br><span class="hljs-comment">// 解锁的使用</span><br><span class="hljs-type">long</span> <span class="hljs-variable">w_stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>lock.unlockWrite(w_stamp)<br></code></pre></td></tr></table></figure><blockquote><p>StampedLock进一步优化了读的性能，是因为它底层使用了乐观读的思想。在读取完毕之后，StampedLock会进行一次戳校验，如果校验通过，则表示这期间没有其他线程的写操作，数据可以安全使用；如果校验没有通过，则需要重新获取读锁，保证数据的一致性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br><span class="hljs-comment">// 验戳</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br><span class="hljs-comment">// 锁升级</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>需要注意的是，StampedLock不支持条件变量，不支持重入</p></blockquote><h1 id="semaphore">Semaphore</h1><p>Semaphore，信号量，联想到操作系统中的信号量。它可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理地使用公共资源。</p><p>Semaphore的基本使用如下：</p><p>构造方法：</p><ul><li><code>public Semaphore(int permits)</code>：permits表示许可线程的数量，会将其直接设置到内部同步器中的state上</li><li><code>public Semaphore(int permits, boolean fair)</code>：fair表示公平性，如果设为 true，下次执行的线程会是等待最久的线程</li></ul><p>PV操作：</p><ul><li><code>public void acquire()</code>：表示获取许可</li><li><code>public void release()</code>：表示释放许可，acquire() 和release() 方法之间的代码为同步代码</li></ul><p>其他方法：</p><ul><li><code>int availablePermis()</code>：返回此信号量中当前可用的许可数</li><li><code>int getQueueLength()</code>：返回正在等待获取许可证的线程数</li><li><code>boolean hasQueuedThreads()</code>：是否有线程正在等待获取许可</li><li><code>protected void reducePermits(int reduction)</code>：减少reduction个许可</li><li><code>protected Collection&lt;Thread&gt; getQueuedThreads()</code>：返回所有等待获取许可的线程集合</li></ul><h1 id="countdownlatch">CountDownLatch</h1><p>CountDownLatch允许一个或者多个线程等待其他线程完成操作。它可以用来进行线程同步线程，等待所有线程完成倒计时。</p><p>构造器如下：</p><ul><li><code>public CountDownLatch(int count)</code>：初始化需要完成倒计时的步数，也可以将其看作是等待完成的count个执行步骤</li></ul><p>常用API：</p><ul><li><code>public void await()</code>：让当前线程等待，只有当计数器减到0的时候才会继续执行（当然也提供有超时时间的版本）</li><li><code>public void countDown()</code>：计数器进行减 1</li></ul><p>举例：主线程等待其他线程执行结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    log.debug(<span class="hljs-string">&quot;countdown -1&quot;</span>);<br>    countDownLatch.countDown();<br>&#125;, <span class="hljs-string">&quot;thread1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    log.debug(<span class="hljs-string">&quot;countdown -1&quot;</span>);<br>    countDownLatch.countDown();<br>&#125;, <span class="hljs-string">&quot;thread2&quot;</span>).start();<br><br><span class="hljs-comment">// 主线程等待其他两个线程完成倒计时</span><br>log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>countDownLatch.await();<br>log.debug(<span class="hljs-string">&quot;over&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出如下：thread1和2先后完成countDown之后，计数器变为0，主线程继续运行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">20</span>:<span class="hljs-number">23</span>:<span class="hljs-number">11.345</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.ThreadTest</span> - waiting...<br><span class="hljs-number">20</span>:<span class="hljs-number">23</span>:<span class="hljs-number">12.356</span> <span class="hljs-selector-attr">[thread1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - countdown -<span class="hljs-number">1</span><br><span class="hljs-number">20</span>:<span class="hljs-number">23</span>:<span class="hljs-number">13.346</span> <span class="hljs-selector-attr">[thread2]</span> c<span class="hljs-selector-class">.ThreadTest</span> - countdown -<span class="hljs-number">1</span><br><span class="hljs-number">20</span>:<span class="hljs-number">23</span>:<span class="hljs-number">13.346</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.ThreadTest</span> - over<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>计数器的值始终大于等于0，如果计数器为0，调用await无法阻塞当前线程</li><li>CountDownLatch无法重新初始化，也无法重新修改对象内部计数器的值</li></ul></blockquote><blockquote><p>CountDownLatch与join的区别：</p><p>join同样能够完成等待线程结束操作，但是join是一个比较底层的API，并且是等待线程达到结束状态。而CountDownLatch是一个高级的API，更容易配合线程池等高级API进行使用。线程池中的线程进行复用，使用join不是等待不是很方便</p></blockquote><h1 id="cyclicbarrier">CyclicBarrier</h1><p>CyclicBarrier：循环屏障，用来进行线程协作，等待线程满足某个计数之后，触发继续执行。</p><p>常用方法：</p><ul><li><p><code>public CyclicBarrier(int parties)</code>：屏障前需要的线程数目</p></li><li><p><code>public CyclicBarrier(int parties, Runnable barrierAction)</code>：用于在线程到达屏障parties 时，执行 barrierAction</p><ul><li>parties：代表多少个线程到达屏障开始触发线程任务</li><li>barrierAction：等够线程之后，执行的任务</li></ul></li><li><p><code>public int await()</code>：线程调用 await 方法通知CyclicBarrier 本线程已经到达屏障</p></li></ul><p>举例：重复等待线程</p><p>如果使用CountDownLatch来完成重复等待线程，由于它不能重用，我们需要多次创建新的CountDownLatch对象，但是使用CyclicBarrier，就不需要重新创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>, () -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;task1 task2 finish...&quot;</span>);<br>&#125;);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    service.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            log.debug(<span class="hljs-string">&quot;task1 run to barrier...&quot;</span>);<br>            cyclicBarrier.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br><br>    service.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            log.debug(<span class="hljs-string">&quot;task2 run to barrier...&quot;</span>);<br>            cyclicBarrier.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>&#125;<br><br>service.shutdown();<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">21</span>:<span class="hljs-number">01</span>:<span class="hljs-number">09.206</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] c.ThreadTest - task1 run to barrier...<br><span class="hljs-number">21</span>:<span class="hljs-number">01</span>:<span class="hljs-number">10.217</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-2</span>] c.ThreadTest - task2 run to barrier...<br><span class="hljs-number">21</span>:<span class="hljs-number">01</span>:<span class="hljs-number">10.217</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-2</span>] c.ThreadTest - task1 task2 finish...<br><span class="hljs-number">21</span>:<span class="hljs-number">01</span>:<span class="hljs-number">11.218</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-2</span>] c.ThreadTest - task1 run to barrier...<br><span class="hljs-number">21</span>:<span class="hljs-number">01</span>:<span class="hljs-number">12.229</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] c.ThreadTest - task2 run to barrier...<br><span class="hljs-number">21</span>:<span class="hljs-number">01</span>:<span class="hljs-number">12.229</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] c.ThreadTest - task1 task2 finish...<br><span class="hljs-number">21</span>:<span class="hljs-number">01</span>:<span class="hljs-number">13.236</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] c.ThreadTest - task1 run to barrier...<br><span class="hljs-number">21</span>:<span class="hljs-number">01</span>:<span class="hljs-number">14.240</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-2</span>] c.ThreadTest - task2 run to barrier...<br><span class="hljs-number">21</span>:<span class="hljs-number">01</span>:<span class="hljs-number">14.240</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-2</span>] c.ThreadTest - task1 task2 finish...<br></code></pre></td></tr></table></figure><blockquote><p>CountDownLatch vs CyclicBarrier：</p><ul><li>CountDownLatch的计数器只能使用一次</li><li>CyclicBarrier的计数器可以使用reset方法重置</li><li>CyclicBarrier中还提供了其他有用方法<ul><li><code>getNumberWaiting()</code>：获得阻塞的线程数量</li><li><code>isBroken()</code>：判断阻塞的线程是否被中断</li></ul></li></ul></blockquote><h1 id="exchanger">Exchanger</h1><p>Exchanger：交换器，是一个用于线程间协作的工具类，用于进行线程间的数据交换。</p><p>Exchanger会提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。线程之间通过exchange方法交换数据，线程1先执行到exchange之后，会等待第二个线程也执行到exchange，当两个线程都到达同步点之后，两个线程就可以交换数据</p><p>常用方法：</p><ul><li><code>public Exchanger()</code>：创建一个新的交换器</li><li><code>public V exchange(V x)</code>：等待另一个线程执行到同步点，交换数据，返回交换得到的数据</li><li><code>public V exchange(V x, long timeout, TimeUnit unit)</code>：提供超时时间</li></ul><p>示例：两个线程进行数据交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">Exchanger&lt;Integer&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    log.debug(<span class="hljs-string">&quot;now value: &#123;&#125;&quot;</span>, value);<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        value = exchanger.exchange(value);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    log.debug(<span class="hljs-string">&quot;after exchange value: &#123;&#125;&quot;</span>, value);<br>&#125;, <span class="hljs-string">&quot;thread1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    log.debug(<span class="hljs-string">&quot;now value: &#123;&#125;&quot;</span>, value);<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        value = exchanger.exchange(value);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    log.debug(<span class="hljs-string">&quot;after exchange value: &#123;&#125;&quot;</span>, value);<br>&#125;, <span class="hljs-string">&quot;thread2&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>输出如下，在两个线程都执行到exchange后进行数据交换</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">21</span>:<span class="hljs-number">16</span>:<span class="hljs-number">27.789</span> <span class="hljs-selector-attr">[thread1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - now value: <span class="hljs-number">1</span><br><span class="hljs-number">21</span>:<span class="hljs-number">16</span>:<span class="hljs-number">27.789</span> <span class="hljs-selector-attr">[thread2]</span> c<span class="hljs-selector-class">.ThreadTest</span> - now value: <span class="hljs-number">2</span><br><span class="hljs-number">21</span>:<span class="hljs-number">16</span>:<span class="hljs-number">29.813</span> <span class="hljs-selector-attr">[thread2]</span> c<span class="hljs-selector-class">.ThreadTest</span> - after exchange value: <span class="hljs-number">1</span><br><span class="hljs-number">21</span>:<span class="hljs-number">16</span>:<span class="hljs-number">29.813</span> <span class="hljs-selector-attr">[thread1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - after exchange value: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程笔记(6)-Lock的使用与原理</title>
    <link href="/2022/09/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-6-Lock%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-6-Lock%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="lock">Lock</h1><h2 id="概述">概述</h2><p>在前面的学习中，我们知道<code>synchronized</code>关键字能够帮助我们完成加锁操作，保证代码的原子性、有序性和可见性。而在Java中，除了这个关键字以外还提供了相关的锁类，来帮助我们完成相应的功能。这些能够帮助我们完成锁功能的类，都有一个公共接口<code>Lock</code>，包名为<code>java.util.concurrent.locks</code>。接口中有如下抽象方法：</p><ul><li><code>void lock()</code>：进行加锁，获得锁</li><li><code>void lockInterruptibly() throws InterruptedException</code>：进行加锁，获得可以打断的锁。可中断指的是可以在获取锁的过程中可以被其他线程打断</li><li><code>boolean tryLock()</code>：尝试获取锁，返回是否成功获取锁</li><li><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code>：在给定时间内尝试获取锁，返回是否成功获取锁</li><li><code>void unlock()</code>：解锁操作</li><li><code>Condition newCondition()</code>：获取条件变量进行等待</li></ul><h2 id="基本使用">基本使用</h2><p>Lock本身只是一个接口，规定了锁相关类的操作。这里以其中一个具体实现ReentrantLock的使用来说明锁的基本使用，ReentrantLock与synchronzied类似，都提供可重入锁，但是仍然有一些不同之处。</p><h3 id="加锁和解锁">加锁和解锁</h3><p>Lock需要程序员手动完成锁的获取和锁的释放。如果线程一直不释放锁，那么可能会造成一些问题。因此为了让解锁操作一定执行，一般将其放在finally代码块中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">myLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    myLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">myLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;start&quot;</span>);<br>    myLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获取到锁&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>        myLock.unlock();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;thread1&quot;</span>).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;start&quot;</span>);<br>    myLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获取到锁&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>        myLock.unlock();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;thread2&quot;</span>).start();<br></code></pre></td></tr></table></figure><h3 id="可打断">可打断</h3><p>打断指的是我们可以打断一个阻塞在锁上的进程，通过异常捕获机制进行打断。但是普通的lock加锁操作不会抛出异常，而我们可以使用lockInterruptibly操作来进行锁的获取，打断后将其从阻塞队列中移除。</p><p>下面的代码中，主线程先获取到锁，然后启动thread1。由于主线程一直没有释放锁，因此thread1会一直阻塞在锁上。然后主线程打断thread1，通过异常捕获机制可以将thread1停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">myLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;尝试获取锁&quot;</span>);<br>        myLock.lockInterruptibly();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        log.debug(<span class="hljs-string">&quot;没有获取到锁，被打断，直接返回&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获取到锁&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>        myLock.unlock();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;thread1&quot;</span>);<br><br>myLock.lock();<br>thread1.start();<br>Thread.sleep(<span class="hljs-number">500</span>);<br>log.debug(<span class="hljs-string">&quot;打断thread1&quot;</span>);<br>thread1.interrupt();<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">15</span>:<span class="hljs-number">12</span>:<span class="hljs-number">41.195</span> <span class="hljs-selector-attr">[thread1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - 尝试获取锁<br><span class="hljs-number">15</span>:<span class="hljs-number">12</span>:<span class="hljs-number">41.697</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.ThreadTest</span> - 打断thread1<br><span class="hljs-number">15</span>:<span class="hljs-number">12</span>:<span class="hljs-number">41.697</span> <span class="hljs-selector-attr">[thread1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - 没有获取到锁，被打断，直接返回<br></code></pre></td></tr></table></figure><h3 id="尝试获取锁">尝试获取锁</h3><p>Lock接口中提供操作进行尝试获取锁，返回是否获取成功。我们可以通过if判断进行锁的获取。</p><p>普通的<code>tryLock()</code>：下面的代码在tryLock的时候，主线程并没有释放锁，因此thread1无法获得锁，因此直接从else代码块退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">myLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (myLock.tryLock()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;获取到锁&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>            myLock.unlock();<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        log.debug(<span class="hljs-string">&quot;没有获取到锁&quot;</span>);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;thread1&quot;</span>);<br><br>myLock.lock();<br>log.debug(<span class="hljs-string">&quot;获取锁&quot;</span>);<br>thread1.start();<br>Thread.sleep(<span class="hljs-number">500</span>);<br>log.debug(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>myLock.unlock();<br></code></pre></td></tr></table></figure><p>带时限的<code>tryLock(long time, TimeUnit unit)</code>：下面的代码我们设置了时限为1s。由于在thread1启动的1s之内，主线程释放了锁，那么thread1是能够最终获取到锁的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">myLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (myLock.tryLock(<span class="hljs-number">1</span>,TimeUnit.SECONDS)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;获取到锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>                myLock.unlock();<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            log.debug(<span class="hljs-string">&quot;没有获取到锁&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br><br>&#125;, <span class="hljs-string">&quot;thread1&quot;</span>);<br><br>myLock.lock();<br>log.debug(<span class="hljs-string">&quot;获取锁&quot;</span>);<br>thread1.start();<br>Thread.sleep(<span class="hljs-number">500</span>);<br>log.debug(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>myLock.unlock();<br></code></pre></td></tr></table></figure><h3 id="条件变量">条件变量</h3><p>在使用synchronized的过程中，我们说调用wait方法可以让线程进入WaitSet进行等待。Lock接口中提供的条件变量就可以类比WaitSet。但是在synchronized中，同一个锁的wait方法进入的都是一个WaitSet，而在Lock中可以使用多个条件变量，实现更加精确的划分。条件变量上的等待和唤醒分别对应await和signal方法</p><p>获取Condition对象：<code>public Condition newCondition()</code></p><p>Condition 类 API：</p><ul><li><code>void await()</code>：当前线程从运行状态进入等待状态，释放锁</li><li><code>void signal()</code>：唤醒一个等待在 Condition上的线程，但是必须获得与该 Condition 相关的锁</li></ul><p>使用流程：</p><ol type="1"><li>使用 await / signal前都需要获得锁，只有获得锁的线程才能调用这些方法</li><li>线程执行 await之后，会释放锁进入ConditionObject等待</li><li>线程被 signal唤醒之后，重新竞争Lock锁</li><li>线程在条件对象队列中被打断会抛出中断异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">myLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition1</span> <span class="hljs-operator">=</span> myLock.newCondition();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition2</span> <span class="hljs-operator">=</span> myLock.newCondition();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        myLock.lock();<br>        log.debug(<span class="hljs-string">&quot;获取锁，在condition1上等待&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition1.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;被唤醒&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        myLock.unlock();<br>        log.debug(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;thread1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        myLock.lock();<br>        log.debug(<span class="hljs-string">&quot;获取锁，在condition2上等待&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition2.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;被唤醒&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        myLock.unlock();<br>        log.debug(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;thread2&quot;</span>).start();<br><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>myLock.lock();<br>log.debug(<span class="hljs-string">&quot;唤醒condition1&quot;</span>);<br>condition1.signal();<br>myLock.unlock();<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>myLock.lock();<br>log.debug(<span class="hljs-string">&quot;唤醒condition2&quot;</span>);<br>condition2.signal();<br>myLock.unlock();<br></code></pre></td></tr></table></figure><p>输出如下：通过多个条件变量我们可以实现更加细粒度的唤醒。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">42.203</span> <span class="hljs-selector-attr">[thread1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - 获取锁，在condition1上等待<br><span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">42.219</span> <span class="hljs-selector-attr">[thread2]</span> c<span class="hljs-selector-class">.ThreadTest</span> - 获取锁，在condition2上等待<br><span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">43.218</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.ThreadTest</span> - 唤醒condition1<br><span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">43.218</span> <span class="hljs-selector-attr">[thread1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - 被唤醒<br><span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">43.218</span> <span class="hljs-selector-attr">[thread1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - 释放锁<br><span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">44.219</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.ThreadTest</span> - 唤醒condition2<br><span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">44.219</span> <span class="hljs-selector-attr">[thread2]</span> c<span class="hljs-selector-class">.ThreadTest</span> - 被唤醒<br><span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">44.219</span> <span class="hljs-selector-attr">[thread2]</span> c<span class="hljs-selector-class">.ThreadTest</span> - 释放锁<br></code></pre></td></tr></table></figure><h1 id="aqs">AQS</h1><h2 id="概述-1">概述</h2><p>我们前面也提到了Lock本身只是一个接口，规定了阻塞式锁需要提供的相关操作，但是一个可用的锁还是需要落到具体实现上。</p><p>AQS，全称<code>AbstractQueuedSynchronizer</code>，抽象队列同步器，是阻塞式锁和相关同步器工具的框架，它作为抽象父类，向我们提供了一些模板方法。通过AQS我们可以较为方便地实现Lock接口中的抽象方法，Lock接口的实现类基本都是通过聚合了一个同步器的子类来完成线程访问控制的</p><blockquote><p><strong>AQS是实现锁或者其他同步组件的关键</strong>，在锁的实现中聚合同步器，利用同步器来实现锁的语义。</p><ul><li>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节</li><li>同步器面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程排队、等待与唤醒等底层操作</li></ul></blockquote><p>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法，来管理同步状态。继承得到的同步器被组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p><p>AQS的主要思想如下：</p><ul><li>使用state属性来表示资源的状态（分为独占模式和共享模式），这是一个int型整数，子类需要定义如何维护这个状态，如何获取锁和释放锁。<ul><li>对这个状态的操作使用AQS中提供的三个方法（getState、setState、compareAndSetState）</li><li>独占模式：只有一个线程能够访问资源</li><li>共享模式：允许多个线程访问资源</li></ul></li><li>提供了基于FIFO的等待队列，类似于Monitor的EntryList</li><li>使用条件变量来实现等待唤醒机制，支持多个条件变量，类似于Monitor的WaitSet</li></ul><h2 id="原理简述">原理简述</h2><p>AQS的原理与Monitor类似，包括同步队列，等待队列等机制。</p><p>AQS利用内部的同步队列来完成<strong>同步状态的管理</strong>。</p><ul><li>AQS中的内部类Node即为其中的节点，用来保存获取锁失败的线程引用、等待状态以及前驱后继节点、等待状态等。</li><li>如果当前线程获取锁失败之后，同步器会将当前线程以及等待状态等信息构造程一个节点（Node）并将其加入同步队列，同时阻塞当前线程。当锁释放之后，会将首节点中的线程唤醒，使其再次尝试获取锁。</li><li>同步队列是双向链表，便于出队入队</li><li>条件队列（或等待队列，WaitSet）是单向链表</li></ul><p>AQS利用state属性来完成<strong>锁状态的表示</strong>。</p><ul><li>state是一个32位的整数，利用volatile修饰，配合CAS来保证其修改时的原子性</li><li>在独占模式下，state表示线程重入的次数；在共享模式下，state表示剩余的许可数</li></ul><h2 id="可重写的方法">可重写的方法</h2><p>AQS使用了模板方法模式，继承AQS的自定义同步器可以重写的方法如下，默认情况下下面的方法都是直接抛出<code>UnsupportedOperationException</code>。</p><p>在实现方法的过程中，需要注意这些方法的实现必须是内部线程安全的</p><table><thead><tr class="header"><th>方法名称</th><th>语义描述</th></tr></thead><tbody><tr class="odd"><td>protected boolean tryAcquire(int arg)</td><td>独占式获取锁<br />该方法的实现需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</td></tr><tr class="even"><td>protected boolean tryRelease(int arg)</td><td>独占式释放锁。等待获取同步锁的线程将有机会获取同步状态</td></tr><tr class="odd"><td>protected int tryAcquireShared(int arg)</td><td>共享式获取锁<br />返回大于等于0的值则表示获取成功，反之则表示获取失败</td></tr><tr class="even"><td>protected boolean tryReleaseShared(int arg)</td><td>共享式释放锁</td></tr><tr class="odd"><td>protected boolean isHeldExclusively()</td><td>判断当前的锁是否被占用。一般用来判断是否被当前线程所独占</td></tr></tbody></table><h2 id="提供的模板方法">提供的模板方法</h2><p>实现自定义同步组件的时候，会调用同步器提供的模板方法，常用的模板方法如下：</p><table><thead><tr class="header"><th>方法名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>void acquire(int arg)</td><td>独占式获取锁。<br />如果当前线程获取同步状态成功，则由该方法返回，否则将会进入同步队列等待。该方法会调用重写的tryAcquire(intarg)方法</td></tr><tr class="even"><td>void acquireInterruptibly(int arg)</td><td>与acquire(intarg)相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException返回</td></tr><tr class="odd"><td>boolean tryAcquireNanos(int arg, long nanos)</td><td>在acquireInterruptibly(int arg)基础上增加了超时限制</td></tr><tr class="even"><td>void acquireShared(int arg)</td><td>共享式获取锁。与独占式获取的主要区别是在同一时刻可以有多个线程获取到锁</td></tr><tr class="odd"><td>void acquireSharedInterruptibly(int arg)</td><td>与acquireShared(int arg)相同，该方法响应中断</td></tr><tr class="even"><td>boolean tryAcquireSharedNanos(int arg, long nanos)</td><td>在acquireSharedInterruptibly(int arg)的基础上增加了超时限制</td></tr><tr class="odd"><td>boolean release(int arg)</td><td>独占式释放锁。释放锁之后会将同步队列中第一个节点包含的线程唤醒</td></tr><tr class="even"><td>boolean releaseShared(int arg)</td><td>共享式释放锁</td></tr><tr class="odd"><td>Collection&lt;Thread&gt; getQueuedThreads()</td><td>获取等待在同步队列上的线程集合</td></tr></tbody></table><h2 id="示例自定义不可重入锁实现">示例：自定义不可重入锁实现</h2><p>利用AQS，我们可以尝试实现一个自定义的不可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义锁(不可重入锁)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-comment">// 自定义同步器(继承AQS)</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-comment">// 利用state来表示锁状态，如果将state从0修改为1，表示获取锁成功</span><br>            <span class="hljs-comment">// state为0表示没有线程持有锁，为1表示有线程得到锁</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">// 将Owner设置为当前线程</span><br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>); <span class="hljs-comment">// volatile 修饰的变量放在后面，防止指令重排</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">MySync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySync</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程笔记(5)-线程池的使用</title>
    <link href="/2022/09/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="线程池概述">线程池概述</h1><p>线程池指的是一种容纳多个线程的容器。线程池中的线程可以重复使用，省去了频繁创建和销毁对象的操作。线程池的核心思想在于线程的复用，一个线程可以被重复使用，用来处理多个任务。线程池有以下的作用：</p><ol type="1"><li>降低资源消耗。减少了创建和销毁线程的次数，使得创建出来的工作线程得到重复利用</li><li>提高系统的响应速度。当有任务来临的时候，可以直接使用线程池中的线程，而不用等待线程的创建</li><li>提高线程的可管理性。使用线程池可以对线程进行统一的分配，管理和监控</li></ol><p>Java中的线程池，基本的继承关系如下，其中的不同部分会在后续进行说明</p><img src="/2022/09/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" class="" title="线程池继承关系"><h1 id="threadpoolexecutor">ThreadPoolExecutor</h1><p>ThreadPoolExecutor是Java中提供的线程池类，通过这个类我们可以很容易地创建出一个线程池。</p><h2 id="线程池创建">线程池创建</h2><h3 id="构造方法">构造方法</h3><p>ThreadPoolExecutor中完整的构造方法如下所示，其中一共有7个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><p>不同参数对应线程池工作流程中的不同过程，我们首先描述线程池的工作流程。</p><ol type="1"><li>线程池中刚开始没有线程，当一个任务提交给线程池之后，线程池会创建一个新线程来执行任务</li><li>当一个线程完成任务之后，会从队列中取得下一个任务来执行</li><li>当线程数达到<code>corePoolSize</code>并且没有线程空闲，这时候再加入任务，新增加的任务会被加入阻塞队列<code>workQueue</code>中排队，直到有空闲的线程</li><li>如果队列选择了有界队列，那么任务数量超过队列大小时，会创建<code>maximumPoolSize - corePoolSize</code>数目的线程来救急</li><li>如果线程数目已经达到了<code>maximumPoolSize</code>，仍然有新任务，这时候会执行拒绝策略</li><li>当高峰过去之后，超过<code>corePoolSize</code>的救急线程如果一段时间内没有任务执行，那么需要结束来节省资源。这个时间由<code>keepAliveTime</code>和<code>unit</code>来控制</li><li>至于线程工厂参数<code>threadFactory</code>，主要还是用来创建新线程以及进行新线程的命名</li></ol><blockquote><p>提交任务的优先级：核心线程 &gt; 阻塞队列 &gt; 救急线程</p><p>执行任务的优先级：核心线程 &gt; 救急线程 &gt; 阻塞队列</p></blockquote><blockquote><p>线程池中的任务被包装成一个内部类Worker，其中的线程都存储在一个HashSet中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Worker&gt;();<br></code></pre></td></tr></table></figure></blockquote><h3 id="阻塞队列">阻塞队列</h3><p>阻塞队列与普通队列的不同点在于阻塞队列中提供了阻塞添加以及阻塞删除方法，并且能够保证线程安全</p><ul><li>阻塞添加put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行</li><li>阻塞删除take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作（一般会返回被删除的元素)</li></ul><p>核心方法如下：</p><table><thead><tr class="header"><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr class="odd"><td>插入（尾部）</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr class="even"><td>移除（头部）</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr class="odd"><td>检查（队首元素）</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li>抛出异常组：<ul><li>当阻塞队列满时，往队列中 add 插入元素会抛出异常</li><li>当阻塞队列空时，从队列中 remove 移除元素会抛出异常</li></ul></li><li>特殊值组：<ul><li>插入方法：返回是否插入成功，成功插入返回true，否则false</li><li>移除方法：如果成功则返回出队列元素，队列没有就返回 null</li></ul></li><li>阻塞组：<ul><li>当阻塞队列满时，生产者继续往队列里 put元素，队列会一直阻塞生产线程直到队列有空间 put 数据或响应中断退出</li><li>当阻塞队列空时，消费者线程试图从队列里 take元素，队列会一直阻塞消费者线程直到队列中有可用元素</li></ul></li><li>超时退出：插入和移除不满足条件时，会等待一定时间</li></ul><p>阻塞队列又可以分为有界队列和无界队列：</p><ul><li>有界队列：指的是有固定大小的队列</li><li>无界队列：没有设置固定大小的队列，可以直接将元素入队直到溢出（最大值为<code>Integer.MAX_VALUE</code>）</li></ul><blockquote><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p><ul><li>ArrayBlockQueue：由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：由链表结构组成的无界（默认大小Integer.MAX_VALUE）的阻塞队列，当然也支持指定大小成为有界队列</li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayedWorkQueue：使用优先级队列实现的延迟无界阻塞队列</li><li>SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个put 的线程放入元素为止</li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li></ul></blockquote><h3 id="拒绝策略">拒绝策略</h3><p>拒绝策略在Java中对应的是<code>RejectExecutionHandler</code>接口，这个接口中只有下面一个抽象方法，其中实现具体的拒绝策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span>;<br></code></pre></td></tr></table></figure><p>在JDK中也给我们提供了下面4个实现：</p><ul><li><code>AbortPolicy</code>：默认策略，让调用者抛出<code>RejectedExecutionExecption</code>异常</li><li><code>CallerRunsPolicy</code>：让调用者来执行任务</li><li><code>DiscardPolicy</code>：放弃本次任务的执行</li><li><code>DiscardOldestPolicy</code>：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交当前任务</li></ul><h3 id="executors工具类">Executors工具类</h3><p>在Executors工具类中，给我们提供了许多模式的线程池创建方式。当然实际上只是对ThreadPoolExecutor类的创建方法进行了一层封装。常见的线程池有下面三种：</p><p><code>newFixedThreadPool</code>：固定线程数目的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>核心线程数=最大线程数，无救急线程，从而也不需要超时时间</li><li>阻塞队列为<code>LinkedBlockingQueue</code>，无界，默认大小为<code>Integer.MAX_VALUE</code>，可以存放任意数量的任务，在任务比较多的时候会造成内存溢出OOM</li><li>适用于任务量已知，相对耗时的长期任务</li></ul><p><code>newCachedThreadPool</code>：带有缓冲的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>核心线程数为0，最大线程数为<code>Integer.MAX_VALUE</code>，即创建的所有线程都是救急线程</li><li>救急线程的存活时间为60s</li><li>可能出现一次性创建大量线程的情况，导致内存溢出OOM</li><li>阻塞队列为<code>SynchronousQueue</code>，没有容量，对于每一个执行take的线程，会阻塞到有一个put线程放入元素位置</li><li>适合任务数量比较密集，但是每个任务执行时间较短的情况</li></ul><p><code>newSingleThreadExecutor</code>：只有一个线程的单线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>线程池中的线程数固定为1，保证所有任务按照指定顺序执行</li><li>阻塞队列为<code>LinkedBlockingQueue</code>，无界队列。任务数多于1的时候，多余任务会放入无界队列中排队</li><li>任务执行完毕，唯一的线程也不会释放</li></ul><blockquote><p><code>newSingleThreadExecutor()</code> 对比 单线程：</p><ul><li>单线程可以保证串行执行任务，但是如果任务执行失败则没有任何补救措施</li><li><code>SingleThreadExecutor</code>则会新建一个线程，保证线程池的正常工作</li></ul><p><code>newSingleThreadExecutor()</code> 对比<code>newFiexdThreadPool(1)</code>：</p><ul><li><code>newSingleThreadExecutor()</code>线程个数始终为1，不能修改。这是因为它的方法中使用了<code>FinalizableDelegatedExecutorService</code>进行包装，对外只暴露了<code>ExecutorService</code>接口</li><li><code>newFiexdThreadPool(1)</code>初始创建线程池中线程个数为1，但是可以进行修改。因为它的方法中暴露的是<code>ThreadPoolExecutor</code>对象，其中提供了<code>setCorePoolSize</code>方法</li></ul></blockquote><h2 id="线程池使用">线程池使用</h2><h3 id="任务提交">任务提交</h3><p>线程任务可以是Runnable或者Callable，二者的区别在于Runnable没有返回值，不能抛出异常；而Callable支持返回值和泛型，可以抛出异常。</p><p>线程池中任务提交相关的API如下所示：</p><table><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>void execute(Runnable command)</td><td>执行Runnable类型任务</td></tr><tr class="even"><td>Future&lt;?&gt; submit(Runnable task)</td><td>提交任务 task</td></tr><tr class="odd"><td>Future submit(Callable<T> task)</td><td>提交任务 task，用返回值 Future 获得任务执行结果</td></tr><tr class="even"><td>List&lt;Future<T>&gt; invokeAll(Collection&lt;? extendsCallable<T>&gt; tasks)</td><td>提交tasks任务列表中的所有任务，返回任务执行结果Future组成的列表</td></tr><tr class="odd"><td>List&lt;Future<T>&gt; invokeAll(Collection&lt;? extendsCallable<T>&gt; tasks, long timeout, TimeUnit unit)</td><td>提交 tasks中所有任务，返回任务执行结果Future组成的列表。<br />可以设置超时时间。超时会取消提交列表中没有执行完的任务，并抛出超时异常</td></tr><tr class="even"><td>T invokeAny(Collection&lt;? extends Callable<T>&gt; tasks)</td><td>提交 tasks中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</td></tr></tbody></table><blockquote><p>execute对比submit：</p><ul><li>二者都是线程池中提交任务的方法</li><li>execute只能执行Runnable类型的任务，没有返回值。会直接抛出任务执行过程时的异常</li><li>submit既能够提交Runnable类型的任务，也能够提交Callable类型的任务，底层是封装成FutureTask，然后调用execute来执行。在执行过程中会吞掉异常，通过FutureTask的get方法可以将任务执行时的异常重新抛出</li></ul></blockquote><h3 id="线程池关闭">线程池关闭</h3><table><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>void shutdown()</td><td>将线程池状态变为SHUTDOWN，等待任务执行完后关闭线程池，不会接收新任务，但已提交任务会执行完。<br />调用该方法的线程不会被阻塞</td></tr><tr class="even"><td>List<Runnable> shutdownNow()</td><td>将线程池状态变为 STOP，用 interrupt中断正在执行的任务，直接关闭线程池，并将队列中的任务返回</td></tr><tr class="odd"><td>boolean isShutdown()</td><td>判断线程池的状态，如果是SHUTDOWN则返回 true</td></tr><tr class="even"><td>boolean isTerminated()</td><td>判断线程池的状态，如果是TERMINATED则返回true</td></tr><tr class="odd"><td>boolean awaitTermination(long timeout, TimeUnit unit)</td><td>调用 shutdown后，调用线程不会阻塞等待所有任务运行结束<br />如果它想在线程池TERMINATED 后做些事情，可以利用此方法等待</td></tr></tbody></table><h2 id="线程池状态">线程池状态</h2><p>在ThreadPoolExecutor中使用一个<code>AtomicInteger</code>来保存线程池的相关状态，其中高3位表示线程池的状态，低29位表示线程的数量。</p><blockquote><p>使用一个原子整数将状态和数量保存在一起，为的是减少CAS的操作次数，只用一次CAS原子操作就可以进行赋值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><p>这些状态说明如下：</p><table><thead><tr class="header"><th>状态</th><th>高3位</th><th>接收新任务</th><th>处理阻塞任务队列</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr class="even"><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不接收新任务，但处理阻塞队列剩余任务</td></tr><tr class="odd"><td>STOP</td><td>001</td><td>N</td><td>N</td><td>中断正在执行的任务，并抛弃阻塞队列中的任务</td></tr><tr class="even"><td>TIDYING</td><td>010</td><td>-</td><td>-</td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr class="odd"><td>TERMINATED</td><td>011</td><td>-</td><td>-</td><td>终止状态</td></tr></tbody></table><h2 id="注意事项">注意事项</h2><h3 id="使用注意">使用注意</h3><p>在线程池的使用方面，阿里巴巴Java开发手册中有如下两点相关要求：</p><ol type="1"><li>线程资源必须通过线程池来提供，不允许在应用中自行显式创建线程</li><li>线程池不允许使用Executors工具类去创建，而应该通过ThreadPoolExecutor来创建，明确指定线程池的运行规则，规避资源耗尽的风险</li></ol><p>第一点使用线程池而非线程。使用线程池的好处是能够减少创建和销毁线程的消耗，降低系统资源的开销。如果不使用线程池，有可能造成系统创建大量同类线程而导致内存耗尽或者切换频繁的问题</p><p>第二点使用ThreadPoolExecutor，明确各个参数以及运行规则。因为Executors返回的线程池对象中一些参数是固定的，例如无界的阻塞队列，可能造成大量线程的创建，导致OOM</p><h3 id="线程数目设置">线程数目设置</h3><p>如果线程池线程数量太小，有大量请求需要处理的时候，系统的响应就会很慢，甚至可能出现任务队列大量堆积任务导致内存溢出的情况；如果线程池线程数量太多，大量线程争取CPU资源，导致大量的上下文切换，影响效率</p><p>对于CPU密集型任务来说，一般设置为N+1。N为CPU核数。多出来的一个线程可以在某些线程阻塞的时候顶上，充分利用空闲时间；对于IO密集型任务来说，一般设置为2N。频繁出现IO阻塞的话，可以多配置一些线程来利用CPU</p><h1 id="scheduledthreadpoolexecutor">ScheduledThreadPoolExecutor</h1><h2 id="任务调度">任务调度</h2><p>我们程序的一种需求是能够定时执行，定时执行可以通过一些脚本来实现，但是Java中也提供了一些类有对应的功能。ScheduledThreadPoolExecutor就是其中一种。在介绍调度线程池之前，我们可以简单了解一下在它出现之前，Java中用来定时执行任务的类Timer</p><p>Timer可以实现定时功能，它简单易用，但是由于所有的任务都是通过同一个线程来调度，因此所有的任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响之后的任务。（加入Timer执行的任务需要封装成TimerTask）</p><p>如下面的代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br><span class="hljs-type">TimerTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-type">TimerTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;task2&quot;</span>);<br>    &#125;<br>&#125;;<br>timer.schedule(task1, <span class="hljs-number">1000</span>);<br>timer.schedule(task2, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>正常情况输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">35.621</span> <span class="hljs-selector-attr">[Timer-0]</span> c<span class="hljs-selector-class">.ThreadTest</span> - task1<br><span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">35.621</span> <span class="hljs-selector-attr">[Timer-0]</span> c<span class="hljs-selector-class">.ThreadTest</span> - task2<br></code></pre></td></tr></table></figure><p>如果任务1中出现异常，会影响任务2的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在任务1中添加</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>输出报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">20</span>:<span class="hljs-number">49</span>:<span class="hljs-number">36.887</span> <span class="hljs-selector-attr">[Timer-0]</span> c<span class="hljs-selector-class">.ThreadTest</span> - task1<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;Timer-0&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArithmeticException</span>: / by zero<br>at ThreadTest$<span class="hljs-number">1</span><span class="hljs-selector-class">.run</span>(ThreadTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">20</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.TimerThread</span><span class="hljs-selector-class">.mainLoop</span>(Timer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">555</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.TimerThread</span><span class="hljs-selector-class">.run</span>(Timer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">505</span>)<br></code></pre></td></tr></table></figure><p>如果任务1中出现延迟，也会影响任务2的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在任务1中添加</span><br>Thread.sleep(<span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><p>输出如下：但是我们希望任务2是从当前延时1000ms后执行，这里被任务1的延时影响了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">20</span>:<span class="hljs-number">50</span>:<span class="hljs-number">23.973</span> <span class="hljs-selector-attr">[Timer-0]</span> c<span class="hljs-selector-class">.ThreadTest</span> - task1<br><span class="hljs-number">20</span>:<span class="hljs-number">50</span>:<span class="hljs-number">25.985</span> <span class="hljs-selector-attr">[Timer-0]</span> c<span class="hljs-selector-class">.ThreadTest</span> - task2<br></code></pre></td></tr></table></figure><h2 id="调度线程池概述">调度线程池概述</h2><p>调度线程池ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，通过创建线程来执行定时任务，解决了上面使用Timer过程中可能遇到的问题</p><p>构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用内部类 ScheduledFutureTask 封装任务</li><li>使用内部类 DelayedWorkQueue 作为线程池队列</li></ul><h2 id="常用方法">常用方法</h2><p><code>ScheduledFuture&lt;?&gt; schedule(Runnable/Callable&lt;V&gt;, long delay, TimeUnit u)</code>：<strong>延迟执行任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">poolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">2</span>);<br>poolExecutor.schedule(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    log.debug(<span class="hljs-string">&quot;task 1&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>&#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>poolExecutor.schedule(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;task 2&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure><p>输出如下：任务1的异常和延时并不会影响其他任务。（异常不会在控制台上打印）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">21</span>:<span class="hljs-number">04</span>:<span class="hljs-number">00.987</span> <span class="hljs-selector-attr">[pool-1-thread-2]</span> c<span class="hljs-selector-class">.ThreadTest</span> - task <span class="hljs-number">2</span><br><span class="hljs-number">21</span>:<span class="hljs-number">04</span>:<span class="hljs-number">02.994</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - task <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable/Callable&lt;V&gt;, long initialDelay, long period, TimeUnit unit)</code>：定时<strong>执行周期任务</strong>，不考虑执行的耗时，参数为初始延迟时间、间隔时间、时间单位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">poolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;start&quot;</span>);<br>poolExecutor.scheduleAtFixedRate(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>输出如下：执行耗时大于周期间隔，发现2s执行一次：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">49.291</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.ThreadTest</span> - start<br><span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">50.352</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">52.366</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">54.379</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">56.380</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">58.388</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">07</span>:<span class="hljs-number">00.403</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">07</span>:<span class="hljs-number">02.416</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">07</span>:<span class="hljs-number">04.422</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br></code></pre></td></tr></table></figure><p><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable/Callable&lt;V&gt;, long initialDelay, long delay, TimeUnit unit)</code>：定时<strong>执行周期任务</strong>，考虑执行的耗时，参数为初始延迟时间、间隔时间、时间单位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">poolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;start&quot;</span>);<br>poolExecutor.scheduleWithFixedDelay(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>输出如下：执行耗时大于周期间隔，发现3s执行一次：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">06.562</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.ThreadTest</span> - start<br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">07.619</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">10.635</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">13.662</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">16.677</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">19.699</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">22.713</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">25.743</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - running...<br></code></pre></td></tr></table></figure><blockquote><p>scheduleAtFixedRate 对比 scheduleWithFixedDelay：</p><ul><li>前者的间隔时间和执行耗时是同时计算的，如果执行耗时大于间隔时间，则等到执行完毕后就会立即执行下一个周期，不会再次等待</li><li>后者的间隔时间和执行耗时是先后计算的，执行完毕之后再计算间隔，间隔之后再执行下一个周期</li></ul></blockquote><h1 id="fork-join-线程池">Fork-Join 线程池</h1><h2 id="概述">概述</h2><p>Fork-Join是JDK1.7加入的新的线程池的实现，它体现的是一种分治思想，适用于能够进行任务拆分的CPU密集型运算。所谓的任务拆分，就是将一个大任务拆分成算法上相同的小任务，直至不能拆分，可以直接求解。与递归相关的一些计算，如归并排序，斐波那契数列等，都可以用分治思想进行求解。</p><p>Fork-Join在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率。</p><ul><li>Fork-Join使用ForkJoinPool来启动，这是一个特殊的线程池，默认会创建与CPU核心数大小相同的线程池</li><li>提交给ForkJoinPool任务需要继承RecursiveTask（有返回值）或RecursiveAction（没有返回值）</li></ul><h2 id="使用示例">使用示例</h2><p>利用ForkJoinPool来完成1~n的累加，我们需要提交对应的任务类task，并且这个任务类需要继承RecursiveTask或者RecursiveAction，在类中重写计算逻辑，在计算逻辑中进行分治的拆分和结果合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">3</span>);<br>    log.debug(<span class="hljs-string">&quot;result: &#123;&#125;&quot;</span>, forkJoinPool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> start;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> end;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;compute from &#123;&#125; to &#123;&#125;&quot;</span>, start, end);<br>        <span class="hljs-comment">// 按照二分进行拆分</span><br>        <span class="hljs-keyword">if</span> (start == end) &#123;<br>            <span class="hljs-keyword">return</span> start;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start + <span class="hljs-number">1</span> == end) &#123;<br>            <span class="hljs-keyword">return</span> start + end;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// fork</span><br>            <span class="hljs-type">MyTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(start, mid);<br>            <span class="hljs-type">MyTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(mid + <span class="hljs-number">1</span>, end);<br>            task1.fork();<br>            task2.fork();<br><br>            <span class="hljs-comment">// join</span><br>            <span class="hljs-keyword">return</span> task1.join() + task2.join();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：其中，每次新建的MyTask相当于加入线程池中的任务，可能由线程池中任一线程来执行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">32.889</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - compute from <span class="hljs-number">1</span> to <span class="hljs-number">5</span><br><span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">32.889</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - compute from <span class="hljs-number">1</span> to <span class="hljs-number">3</span><br><span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">32.889</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-1]</span> c<span class="hljs-selector-class">.ThreadTest</span> - compute from <span class="hljs-number">1</span> to <span class="hljs-number">2</span><br><span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">32.889</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-3]</span> c<span class="hljs-selector-class">.ThreadTest</span> - compute from <span class="hljs-number">4</span> to <span class="hljs-number">5</span><br><span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">32.889</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-2]</span> c<span class="hljs-selector-class">.ThreadTest</span> - compute from <span class="hljs-number">3</span> to <span class="hljs-number">3</span><br><span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">32.889</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.ThreadTest</span> - result: <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><blockquote><p>由于这种方式需要用户自定义实现分治和合并操作，仍然有一定的门槛，后续Java提供了StreamAPI，其中的并行流也可以达到类似的效果</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程笔记(4)-CAS与Atomic原子类</title>
    <link href="/2022/09/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-4-CAS%E4%B8%8EAtomic%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
    <url>/2022/09/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-4-CAS%E4%B8%8EAtomic%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="cas">CAS</h1><p>CAS，全称为Compare-And-Set /Compare-And-Swap，它是一个CPU并发原语，保证其是一个原子操作</p><p>CAS完成一个变量的交换操作，需要提供变量的预期值A以及设置值B，然后进行CAS原子操作。CAS会先检测当前变量的值是否是预期值A，如果是就将其赋值为设置值B，如果不是则交换失败，对变量不做其他操作</p><p><strong>CAS的操作必须需要借助volatile</strong>，读取到共享变量的最新值，来实现比较并交换的效果。并且在使用的时候，通常会配合while使用，通过自旋+CAS来实现无锁并发的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自旋+CAS实现无锁并发的伪代码</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> xxx;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> yyy;<br>    CAS(target, prev, next);<br>&#125;<br></code></pre></td></tr></table></figure><p>结合CAS和volatile可以实现无锁并发，基于乐观锁的思想，适用于线程数少，多核CPU的场景下，最好不要超过CPU的核心数。因为没有使用synchronzied，所以线程不会陷入阻塞，这也是效率提升的因素之一。但是如果竞争激烈，可以想到的是重试必然频繁发生，效率反而受到影响</p><p>CAS本身也有一些缺点：</p><ul><li>循环时间长，开销大。如果CAS比较不成功会一直空转，在竞争激烈的情况下会导致效率很低。因此在使用CAS的时候，最好线程数不要超过CPU的核心数</li><li>CAS只能保证一个共享变量的原子操作，如果对于多个共享变量，循环+CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性</li><li>ABA问题。考虑如下场景，线程1希望将共享变量从A修改成C，但是过程中有其他线程先将这个共享变量从A修改成了B，又将其从B修改成了A，线程1仍然能够达到修改效果，但是期间有其他线程修改了共享变量，和我们的预期效果有所不符。这个问题可以通过增加版本来解决，在后续的原子引用中会继续提到</li></ul><p>Java中的CAS，底层都是通过<code>sun.misc.Unsafe</code>类来完成的。在Unsafe类中提供了一个单例的Unsafe对象，其中的所有方法都是native方法，直接调用操作系统底层资源执行相应的任务</p><p>这里，Unsafe指的并不是线程安全，而是说这个类是直接调用操作系统底层的资源，因此不建议程序员直接使用。在Unsafe类中的单例对象也是使用了private进行修饰，无法直接获得，但是可以通过反射进行获取</p><p>Unsafe类中，提供的与CAS相关的方法有<code>getAndSetInt</code>，<code>getAndSetLong</code>，<code>getAndSetObject</code></p><h1 id="原子类">原子类</h1><p>利用循环+CAS机制可以实现无锁并发，但是如果由程序员直接使用的话会较为复杂，因此Java中也封装了一些比较方便的方法。<code>java.util.concurrent.atomic</code>包提供了许多利用CAS机制实现的原子类和工具类，这些类可以保证不同共享变量的原子性</p><h2 id="原子基本类型">原子基本类型</h2><p>原子基本类型可以保证基本类型的原子性，常用的类有<code>AtomicInteger</code>、<code>AtomicBoolean</code>、<code>AtomicLong</code>，下面简单介绍其中原子整数的使用</p><p>构造方法：</p><ul><li><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型Integer</li><li><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型Integer</li></ul><p>常用API：</p><table><thead><tr class="header"><th>方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>public final int get()</td><td>获取 AtomicInteger 的值</td></tr><tr class="even"><td>public final boolean compareAndSet(int expect, int update)</td><td>原子方式CAS，判断当前元素值是否是expect<br />如果是则将其设置为update并返回true，否则返回false</td></tr><tr class="odd"><td>public final int getAndIncrement()</td><td>以原子方式将当前值加 1，返回的是自增前的值</td></tr><tr class="even"><td>public final int incrementAndGet()</td><td>以原子方式将当前值加 1，返回的是自增后的值</td></tr><tr class="odd"><td>pubilc final int getAndDecrement()</td><td>以原子方式将当前值减1，返回的是自减前的值</td></tr><tr class="even"><td>public final int decremantAndGet()</td><td>以原子方式将当前值减1，返回的是自减后的值</td></tr><tr class="odd"><td>public final int getAndSet(int value)</td><td>以原子方式设置为 newValue 的值，返回旧值</td></tr><tr class="even"><td>public final int addAndGet(int data)</td><td>以原子方式将输入的数值与实例中的值相加并返回</td></tr><tr class="odd"><td>public final int getAndUpdate(IntUnaryOperator updateFunction)</td><td>提供一个函数式接口，描述对元素值的操作，以原子方式进行操作<br />返回旧值</td></tr><tr class="even"><td>public final int updateAndGet(IntUnaryOperator updateFunction)</td><td>提供一个函数式接口，描述对元素值的操作，以原子方式进行操作<br />返回进行操作后的值</td></tr></tbody></table><h2 id="原子引用">原子引用</h2><p>如果需要保证一个对象的原子性，则需要使用原子引用类。原子引用类可以对某个对象进行原子操作。常用的原子引用类有<code>AtomicReference</code>、<code>AtomicMarkableReference</code>、<code>AtomicStampedReference</code></p><p>AtomicReference类的使用：</p><ul><li><p>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></p></li><li><p>常用 API：</p><ul><li><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS操作</li><li><code>public final void set(V newValue)</code>：将值设置为newValue</li><li><code>public final V get()</code>：返回当前值</li></ul></li></ul><p>前面我们提到了CAS中会存在的ABA问题，我们可以使用版本号来解决这种问题。<code>AtomicStampedReference</code>类就是带版本的原子类。考虑下面的代码，模拟ABA问题的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 打印初始状态</span><br>    log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">startStamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>    log.debug(<span class="hljs-string">&quot;当前状态: ref:&#123;&#125;, stamp:&#123;&#125;&quot;</span>, prev, startStamp);<br><br>    <span class="hljs-comment">// thread1先将A修改成B</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>        log.debug(<span class="hljs-string">&quot;change A-&gt;B:&#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nowStamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>        log.debug(<span class="hljs-string">&quot;stamp:&#123;&#125;-&gt;&#123;&#125;&quot;</span>, stamp, nowStamp);<br>    &#125;, <span class="hljs-string">&quot;thread1&quot;</span>).start();<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    <span class="hljs-comment">// thread2再将B修改成A</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>        log.debug(<span class="hljs-string">&quot;change B-&gt;A:&#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nowStamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>        log.debug(<span class="hljs-string">&quot;stamp:&#123;&#125;-&gt;&#123;&#125;&quot;</span>, stamp, nowStamp);<br>    &#125;, <span class="hljs-string">&quot;thread2&quot;</span>).start();<br><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">// main将A修改成C</span><br>    log.debug(<span class="hljs-string">&quot;change A-&gt;C:&#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, startStamp, startStamp + <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下，发现确实无法修改，解决了ABA问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03.464</span> [main] c.ThreadTest - main start...<br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03.464</span> [main] c.ThreadTest - 当前状态: ref:A, stamp:<span class="hljs-number">0</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03.519</span> [thread1] c.ThreadTest - change A-&gt;B:<span class="hljs-literal">true</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03.519</span> [thread1] c.ThreadTest - stamp:<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">04.021</span> [thread2] c.ThreadTest - change B-&gt;A:<span class="hljs-literal">true</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">04.021</span> [thread2] c.ThreadTest - stamp:<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">05.030</span> [main] c.ThreadTest - change A-&gt;C:<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>如果我们深入到<code>compareAndSet</code>的方法中，可以看到实际上这种版本的机制在底层实际上相当于是多增加了一个stamp的CAS机制，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V   expectedReference,</span><br><span class="hljs-params">                             V   newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> expectedStamp,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> newStamp)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedStamp == current.stamp &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newStamp == current.stamp) ||<br>         casPair(current, Pair.of(newReference, newStamp)));<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们在使用的时候不利用stamp的规则，在修改的时候不进行stamp的更新，那么也是无法解决ABA的问题的。即如果将上面的代码中，在指定expectedStamp和newStamp的时候，给定相同的值，不进行+1的操作，那么主线程还是可以完成修改。输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">36.729</span> [main] c.ThreadTest - main start...<br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">36.729</span> [main] c.ThreadTest - 当前状态: ref:A, stamp:<span class="hljs-number">0</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">36.776</span> [thread1] c.ThreadTest - change A-&gt;B:<span class="hljs-literal">true</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">36.776</span> [thread1] c.ThreadTest - stamp:<span class="hljs-number">0</span>-&gt;<span class="hljs-number">0</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">37.290</span> [thread2] c.ThreadTest - change B-&gt;A:<span class="hljs-literal">true</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">37.290</span> [thread2] c.ThreadTest - stamp:<span class="hljs-number">0</span>-&gt;<span class="hljs-number">0</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">38.305</span> [main] c.ThreadTest - change A-&gt;C:<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>因此我们在使用带有版本号的原子引用的时候，需要自我约束，遵循版本stamp的使用规则</p></blockquote><p><code>AtomicStampedReference</code>可以给原子引用增加版本号，追踪原子引用整个的变化过程。通过它，我们可以知道引用变量在中途被更改了多少次。但是有的时候，我们可能并不关心引用变量更改了多少次，而只是单纯地关心它是否被更改过，那么可以使用<code>AtomicMarkableReference</code></p><p>相比于前面利用一个整型的stamp记录版本，AtomicMarkableReference将其替换成了一个布尔型的mark，可以记载的状态就只有true和false两种了，而其他的逻辑都基本类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicMarkableReference</span><span class="hljs-params">(V initialRef, <span class="hljs-type">boolean</span> initialMark)</span> &#123;<br>        pair = Pair.of(initialRef, initialMark);<br>&#125;<br><br><span class="hljs-comment">// cas方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V       expectedReference,</span><br><span class="hljs-params">                             V       newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">boolean</span> expectedMark,</span><br><span class="hljs-params">                             <span class="hljs-type">boolean</span> newMark)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedMark == current.mark &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newMark == current.mark) ||<br>         casPair(current, Pair.of(newReference, newMark)));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原子数组">原子数组</h2><p>原子数组类型可以保护数组内的元素的原子性，常用的原子数组类有<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code>。这里简要介绍原子整数数组类的使用</p><p>构造方法：</p><ul><li><code>public AtomicIntegerArray(int length)</code>：提供数组长度，构造一个空数组</li><li><code>public AtomicIntegerArray(int[] array)</code>：传入数组进行构造</li></ul><p>CAS方法：</p><p><code>public final boolean compareAndSet(int i, int expect, int update)</code>：利用CAS修改指定下标上的值</p><h2 id="原子更新器">原子更新器</h2><p>原子更新器可以允许我们针对对象的某个属性进行原子操作，常用的原子更新器有<code>AtomicReferenceFieldUpdater</code>、<code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code></p><p>利用原子更新器，可以针对对象的某个属性进行原子操作，但是只能配合volatile 修饰的字段使用，否则会出现异常<code>IllegalArgumentException: Must be volatile type</code></p><p>常用 API：</p><ul><li><p><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</p><blockquote><p>如果是AtomicReferenceFieldUpdater，则还需要指定一个字段的类型对应的Class类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U,W&gt; AtomicReferenceFieldUpdater&lt;U,W&gt; <span class="hljs-title function_">newUpdater</span><span class="hljs-params">(Class&lt;U&gt; tclass, Class&lt;W&gt; vclass, String fieldName)</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS方法，需要指定修改哪个对象的字段</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程笔记(3)-volatile与Java内存模型</title>
    <link href="/2022/09/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-3-volatile%E4%B8%8EJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/09/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-3-volatile%E4%B8%8EJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线程安全三大特性">线程安全三大特性</h1><p>在多线程代码编写的过程中，线程安全是一个非常重要的话题。而线程安全通常需要考虑三个方面：原子性，可见性和有序性</p><ul><li><p>原子性：一个线程内多行代码以一个整体运行</p></li><li><p>可见性：一个线程对共享变量修改，另一个线程能够看到最新的结果</p></li><li><p>有序性：一个线程内代码按照编写顺序执行</p></li></ul><h2 id="原子性">原子性</h2><p>原子性问题很好理解，与临界区和临界资源相关。对于临界区的代码，同一时刻最多只能有一个线程执行。</p><h2 id="可见性">可见性</h2><p>可见性问题指的是线程对于变量的可见性，考虑如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        stop = <span class="hljs-literal">true</span>;<br>        log.debug(<span class="hljs-string">&quot;modify stop to true...&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;thread1&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">200</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;stop: &#123;&#125;&quot;</span>, stop);<br>    &#125;, <span class="hljs-string">&quot;thread2&quot;</span>).start();<br><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!stop) &#123;<br>        i++;<br>    &#125;<br>    log.debug(<span class="hljs-string">&quot;stopped... count:&#123;&#125;&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，主线程启动了两个线程分别是thread1和thread2，主线程中循环对i进行自增；thread1在睡眠100ms之后将stop标志修改为true，希望让主线程停下来；thread2在睡眠200ms之后输出它看到的目前stop的值。</p><p>我们预期希望主线程能够正常停止，但是实际运行发现无法暂停：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">01.289</span> [thread1] c.ThreadTest - modify <span class="hljs-built_in">stop</span> <span class="hljs-built_in">to</span> <span class="hljs-literal">true</span>...<br><span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">01.367</span> [thread2] c.ThreadTest - <span class="hljs-built_in">stop</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>出现这种情况的原因是由于可见性。thread1在修改了stop之后，将其同步到了主存中，但是主线程中的循环会经过JIT热点代码。优化后，JIT发现循环中stop一直是false，那么它就认为这个stop一直是false，将其缓存到工作内存中。而其他线程thread2没有热点代码，没有进行JIT优化，因此可以看到stop的最新值true</p><p>如果我们增加虚拟机参数<code>-Xint</code>，只用解释器，禁用JIT优化，则发现主线程可以正常停下来：</p><blockquote><p>IDEA虚拟机参数：<code>Edit Configurations</code>-&gt;<code>Modify options</code>-&gt;<code>Add VM options</code></p></blockquote><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">10</span>:<span class="hljs-number">18</span>:<span class="hljs-number">17.259</span> [main] <span class="hljs-keyword">c</span>.ThreadTest - stopped... count:<span class="hljs-number">17411102</span><br><span class="hljs-number">10</span>:<span class="hljs-number">18</span>:<span class="hljs-number">17.259</span> [thread<span class="hljs-number">1</span>] <span class="hljs-keyword">c</span>.ThreadTest - modify stop <span class="hljs-keyword">to</span> <span class="hljs-keyword">true</span>...<br><span class="hljs-number">10</span>:<span class="hljs-number">18</span>:<span class="hljs-number">17.359</span> [thread<span class="hljs-number">2</span>] <span class="hljs-keyword">c</span>.ThreadTest - stop: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>热点代码的优化是有次数阈值的，如果我们降低Thread1的睡眠时间，让循环执行次数减少，那么主线程也是可以正常停止下来。这里我们将thread1的睡眠时间修改为1ms（修改为<code>Thread.sleep(1)</code>），发现主线程也是能够正常地停止，循环的次数对应也降低了很多：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">10</span>:<span class="hljs-number">22</span>:<span class="hljs-number">07.228</span> [main] <span class="hljs-keyword">c</span>.ThreadTest - stopped... count:<span class="hljs-number">351417</span><br><span class="hljs-number">10</span>:<span class="hljs-number">22</span>:<span class="hljs-number">07.228</span> [thread<span class="hljs-number">1</span>] <span class="hljs-keyword">c</span>.ThreadTest - modify stop <span class="hljs-keyword">to</span> <span class="hljs-keyword">true</span>...<br><span class="hljs-number">10</span>:<span class="hljs-number">22</span>:<span class="hljs-number">07.431</span> [thread<span class="hljs-number">2</span>] <span class="hljs-keyword">c</span>.ThreadTest - stop: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>当然上面的两种方式都不是通用的解决方式，解决方式应该是使用关键字<code>volatile</code>来修饰stop。volatile可以解决可见性问题，其修饰的变量每次用到的时候都到主存中找。增加volatile修饰之后，主线程也能够正常停止：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">10</span>:<span class="hljs-number">23</span>:<span class="hljs-number">05.430</span> [main] <span class="hljs-keyword">c</span>.ThreadTest - stopped... count:<span class="hljs-number">376220487</span><br><span class="hljs-number">10</span>:<span class="hljs-number">23</span>:<span class="hljs-number">05.430</span> [thread<span class="hljs-number">1</span>] <span class="hljs-keyword">c</span>.ThreadTest - modify stop <span class="hljs-keyword">to</span> <span class="hljs-keyword">true</span>...<br><span class="hljs-number">10</span>:<span class="hljs-number">23</span>:<span class="hljs-number">05.524</span> [thread<span class="hljs-number">2</span>] <span class="hljs-keyword">c</span>.ThreadTest - stop: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><h2 id="有序性">有序性</h2><p>CPU的基本工作就是执行存储的指令序列。现代CPU支持多级指令流水线，我们可以将一条指令分成5个阶段：取指令--指令译码--执行指令--访存取数--结果写回，称之为五级指令流水线。CPU可以在一个时钟周期内，同时运行五条指令的不同阶段。流水线计数本质上不能缩短单条指令的执行时间，但是可以提高指令的吞吐率</p><p>在不改变程序结果的前提下，指令的各个阶段可以通过重排序和组合来实现指令级并行。指令重排序的目的是减少流水线阻塞。在单线程的场景下，指令重排序并不会影响程序的正确性，但是在多线程的场景下，指令重排序就可能带来预期之外的结果</p><p>考虑单例模式的经典实现，双重检验锁模式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双重检验锁有三个注意点：</p><ul><li>第一个注意点是使用final修饰类，防止子类的方法修改单例</li><li>第二个注意点是在synchronzied同步代码块内外都需要进行null的判断，第二个null的判断是为了防止在第一次创建单例的时候有多个线程进入第一个if内的代码块</li><li>第二个注意点是使用volatile修饰instance，防止指令重排序</li></ul><p>考虑不使用volatile的情况</p><p>在这种情况下，可能会出现指令的重排序。问题的关键在于<code>instance = new Singleton()</code>的底层并不是一个原子操作，而是可以分成四个部分：创建对象，复制引用地址，调用构造方法，将引用地址赋值给instance。但是由于可能有指令重排，一种可能的顺序是先将引用地址赋值给instance，再调用构造方法。在这种情况下，可能出现一个线程执行第一个if发现不为null，直接返回结果，但是得到的单例对象还没有被初始化，使用的话就会出现错误</p><p>解决方式就是使用volatile关键字，防止指令的重排序</p><h1 id="volatile">volatile</h1><p>Java中提供<code>volatile</code>关键字，用来修饰成员变量或者静态变量。可以保证可见性和有序性，但是没有办法保证原子性</p><p>对于可见性来说：被volatile修饰的变量，每次都会到主存中进行最新值的读取</p><p>对于有序性来说：使用内存屏障来达到效果，具体来说又分为写屏障和读屏障</p><ul><li><p>在对volatile变量的写指令之前加入写屏障<code>^^^^^</code>，保证前面的代码不会跑到后面去，但是后面的代码可以跑到前面</p></li><li><p>在对volatile变量的读指令之后加入读屏障<code>vvvvv</code>，保证后面的代码不会跑到前面去，但是前面的代码可以跑到后面</p></li></ul><p>考虑下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> y;<br><br><span class="hljs-comment">// 在写操作前增加写屏障</span><br>x = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// ^^^^^</span><br>y = <span class="hljs-number">2</span>;<br><br><br><span class="hljs-comment">// 在读操作之后增加读屏障</span><br>y;<br><span class="hljs-comment">// vvvvv</span><br>x;<br></code></pre></td></tr></table></figure><blockquote><p>一般来说，对于volatile变量的读操作在最先完成，写操作在最后完成，这样能够最大程度利用内存屏障。</p></blockquote><h1 id="java内存模型">Java内存模型</h1><h2 id="jmm">JMM</h2><p>Java内存模型（Java MemoryModel，JMM）是Java虚拟机中的一种规范，目的是屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。它的主要目的是定义程序中各种变量的访问规则，包括实例字段、静态字段和数组元素等。（不包括局部变量与方法参数，因为这些是线程私有的，不共享，也就不存在竞争关系）</p><p>JMM规定所有变量都存储在主内存（MainMemory，可以类比物理硬件的主内存，实际上是虚拟机内存的一部分）中，主内存对于所有线程来说是共享的。而每条线程还有自己的工作内存（WorkingMemory，可以类比高速缓存），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接操作主内存中的变量。线程之间无法相互直接访问，线程间变量值的传递均需要通过主内存来完成</p><blockquote><p>注意：JMM和Java内存区域中的堆、栈、方法区等并不是一个层次上对内存的划分，两者基本上是没有任何关系的</p></blockquote><h2 id="happens-before">happens-before</h2><p>JMM中定义了8种操作来描述主内存与工作内存之间的交互，包括lock、unlock、read、load、use、assign、write。同时JMM还规定了在执行上述8种基本操作时必须满足的规则。规则定义非常严谨，但是也是极为繁琐。happens-before则是这些定义的等效判断原则，通过happens-before原则，我们可以确定操作在并发环境下是安全的</p><p>happens-before原则由一系列原则构成。happens-before是JMM中定义的两个操作之间的偏序关系。JMM向程序员提供保证，如果两个操作满足happens-before原则，例如操作Ahappens-before操作B，那么就可以保证操作A的结果对操作B是可见的。而如果不满足happens-before原则，则不能得到可见性的保证。happens-before原则也是我们判断是否存在竞争，线程是否安全的主要依据</p><p>具体来说，happens-before原则由如下的规则构成：</p><ul><li><p><strong>程序次序规则（Program OrderRule）</strong>：在一个线程内，按照控制流顺序，前面的操作 happens-before后面的操作。</p><p>即同一个线程中前面的所有操作对后面的操作可见</p></li><li><p><strong>管程锁定规则（Monitor LockRule）</strong>：一个unlock操作 happens-before后面对于同一个锁的lock操作。这里的lock和unlock指的是对Monitor的操作，与synchronized原理有关。</p><p>举例来说，如果线程1解锁了Monitor a，然后线程2锁定了Monitora，那么线程1解锁a之前的所有操作对线程2可见</p></li><li><p><strong>volatile变量规则（Volatile VariableRule）</strong>：对于一个volatile变量的写操作 happens-before之后对于这个变量的读操作。</p><p>举例来说，如果线程1写入了volatile变量，之后线程2读取了v，那么线程1写入v以及之前的操作对线程2可见</p></li><li><p><strong>线程启动规则（Thread StartRule）</strong>：Thread对象的start方法 happens-before该线程的每一个操作。</p><p>举例来说，线程1在执行过程中通过调用Thread2.start()来启动线程2，那么线程1在调用start方法之前的操作对线程2是可见的。注意在线程2启动之后，线程1的操作对于线程2来说未必可见</p></li><li><p><strong>线程终止规则（Thread TerminationRule）</strong>：线程中所有的操作 happens-before对于此线程的终止检测。终止检测可以通过<code>Thread::join()</code>或<code>Thread::isAlive()</code>等手段来进行检测。</p><p>举例来说，线程1的所有操作都对线程2调用线程1的t1.join()或t1.isAlive()并成功返回之后可见</p></li><li><p><strong>线程中断规则（Thread InterruptionRule）</strong>：线程<code>Thread::interrupt()</code>方法的调用happens-before 被中断线程代码检测到中断事件的发生</p><p>举例来说，线程1在执行线程2.interrupt()之前的操作，对于线程2在检测到打断之后是可见的</p></li><li><p><strong>对象终结规则（FinalizerRule）</strong>：一个对象的初始化完成 happens-before它的finalize()方法的开始。</p><p>即对象调用finalize()方法的时候，对象初始化完成的任意操作都对其可见</p></li><li><p><strong>传递性（Transitivity）</strong>：如果操作A happens-before操作B，操作B happens-before 操作C，那么操作A happens-before操作C</p></li></ul><blockquote><p>上面的原则描述起来可能有些拗口，但是实际含义与我们直觉相符合。事实上，这是JMM做出的努力，它通过定义的8种操作和烦琐的规则，让程序员能够更加直接方便地进行多线程的编程</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程笔记(2)-synchronized的使用与原理</title>
    <link href="/2022/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-2-synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-2-synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="临界区">临界区</h1><p>在多线程的场景下，会涉及到如下的一些概念：</p><ul><li><p><strong>临界资源</strong>：一次仅允许一个进程使用的资源称为临界资源</p></li><li><p><strong>临界区</strong>：访问临界资源的代码块</p></li><li><p><strong>竞态条件</strong>：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件（竞争）</p></li></ul><p>一个程序运行多个线程本身是没有问题的，多个线程读取共享资源也是没有问题的，而在多个线程对共享资源读写操作的时候发生了指令交错，就会出现问题。而为了避免临界区的竞态条件发生，解决线程安全问题，可以有如下两种解决方案：</p><ol type="1"><li>阻塞式的解决方案：synchronized，lock</li><li>非阻塞式的解决方案：原子变量</li></ol><h1 id="synchronized">synchronized</h1><h2 id="锁使用">锁使用</h2><p><strong>synchronized</strong>：对象锁，保证了临界区内代码的原子性。临界区内的代码对外是不可分割的，只有获取到锁的线程才能执行临界区内的代码。采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><p>synchronized的使用方式有：</p><ol type="1"><li>修饰静态方法，对应的锁对象即为<code>类.class</code></li><li>修饰普通方法，对应的锁对象即为该实例对象</li><li>修饰代码块，对应的锁对象即为指定的对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象)&#123;<br>    临界区...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在分析利用synchronized的时候，主要需要关注锁住的对象是不是同一个</p><ul><li>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</li><li>锁住 this对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</li></ul></blockquote><h2 id="锁原理-monitor">锁原理-Monitor</h2><p>首先我们需要回顾一下Java中的对象组成。Java中的对象组成分为Java对象头+实例数据，其中Java对象头又分为了MarkWord和Klass Word，如果是数组对象的话，还会有一个数组长度ArrayLength的记录。</p><p>在这里我们主要关注Mark Word。MarkWord在正常情况下，会存储hashcode、分代年龄、锁标志位等信息，但是在其他特殊情况下，存储的信息会有所改变，具体如下：（MarkWord的最后两位是锁标志位）</p><p>32位虚拟机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">|--------------------------------------------------------|---------------------|<br>|                   Mark <span class="hljs-title function_">Word</span><span class="hljs-params">(<span class="hljs-number">32</span> bits)</span>                   |       State         |<br>|--------------------------------------------------------|---------------------|<br>|       hashcode:<span class="hljs-number">25</span>      | age:<span class="hljs-number">4</span> | biased_lock:<span class="hljs-number">0</span> | <span class="hljs-number">01</span>    |       Normal        |<br>|--------------------------------------------------------|---------------------|<br>|  thread:<span class="hljs-number">23</span>  | epoch: <span class="hljs-number">2</span> | age:<span class="hljs-number">4</span> | biased_lock:<span class="hljs-number">1</span> | <span class="hljs-number">01</span>    |       Biased        |<br>|--------------------------------------------------------|---------------------|<br>|             ptr_to_lock_record:<span class="hljs-number">30</span>              | <span class="hljs-number">00</span>    |  LightWeight Locked |<br>|--------------------------------------------------------|---------------------|<br>|           ptr_to_heavyweight_monitor:<span class="hljs-number">30</span>        | <span class="hljs-number">10</span>    |  HeavyWeight Locked |<br>|--------------------------------------------------------|---------------------|<br>|                                                | <span class="hljs-number">11</span>    |    Marked <span class="hljs-keyword">for</span> GC    |<br>|--------------------------------------------------------|---------------------|<br></code></pre></td></tr></table></figure><p>64位虚拟机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">|------------------------------------------------------------|---------------------|<br>|                   Mark <span class="hljs-title function_">Word</span><span class="hljs-params">(<span class="hljs-number">64</span> bits)</span>                       |       State         |<br>|------------------------------------------------------------|---------------------|<br>| unused:<span class="hljs-number">25</span> |hashcode:<span class="hljs-number">31</span> |unused:<span class="hljs-number">1</span> |age:<span class="hljs-number">4</span> |biased_lock:<span class="hljs-number">0</span> |<span class="hljs-number">01</span> |       Normal        |<br>|------------------------------------------------------------|---------------------|<br>| thread:<span class="hljs-number">54</span> |epoch: <span class="hljs-number">2</span>    |unused:<span class="hljs-number">1</span> |age:<span class="hljs-number">4</span> |biased_lock:<span class="hljs-number">1</span> |<span class="hljs-number">01</span> |       Biased        |<br>|------------------------------------------------------------|---------------------|<br>|             ptr_to_lock_record:<span class="hljs-number">30</span>                      |<span class="hljs-number">00</span> |  LightWeight Locked |<br>|------------------------------------------------------------|---------------------|<br>|           ptr_to_heavyweight_monitor:<span class="hljs-number">30</span>                |<span class="hljs-number">10</span> |  HeavyWeight Locked |<br>|------------------------------------------------------------|---------------------|<br>|                                                        |<span class="hljs-number">11</span> |    Marked <span class="hljs-keyword">for</span> GC    |<br>|------------------------------------------------------------|---------------------|<br></code></pre></td></tr></table></figure><p>synchronzied的锁原理涉及到Monitor的概念。Monitor的源码由C++实现。</p><p>每个Java对象都可以关联一个Monitor对象，Monitor也是一个类，其实例存储在堆中。如果使用synchronized给对象上锁（重量级）之后，该对象头中的MarkWord就被设置为执行Monitor的指针。在Monitor中有一些关键属性，包括Owner，EntryList和WaitSet，分别指示锁持有线程，阻塞队列和等待队列。</p><img src="/2022/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-2-synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/Synchronzed-Monitor.png" class="" title="Synchronzed-Monitor"><p>具体工作流程如下：</p><ol type="1"><li>一开始Monitor中的Owner为null，表示没有线程持有锁</li><li>当有线程Thread-2执行synchronzied(obj)的时候，就会将Monitor的所有者Owner置为Thread-2。同一个时刻，一个Monitor中只能有一个Owner</li><li>之后将obj对象的MarkWord设置为指向Monitor（即上面的重量级锁情况），将对象原有的MarkWord存入对应的Monitor对象中，用于后续释放时恢复</li><li>在Thread-2上锁的过程中，Thread-3、Thread-4和Thread-5也执行synchronized(obj)，就会进入EntryList（双向链表），进入阻塞状态</li><li>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回MarkWord</li><li>之后唤醒 EntryList中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</li><li>WaitSet 中的Thread-0和Thread-1，指的是调用wait进入WAITING状态的线程（wait-notify机制）</li></ol><blockquote><p>注意：</p><ul><li>synchronzied必须是进入同一个对象的Monitor才会有上述的效果</li><li>不加synchronized的对象不会关联Monitor</li><li>synchronized在字节码层面，通过异常try-catch机制，确保一定会被解锁</li></ul></blockquote><h2 id="锁升级">锁升级</h2><h3 id="轻量级锁">轻量级锁</h3><p>轻量级锁的使用场景：一个对象虽然有多线程访问，但是多线程访问的时间是相互错开的，实际上没有竞争，那么可以使用轻量级锁来进行优化。在轻量级锁的情况下，不会涉及到Monitor对象的关联等一系列操作，而是使用到线程栈帧中的锁记录对象</p><p>轻量级锁的工作原理如下：</p><ol type="1"><li><p>首先创建锁记录（LockRecord）对象。每个线程的栈帧都会包含一个锁记录的结果，内部可以存储锁定对应的MarkWord。一开始，锁记录中存储了本身锁记录的地址，以及对应的锁对象的引用</p><img src="/2022/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-2-synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-1.png" class="" title="轻量级锁-1"></li><li><p>开始执行加锁。即让锁记录中的ObjectReference指向对应锁住的对象，并尝试用CAS来替换Object中的MarkWord，将Mark Word的值存入锁记录中</p></li><li><p>如果CAS替换成功，那么Object的MarkWord就存储了锁记录地址以及锁标志位00，表示轻量级锁。这样就表示由对应线程持有了锁</p><img src="/2022/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-2-synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-2.png" class="" title="轻量级锁-2"></li><li><p>如果CAS替换失败，则可能的情况有两种</p><ul><li>其他线程已经持有了该Object的轻量级锁，这样就表示此时发生了竞争，则进入锁膨胀的过程</li><li>该Object上的锁记录指向的是自己线程，即执行了synchronized的锁重入，则此时就再添加一条LockRecord作为重入的计数，其中原本记录锁记录地址的位置置为null</li></ul><img src="/2022/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-2-synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-3.png" class="" title="轻量级锁-3"></li><li><p>当退出synchronzed代码块，执行解锁的时候</p><ul><li>如果有取值为null的锁记录，则表示重入，则重置锁记录，表示重入计数减一</li><li>如果锁记录的值不为null，则表示是一开始加的锁，则此时使用CAS将普通状态的MarkWord值恢复给Object中的对象头<ul><li>此时的CAS可能失败也可能成功，如果成功即表示解锁成功</li><li>如果失败，说明该轻量级锁已经升级成为了重量级锁，则进入重量级锁的解锁流程</li></ul></li></ul></li></ol><blockquote><p>锁膨胀即锁升级为重量级锁，关联到Monitor对象的一系列过程</p></blockquote><h3 id="偏向锁">偏向锁</h3><p>轻量级锁在没有竞争的时候，每次重入仍然需要执行CAS操作，有一定的性能消耗。因此，Java6中引入了偏向锁来及进行进一步的优化。</p><p>只有第一次需要使用CAS将线程ID设置到对象的MarkWord头中，之后发现这个线程ID是自己的就表示没有竞争，无需重新CAS。并且以后只要不发生竞争，这个锁对象就归该线程所有。</p><p>当有另外一个线程去尝试获取这个锁对象的时候，偏向状态就宣告结束，进行偏向撤销，然后恢复到未锁定或者轻量级锁的状态。</p><p>当一个对象创建的时候：</p><ul><li>如果开启了偏向锁，那么对象创建之后，MarkWord的最后3位为101，thread、epoch、age都为0</li><li>如果没有开启偏向锁，那么对象创建后，MarkWord的最后3位为001，hashcode、age都为0，当第一次用到hashCode的时候才会赋值</li><li>偏向锁默认开启，也可以使用参数<code>-XX:-UseBiasedLocking</code>来禁用偏向锁</li><li>偏向锁默认是延迟的，会在程序启动后延迟几秒生效。这是因为在刚开始执行代码的时候，可能会有很多线程进行竞争，开启偏向锁效率反而降低。我们也可以使用参数<code>-XX:BiasedLockingStartupDelay=0</code>来避免延迟</li></ul><p>偏向锁在一些情况下会被撤销：</p><ul><li>调用对象的hashCode时，偏向锁被撤销。因为在偏向锁状态下无法存放hashCode</li><li>当有其他线程使用偏向锁对象的时候，会将偏向锁升级成为轻量级锁</li><li>调用wait -notify的时候，会将偏向锁升级为重量级锁，因为在Monitor中才有WatiSet</li></ul><h3 id="升级过程">升级过程</h3><p>上述的锁升级对于使用者来说都是透明的，使用语法都是synchronized。JVM会自动根据情况进行锁升级的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁<span class="hljs-comment">// 随着竞争的增加，只能锁升级，不能降级</span><br></code></pre></td></tr></table></figure><h2 id="锁优化">锁优化</h2><p>自旋优化：重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功，即持锁线程已经退出了同步块释放锁，这时候当前线程就可以避免阻塞</p><ul><li>优点：不会进入阻塞状态，减少线程上下文切换的消耗</li><li>缺点：消耗CPU资源</li><li>说明：<ul><li>在 Java 6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</li><li>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</li></ul></li></ul><p>锁消除：指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM即时编译器JIT的优化。锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM逃逸分析）</p><h1 id="wait---notify">wait - notify</h1><p>wait -notify机制表示对象的等待和唤醒机制。wait、notify、notifyAll是Object的方法，需要用锁对象来调用。获取了该对象锁才能调用这些方法。相关API如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 唤醒正在等待对象Monitor的单个线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 唤醒正在等待对象Monitor的所有线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 让当前线程等待，直到另一个线程调用该对象的notify()方法或 notifyAll()方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span>; <span class="hljs-comment">// 有时限的等待, 到n毫秒后结束等待，或是被唤醒</span><br></code></pre></td></tr></table></figure><p>wait -notify的使用需要配合Monitor进行。调用wait的线程会变为WAITING状态，进入对应Monitor的WaitSet中。当Owner线程调用notify或者notifyAll唤醒处于WAITING状态的线程之后，被唤醒的线程进入EntryList重新竞争</p><blockquote><p>sleep和wait的区别：</p><p>方法归属不同：</p><ol type="1"><li>sleep是Thread的静态方法</li><li>wait是Object的成员方法</li></ol><p>醒来时机不同：</p><ol type="1"><li>sleep(long)和wait(long)都可以在等待超过对应时间后醒来</li><li>wait可以被notify和notifyAll进行唤醒</li><li>它们都可以被打断唤醒</li></ol><p>锁特性不同：</p><ol type="1"><li>wait方法的调用必须先调用wait对象的锁，而sleep则没有这个限制</li><li>wait方法执行后会释放对象锁，但是sleep不会放弃锁</li></ol></blockquote><p>使用wait -notify的时候，可能遇到虚假唤醒的问题。这种情况指的是，notify只能随机唤醒WaitSet中的一个线程，但是可能有多个线程处于WAITING状态，唤醒的不一定是正确的线程。针对这种情况，我们选择采用notifyAll</p><p>采用notifyAll之后，可以解决线程的唤醒问题。但是这会唤醒所有的线程，有的线程可能条件没有得到满足也被唤醒了。为了解决这个问题，我们一般不使用if+ wait来进行条件判断，而应该使用while +wait。唤醒之后重新判断，如果条件不满足，则继续等待</p><h1 id="park---unpark">park - unpark</h1><p>park和unpark是LockSupport中提供的相关API：</p><ul><li><p><code>LockSupport.park()</code>：暂停当前线程，挂起原语</p></li><li><p><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</p></li></ul><p>LockSupport 出现就是为了增强 wait &amp; notify 的功能：</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用；而park、unpark 不需要</li><li>park &amp; unpark<strong>以线程为单位</strong>来阻塞和唤醒线程，更加精确；而 notify只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</li><li>wait 会释放锁资源进入等待队列，<strong>park不会释放锁资源</strong>，只负责阻塞当前线程，会释放CPU（进入WAITING状态）</li></ul><blockquote><p>park会让线程进入WAITING状态，但是我们打断park线程并不会清除打断标记，并且如果打断标记为true，调用park是无法让线程阻塞的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br> log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br> LockSupport.park();<br> log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br> log.debug(<span class="hljs-string">&quot;打断标记: &#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());<br> <span class="hljs-comment">// log.debug(&quot;打断标记: &#123;&#125;&quot;, Thread.interrupted());</span><br><br> LockSupport.park();<br> log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>&#125;, <span class="hljs-string">&quot;thread1&quot;</span>);<br><br>thread.start();<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>thread.interrupt();<br></code></pre></td></tr></table></figure></blockquote><h1 id="线程分析">线程分析</h1><h2 id="线程安全分析">线程安全分析</h2><p>对于成员变量和静态变量：</p><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，分两种情况：<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题</li></ul></li></ul><p>对于局部变量：</p><ul><li>局部变量是线程安全的</li><li>局部变量引用的对象不一定线程安全（逃逸分析）：<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全问题</li></ul></li></ul><p>常见线程安全类：String、Integer、StringBuffer、Random、Vector、Hashtable、java.util.concurrent包</p><ul><li><p>线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的</p></li><li><p><strong>每个方法是原子的，但多个方法的组合不是原子的</strong>，只能保证调用的方法内部安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Hashtable</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br><span class="hljs-comment">// 线程1，线程2</span><br><span class="hljs-keyword">if</span>(table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-literal">null</span>) &#123;<br>table.put(<span class="hljs-string">&quot;key&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>无状态类线程安全：无状态类指的是没有成员变量的类</p><p>不可变类线程安全：String、Integer等都是不可变类，<strong>内部的状态不可以改变</strong>，所以方法是线程安全</p><blockquote><p>不可变类的设计：如果一个对象不能够修改其内部属性，则这个对象就是不可变对象。不可变对象是线程安全的，不存在并发修改和可见性问题</p><p>以String类为例，我们可以观察不可变类的设计：</p><ul><li>类本身使用final修饰，保证该类中的方法不会被子类破坏</li><li>属性使用final修饰，保证该属性是只读的，不能被修改</li><li>不提供写入方法，保证外部不能对属性进行修改</li><li>在更改String类数据的时候，会构造新的字符串对象，生成新的<code>char[] value</code>。这种通过创建对象来避免共享的方式称为保护性拷贝</li></ul></blockquote><h2 id="线程活跃性">线程活跃性</h2><h3 id="死锁">死锁</h3><p>死锁产生的必要条件：</p><ol type="1"><li>互斥条件：在一段时间内，某个资源只能由一个进程占用</li><li>请求和保持条件：进程保持至少一个资源，又提出了新的资源请求。请求阻塞的时候，对自己已经保持的资源保持不放</li><li>不剥夺条件：进程已经获得的资源，在未使用前不能被剥夺，只能在使用完之后自己释放</li><li>环路等待条件：在发生死锁的时候，必然存在两个或多个进程构成的环形链路，里面的每个进程都在等待下一个进程释放其占用的资源</li></ol><p>死锁示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLock</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>             System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;获取资源1&quot;</span>);<br>             <span class="hljs-keyword">try</span> &#123;<br>                 Thread.sleep(<span class="hljs-number">1000</span>);<br>             &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                 e.printStackTrace();<br>             &#125;<br><br>             System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;等待获取资源2&quot;</span>);<br>             <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                 System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;获取资源2&quot;</span>);<br>             &#125;<br>         &#125;<br>     &#125;, <span class="hljs-string">&quot;线程1&quot;</span>).start();<br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>             System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;获取资源2&quot;</span>);<br>             <span class="hljs-keyword">try</span> &#123;<br>                 Thread.sleep(<span class="hljs-number">1000</span>);<br>             &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                 e.printStackTrace();<br>             &#125;<br><br>             System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;等待获取资源1&quot;</span>);<br>             <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                 System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;获取资源1&quot;</span>);<br>             &#125;<br>         &#125;<br>     &#125;, <span class="hljs-string">&quot;线程2&quot;</span>).start();<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>死锁的定位：</p><ul><li>使用<code>jps</code>定位进程id，再用<code>jstack id</code>定位死锁，找到死锁的线程去查看源码</li><li>使用<code>jconsole</code>工具进行检测死锁</li></ul><h3 id="活锁">活锁</h3><p>活锁指的是任务并没有被阻塞，但是由于某些条件没有满足，导致一直重复尝试然后失败的过程。举例来说，下面的代码两个线程互相改变对方的结束条件，最后谁也没有办法结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 期望count减到0退出循环</span><br>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            count -= <span class="hljs-number">1</span>;<br>            log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;thread1&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 期望count加到超过20退出循环</span><br>        <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            count += <span class="hljs-number">1</span>;<br>            log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;thread2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这种情况下还是有可能结束的，和线程的调度有关，随机性很强</li></ul><h3 id="饥饿">饥饿</h3><p>饥饿：一个线程由于优先级太低，始终得不到 CPU调度执行，也不能够结束</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程笔记(1)-线程的基本使用</title>
    <link href="/2022/09/08/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/08/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="基本知识">基本知识</h1><h2 id="进程与线程">进程与线程</h2><p>进程：</p><ul><li>程序由指令和数据组成，但是这些指令要运行，数据要读写，就必须将指令加载至CPU，将数据加载至内存；同时在指令运行过程中还需要用到磁盘、网络等设备。而进程就是用来加载指令、管理内存、管理IO的</li><li>当一个程序被执行，从磁盘加载这个程序的代码到内存中，就已经开启了一个进程</li><li>进程可以视为程序的一个实例，大部分程序可以同时运行多个实例进程，有的程序只启动一个实例进程</li></ul><p>线程：</p><ul><li>一个进程可以启动一个或者多个线程</li><li>一个线程就是一个指令流，指令流中的指令按照一定的顺序交给CPU执行</li><li>Java中，线程是调度的基本单位，进程是资源分配的基本单位</li></ul><p>两者对比：</p><ul><li>进程之间相互独立，而线程是存在于进程内部</li><li>线程会共享进程拥有的资源</li><li>进程间的通信较为复杂，同一台计算机的进程通信称为IPC（Inter-ProcessCommunication），不同计算机之间的进程通信，则需要通过网络进行，遵循共同的协议</li><li>线程间的通信较为简单，因为它们共享进程的内存</li><li>线程更加轻量级，线程上下文的切换成本一般要低于进程上下文的切换</li></ul><p>线程的作用：</p><ul><li>使多道程序更好的并发执行</li><li>提高资源利用率和系统吞吐量</li><li>增强操作系统的并发性能</li></ul><h2 id="并行与并发">并行与并发</h2><ul><li>并行（parallel）：在同一时刻，多个指令在多个CPU上同时执行。（真正同时）</li><li>并发（concurrent）：在同一时刻，多个指令在单个CPU上交替执行（模拟同时，微观串行，宏观并行）</li></ul><h2 id="同步与异步">同步与异步</h2><p>从方法调用的角度来看：</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><blockquote><p>IO不占用CPU，只是我们一般拷贝文件使用的是阻塞IO，这时相当于线程虽然不用CPU，但是需要一直等待IO结束，没能充分利用线程。所以才有后面的非阻塞IO和异步IO的优化。</p></blockquote><h1 id="java线程">Java线程</h1><h2 id="线程创建">线程创建</h2><h3 id="方法1thread">方法1：Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            log.info(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;thread1&quot;</span>); <span class="hljs-comment">// 继承Thread</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;thread2&quot;</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                log.info(i + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;; <span class="hljs-comment">// 匿名内部类形式</span><br><br>    thread1.start();<br>    thread2.start();<br><br>    <span class="hljs-comment">// 主线程执行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        log.info(i + <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>继承Thread，重写run方法。也可以使用匿名内部类来完成</p></li><li><p>Thread 相关构造器：</p><ul><li><code>public Thread()</code>：默认构造器</li><li><code>public Thread(String name)</code>：指定线程名称</li></ul></li><li><p>优点：编码简单</p></li><li><p>缺点：线程类已经继承了 Thread类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</p></li></ul><blockquote><ol type="1"><li><p>start() 方法向 CPU 注册当前线程，并且触发 run() 方法执行</p></li><li><p>线程的启动必须调用 start() 方法，如果线程直接调用 run()方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</p></li></ol></blockquote><h3 id="方法2runnable">方法2：Runnable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            log.info(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(); <span class="hljs-comment">// 实现Runnable接口</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target, <span class="hljs-string">&quot;thread1&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            log.info(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;thread2&quot;</span>); <span class="hljs-comment">// lambda表达式</span><br><br>    thread1.start();<br>    thread2.start();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>实现Runnable，实现run（没有返回值，不能抛异常），之后传递给Thread构造方法</p></li><li><p>Thread 相关构造器：</p><ul><li><code>public Thread(Runnable target)</code></li><li><code>public Thread(Runnable target, String name)</code></li></ul></li><li><p>优点：</p><ol type="1"><li>线程任务类只是实现了 Runnable接口，可以继续继承其他类，避免了单继承的局限性</li><li>将线程和任务分开，让任务类脱离了Thread继承体系，更加灵活</li><li>更容易与线程池等高级API配合，线程池可以放入实现 Runnable 或 Callable线程任务对象</li></ol></li></ul><blockquote><p>Thread和Runnable之间的关系</p><ul><li>方法1直接重写Thread的run方法</li><li>方法2中将Runnable对象赋值给Thread类内部的一个Runnable类型的target属性，然后在run方法中调用target的run方法</li></ul></blockquote><h3 id="方法3callable">方法3：Callable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.info(<span class="hljs-string">&quot;Hello1&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    Callable&lt;Integer&gt; myCallable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>    FutureTask&lt;Integer&gt; futureTask1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(myCallable); <span class="hljs-comment">// 实现Callable接口</span><br>    FutureTask&lt;Integer&gt; futureTask2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;<br>        log.info(<span class="hljs-string">&quot;Hello2&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>    &#125;); <span class="hljs-comment">// Lambda表达式</span><br><br>    <span class="hljs-comment">// 包装成Thread对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask1, <span class="hljs-string">&quot;thread1&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask2, <span class="hljs-string">&quot;thread2&quot;</span>);<br><br>    thread1.start();<br>    thread2.start();<br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">res1</span> <span class="hljs-operator">=</span> futureTask1.get(); <span class="hljs-comment">// 调用FutureTask的get方法获取返回值</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">res2</span> <span class="hljs-operator">=</span> futureTask2.get();<br>    log.info(<span class="hljs-string">&quot;res1: &quot;</span> + res1);<br>    log.info(<span class="hljs-string">&quot;res2: &quot;</span> + res2);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现Callable接口，重写其中的call方法。在这个call方法中可以有泛型，也可以有返回值</li><li>创建一个Callable的线程任务对象，将其包装成一个FutureTask</li><li>FutureTask能够接收Callable类型的参数，用来处理有结果的情况</li><li>将FutureTask再包装成Thread，获得线程对象</li><li>同样可以用Lambda表达式简化</li></ul><blockquote><p><strong>FutureTask补充</strong>：</p><p>FutureTask继承了Runnable、Future接口，用于包装Callable对象，实现任务的提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 相关类和接口的定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Runnable</span>, Future&lt;V&gt;<br></code></pre></td></tr></table></figure><p>相关API：</p><p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：在线程执行完后得到线程的执行结果</p><ul><li>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行Runnable 实例的任务对象</strong>，所以把 Callable 包装成FutureTask</li></ul><p><code>public FutureTask(Runnable runnable, V result)</code>：也可以将Runnable再进行包装</p><p><code>public V get()</code>：同步等待 task执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p><ul><li>get() 线程会阻塞等待任务执行完成</li><li>run() 执行完后会把结果设置到 FutureTask 的一个成员变量，get()线程可以获取到该变量的值</li></ul></blockquote><h2 id="线程查看">线程查看</h2><p>Windows：</p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li><code>tasklist</code> 查看进程</li><li><code>taskkill</code> 杀死进程</li></ul><p>Linux：</p><ul><li><code>ps -ef</code> 查看所有进程</li><li><code>ps -fT -p &lt;PID&gt;</code>查看某个进程（PID）的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>top</code> 按大写 H 切换是否显示线程</li><li><code>top -H -p &lt;PID&gt;</code>查看某个进程（PID）的所有线程</li></ul><p>Java：</p><ul><li><code>jps</code> 命令查看所有 Java 进程</li><li><code>jstack &lt;PID&gt;</code> 查看某个 Java进程（PID）的所有线程状态</li><li><code>jconsole</code> 来查看某个 Java进程中线程的运行情况（图形界面）</li></ul><h2 id="线程原理">线程原理</h2><p>一个方法对应一个栈帧中的内容，其中包括了局部变量表、返回地址，锁记录，操作数栈等。一个线程对应一块栈内存，不同的线程使用不同的栈空间，里面有多个栈帧。即使用不同的Java虚拟机栈，每个线程启动后，虚拟机就会为其分配一块栈内存</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU不再执行当前线程，转而执行另一个线程。可能发生上下文切换的情况如下：</p><ul><li>线程的 CPU 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等。可以预见的是，上下文切换频繁会影响性能，因此线程数不是越多越好。</p><h2 id="线程常用方法">线程常用方法</h2><h3 id="api-列表">API 列表</h3><table><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public void start()</td><td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td></tr><tr class="even"><td>public void run()</td><td>线程启动后被调用的方法</td></tr><tr class="odd"><td>public void setName(String name)</td><td>给当前线程设置名称</td></tr><tr class="even"><td>public void getName()</td><td>获取当前线程的名称<br />线程存在默认名称：子线程是Thread-索引，主线程是 main</td></tr><tr class="odd"><td>public static Thread currentThread()</td><td>获取当前线程对象，代码在哪个线程中执行</td></tr><tr class="even"><td>public static void sleep(long time)</td><td>让当前线程休眠多少毫秒再继续执行<br /><strong>Thread.sleep(0)</strong>: 让操作系统立刻重新进行一次 CPU 竞争</td></tr><tr class="odd"><td>public static native void yield()</td><td>提示线程调度器让出当前线程对 CPU 的使用</td></tr><tr class="even"><td>public final int getPriority()</td><td>返回此线程的优先级</td></tr><tr class="odd"><td>public final void setPriority(int priority)</td><td>更改此线程的优先级，常用 1 5 10</td></tr><tr class="even"><td>public void interrupt()</td><td>中断这个线程，异常处理机制</td></tr><tr class="odd"><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td></tr><tr class="even"><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td></tr><tr class="odd"><td>public final void join()</td><td>等待这个线程结束</td></tr><tr class="even"><td>public final void join(long millis)</td><td>等待这个线程，最多等待millis 毫秒，0 意味着永远等待</td></tr><tr class="odd"><td>public final native boolean isAlive()</td><td>判断线程是否存活（还没有运行完毕）</td></tr><tr class="even"><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td></tr></tbody></table><h3 id="start-vs-run">start vs run</h3><p>如果要使用多线程启动Thread，必须要调用Thread的start方法。如果直接调用run方法，则只是简单的方法调用，而不是多线程执行</p><p>start不能多次调用，多次调用会抛出异常<code>java.lang.IllegalThreadStateException</code></p><h3 id="sleep-vs-yield">sleep vs yield</h3><p>sleep：</p><ul><li>调用 sleep 会让当前线程从 <code>Running</code> 进入<code>Timed Waiting</code> 状态</li><li>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></li><li>其它线程可以<strong>使用 interrupt方法打断正在睡眠的线程</strong>，这时 sleep 方法会抛出InterruptedException，可以使用try/catch来进行代码执行</li><li>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep来获得更好的可读性</li></ul><blockquote><p>sleep通常用来防止CPU占用100%。</p><p>在没有利用CPU来计算的时候，我们希望不要让while(true)空转占用CPU，这时候就可以使用sleep来让出CPU的使用权给其他程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在一些服务端监听的场景下会用到 while(true)</li></ul></blockquote><p>yield：</p><ul><li><p>调用yield会让当前线程从<code>Running</code>进入<code>Runnable</code>状态</p></li><li><p>调用yield之后调度执行其他同优先级的线程。但是如果这时没有同优先级的线程，那么不能保证达到让当前线程暂停的效果</p></li><li><p>具体的实现依赖于操作系统的任务调度器</p></li><li><p><strong>会放弃 CPU 资源，锁资源不会释放</strong></p></li></ul><blockquote><p>线程优先级：</p><ul><li>线程优先级会提示（hint）调度器优先调度该线程。但是仅仅是一个提示，调度器可以忽略</li><li>如果CPU忙，那么优先级高的线程会获得更多的时间片，如果CPU空闲，则优先级几乎没有用。</li><li>最小优先级1，最大优先级10，默认优先级5。数字越大，优先级越高</li></ul></blockquote><h3 id="join">join</h3><p>join可以等待线程结束，底层原理是调用者轮询检查线程的alive状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束</span><br>    <span class="hljs-comment">// wait(0)和wait()方法的实际意义是一样的，都表示在没有唤醒的情况下该线程一直处于等待状态</span><br>    ...<br>    <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以设置超时时间</li><li>join 方法是一个Thread类的成员方法，并且被 synchronized 修饰</li></ul><h3 id="interrupt">interrupt</h3><p><code>public void interrupt()</code>：打断这个线程，触发<code>InterruptedExecption</code>异常</p><p><code>public static boolean interrupted()</code>：Thread类的静态方法，判断当前线程是否被打断，打断返回true，<strong>清除打断标记</strong>，连续调用两次一定返回 false</p><p><code>public boolean isInterrupted()</code>：Thread类的成员方法，判断当前线程是否被打断，不清除打断标记</p><blockquote><p>打断并不是停下线程，而是干扰。而被打断的线程会知道有人在干扰自己。线程判断打断标记，再决定自己要干什么。优雅的停止线程】</p></blockquote><ul><li>线程被打断之后，会出现<code>InterruptedException</code></li><li>打断标记用于标记该线程被打断</li><li>打断阻塞状态的线程，<strong>会清除打断标记</strong></li><li>打断正常情况下的线程，不会清除打断标记</li></ul><p>打断阻塞状态的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;sleeping....&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;thread1&quot;</span>);<br><br>thread1.start();<br><br>Thread.sleep(<span class="hljs-number">1000</span>); <br><span class="hljs-comment">// 注意主线程需要先等一会，才会出现打断睡眠状态线程的情况</span><br><span class="hljs-comment">// 如果主线程不等的话，可能就不是打断睡眠状态的线程了</span><br>thread1.interrupt();<br>log.debug(<span class="hljs-string">&quot;打断标记: &#123;&#125;&quot;</span>, thread1.isInterrupted());<br></code></pre></td></tr></table></figure><p>输出如下：可以看到会清除打断标记</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">15:08:55.136 [thread1] c.ThreadTest - sleeping....<br>java.lang.InterruptedException: sleep interrupted<br>at java.lang.Thread.sleep(Native Method)<br>at ThreadTest.lambda$main$0(ThreadTest.java:14)<br>at java.lang.Thread.run(Thread.java:748)<br>15:08:56.140 [main] c.ThreadTest - 打断标记: false<br></code></pre></td></tr></table></figure><p>打断正常运行的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> current.isInterrupted();<br>        <span class="hljs-keyword">if</span> (interrupted) &#123;<br>            log.debug(<span class="hljs-string">&quot;退出循环&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>    &#125;<br>&#125;, <span class="hljs-string">&quot;thread1&quot;</span>);<br><br>thread1.start();<br><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>thread1.interrupt();<br>log.debug(<span class="hljs-string">&quot;打断标记: &#123;&#125;&quot;</span>, thread1.isInterrupted());<br></code></pre></td></tr></table></figure><p>输出如下：可以看到没有清除打断标记</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">15:18:35.108 [main] c.ThreadTest - 打断标记: true<br>15:18:35.108 [thread1] c.ThreadTest - 退出循环<br></code></pre></td></tr></table></figure><blockquote><p>利用interrupt，可以完成多线程设计模式-两阶段终止。具体实现可以参考后面的多线程设计模式笔记。</p></blockquote><h3 id="daemon">daemon</h3><p>守护线程的生命周期与其他非守护线程相同，它是服务于用户线程的。只要其它非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束。JVM中的垃圾回收线程就是一种守护线程</p><p>设置守护线程需要在线程启动之前调用方法<code>setDaemon(boolean on)</code>，将其中的标志位设置为true。</p><h2 id="线程状态">线程状态</h2><p>从操作系统层面来看，分为初始状态、就绪状态、运行状态、阻塞状态、终止状态。</p><img src="/2022/09/08/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" class="" title="操作系统层面线程状态"><p>从Java API层面来看，在 API 中 <code>java.lang.Thread.State</code>这个枚举中给出了六种线程状态，分为新建New、可运行Runnable、阻塞Blocked、等待Waiting、超时等待TimedWaiting、结束Terminated。</p><img src="/2022/09/08/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/JavaAPI%E5%B1%82%E9%9D%A2%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" class="" title="JavaAPI层面的线程状态"><blockquote><ul><li>操作系统层面的阻塞状态指的是因为等待某一事件而不能运行，例如等待IO。</li><li>Java API层面的可运行，对应操作系统层面的就绪、运行和阻塞状态</li><li>JavaAPI层面的阻塞，指的是当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked 状态；当该线程持有锁时，该线程将变成 Runnable状态。【阻塞在锁上】</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性</title>
    <link href="/2022/09/04/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/09/04/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="java8新特性">Java8新特性</h1><ul><li><strong>Lambda 表达式</strong>：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li><li><strong>方法引用</strong>：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong>默认方法</strong>：默认方法就是一个在接口里面有了一个实现的方法。</li><li><strong>新工具</strong> ：新的编译工具，如：Nashorn引擎 jjs、类依赖分析器jdeps。</li><li><strong>Stream API</strong>：新添加的Stream API（java.util.stream）把真正的函数式编程风格引入到Java中。</li><li><strong>Date Time API</strong> ： 加强对日期与时间的处理。</li><li><strong>Optional 类</strong> ：Optional 类已经成为 Java 8类库的一部分，用来解决空指针异常。</li><li><strong>Nashorn, JavaScript 引擎</strong> ： Java8提供了一个新的Nashornjavascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul><h1 id="lambda表达式">Lambda表达式</h1><h2 id="语法格式">语法格式</h2><p>lambda表达式的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(parameters) -&gt; expression<br>或<br>(parameters) -&gt;&#123; statements; &#125;<br></code></pre></td></tr></table></figure><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值</li><li>可选参数圆括号：一个参数无需定义圆括号，但是多个参数需要定义圆括号</li><li>可选大括号：如果主体只包含一个语句，就不需要使用大括号</li></ul><h2 id="函数式接口">函数式接口</h2><p>函数式接口（FunctionInterface）：是一个接口。这个接口有且仅有一个抽象方法，但是可以有多个非抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyFunctionalInterface</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayMessage</span><span class="hljs-params">(String message)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在函数式编程语言当中，函数被当作一等公民。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中有所不同。在Java8中，Lambda表达式是对象，而不是函数。它们必须依附于一类特别的对象类型——函数式接口而存在。</p><p>简单来说，在Java8中，Lambda表达式就是一个函数式接口的实例。只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示（在此之前，完成对应功能的是匿名类）</p></blockquote><p><code>java.util.function</code> 它包含了很多类，用来支持 Java的函数式编程。</p><p>并且在Java中，有四大核心函数式编程接口：</p><table><thead><tr class="header"><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>Consumer&lt;T&gt;</code></td><td>T</td><td>void</td><td>对类型为T的对象应用操作<br />对应的抽象方法为<code>void accept(T t)</code></td></tr><tr class="even"><td><code>Supplier&lt;T&gt;</code></td><td>无</td><td>T</td><td>返回类型为T的对象<br />对应的抽象方法为<code>T get()</code></td></tr><tr class="odd"><td><code>Function&lt;T, R&gt;</code></td><td>T</td><td>R</td><td>对类型为T的对象应用操作并返回类型为R的对象<br />对应的抽象方法为<code>R apply(T t)</code></td></tr><tr class="even"><td><code>Predicate&lt;T&gt;</code></td><td>T</td><td>boolean</td><td>确定类型为T的对象是否满足某约束，返回boolean值<br />对应的抽象方法为<code>boolean test(T t)</code></td></tr></tbody></table><h2 id="方法引用">方法引用</h2><p>有时候lambda表达式<strong>只涉及一个方法的调用</strong>，我们可以使用方法引用。方法引用指示编译器生成一个函数式接口的实例，覆盖这个接口的抽象方法，调用给定的方法。方法引用的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类(或者对象)::方法名<br></code></pre></td></tr></table></figure><p>可能的情况有：</p><ul><li><code>类::静态方法</code>：要求方法和接口参数列表相同</li><li><code>实例::非静态方法</code>：要求方法和接口参数列表相同</li><li><code>类::非静态方法</code>：接口中第一个参数来调用该方法，方法参数为剩余参数</li></ul><blockquote><p>方法引用最终也是对应到一个lambda表达式，从而对应到一个实现接口的匿名类</p></blockquote><p>当然这里的方法也可以是构造器方法，此时的调用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类::new</span><br>String::<span class="hljs-keyword">new</span>; <span class="hljs-comment">// 构造器引用</span><br><span class="hljs-type">int</span>[]::<span class="hljs-keyword">new</span>; <span class="hljs-comment">// 数组引用</span><br></code></pre></td></tr></table></figure><h1 id="stream-api">Stream API</h1><h2 id="介绍">介绍</h2><p>StrreamAPI，所在的包为<code>java.util.stream</code>，把真正的函数式编程风格引入到Java中，极大程度上提高Java程序员的生产力，写出高效率、干净、简洁的代码。Stream是Java8中处理集合的关键抽象概念，它可以指定我们希望对集合进行的操作，执行非常复杂的查找、过滤和映射等。还可以使用StreamAPI来并行执行操作。简言之，StreamAPI提供了一种高效且易于使用的处理数据的方式。</p><p>利用Stream，我们可以完成一系列的链式调用，最终得到想要的结果。（可以联想到Scala中的函数式编程）</p><blockquote><p>Stream和Collection集合的区别：Collection是一种静态的内存数据接口，而Stream是有关计算的，前者主要面向内存，存储在内存中；后者主要面向CPU，通过CPU实现计算</p></blockquote><ol type="1"><li>Stream自己不会存储元素</li><li>Stream不会改变源对象，而是会返回一个持有结果的新Stream</li><li>Stream操作是惰性执行的，需要结果的时候才会执行</li></ol><p>Stream的操作一般分为以下步骤：</p><ol type="1"><li>创建Stream，进行Stream的实例化</li><li>一系列中间操作</li><li>终止操作</li></ol><p>需要注意的是，调用了终止操作之后，流就会关闭，不能再进行新的操作。强行调用操作会报错<code>java.lang.IllegalStateException: stream has already been operated upon or closed</code>。我们需要生成新的流才能继续操作。</p><h2 id="stream实例化">Stream实例化</h2><p>Stream的实例化主要分为四种情况：</p><ol type="1"><li>通过集合进行创建，调用集合的方法</li><li>通过数组进行创建，调用Arrays的静态方法</li><li>调用<code>Stream.of</code>方法</li><li>创建无限流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><span class="hljs-type">int</span>[] list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100</span>];<br><br><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">100</span>);<br>list1.add(n);<br>list2[i] = n;<br>&#125;<br><br><span class="hljs-comment">// 通过集合进行创建，包括顺序流和并行流</span><br>Stream&lt;Integer&gt; stream1 = list1.stream();<br>Stream&lt;Integer&gt; stream2 = list1.parallelStream();<br><br><span class="hljs-comment">// 通过数组进行创建</span><br><span class="hljs-type">IntStream</span> <span class="hljs-variable">stream3</span> <span class="hljs-operator">=</span> Arrays.stream(list2);<br><br><span class="hljs-comment">// 通过Stream.of进行创建</span><br>Stream&lt;Integer&gt; stream4 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 创建无限流</span><br>Stream.iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<span class="hljs-comment">// 迭代生成</span><br>Stream.generate(Math::random).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<span class="hljs-comment">// 直接生成</span><br></code></pre></td></tr></table></figure><p>迭代生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">iterate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T seed, <span class="hljs-keyword">final</span> UnaryOperator&lt;T&gt; f)</span>;<br><span class="hljs-comment">// 对应一个函数式接口：Function&lt;T, T&gt;</span><br></code></pre></td></tr></table></figure><p>直接生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(Supplier&lt;T&gt; s)</span>;<br><span class="hljs-comment">// 对应一个函数接口：Supplier&lt;T&gt;</span><br></code></pre></td></tr></table></figure><h2 id="中间操作">中间操作</h2><p>筛选与切片</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>filter(Predicate p)</code></td><td>从流中过滤某些元素</td></tr><tr class="even"><td><code>distinct()</code></td><td>去重</td></tr><tr class="odd"><td><code>limit(long maxSize)</code></td><td>截断流，使其元素不超过给定数量</td></tr><tr class="even"><td><code>skip(long n)</code></td><td>跳过前n个元素。如果流中元素不足n个，则返回一个空流</td></tr></tbody></table><p>映射</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>map(Function f)</code></td><td>接收一个函数作为参数，该函数会应用到每个元素上，并将其映射成一个新的元素</td></tr><tr class="even"><td><code>mapToDouble(ToDoubleFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并产生一个新的DoubleStream</td></tr><tr class="odd"><td><code>mapToInt(ToIntFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并产生一个新的IntStream</td></tr><tr class="even"><td><code>mapToLong(ToLongFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并产生一个新的LongStream</td></tr><tr class="odd"><td><code>flatMap(Function f)</code></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有的流连接成一个流</td></tr></tbody></table><p>排序</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>sorted()</code></td><td>产生一个新流，其中按照自然顺序排序</td></tr><tr class="even"><td><code>sorted(Comparator com)</code></td><td>产生一个新流，其中按照比较器顺序排序</td></tr></tbody></table><h2 id="终止操作">终止操作</h2><p>匹配与查找</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>allMatch(Predicate p)</code></td><td>返回布尔值，检查是否所有元素都符合条件</td></tr><tr class="even"><td><code>anyMatch(Predicate p)</code></td><td>返回布尔值，检查是否至少有一个元素符合条件</td></tr><tr class="odd"><td><code>noneMatch(Precicate p)</code></td><td>返回布尔值，检查是否所有元素都不符合条件</td></tr><tr class="even"><td><code>findFirst()</code></td><td>返回第一个元素</td></tr><tr class="odd"><td><code>findAny()</code></td><td>返回任意一个元素</td></tr><tr class="even"><td><code>count()</code></td><td>返回流中元素总数</td></tr><tr class="odd"><td><code>max(Comparator c)</code></td><td>返回流中最大值</td></tr><tr class="even"><td><code>min(Comparator c)</code></td><td>返回流中最小值</td></tr><tr class="odd"><td><code>forEach(Consumer c)</code></td><td>内部迭代，对流中每个元素执行对应操作</td></tr></tbody></table><p>规约</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>reduce(T iden, BinaryOperator b)</code></td><td>对流中元素进行规约，iden为初始值。返回T</td></tr><tr class="even"><td><code>reduce(BinaryOperator b)</code></td><td>对流中元素进行规约，返回<code>Optional&lt;T&gt;</code></td></tr></tbody></table><p>收集</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>collect(Collector c)</code></td><td>将流转化为其他形式。接收一个Collector接口的实现，用于汇总流中的元素</td></tr></tbody></table><p>Collector接口中方法的实现决定了如何对流执行收集（如收集到List、Set、Map）。另外在Collectors类中，提供了很多静态方法，可以方便地创建常见收集器实例。</p><h1 id="optional">Optional</h1><p><code>Optional&lt;T&gt;</code>类是一个容器类，来自<code>java.util.Optional</code>。它可以保存类型T的值，代表这个值存在；或者仅仅保存null，代表这个值不存在。原来使用null表示一个值不存在，现在使用Optional可以更好地表达这个概念，并且可以避免<strong>空指针异常</strong>。Optional中提供很多有用的方法，让我们不需要显式地进行空值检测</p><p>创建Optional类对象：</p><ul><li><code>Optional.of(T t)</code>：创建一个Optional实例，t必须非空</li><li><code>Optional.empty()</code>：创建一个空的Optional实例</li><li><code>Optional.ofNullable(T t)</code>：创建一个Optional实例，t可以为null</li></ul><p>判断Optional容器中是否包含对象：</p><ul><li><code>boolean isPresent()</code>：判断是否包含对象</li><li><code>void ifPresent(Consumer&lt;? super T&gt; consumer)</code>：如果有值，就执行Consumer接口的实现代码，其中该值作为consumer的参数</li></ul><p>获取Optional容器的对象：</p><ul><li><code>T get()</code>：如果调用对象包含值，返回该值，否则抛出异常</li><li><code>T orElse(T other)</code>：如果有值则将其返回，否则返回指定的other对象</li><li><code>T orElseGet(Supplier&lt;? extends T&gt; other)</code>：如果有值则将其返回，否则返回由Supplier接口实现提供的对象</li><li><code>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常</li></ul><h1 id="参考文章">参考文章</h1><ol type="1"><li><a href="https://www.runoob.com/java/java8-new-features.html">Java 8新特性 | 菜鸟教程 (runoob.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础笔记(5)-IO流</title>
    <link href="/2022/09/03/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-5-IO%E6%B5%81/"/>
    <url>/2022/09/03/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-5-IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="io流">I/O流</h1><h2 id="io流原理以及分类">I/O流原理以及分类</h2><p>IO流原理：</p><ol type="1"><li>I/O技术，用于处理数据传输，如读写文件，网络通讯等</li><li><code>java.io</code>包下提供了各种“流”的类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</li></ol><p>流的分类：</p><ul><li>按照操作数据单位不同分为：<ul><li>字节流（8 bit）</li><li>字符流（按照字符，不同的编码可能对应不同的字节大小）</li></ul></li><li>按照流的流向不同分为：<ul><li>输入流</li><li>输出流</li></ul></li><li>按照流的角色不同分为：<ul><li>节点流</li><li>处理流 / 包装流</li></ul></li></ul><table><thead><tr class="header"><th>抽象基类</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr class="odd"><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr class="even"><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><h2 id="字节流">字节流</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p><p>字节流中又分为了字节输入流和字符输出流。</p><p><strong>InputStream</strong>：字节输入类</p><table><thead><tr class="header"><th>InputSteam常用的子类</th><th></th></tr></thead><tbody><tr class="odd"><td>FileInputStream</td><td>文件输入流</td></tr><tr class="even"><td>BufferedInputStream</td><td>缓冲字节输入流</td></tr><tr class="odd"><td>ObjectInputStream</td><td>对象字节输入流</td></tr></tbody></table><ul><li><code>public void close()</code>：关闭此输入流并释放与此流相关联的任何系统资源</li><li><code>public abstract int read()</code>：从输入流读取数据的下一个字节</li><li><code>public int read(byte[] b)</code>：从输入流中读取一些字节数，并将它们存储到字节数组 b中，返回读取的字节数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构建字节输入流</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInput</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;xxx/xxx&quot;</span>);<br><br><span class="hljs-comment">// 准备buf字节数组，承接字节流中的数据</span><br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">256</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 循环读取字节流中的字节，存入buf中</span><br><span class="hljs-keyword">while</span>(len = fileInput.read(buf) != -<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">// get new buf[0 - len]</span><br>&#125;<br><br><span class="hljs-comment">// 关闭流</span><br>fileInput.close();<br></code></pre></td></tr></table></figure><p><strong>OutputStream</strong>：字节输出类</p><table><thead><tr class="header"><th>OutputStream常用的子类</th><th></th></tr></thead><tbody><tr class="odd"><td>FileOutputStream</td><td>文件输出流</td></tr></tbody></table><ul><li><code>public void close()</code>：关闭此输出流并释放与此流相关联的系统资源</li><li><code>public void flush()</code>：刷新此输出流并强制任何缓冲的输出字节被写出</li><li><code>public void write(byte[] b)</code>：将b.length字节从指定的字节数组写入此输出流</li><li><code>public void write(byte[] b, int off, int len)</code>：从指定的字节数组写入len字节，从偏移量off开始输出到此输出流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构建字节输出流</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutput</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;xxx/xxx&quot;</span>);<br><br><span class="hljs-comment">// 准备字节数组</span><br><span class="hljs-type">byte</span>[] b = <span class="hljs-string">&quot;abcde&quot;</span>.getBytes();<br><br><span class="hljs-comment">// 输出字节</span><br>fileOutput.write(b);<br><br><span class="hljs-comment">// 流关闭</span><br>fileOutput.close();<br><br><span class="hljs-comment">// 默认是覆盖写，追加写需要在构造输出流的时候指定第二个参数 </span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FileOutputStream</span><span class="hljs-params">(File file, <span class="hljs-type">boolean</span> append)</span>;<br><span class="hljs-comment">// 创建文件输出流以写入由指定的 File对象表示的文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FileOutputStream</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> append)</span>;<br><span class="hljs-comment">// 创建文件输出流以指定的名称写入文件</span><br></code></pre></td></tr></table></figure><h2 id="字符流">字符流</h2><p>当使用字节流读取文本文件时，可能会有一个小问题。字节是计算机能够读取的形式，但是对于人类来说，可读性并不是很好。对于人类来说，可读性较好的是字符。但是对于字符的编码方式有多种多样，对应占用的字节数也不同。而Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p><p><strong>Reader</strong>：字符输入类</p><table><thead><tr class="header"><th>InputSteam常用的子类</th><th></th></tr></thead><tbody><tr class="odd"><td>FileReader</td><td>文件字符输入流</td></tr></tbody></table><ul><li><code>public void close()</code>：关闭此流并释放与此流相关联的任何系统资源</li><li><code>public int read()</code>： 从输入流读取一个字符</li><li><code>public int read(char[] cbuf)</code>：从输入流中读取一些字符，并将它们存储到字符数组 cbuf中</li></ul><p><strong>Writer</strong>：字符输出类</p><table><thead><tr class="header"><th>InputSteam常用的子类</th><th></th></tr></thead><tbody><tr class="odd"><td>FileWriter</td><td>文件字符输入流</td></tr></tbody></table><ul><li><code>void write(int c)</code>：写入单个字符</li><li><code>void write(char[] cbuf)</code>：写入字符数组</li><li><code>abstract void write(char[] cbuf, int offset, int len)</code>：写入字符数组的某一部分，offset为数组的开始索引，len为写的字符个数</li><li><code>void write(String str)</code>：写入字符串</li><li><code>void write(String str, int offset, int len)</code>：写入字符串的某一部分，offset为字符串的开始索引，len为写的字符个数</li><li><code>void flush()</code>：刷新该流的缓冲</li><li><code>void close()</code>：关闭此流，但要先刷新它</li></ul><h2 id="节点流和处理流">节点流和处理流</h2><p>基本介绍：</p><ul><li>节点流：节点流可以从一个特定的数据源读写数据，如FileReader、FileWriterd</li><li>处理流：也叫做包装流，是连接在已存在的流（节点流或者处理流、对节点流进行包装）之上，为程序提供更加强大的读写功能。如BufferedReader、BufferedWriter<ul><li><strong>处理流中存放了一个Reader或者Writer对象，在使用的时候这个对象可以传入对应的子类，进行功能的扩充</strong>（对其他流进行包装）</li></ul></li></ul><p>节点流和处理流之间的区别和联系：</p><ol type="1"><li>节点流是底层流/低级流，直接和数据源相接</li><li>处理流（包装流）包装节点流，既可以消除不同节点流之间的实现差异，也可以提供更方便的方法来完成输入输出</li><li>处理流对节点流进行包装，使用修饰器设计模式，不会直接与数据源相连</li></ol><blockquote><p>处理流的功能体现：</p><ol type="1"><li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</li><li>操作的便捷：处理流提供了一系列便捷的方法来一次性输入输出大批量的数据，使用更加灵活方便</li></ol></blockquote><h2 id="转化流">转化流</h2><p>转化流：将字节流转化成字符流（应对可能存在的文件乱码问题）</p><ul><li><p>转化流有两种：InputStramReader和OutputStreamWriter</p></li><li><p>在转化流上可以指定编码方式</p></li><li><p>InputStramReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.把FileInputStream 转成 InputStreamReader</span><br><span class="hljs-comment">// 2.指定编码</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(path), <span class="hljs-string">&quot;gbk&quot;</span>); <br><br><span class="hljs-comment">// 3.把InputStreamReader 传入 BufferedReader</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(inputStramReader);<br><br><span class="hljs-comment">// 4.读取</span><br>bufferedReader.readLine();<br><br><span class="hljs-comment">// 5.关闭外层流</span><br>bufferedReader.close();<br></code></pre></td></tr></table></figure></li><li><p>OutputStreamWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建流对象</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(path), <span class="hljs-string">&quot;gbk&quot;</span>);<br><br><span class="hljs-comment">// 2.写入</span><br>osw.write(<span class="hljs-string">&quot;xxx&quot;</span>);<br><br><span class="hljs-comment">// 3.关闭</span><br>osw.close();<br></code></pre></td></tr></table></figure></li></ul><h2 id="标准输出流">标准输出流</h2><p>标准输出流：PrintStream和PrintWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//PrintStream：字节打印流</span><br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> System.out;<br>out.print(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>out.close();<br><br><span class="hljs-comment">//改变输出位置</span><br>System.setOut(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(path));<br>System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br><br><span class="hljs-comment">//PrintWriter：字符打印流</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(System.out);<br><span class="hljs-comment">// new PrintWriter(new FileWriter(path));</span><br>pw.print(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>pw.close();<br></code></pre></td></tr></table></figure><h1 id="文件类">文件类</h1><p>常用的文件操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用File类</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(String pathname);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(File parent, String child);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(String parent, String child);<br><br><span class="hljs-comment">// 进行文件创建</span><br>.creatNewFile();<br><br><span class="hljs-comment">// 获取文件相关信息</span><br>getName();<br>getAbsolutePath();<br>getParent();<br>length();<br>exists();<br>isFile();<br>isDirectory();<br><br><span class="hljs-comment">//目录操作和文件删除</span><br>mkdir();<br>mkdirs();<br>delete();<span class="hljs-comment">//如果删除目录是删除一个空目录</span><br></code></pre></td></tr></table></figure><h1 id="文件操作">文件操作</h1><p>以字节流中文件中获取输入字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] getBytesFromFile(String sourceFilePath) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(sourceFilePath);<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[fileInputStream.available()];<br>    fileInputStream.read(bytes);<br>    fileInputStream.close();<br>    <span class="hljs-keyword">return</span> bytes;<br>&#125;<br></code></pre></td></tr></table></figure><p>以字节数组写入文件中，append标识是否追加写入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBytesToFile</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, String targetFilePath, <span class="hljs-type">boolean</span> append)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(targetFilePath, append);<br>    fileOutputStream.write(bytes);<br>    fileOutputStream.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出文件内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输出文件内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showFileContent</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fileReader);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>        System.out.println(line);<br>    &#125;<br>    reader.close();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://blog.csdn.net/m0_66689823/article/details/125881759?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-125881759-blog-116501936.pc_relevant_multi_platform_whitelistv3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">java中的io流_Jm呀的博客-CSDN博客_java的io流</a></li><li><ahref="https://blog.csdn.net/GRuion/article/details/120792320">Java文件处理_神奇的海螺呀的博客-CSDN博客_java文件处理</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础笔记(4)-泛型</title>
    <link href="/2022/09/03/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-4-%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/09/03/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-4-%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型基础">泛型基础</h1><h2 id="泛型定义">泛型定义</h2><ol type="1"><li><p>泛型又称为参数化类型，是在JDK5之后出现的新特性，解决数据类型的安全性问题</p></li><li><p>在类声明或实例化的时候只需要指定好需要的具体的类型即可</p></li><li><p>Java泛型可以保证如果程序在编译的时候没有发出警告，运行时就不会产生ClassCastException异常。同时代码更加简洁、健壮</p></li><li><p>泛型的作用是：可以在类声明的时候通过一个标识符表示类中某个属性的类型，或者某个方法返回值的类型，或者是参数类型（类似于模板）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;T&gt; &#123;<br>    T s; <span class="hljs-comment">//对应中括号中的T</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="泛型的声明">泛型的声明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口&lt;T&gt;&#123;&#125;;<br>class 类&lt;K,V&gt;&#123;&#125;;<br></code></pre></td></tr></table></figure><ul><li>其中，T，K，V等不代表值，而是代表类型</li><li>任意字母都可以，常用T来表示，是Type的缩写</li><li>Java库使用变量E来表示集合的元素类型；K和V分别表示键和值；T、S、U表示任意类型</li></ul><p>注意事项：</p><ol type="1"><li><p>T，E只能是引用类型</p></li><li><p>在指定泛型具体类型之后，可以传入该类型或其子类类型</p></li><li><p>如果不给定泛型的具体类型，则默认泛型类型为Object</p></li><li><p>在实际开发的时候可以简写，在new后面的可以简写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></li></ol><h2 id="自定义泛型">自定义泛型</h2><p>自定义泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名&lt;T,R,...&gt;&#123;&#125;;<br></code></pre></td></tr></table></figure><ol type="1"><li>普通成员可以使用泛型（属性、方法）</li><li>使用泛型的数组，不能初始化（因为在new的时候并不知道应该开多少空间）</li><li>静态方法中不能使用类的泛型（因为静态的在类加载的时候就创建了，与对象无关）</li><li>泛型类的类型，是在创建对象时确定的（因为创建对象的时候，需要指定确定类型）</li><li>如果在创建对象的时候，没有指定类型，默认为Object</li></ol><p>自定义泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口名&lt;T,R,...&gt;&#123;&#125;;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>接口中，静态成员也不能使用泛型（与泛型类的规定一样）（接口中的属性都是静态的）</p></li><li><p>泛型接口的类型，在<strong>继承接口</strong>或者<strong>实现接口</strong>的时候确定</p></li><li><p>没有指定类型，默认为Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> implenments I&#123;&#125;;<br>/ /等价于<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> implentments I&lt;Object, Object&gt;&#123;&#125;;<br><span class="hljs-comment">// 但是建议使用下面这种方式，更加规范</span><br></code></pre></td></tr></table></figure></li></ol><p>自定义泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符&lt;T,R,...&gt; 返回类型 方法名(参数列表)&#123;&#125;;<br><span class="hljs-keyword">public</span> &lt;T, R&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">(T t, R r)</span>&#123;&#125;;<span class="hljs-comment">//泛型方法</span><br><span class="hljs-comment">// 定义的泛型是提供给方法使用的</span><br><span class="hljs-comment">// 在调用方法的时候，会根据传入的参数自动确定对应的类型</span><br></code></pre></td></tr></table></figure><ol type="1"><li>泛型方法，可以定义在普通类中，也可以定义在泛型类当中</li><li>当泛型方法被调用的时候，会确定类型</li><li><code>public void eat(E e)&#123;&#125;</code>，修饰符后面没有尖括号，这是使用了类声明的泛型，而不是泛型方法</li><li>泛型方法可以使用类声明的泛型，也可以使用自己定义的泛型</li></ol><h2 id="泛型的继承和通配符">泛型的继承和通配符</h2><ol type="1"><li><p>泛型不具备继承性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<span class="hljs-comment">//这样书写是错误的</span><br></code></pre></td></tr></table></figure></li><li><p><code>&lt;?&gt;</code>: 支持任意泛型类型</p></li><li><p><code>&lt;? extends A&gt;</code>：支持A类以及A类的子类，规定了泛型的上限（实现接口的限制也是使用extends关键字）</p></li><li><p><code>&lt;? super A&gt;</code>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</p></li></ol><h2 id="泛型擦除">泛型擦除</h2><p>泛型擦除：虚拟机并没有泛型类型对象，所有的对象都属于一个普通的类。无论何时定义一个泛型类型，都会自动提供一个相应的原始类型。类型变量会被擦除，被替换为限定类型（通配符的限制），或者无限定的变量替换为Object</p><ul><li>虚拟机中没有泛型，只有普通的类和方法</li><li>所有的类型参数都会替换为它们的限定类型</li><li>合成桥方法来保持多态</li><li>为保持类型安全性，必要时会插入强制类型转换</li></ul><h2 id="泛型的限制">泛型的限制</h2><ol type="1"><li><p>不能使用基本数据类型实例化类型参数</p></li><li><p>运行时类型查询只适用于原始类型，不能查询泛型类型</p></li><li><p>不能创建参数化类型的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;String&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">// ERROR</span><br></code></pre></td></tr></table></figure></li><li><p>不能实例化类型变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">()</span>&#123;<br>first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>second = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>&#125;<span class="hljs-comment">// ERROR</span><br></code></pre></td></tr></table></figure></li><li><p>不能构造泛型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">T[] mm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">// ERROR</span><br></code></pre></td></tr></table></figure></li><li><p>泛型类的静态上下文中类型变量无效</p><ul><li>不能在静态字段或方法中引用类型变量，即不能使用带有类型变量的静态字段和方法</li></ul></li><li><p>不能抛出或捕获泛型类的实例</p><ul><li>既不能抛出也不能捕获泛型类的对象</li><li>泛型类扩展Throwable是不合法的</li><li>catch子句中不能使用类型变量</li></ul></li><li><p>可以取消对检查型异常的检查</p><p>使用泛型类、擦除以及<code>@SuppressWarnings</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwAs</span><span class="hljs-params">(Throwable t)</span> <span class="hljs-keyword">throws</span> T&#123;<br><span class="hljs-keyword">throw</span> (T) t;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础笔记(3)-异常、断言和日志</title>
    <link href="/2022/09/02/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-3-%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/"/>
    <url>/2022/09/02/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-3-%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="异常">异常</h1><h2 id="异常介绍">异常介绍</h2><p>Java中异常整体的架构图如下：</p><img src="/2022/09/02/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-3-%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" class="" title="Java异常体系"><p>在Java中，异常对象都是派生于Throwable类的一个类实例。当然用户也可以创建自己的异常类。所有异常都是由Throwable继承而来，然后分解为两个分支：</p><ol type="1"><li>Error（错误）：Java虚拟机无法解决的严重问题，例如JVM系统内部错误，资源耗尽等</li><li>Exception（异常）：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码来进行处理，例如空指针访问等</li></ol><p>在编写Java程序的时候，我们重点管制的时Exception层次，这里又分为两个分支，一个分支派生于RuntimeException，另一个则是其他异常。</p><p>由编程错误导致的异常属于RuntimeException，例如：</p><ul><li>错误的强制类型转换</li><li>数组访问越界</li><li>空指针异常</li></ul><p>程序本身没有问题，但是由于像IO错误这类问题导致的异常属于其他异常，例如：</p><ul><li>试图超越文件末尾继续读取数据</li><li>试图打开一个不存在的文件</li><li>试图根据给定的字符串查找Class对象，但是这个字符串表示的类并不存在</li></ul><p>在Java语言规范中，将派生于Error类或者RuntimeException类的所有异常称为<strong>非检查型（unchecked）异常</strong>，其他的异常称为<strong>检查型（checked）异常</strong>。所有检查型异常都应该在代码中处理，处理包括捕获或者抛出。</p><h2 id="自定义异常">自定义异常</h2><p>当程序中出现了某些“错误”，但是这些错误信息并没有在Throwable子类中进行描述处理，这个时候可以自己设计异常类，用于描述该错误信息。实现自定义异常只需要定义一个派生于Exception的类，或者派生于Exception的某个子类。</p><p>习惯的做法是，自定义的这个类应该包含两个构造器，一个是默认的构造器，另一个是包含详细描述信息的构造器。</p><blockquote><p>Throwable的toString方法会返回一个字符串，其中包含了这个详细信息，同时还提供getMessage()方法，用于获得Throwable对象的详细描述信息。</p></blockquote><h2 id="异常处理机制">异常处理机制</h2><p>异常处理机制包括捕获和抛出。</p><p>抛出指的是<code>throws</code>关键字。如果使用抛出来处理异常，那么一个方法应该声明所有可能抛出的检查型异常。</p><blockquote><p>throws和throw的对比：</p><ul><li><p>throws：用来声明一个方法可能产生的所有异常</p></li><li><p>throw：用来抛出一个具体的异常对象</p></li></ul><table><thead><tr class="header"><th></th><th>throws</th><th>throw</th></tr></thead><tbody><tr class="odd"><td>意义</td><td>异常处理的一种方式</td><td>手动生成异常对象的关键字</td></tr><tr class="even"><td>位置</td><td>方法声明处</td><td>方法体中</td></tr><tr class="odd"><td>后面带的东西</td><td>异常类型</td><td>异常对象</td></tr></tbody></table></blockquote><ul><li>注意：子类重写父类的方法的时候，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么是父类抛出异常类型的子类型</li></ul><p>捕获指的是<code>try-catch-finally</code>。在代码中捕获了该异常，就无需继续抛出了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">// 代码可能有异常</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    <span class="hljs-comment">// 当异常发生的时候，系统将异常封装成Exception对象e，传递给catch</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">// 无论是否发生异常，finally代码块都需要执行</span><br>    <span class="hljs-comment">// 通常将关闭和释放资源的代码放在这里</span><br>&#125;<br></code></pre></td></tr></table></figure><p>多个异常的捕获</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><br>&#125;<span class="hljs-keyword">catch</span>(FileNotFoundException | UnknownHostException e)&#123;<br><br>&#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>捕获多个异常的时候，异常变量隐含为final变量</li><li>可以在catch子句中再次抛出异常，这通常用来改变异常的类型</li><li>不应该在finally代码块中包含return语句，否则返回值会进行覆盖，甚至会吞掉可能的异常</li></ul><blockquote><p>堆栈轨迹（StackTrace）是程序执行过程中某个特定点上所有挂起方法调用的一个列表。</p><p>可以调用Throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息</p></blockquote><h2 id="try-with-resources">try-with-resources</h2><p>在finally语句中我们一般执行一些清除资源的流程，try-with-resources语句也能够达到相同的效果。它的最简语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<span class="hljs-type">Resource</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> ...)&#123;<br>work with res<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码，在try代码块执行完毕之后，会自动调用<code>res.close()</code>方法。当然这要求我们使用的资源类都实现了<code>AutoCloseable</code>接口，在这个接口中提供的方法<code>void close() throws Exception</code></p><ul><li>在括号中也可以指定多个资源，即使用多个语句定义资源，语句之间使用分号<code>;</code>分开</li><li>try-with-resources语句本身也可以有catch子句和finally子句</li><li>如果try块抛出异常，close方法也抛出异常，那么原来的异常会重新抛出，而close方法抛出的异常会被抑制。这些异常会被自动捕获，并由addSuppreseed方法增加到原来的异常。调用getSuppressed方法，可以生成从close方法抛出并抑制的异常数组</li></ul><h1 id="断言">断言</h1><p>断言机制允许在测试期间向代码中插入一些检查，而在生产代码中会自动删除这些检查。断言对应的关键字是<code>assert</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">assert</span> condition;<br><br><span class="hljs-keyword">assert</span> condition: expression;<br></code></pre></td></tr></table></figure><p>上面两个语句都会计算条件，如果结果为false，则抛出一个AssertionError异常。在第二种形式中，表达式expression将传入AssertionError对象的构造器，转化成一个消息字符串。</p><blockquote><p>表达式的唯一目的是产生一个消息字符串。AssertionError对象并不存储具体的表达式值。</p></blockquote><p>在默认情况下，断言是禁用的，可以在运行程序的时候使用选项开启。<code>java -enableassertions</code>或者<code>java -ea</code>。我们不必重新编译程序来启动或禁用断言，这是类加载器的职责。禁用断言的时候，类加载器会去除断言代码。</p><p>断言也可以是一种错误处理的机制，但是断言使用的情况往往是下面几种：</p><ul><li>断言失败是致命的，不可恢复的错误</li><li>断言检查只是在开发和测试阶段才会打开</li></ul><p>我们不应该使用断言向程序的其他部分通知错误，不应该利用断言与程序用户沟通问题。断言只应该用于在测试阶段确定程序内部错误的位置。</p><h1 id="日志">日志</h1><h2 id="日志优点">日志优点</h2><p>在一些简单的场景下，我们会使用<code>System.out.println</code>来进行一些输出，观察程序的行为。但是这个输出语句毕竟不是专门用来解决日志问题，日志API相比于它，会有更多的优点：</p><ul><li>可以很容易地取消其全部日志记录，或者仅仅取消某个级别以下的日志</li><li>可以很容易地禁止日志记录</li><li>日志记录可以被定向到不同的处理器</li><li>日志记录器和处理器都可以对记录进行过滤</li><li>日志记录可以采用不同的方式进行格式化</li><li>应用程序可以使用多个日志记录器</li><li>日志系统的配置由配置文件控制</li></ul><h2 id="标准java日志框架">标准Java日志框架</h2><p>标准Java日志框架需要引入的包为<code>java.util.logging</code></p><p>下面是一个基本的日志使用方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取全局日志记录器，调用info方法记录日志 </span><br>Logger.getGlobal().info(<span class="hljs-string">&quot;something...&quot;</span>);<br><br><span class="hljs-comment">// 取消日志记录</span><br>Logger.getGlobal().setLevel(Level.OFF);<br></code></pre></td></tr></table></figure><p>在一个专业的应用程序中，我们不应该将所有的日志都记录到一个全局的日志记录器中，因此我们可以定义自己的日志记录器，使用<code>getLogger</code>方法创建或者获取日志记录器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">myLogger</span> <span class="hljs-operator">=</span> Logger.getLogger(<span class="hljs-string">&quot;xxx.yyy.zzz&quot;</span>);<br></code></pre></td></tr></table></figure><p>日志记录器的名称具有层次结构，父子日志记录器会共享某些属性，如日志级别等。</p><p>通常会有下面7个日志级别：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>日志级别从高到底，默认只记录前三个级别的日志。也可以显式地设置日志记录级别，例如<code>logger.setLevel(Level.FINE)</code>，这样就会记录该级别以及更高级别的日志。也可以使用<code>Level.ALL</code>开启所有级别的日志记录，<code>Level.OFF</code>关闭所有级别的日志记录。</p><p>可以通过编辑配置文件来修改日志系统的各个属性。默认情况下，配置文件位于<code>conf/logging.properties</code>目录下，也可以通过设置<code>java.util.logging.config.file</code>的属性来确定配置文件的位置。</p><p>在日志框架中，还有三个比较重要的概念，处理器Handler、过滤器Filter和格式化器Formatter。</p><p>在默认情况下，日志记录器将日志记录发送到自己的处理器以及父日志记录器的处理器，最终会达到祖先处理器的ConsoleHandler中，它默认将记录输出到System.err流中，且日志记录等级为INFO。如果想要将日志记录发送到其他地方，就需要添加其他的处理器。日志API中提供了两个有用的Handler，分别是FileHandler，将日志发送到文件中；和SocketHandler，将日志发送到指定的主机和端口。调用<code>addHandler</code>方法来增加处理器。</p><p>在默认情况下，会根据日志记录的级别进行过滤。每个日志记录器和处理器都有一个可选的过滤器来完成附加的过滤。定义过滤器，需要实现Filter接口，并定义方法<code>boolean isLoggable(LogRecord record)</code>。这个方法对那些应该包含在日志中的记录返回true。使用<code>setFilter</code>方法来设置过滤器，同一时刻最多只能有一个过滤器。</p><p>ConsoleHandler类和FileHandler类可以生成文本和XML格式的日志记录。当然我们也可以自定义格式，这需要继承Formatter类并重写其中的<code>String format(LogRecord record)</code>方法，根据需要对记录中的信息进行格式化，并返回结果字符串。使用<code>setFormatter</code>方法来设置格式化器。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础笔记(2)-面向对象</title>
    <link href="/2022/09/02/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/09/02/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象基础">面向对象基础</h1><h2 id="包package">1.包package</h2><p><strong>应用场景</strong>：</p><ul><li>区分相同名称的类</li><li>当类很多的时候，可以很好地管理类</li><li>控制访问范围</li></ul><p><strong>基本语法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> xxx.yyy<br></code></pre></td></tr></table></figure><ul><li>package：关键字，表示打包</li><li>后面加包的名称</li></ul><p><strong>包的本质</strong>：</p><ul><li>创建不同的文件夹来保存类文件</li></ul><p><strong>包的使用</strong>：</p><ul><li>需要先在当前src中new一个package，然后在package中新建class。实际上也是对应不同的文件夹</li><li>如果要使用不同包的类，使用import指定引入对应的包里面的类</li><li>也可以不使用import，直接在使用类的时候带上包名</li></ul><p><strong>包的命名规范</strong>：</p><ul><li>一般是小写字母+小圆点</li><li>一般是公司名.项目名.业务模块名</li></ul><p><strong>使用细节</strong>：</p><ul><li>package的作用是声明当前类所在的包，需要放在类的最上面，一个类最多只有一句package</li><li>import指令放在package的下面，在类定义的前面，没有顺序要求</li><li>从编译器的角度来看，嵌套的包之间没有任何关系，每一个包都是独立的类集合</li></ul><p><strong>常用的包</strong>：</p><table><thead><tr class="header"><th>包名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>java.lang.*</td><td>lang包是基本包，默认引入，不需要再引入</td></tr><tr class="even"><td>java.util.*</td><td>util包，系统提供的工具包，工具类，使用Scanner</td></tr><tr class="odd"><td>java.net.*</td><td>网络包，网络开发</td></tr><tr class="even"><td>java.awt.*</td><td>Java的界面开发，GUI</td></tr></tbody></table><h2 id="类与对象的快速入门">2.类与对象的快速入门</h2><p><strong>快速使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String color;<br>&#125;<br><br><span class="hljs-comment">//使用</span><br>myCat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><blockquote><p>Java对象内存布局：</p><ul><li><p><strong>真正的对象存放在堆当中</strong></p></li><li><p>实例在栈空间中对应一个堆空间的地址，堆空间中对应存放了属性的值</p></li><li><p>如果默认赋值，仍然是<strong>引用赋值</strong>（地址复制）</p></li></ul></blockquote><p><strong>成员方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-comment">//成员属性</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一个好人&quot;</span>);<br>        System.out.println(n);<br>    &#125;<br>    <span class="hljs-comment">//public:访问修饰符（public、protected、private、默认）</span><br>    <span class="hljs-comment">//后面的与C++中类似</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>方法调用方式：</p><ol type="1"><li>当程序执行到方法时，就会开辟一个独立的栈空间</li><li>当方法执行完毕，或执行到return语句时，就会返回</li><li>返回到调用方法的地方</li><li>返回后继续执行方法后面的代码</li></ol></blockquote><p>注意事项：</p><ul><li><p>可以重载（overload）【函数签名：函数名称+参数类型+参数个数】</p></li><li><p>可变参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span>... nums)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        res += nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 基本语法：访问修饰符 返回类型 方法名(数据类型...形参名)</span><br><span class="hljs-comment">// 可以接收多个参数</span><br><span class="hljs-comment">// 使用可变参数的时候，可以将nums看作一个数组来使用</span><br></code></pre></td></tr></table></figure><ul><li><p>可变参数可以和普通类型的参数一起放在形参列表，但是必须保证可变参数在最后</p></li><li><p>一个形参列表中只能有一个可变参数</p></li></ul></li><li><p>作用域：全局变量有默认值、局部变量没有默认值、全局变量可以加修饰符、局部变量不可以加修饰符</p></li><li><p>同样具有<code>this</code>关键字</p></li></ul><h2 id="构造方法构造器">3.构造方法（构造器）</h2><p>构造方法完成初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person(my_name, my_age)&#123;<br>    <span class="hljs-built_in">this</span>.name = my_name;<br>    <span class="hljs-built_in">this</span>.age = my_age;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造器的修饰符可以默认，也可以是public、protected，不能是private</li><li>没有返回值</li><li>方法名和类名一致</li><li>系统自动调用</li><li>构造方法可以进行重载</li><li>同样有默认的无参构造器，如果定义了自己的构造器，则默认的构造器会被覆盖，就不能使用默认的无参构造器了，如果要使用，需要显式定义</li><li>在构造器方法中可以调用其他构造器方法，使用<code>this(参数列表)</code><ul><li>这个<code>this()</code><strong>必须在构造器中的第一行，所以最多只能有一个</strong></li></ul></li></ul><h2 id="访问修饰符">4.访问修饰符</h2><p>提供四种访问修饰符，用于控制方法和属性的访问权限（范围）</p><ul><li><p><code>public</code>：对外公开</p></li><li><p><code>protected</code>：对子类和同一个包中的类公开</p></li><li><p><code>默认，无修饰符号</code>：对同一个包中的类公开（有时候子类可能也在同一个包中）</p></li><li><p><code>private</code>：只有类本身可以访问，不对外公开</p></li></ul><table><thead><tr class="header"><th>修饰符</th><th>本类</th><th>同一个包</th><th>子类</th><th>不同包</th></tr></thead><tbody><tr class="odd"><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr class="even"><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr class="odd"><td>默认</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr class="even"><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>使用细节：</p><ul><li><p>修饰符可以用来修饰类中的属性，成员方法以及类本身</p></li><li><p>对于类本身来说，只能使用两种默认和public，并且遵循上述访问权限的特点</p></li></ul><h2 id="静态变量和类方法">5.静态变量和类方法</h2><h3 id="类变量静态变量">类变量（静态变量）</h3><p>对于一个类来说，静态变量是所有类的实例所共享的，使用<code>static</code>来修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count;<span class="hljs-comment">//被Child的所有实例所共享</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>访问修饰符的规则与前面相同</p></li><li><p>实例和类名都可以对静态属性进行访问，建议使用类名来进行访问</p></li><li><p>静态变量的初值</p><ul><li><p>可以在类中直接赋值</p></li><li><p>可以使用static代码块进行初值定义</p></li><li><p>如果都没有，则是默认值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">//方法1，在类中直接赋值，id = 1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">//方法2，在static代码块中赋初值，id = 2</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        id = <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//方法3，不写，为默认值 id = 0</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> id;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="类方法静态方法">类方法（静态方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">访问修饰符 <span class="hljs-keyword">static</span> 数据返回类型 方法名()&#123;&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>当方法中不涉及到任何和对象实例相关的成员，不生成实例也可以使用，则可以将方法设计成静态方法，提高开发效率</li><li>在实际设计的时候，往往将一些通用方法设计成静态方法，例如打印数组，排序等方法（工具类）</li><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区</li><li>类方法中没有this的参数，普通方法中隐含着this的参数</li><li>实例和类名都可以调用类方法</li><li><strong>类方法中不允许使用和对象有关的关键字</strong>，比如<code>this</code>和<code>super</code></li><li><strong>类方法中只能访问静态变量或静态方法</strong></li><li><strong>普通成员方法，既可以访问普通变量或方法，又可以访问静态变量或方法</strong>（遵守访问权限）</li></ol><h3 id="main方法">main方法</h3><p>main方法的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>理解：</p><ol type="1"><li><p>main()方法是由Java虚拟机来进行调用的，所以该方法的访问权限必须<strong>pubilc</strong></p></li><li><p>Java虚拟机在执行main方法的时候不需要创建对象，所以是类方法<strong>static</strong></p></li><li><p>接收String类型的数组参数，该数组中保存执行Java命令的时候传递给所运行的类的参数</p></li><li><p>在main方法中，我们可以直接调用main方法所在类的静态方法或静态属性；但是不能直接访问该类中的非静态成员，必须创建该类的一个实例对象之后才能通过这个对象去访问类中的非静态成员</p></li></ol><blockquote><p>IDEA main函数动态传值：Program arguments</p></blockquote><h3 id="工厂方法">工厂方法</h3><p>静态方法的另外一种常见用途就是工厂方法，使用静态工厂方法来构造对象。构造对象可以通过构造器来完成，而工厂方法可以提供更多选择，更多类型的构造方式。</p><h2 id="代码块">6.代码块</h2><p>代码块：又称为初始化块，是类的一部分，类似于方法但是没有方法名，没有返回也没有参数，只有方法体。代码块不需要通过对象和类显式调用，而是在加载类，或创建对象的时候隐式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符]&#123;代码块体&#125;;<br></code></pre></td></tr></table></figure><p>细节：</p><ol type="1"><li>修饰符可选，但是只能写static</li><li>有static的为静态代码块、没有static的为普通代码块</li><li>静态代码块只会在类加载的时候调用一次（<strong>对类进行初始化</strong>）</li><li>普通代码块会在每次创建对象的时候都进行调用，在仅加载的时候不会被调用</li><li>静态代码块只能调用静态成员，普通代码块可以调用任意成员</li><li>代码块的调用顺序优先于构造器</li><li>构造器的最前面其实是隐含了super()和调用普通代码块</li><li>分号可写可省略</li></ol><blockquote><p>类被加载的时机：</p><ol type="1"><li>创建对象实例的时候（new）</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员的时候</li></ol></blockquote><blockquote><p><strong>创建一个对象的时候，在一个类中的执行情况</strong>：</p><ol type="1"><li>调用静态代码块和静态属性初始化（两种初始化调用的优先级相同，按照执行顺序调用）</li><li>调用普通代码块和普通属性初始化（两种初始化调用的优先级相同，按照执行顺序调用）</li><li>调用构造器</li></ol></blockquote><blockquote><p><strong>创建一个子类对象的时候，类中的执行情况：</strong></p><p>（父类加载、子类加载、父类创建、子类创建）</p><ol type="1"><li>父类的静态代码块和静态属性</li><li>子类的静态代码块和静态属性</li><li>父类的普通代码块和普通属性</li><li>父类的构造方法</li><li>子类的普通代码块和普通属性</li><li>子类的构造方法</li></ol></blockquote><h2 id="jar文件">7.JAR文件</h2><p>在将应用程序打包的时候，我们希望只向用户提供一个单独的文件，而不是一个包含大量类文件的目录结构。Java归档文件(JAR)就是为此目的而设计的。一个JAR文件可以包含类文件，也可以包含诸如图像、声音等其他类型的文件。JAR文件采用ZIP压缩格式。</p><h1 id="面向对象特性">面向对象特性</h1><h2 id="封装">1.封装</h2><p>封装（encapsulation）：黑盒，内部细节隐藏。对数据进行验证，保证安全合理</p><p>封装实现的步骤：</p><ol type="1"><li>将属性进行私有化private，不能直接修改属性</li><li>提供一个公共的public的<strong>set</strong>方法，进行对属性的设置赋值</li><li>提供一个公共的public的<strong>get</strong>方法，进行对属性的值获取</li></ol><h2 id="继承">2.继承</h2><p>继承（extends）的必要性：提高代码复用，扩展性</p><p>继承的基本语法<code>extends</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class 子类 extends 父类&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>子类会自动拥有父类定义的属性和方法</li><li>父类又可以叫做 超类、基类</li><li>子类又可以叫做 派生类</li></ul><p>继承的细节：</p><ol type="1"><li>子类继承了所有的属性和方法，但是私有属性和方法不能在子类中直接访问（可以通过间接方法public访问）</li><li>子类必须调用父类的构造器，完成父类的初始化</li><li>当创建子类对象的时候，不管使用子类的哪一个构造器，<strong>默认情况下都会先调用父类的无参构造器</strong>。<ul><li>默认有一个<code>super()</code>，默认调用父类的无参构造器</li></ul></li><li>如果父类没有提供无参构造器，则必须在子类的构造器中<strong>使用<code>super</code>关键字来指定使用父类的哪一个构造器</strong>来完成对父类的初始化，否则编译报错<ul><li><code>super(参数列表)</code>即表示调用父类对应的构造器</li><li>super在使用的时候，必须要放在构造器的第一行</li><li><strong><code>super()</code>和<code>this()</code>都必须要放在构造器的第一行，所以这两个方法不能存在于同一个构造器内</strong></li></ul></li><li>java所有类都是Object类的子类，Object类是所有类的基类</li><li>父类构造器的调用（super）不限于直接父类，可以一直向上追溯直到Object类（顶级父类）</li><li>子类最多只能继承一个父类（直接继承），即Java中是<strong>单继承</strong>的机制<ul><li>如果想让A类继承B类和C类，构造继承链条<code>A-&gt;B-&gt;C</code></li></ul></li><li>不能滥用继承，子类和父类之间应该要满足IsA的逻辑关系</li></ol><p><strong>继承的本质</strong>：</p><p>当子类对象创建好了之后，其实在内存中会保存一种子类和父类之间的查找关系。子类对象创建的时候，首先会从Object加载开始加载该子类的所有父类信息，然后子类对应的堆内存中保存了自己所有父类的变量空间，即使父类之间存在相同属性，也不会进行空间的覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//继承关系：Son -&gt; Father -&gt; GrandPa</span><br><span class="hljs-keyword">public</span> GrandPa&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;GrandPa&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">hobby</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;traval&quot;</span>;<br>&#125;<br><span class="hljs-keyword">public</span> Father&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Father&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br>&#125;<br><span class="hljs-keyword">public</span> Son&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Son&quot;</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.70</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>son.</code>来进行属性的访问过程：</p><ol type="1"><li>首先看子类是否具有该属性</li><li>如果子类具有该属性并且可以访问（访问修饰符的作用），那么就返回该信息，<strong>如果不能访问就直接报错而不会再往下面找</strong></li><li>如果子类没有这个属性，就看父类有没有，按照规则逐级向上，直到找到一个或者哪里都找不到报错</li></ol><p><strong>super关键字</strong>：super代表父类的引用，可以用于访问父类的属性、方法和构造器</p><p>基本语法：<code>super.属性</code> <code>super.方法</code><code>super(参数列表)</code></p><ol type="1"><li>可以访问父类的属性和方法（受访问控制符限制）</li><li>可以访问父类的构造器</li></ol><p>使用细节：</p><ol type="1"><li>调用父类构造器的好处，达到分工明确的效果（父类属性父类初始化、子类属性子类初始化）</li><li>当子类和父类存在同名的成员的时候，为了访问父类的成员必须使用<code>super</code><ul><li><strong>如果不存在同名，则super、this和直接访问是一样的效果</strong></li></ul></li><li>super的访问不限于直接父类，如果爷爷类和本类中具有同名的成员，也可以使用super去访问爷爷类中的成员；如果多个父类（上级类）中都有同名的成员，使用super访问按照就近原则进行</li></ol><p>super和this的比较：</p><table><thead><tr class="header"><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr class="odd"><td>访问属性</td><td>访问本类中的属性，如果没有再从父类中进行查找</td><td>直接访问父类中的属性</td></tr><tr class="even"><td>调用方法</td><td>访问本类中的方法，如果没有再从父类中进行查找</td><td>直接访问父类中的方法</td></tr><tr class="odd"><td>调用构造器</td><td>调用本类构造器，必须放在构造器的首行</td><td>调用父类构造器，必须放在子类构造器的首行</td></tr><tr class="even"><td>特殊</td><td>表示当前对象</td><td>用于子类中访问父类对象</td></tr></tbody></table><p><strong>方法重写/覆盖</strong>（override）：</p><p>简单来说，方法重写就是子类有一个方法和父类的某个方法的名称、返回类型和参数等都一样，我们就说子类的这个方法覆盖了父类的那个方法（<strong>但是并不是完全覆盖，父类的方法并没有消失，通过super仍然可以访问到</strong>）</p><ol type="1"><li>子类的方法的参数、方法名称要和父类的参数，方法名称完全一样</li><li>子类的返回类型和父类的返回类型一样，或者是父类的返回类型的子类（eg：父类的返回类型是Object、子类的返回类型是String，这种情况也可以，即<strong>返回类型也要是子类</strong>）</li><li>访问控制符不需要完全相同，但是<strong>子类方法不能缩小父类方法的访问权限</strong></li></ol><h2 id="多态">3.多态</h2><p>多态（polymorphic）：代码复用，代码维护</p><ul><li>方法或者对象具有多种形态，称之为多态。多态是建立在封装和继承的基础之上的</li><li>多态的具体体现<ul><li>方法的多态：重写和重载体现多态</li><li>对象的多态：<strong>多态的核心</strong></li></ul></li></ul><p>对象的多态：<strong>可以让父类的引用指向子类的对象</strong></p><ol type="1"><li>一个对象的<strong>编译类型</strong>和<strong>运行类型</strong>可以不一致</li><li>编译类型在定义对象的时候就去确定了，不能改变</li><li>运行类型是可以变化的（体现多态）</li><li>编译类型看定义的时候等号的左边，运行类型看等号的右边</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<span class="hljs-comment">//animal的编译类型是Animal，运行类型是Dog</span><br>animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//animal的运行类型变成了Cat，但是编译类型仍然是Animal</span><br></code></pre></td></tr></table></figure><p>多态的细节：</p><ol type="1"><li><p>多态的前提是：<strong>两个类之间是存在继承关系的</strong></p></li><li><p>多态的向上转型：</p><ul><li><p>本质：父类的引用指向了子类的对象（子类向上转型成为父类，不限于直接父类）</p></li><li><p>语法：<code>父类类型 引用名称 = new 子类类型();</code></p></li><li><p>特点：</p><ul><li>编译类型看左边，运行类型看右边</li><li>可以调用父类中的所有成员（遵循访问权限）</li><li>不能调用子类中的特有成员（在编译的时候能够调用哪些成员是看编译类型）</li><li>最终执行效果以子类中（运行类型）的实现为主</li></ul></li></ul></li><li><p>多态的向下转型：</p><ul><li><p>本质：当前对象向下转型成为与运行类型相同的类型</p></li><li><p>语法：<code>子类类型 引用名称 = (子类类型) 父类引用名称;</code></p></li><li><p>特点：只能强转父类的引用，不能强转父类的对象；</p><p>​要求父类的引用必须指向的是当前目标类型的对象；（运行类型和目标类型相同）</p><p>​ 可以调用子类类型中的所有成员；</p></li></ul></li><li><p><strong>直接调用属性的时候，看的是编译类型中的实现</strong></p></li><li><p><code>instanceOf</code>操作符：用于判断对象的类型（运行类型）是否为某某类型或者某某类型的子类型</p><ul><li>在将父类强制转换成子类之前，应该使用instancof进行检查</li></ul></li></ol><p><strong>动态绑定机制</strong></p><ul><li><p>当调用<strong>对象方法</strong>的时候，<strong>具有动态绑定机制</strong>，该方法会和该对象的内存地址/运行类型绑定</p><ul><li>如果是private、static、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，这称为静态绑定</li></ul></li><li><p>当调用<strong>对象属性</strong>的时候，<strong>没有动态绑定机制</strong>，哪里声明，哪里使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getI() + <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果使用b去调用sum1()方法，里面的i使用的是父类里的i</p></li><li><p>如果使用b去调用sum2()方法，里面的getI()方法使用的是子类里面的getI()方法</p></li></ul><h1 id="面向对象补充">面向对象补充</h1><h2 id="final关键字">1.final关键字</h2><p>final：修饰关键字，可以用来修饰类、属性、方法和局部变量</p><p>使用到final的一些情况：</p><ol type="1"><li>当不希望类被继承的时候，使用final修饰</li><li>当不希望父类的某个方法被子类覆盖或者重写（override）的时候，使用final修饰</li><li>当不希望类的某个属性的值被修改，使用final修饰</li><li>当不希望某个局部变量的值被修改，使用final修饰</li></ol><p>final使用细节：</p><ol type="1"><li>final修饰的属性又称为常量，用大写+下划线来命名</li><li>final修饰的属性在定义的时候必须赋初值，并且不能修改，赋初值的位置有<ul><li>定义时</li><li>在构造器中</li><li>在代码块中</li></ul></li><li>如果final修饰的属性是静态的，则赋初值的位置只能是定义时或者静态代码块中</li><li>如果类已经被声明了final，其中的方法就没必要再用final了</li><li>final不能修饰构造方法</li><li>final和static往往搭配使用，效率更高，调用该属性的时候不会使得类加载。（底层编译器实现了优化）</li><li>包装类（Boolean，Integer...）和String类都是final的</li></ol><h2 id="抽象类">2.抽象类</h2><p>应用场景引出：当父类的某些方法需要声明但是又不确定该如何实现，可以将其声明为抽象方法，此时这个类就是抽象类</p><p>抽象方法的声明：（抽象方法没有实现，即没有方法体，空的也不行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">xxx</span>&#123;<br>访问修饰符 <span class="hljs-keyword">abstract</span> 返回类型 方法名称();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用了<code>abstract</code>声明了抽象方法，此时类也需要使用<code>abstract</code>来声明</li></ul><p>使用细节：</p><ol type="1"><li><p>抽象类不能被实例化（new）</p></li><li><p>可以定义一个抽象类的对象变量</p><blockquote><p>举例来说，Person是一个抽象类，Student继承了Person并实现了其中的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">// 错误</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(); <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>抽象类不一定要包含abstract方法</strong></p></li><li><p><code>abstract</code>只能用来修饰类或者方法</p></li><li><p>抽象类的本质还是类，可以拥有任何应有的成员</p></li><li><p>如果一个类继承了抽象类，<strong>则必须实现抽象类中的所有抽象方法，或者自己也声明成abstract类</strong></p></li><li><p><strong>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</strong></p></li></ol><h2 id="object类的详解">3.Object类的详解</h2><p>Object类是Java中所有类的始祖，在Java中每个类都扩展了Object，但是不需要显式地写出。如果没有明确地指出父类，那么就认为Object是这个类的超类</p><p>Object方法摘要：</p><table><thead><tr class="header"><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr class="odd"><td>clone()</td><td>创建并返回此对象的一个副本</td></tr><tr class="even"><td>equals()</td><td>指示其他某个对象是否与此对象相等</td></tr><tr class="odd"><td>finalize()</td><td>当GC确定不存在对该对象的更多引用的时候，由对象的垃圾回收机制调用</td></tr><tr class="even"><td>getClass()</td><td>返回此Object的运行时类</td></tr><tr class="odd"><td>hashCode()</td><td>返回该对象的哈希码</td></tr><tr class="even"><td>notify()</td><td>唤醒在此对象监视器上等待的单个线程</td></tr><tr class="odd"><td>notifyAll()</td><td>唤醒在此对象监视器上等待的所有线程</td></tr><tr class="even"><td>toString()</td><td>返回该对象的字符串表示</td></tr><tr class="odd"><td>wait()</td><td>线程等待</td></tr></tbody></table><p><code>equals</code>方法：是Object类中的方法，只能判断引用类型</p><p>默认判断的是地址是否相等，在子类中一般会对该方法进行重写，用于判断内容是否相等。例如Integer</p><blockquote><p>==和equals的对比：</p><p>==是一个比较运算符：</p><ol type="1"><li>==既可以判断基本类型，又可以判断引用类型</li><li>如果是判断基本类型，那么就比较<strong>值</strong>是否相等</li><li>如果是判断引用类型，那么就判断<strong>地址</strong>的值是否相等，即判断是否是一个同一个对象</li></ol></blockquote><p>Java语言规范要求equals方法具有下面的特性：</p><ol type="1"><li>自反性：对于任何非空应用x，x.equals(x)应该返回true</li><li>对称性：对于任何引用x和y，应该有y.equals(x) <spanclass="math inline">\(\Leftrightarrow\)</span> x.equals(y)</li><li>传递性：对于任何引用x，y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也要返回true</li><li>一致性：如果x和y引用的对象没有发生变化，反复调用x.equal(y)应该返回相同的结果</li><li>对于任意非空引用x，x.equals(null)应该返回false</li></ol><blockquote><p>在重写Object中的equals方法的时候，一个常见的错误是定义的形参类型不是Object，这样的话是没有进行方法的重写，而是定义了一个完全无关的方法。因此在重写的时候可以增加注解<code>@Override</code>来进行检查</p></blockquote><p><code>hashCode</code>方法：返回该对象的哈希码</p><ol type="1"><li>用于提高具有哈希结构的容器的效率</li><li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</li><li>两个引用，如果指向的是不同对象，则哈希值是不一样的（不严谨，可能存在冲突）</li><li>哈希值主要与地址有关，但是不能完全等价于地址</li><li>有必要的时候也可以重写hashCode方法</li><li>如果重写了equals方法，那么也需要重写hashCode方法</li></ol><p><code>toString</code>方法：返回该对象的字符串表示</p><ol type="1"><li>默认返回<code>全类名@哈希值的十六进制表示</code>（全类名 = 包名 +类名）</li><li>子类往往重写toString方法，用于返回对象的属性信息（一般情况下是这样，并且IDEA中有生成的快捷键）</li><li>重写toString方法，打印对象或者拼接对象的时候，都会自动调用该对象的toString形式</li><li>当直接输出一个对象的时候，toString方法会被默认调用</li></ol><p><code>finalize</code>方法：垃圾回收的时候会被调用（<em>已经被废弃</em>）</p><ol type="1"><li>当对象被回收的时候，系统会自动调用该对象的finalize方法。</li><li>子类可以重写该方法，做一些释放资源的操作</li><li>当某个对象没有任何引用的时候，JVM就认为这个对象是垃圾对象，就会使用垃圾回收机制来销毁该对象。在销毁该对象之前，会调用该对象的finalize方法</li><li>垃圾回收机制的调用是由系统来决定的，也可以通过<code>System.gc()</code>来主动触发垃圾回收机制（也不一定绝对成功）</li></ol><h2 id="包装类与自动装箱">4.包装类与自动装箱</h2><p>包装类（Wrapper）：所有的基本类型都有一个与之对应的类，这些类被成为包装器。这些包装器类是不可变的，一旦构造了包装器，就不允许更改其中的值。同时包装器类还是final，因此不能派生它们的子类</p><table><thead><tr class="header"><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr class="odd"><td>boolean</td><td>Boolean</td></tr><tr class="even"><td>char</td><td>Character</td></tr><tr class="odd"><td>byte</td><td>Byte</td></tr><tr class="even"><td>short</td><td>Short</td></tr><tr class="odd"><td>int</td><td>Integer</td></tr><tr class="even"><td>long</td><td>Long</td></tr><tr class="odd"><td>float</td><td>Float</td></tr><tr class="even"><td>double</td><td>Double</td></tr></tbody></table><p><strong>装箱和拆箱</strong>：包装类和基本数据类型的相互转换</p><blockquote><p>装箱：基本数据类型 -&gt; 包装类型</p><p>拆箱：包装类型 -&gt; 基本数据类型</p></blockquote><ul><li>JDK 5 之前采用手动装箱和拆箱的方式</li><li>JDK 5 以后（含JDK 5）采用自动装箱和拆箱的方式</li><li>自动装箱底层调用了valueOf方法</li><li>装箱和拆箱是编译器要做的工作，而不是虚拟机。编译器在生成类的字节码的时候会插入必要的方法调用，虚拟机只是执行这些字节码</li></ul><p>手动装箱和拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//手动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(n);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> Integer.valueOf(n);<br><span class="hljs-comment">//手动拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> integer.intValue();<br></code></pre></td></tr></table></figure><p>自动装箱和拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> n;<span class="hljs-comment">//底层使用的仍然是ValueOf方法</span><br><span class="hljs-comment">//自动拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> integer;<span class="hljs-comment">//底层仍然是.intValue方法</span><br></code></pre></td></tr></table></figure><blockquote><p>valueOf的源码会进行判断，举<code>Integer.valueOf</code>为例。如果传入的整数在-128到127范围内，会直接返回Integer对象，否则再才会new一个新对象。（下为源码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<span class="hljs-comment">//-128~127</span><br>      <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>包装类和String的相互转换</strong>：</p><p>包装类 -&gt; String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//方式一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> i.toString();<span class="hljs-comment">//方式二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(i);<span class="hljs-comment">//方式三</span><br></code></pre></td></tr></table></figure><p>String -&gt; 包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.parseInt(str);<span class="hljs-comment">//方式一</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(str);<span class="hljs-comment">//方式二</span><br></code></pre></td></tr></table></figure><p><strong>包装类的常用方法</strong>：</p><table><thead><tr class="header"><th>方法名（部分为属性名）</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>MIN_VALUE</td><td>返回最大值</td></tr><tr class="even"><td>MAX_VALUE</td><td>返回最小值</td></tr><tr class="odd"><td>isDigt()</td><td>判断是否是数字</td></tr><tr class="even"><td>isLetter()</td><td>判断是否是字母</td></tr><tr class="odd"><td>isUpperCase()</td><td>判断是否是大写</td></tr><tr class="even"><td>isLowerCase()</td><td>判断是否是小写</td></tr><tr class="odd"><td>isWhitespace()</td><td>判断是否是空格</td></tr><tr class="even"><td>toUpperCase()</td><td>转成大写</td></tr><tr class="odd"><td>toLowerCase()</td><td>转成小写</td></tr></tbody></table><h2 id="枚举类">5.枚举类</h2><p>枚举（enumeration、enum）：枚举是一组常量的集合，枚举属于一种特殊的类，里面包含一组特定的有限的对象。实现枚举的两种方式有自定义枚举类实现，以及使用关键字<code>enum</code>。</p><blockquote><p>我们可以自定义实现一个类来达到枚举类的效果：</p><ol type="1"><li>将构造器私有化，防止外部直接调用new</li><li>删除set相关方法（防止属性被修改，保证只读）</li><li>在类内部直接创建固定的对象（枚举变量名通常大写，遵循常量的命名规范）</li><li>优化，可以加入<code>final</code>修饰符（final与static的编译器联合优化）</li></ol></blockquote><p>当然在Java中有枚举类的实现，使用<code>enum</code>关键字即可。枚举类的实例都事先定义了，如下面的枚举类只有四个实例。因此在比较两个枚举类的值的时候，并不需要调用equals，直接使用<code>==</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span> &#123;<br>    SPRING(<span class="hljs-string">&quot;春天&quot;</span>),SUMMER(<span class="hljs-string">&quot;夏天&quot;</span>),AUTUMN(<span class="hljs-string">&quot;秋天&quot;</span>),WINATER(<span class="hljs-string">&quot;冬天&quot;</span>);<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Season</span><span class="hljs-params">(String name)</span>&#123;<span class="hljs-built_in">this</span>.name = name;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>使用关键字<code>enum</code>替代class</li><li>使用<code>常量名(实参列表)</code>代替手动new的固定对象</li></ol><p>枚举类的注意事项：</p><ol type="1"><li>当使用<code>enum</code>的时候开发枚举类的时候，<strong>会默认继承一个名称为Enum的类</strong>，而且枚举类是一个final类</li><li>如果使用无参构造器，那么括号可以省略</li><li>如果有多个常量对象，使用<code>,</code>间隔</li><li>如果使用<code>enum</code>来实现枚举，要求将常量对象的定义放在最前面</li><li>使用了<code>enum</code>关键字后，就不能再继承其他类了（因为已经默认继承了Enum类，而Java是单继承机制）</li><li>但是使用了<code>enum</code>关键字后，还是可以实现接口</li><li>枚举的构造器总是私有的，可以省略private修饰符</li></ol><p>所有的枚举类型都是Enum类的子类，因此继承了这个类的许多方法。</p><table><thead><tr class="header"><th>成员函数</th><th>函数说明</th></tr></thead><tbody><tr class="odd"><td>toString</td><td>Enum类中已经重写了，返回当前对象名。子类可以重写该方法</td></tr><tr class="even"><td>name</td><td>返回当前对象名（常量名），子类不能重写（final）</td></tr><tr class="odd"><td>ordinal</td><td>返回当前对象的位置号，默认从0开始</td></tr><tr class="even"><td>values</td><td>返回当前枚举类中的所有常量（不是常量名）</td></tr><tr class="odd"><td>valueOf</td><td>将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常</td></tr><tr class="even"><td>compareTo</td><td>比较两个枚举常量（实际比较的就是位置号，本身编号 - 传入对象的编号）</td></tr></tbody></table><h2 id="反射">6.反射</h2><h3 id="反射机制">反射机制</h3><p>一个快速入门小demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// className = &quot;cat&quot;, methodName= &quot;hi&quot; 均为字符串类型</span><br><br><span class="hljs-comment">// 1.加载类，返回Class类型的对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br><br><span class="hljs-comment">// 2.通过cls得到所加载的对象实例</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> cls.newInstance();<br><br><span class="hljs-comment">// 3.通过cls得到对应加载类的Method对象，即在反射中，可以把方法视为对象</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">method1</span> <span class="hljs-operator">=</span> cls.getMethod(methodName);<br><br><span class="hljs-comment">// 4.通过method1来调用方法，通过方法对象来实现方法的调用</span><br><span class="hljs-comment">// 传统方法是 对象.方法() 在反射机制中是 方法.invoke(对象)</span><br>method1.invoke(o);<br><br><span class="hljs-comment">// 得到类中的字段</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> cls.getField(<span class="hljs-string">&quot;name&quot;</span>); <span class="hljs-comment">// 不能得到私有字段</span><br><span class="hljs-type">String</span> <span class="hljs-variable">nameValue</span> <span class="hljs-operator">=</span> nameField.get(o); <span class="hljs-comment">// 获得name字段的值</span><br></code></pre></td></tr></table></figure><ol type="1"><li><p>反射机制允许程序在执行期间借助于ReflectionAPI取得任何类的内部信息（比如成员变量，构造器，成员方法等），并能够操作对象的属性及方法。反射在设计模式和框架底层中都会用到</p></li><li><p>加载完类之后，在堆中就产生了一个Class类型的对象（这是一个对象，这个对象的类型是Class，<strong>一个类只有一个Class对象</strong>）。这个对象中包含了类的完整结构信息，通过这个对象就能够的得到类的结构。这个Class对象就像一面镜子，透过这个镜子能够看到类的结构</p></li><li><p>通过反射机制可以完成</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ul></li></ol><table><thead><tr class="header"><th>反射相关的主要类</th><th></th></tr></thead><tbody><tr class="odd"><td>java.lang.Class</td><td>代表一个类，Class对象表示某个类加载后在堆中的对象</td></tr><tr class="even"><td>java.lang.reflect.Method</td><td>代表类的方法，Method对象表示某个类的对象</td></tr><tr class="odd"><td>java.lang.reflect.Field</td><td>代表类的成员变量，Field对象表示某个类的成员变量</td></tr><tr class="even"><td>java.lang.reflect.Constructor</td><td>代表类的构造方法，Constructor对象表示某个类的构造器</td></tr></tbody></table><h3 id="class类">Class类</h3><p>在程序运行期间，Java运行时系统始终为所有对象维护一个运行时类型标识。这个辛纳希会跟踪每个对象会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确的方法。</p><p>我们可以通过一个特殊的Java类来访问这些信息，即Class类。</p><p><strong>基本介绍</strong>：</p><ol type="1"><li>Class也是类，因此也继承Object类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li><li>每个类的实例都会记得自己是由哪一个Class实例所生成的</li><li>通过Class对象可以完整地得到一个类的完成结构（提供了一系列API）</li><li>Class对象是存放在堆中的</li></ol><table><thead><tr class="header"><th>Class类的常用方法</th><th></th></tr></thead><tbody><tr class="odd"><td>static Class forName(String name)</td><td>返回指定类名name的Class对象</td></tr><tr class="even"><td>Objecgt newInstance()</td><td>调用缺省构造函数，返回该Class对象的一个实例</td></tr><tr class="odd"><td>getName()</td><td>返回此Class对象所对应的实体（Class、Field、Method...）名称</td></tr><tr class="even"><td>Class getSuperClass()</td><td>返回当前Class对象的父类的Class对象</td></tr><tr class="odd"><td>Class [] getInterfaces()</td><td>获取当前Class对象的接口</td></tr><tr class="even"><td>ClassLoader getClassLoader()</td><td>返回该类的类加载器</td></tr><tr class="odd"><td>Class getSuperclass()</td><td>返回表示此Class所表示的实体的超类的Class</td></tr><tr class="even"><td>Constructor [] getConstructors()</td><td>返回一个包含Constructor对象的数组</td></tr><tr class="odd"><td>Field [] getDeclaredFields()</td><td>返回Field对象数组</td></tr><tr class="even"><td>Method getMethod(String name, Class... paramTypes)</td><td>返回一个Method对象，此对象的形参类型为paramType</td></tr></tbody></table><p>获取Class对象的方法：</p><ol type="1"><li><code>Class.forName()</code>：已知一个类的全类名，可以通过Class类的静态方法forName获取<ul><li>多用于配置文件加载类</li></ul></li><li><code>类.class</code>：已知具体的类，通过该类的class获取。该方式最安全可靠，程序性能最高<ul><li>多用于参数传递，比如通过反射得到对应的构造器对象</li></ul></li><li><code>对象.getClass()</code>：在前面说的这是运行类型。已知对象实例，可以通过getClass方法获取</li><li>从类加载器获得Class对象</li><li>基本数据类型（int、double...）:<code>Class cls = int.class</code></li><li>基本类型对应的包装类：<code>Class cls = 包装类.TYPE</code></li></ol><h3 id="反射应用">反射应用</h3><p>反射机制中一个重要的内容就是检查类的结构。</p><p>在<code>java.lang.reflect</code>包中有三个类Filed、Method和Constructor分别用于描述类的字段、方法和构造器。这三个类都有一个叫做getName的方法，用来返回对应的名称。每个类都同时具有更多方法，分别返回对应字段、方法或构造器的描述信息。</p><p>Java安全机制允许查看一个对象有哪些字段。但是除非是拥有访问权限，否则不允许读写那些字段的值。反射机制的默认行为受限于Java的访问控制，不过可以调用Field、Method或者Constructor对象的setAccessible方法覆盖Java的访问控制。调用<code>setAccessible(true)</code>则可以绕过。</p><p>通过反射创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 首先获得User对应的Class对象</span><br>Class&lt;?&gt; userClass = ClassforName(<span class="hljs-string">&quot;User&quot;</span>);<br><br><span class="hljs-comment">// 调用pubilc，默认的无参构造器创建User类</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> userClass.newInstance(); <br><br><span class="hljs-comment">// 调用pubilc的单参构造器创建User类</span><br>Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);<br><span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;hahaha&quot;</span>);<br><br><span class="hljs-comment">// 调用private的双参构造器创建User类</span><br>Constructor&lt;?&gt; constructor1 = userClass.getConstructor(String.class, String.class);<br>constructor1.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 暴破，使用反射可以访问private的构造器</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> constructor1.newInstance(<span class="hljs-string">&quot;hahaha&quot;</span>, <span class="hljs-string">&quot;hahaha&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过反射访问类中的成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; stuClass = Class.forName(<span class="hljs-string">&quot;Student&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> stuClass.newInstance();<br><br><span class="hljs-comment">// 使用反射得到pubilc属性对象</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> stuClass.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>age.set(o, <span class="hljs-number">88</span>);<br><br><span class="hljs-comment">// 使用反射得到privare属性对象</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stuClass.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>name.setAccessible(<span class="hljs-literal">true</span>);<br>name.set(o,<span class="hljs-string">&quot;hahaha&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过反射访问类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; stuClass = Class.forName(<span class="hljs-string">&quot;Student&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> stuClass.newInstance();<br><br><span class="hljs-comment">// 调用pubilc的方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> stuClass.getMethod(<span class="hljs-string">&quot;hi&quot;</span>, String.class);<br>hi.invoke(o, <span class="hljs-string">&quot;hahaha&quot;</span>);<br><br><span class="hljs-comment">// 调用private的方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">say</span> <span class="hljs-operator">=</span> stuClass.getDeclaredMethod(<span class="hljs-string">&quot;say&quot;</span>, String.class);<br>say.setAccessible(<span class="hljs-literal">true</span>);<br>say.invoke(o, <span class="hljs-string">&quot;lalala&quot;</span>);<br><span class="hljs-comment">// 在反射中，如果方法有返回值，则统一返回Object，但运行类型与定义的返回类型一致</span><br></code></pre></td></tr></table></figure><h1 id="面向对象高级">面向对象高级</h1><h2 id="接口">1.接口</h2><p>一个快速入门的demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">USB</span>&#123;<br>    <span class="hljs-comment">//规定接口的相关方法</span><br>    pubilc <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>;<br>    pubilc <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//类 实现 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">USB</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;&#125;;<br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span>&#123;&#125;;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Camara</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">USB</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;&#125;;<br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span>&#123;&#125;;<br>&#125;<br><span class="hljs-comment">//使用接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">(USB usb)</span>&#123;<br>        usb.start();<br>        usb.end();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Phone类和Camara需要实现USB接口中的所有声明的方法</p></li><li><p>在Computer中规定使用接口的相关方法</p></li></ul><p>接口（interface）：接口是用来指定规范的。接口就是给出一些没有实现的方法，将他们封装在一起，某个类要使用的时候，再根据情况把这些方法写出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口名&#123;<br>    <span class="hljs-comment">//接口属性</span><br>    <span class="hljs-comment">//接口方法</span><br>&#125;<br>class 类名 implements 接口&#123;<br>    <span class="hljs-comment">//自己的属性</span><br>    <span class="hljs-comment">//自己的方法</span><br>    <span class="hljs-comment">//必须实现的接口的抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项：</p><ol type="1"><li>在JDK 7.0 之前，接口中的所有方法都没有方法体</li><li>JDK 8.0之后，接口类还可以有静态方法，默认方法（接口中可以有方法的具体实现）<ul><li>默认方法需要使用<code>default</code>关键字</li><li>静态方法需要使用<code>static</code>关键字</li><li>其他的就是抽象方法</li></ul></li><li>在接口中，abstract方法可以省略关键字</li></ol><p>接口的使用细节：</p><ol type="1"><li><p>接口不能被实例化</p></li><li><p><strong>接口中所有的方法默认是public方法</strong>，接口中的抽象方法可以不使用abstract来修饰</p></li><li><p>接口方法声明的时候可以不指定为pubilc，默认是public。但是在实现接口的时候，必须把方法声明为pubilc</p></li><li><p>一个普通类实现接口，就必须将接口的所有方法都实现</p></li><li><p>抽象类实现接口，可以不用实现接口的方法</p></li><li><p>一个类同时可以实现<strong>多个</strong>接口（implements多个）</p></li><li><p>接口中的属性只能是<code>final</code>的，而且是<code>pubilc static final</code>，并且必须在定义的时候进行初始化</p><ul><li>在定义的时候可以只写<code>int a = 1</code>，但是等价于<code>public static final int a = 1</code></li><li><strong>接口中的属性都是静态的</strong></li></ul></li><li><p>接口中属性的访问形式：<code>接口名称.属性名</code>（static）</p></li><li><p>一个接口不能继承其他的类，但是可以继承<strong>多个</strong>别的接口（implements多个）</p></li><li><p>接口的修饰符只能是public和默认，与类的修饰符相同</p></li><li><p>接口是对Java单继承机制的一种补充</p><ul><li><strong>当子类继承了父类，就自动拥有了父类的功能</strong></li><li><strong>如果子类需要扩展功能，可以通过实现接口的方式来扩展</strong></li></ul></li><li><p>解决默认方法冲突（如果是抽象方法，则不存在冲突，因此一定需要实现）</p><ul><li>接口和父类冲突：父类优先</li><li>接口之间冲突：由程序员在本类中实现，来消除二义性</li></ul></li></ol><h2 id="lambda表达式">2.lambda表达式</h2><p>lambda表达式是一个可传递的代码块，可以在以后执行一次或者多次。</p><p>lambda表达式的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(params) -&gt; expression<br>(params) -&gt; statement<br>(params) -&gt; &#123; statements &#125;<br></code></pre></td></tr></table></figure><ul><li>即时没有参数，也要提供空括号</li><li>如果可以推导出lambda表达式参数类型，那么可以忽略其类型</li><li>如果只有一个参数，并且参数类型可以推导得出，那么可以省略小括号</li><li>如果是使用{ }的代码块，则需要包含显式的return语句</li></ul><p>另一个概念是函数式接口（functionalinterface）。对于只有一个抽象方法的接口，当我们需要这种接口的对象时，就可以提供一个lambda表达式。这样的接口被称为函数式接口。</p><p>方法引用：</p><p>有时候lambda表达式<strong>只涉及一个方法的调用</strong>，我们可以使用方法引用。方法引用指示编译器生成一个函数式接口的实例，覆盖这个接口的抽象方法，调用给定的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">event -&gt; System.out.println(event)<br><span class="hljs-comment">// 变为方法引用</span><br>System.out::println<br></code></pre></td></tr></table></figure><p>例如，如果我们需要对字符串排序，并且不考虑字母的大小写，可以使用下面的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(strings, String::compareToIgnoreCase)<br></code></pre></td></tr></table></figure><p>我们需要使用<code>::</code>运算符来分隔方法名与对象名或者类名</p><blockquote><p>lambda表达式可以捕获外围作用域中变量的值，但是只能引用值不会改变的变量，不能在lambda表达式中改变外部变量。</p><p>在Java中，lambda表达式就是闭包。</p></blockquote><h2 id="内部类">3.内部类</h2><p>内部类：一个类的内部又嵌套了另一个类结构。被嵌套的类称为内部类，嵌套其他类的类称为外部类。内部类是类的第五大成员（属性、方法、构造器、代码块）。内部类的最大特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p><p>基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-comment">//外部类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<span class="hljs-comment">//内部类</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内部类的分类：</p><ul><li>如果内部类定义在外部类的局部位置上（比如成员方法中）<ul><li>局部内部类（有类名）</li><li>匿名内部类（没有类名）</li></ul></li><li>如果内部类定义在外部类的成员位置上<ul><li>成员内部类（没有static修饰）</li><li>静态内部类（有static修饰）</li></ul></li></ul><p><strong>1.局部内部类</strong></p><p>局部内部类：定义在外部类的局部位置，比如说方法、代码块中，并且有类名</p><p>说明：</p><ol type="1"><li>可以直接访问外部类的所有成员，包括私有成员</li><li>局部内部类相当于一个局部变量。不能使用修饰符，但是可以使用<code>final</code>修饰</li><li>作用域仅仅在定义它的方法或者代码块当中</li><li>在方法中调用内部类的方法需要先实例化（new），再调用</li><li>如果外部类和局部内部类的成员重名的时候，默认遵循就近原则。如果想访问外部类的成员，可以使用<code>外部类名.this.成员</code>来进行访问</li></ol><p><strong>2.匿名内部类</strong></p><p>匿名内部类：定义在外部类的局部位置，比如说方法、代码块中，并且没有类名</p><blockquote><p>本质是类；是一个内部类；该类没有名字（没有用户命名，但是有系统命名外部类$id）；同时还是一个对象</p></blockquote><p>说明：</p><ol type="1"><li><p>匿名内部类的基本语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">编译类型 xxx = <span class="hljs-keyword">new</span> 类或接口(参数列表)&#123;类体&#125;;<br></code></pre></td></tr></table></figure></li><li><p>使用背景：针对那些只使用一次后面不再使用的类，使用匿名类来简化开发</p></li><li><p><strong>这里的类或接口表示生成的匿名内部类扩展了类或者实现了接口</strong></p></li><li><p>编译类型为对应的编译类型，运行类型为匿名内部类</p></li><li><p>JDK底层在创建匿名内部类之后，立即就创建了实例，并且返回对应在栈中的地址</p></li><li><p>匿名内部类不能有构造器，但是可以提供一个对象初始化块</p></li><li><p>匿名内部类使用一次，就不再使用</p></li><li><p>大括号里的类体是匿名内部类的全部定义</p></li><li><p>参数列表中指定的是构造器所用的参数，正常的new中同样有参数列表</p></li><li><p>匿名内部类，即有类的特征，又有对象的特征</p></li><li><p>可以直接访问外部类的所有成员，包括私有成员</p></li><li><p>局部内部类相当于一个局部变量。不能使用修饰符，但是可以使用<code>final</code>修饰</p></li><li><p>作用域仅仅在定义它的方法或者代码块当中</p></li><li><p>如果外部类和匿名内部类的成员重名的时候，默认遵循就近原则。如果想访问外部类的成员，可以使用<code>外部类名.this.成员</code>来进行访问</p></li></ol><blockquote><p>经典使用场景：将匿名内部类直接当作实参进行传递</p></blockquote><p><strong>3.成员内部类</strong></p><p>成员内部类：定义在外部类的成员位置，并且没有static修饰</p><p>说明：</p><ol type="1"><li><p>可以直接访问外部类的所有成员，包括私有的</p></li><li><p>可以添加任意访问修饰符（public、protected、默认、private），它实际上也是一个成员</p></li><li><p>作用域和外部类的其他成员一样，为整个类体</p></li><li><p>成员内部类中不能定义static性质的成员属性和方法</p></li><li><p>成员内部类访问外部类：直接访问</p></li><li><p>外部类访问内部类：先创建对象，再访问</p></li><li><p>其他外部类访问内部类：找到外部类，再找到内部类，创建对象再访问</p><ul><li><p>方式一：相当于<code>new Inner()</code>是Outer的一个成员</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> x = <span class="hljs-keyword">Outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>()<br></code></pre></td></tr></table></figure></li><li><p>方式二：在Outer中编写一个方法返回内部类Inner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>如果外部类和成员内部类的成员重名的时候，默认遵循就近原则。如果想访问外部类的成员，可以使用<code>外部类名.this.成员</code>来进行访问</p></li></ol><p><strong>4.静态内部类</strong></p><p>静态内部类：定义在外部类的成员位置，并且有static修饰</p><p>说明：</p><ol type="1"><li><p>可以直接访问外部类的所有静态成员，包括私有的。<strong>但是不能直接访问非静态成员</strong></p></li><li><p>可以添加任意访问修饰符（public、protected、默认、private），它实际上也是一个成员</p></li><li><p>作用域和外部类的其他成员一样，为整个类体</p></li><li><p>静态内部类可以有静态字段和方法</p></li><li><p>静态内部类访问外部类：直接访问</p></li><li><p>外部类访问内部类：先创建对象，再访问</p></li><li><p>其他外部类访问内部类：</p><ul><li><p>方式一：可以通过类名直接访问得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">xxx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner();<br></code></pre></td></tr></table></figure></li><li><p>方式二：在Outer中编写一个方法返回内部类Inner</p></li></ul></li><li><p>如果外部类和静态内部类的成员重名的时候，默认遵循就近原则。如果想访问外部类的成员，可以使用<code>外部类名.成员</code>来进行访问（这里不需要this，因为只能访问静态成员）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础笔记(1)-语言基础</title>
    <link href="/2022/09/01/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-1-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/01/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-1-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="java的简单介绍">Java的简单介绍</h1><h2 id="java技术体系平台">1.Java技术体系平台</h2><table><thead><tr class="header"><th>版本</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>Java SE（Java Standard Edition）标准版</td><td>支持面向桌面级应用的Java平台，提供完整的Java核心API</td></tr><tr class="even"><td>Java EE（Java Enterprise Edition）企业版</td><td>为开发企业环境下的应用程序提供解决方案，主要针对Web应用开发</td></tr><tr class="odd"><td>Java ME（Java Micro Edition）小型版</td><td>支持运行在移动终端上的平台，对Java API有所精简（目前使用较少）</td></tr></tbody></table><h2 id="java的重要特点">2.Java的重要特点</h2><ul><li><p>简单性：一方面，Java剔除了C++中许多很少使用、难以理解、易混淆的特性，以便系统更容易理解。另一方面，Java的目标之一是支持开发能够在小型机器上独立运行的软件。</p></li><li><p>面向对象（OOP）</p></li><li><p>分布式：Java有一个丰富的例程库，用于处理HTTP、FTP之类的TCP/IP协议</p></li><li><p>健壮性：强类型机制、异常处理、垃圾自动回收等</p></li><li><p>安全性</p></li><li><p>体系结构中立</p></li><li><p>可移植性</p><ul><li><code>.java</code>-&gt;<code>.class</code></li><li>一个编译好的<code>.class</code>文件可以在多个平台上的Java虚拟机上运行</li></ul></li><li><p>解释型</p><ul><li>解释型语言：编译后的代码不能被机器直接执行，需要解释器来执行</li><li>编译型语言：编译后的代码能够被机器直接执行</li></ul></li><li><p>高性能：即时编译器可以监控经常执行哪些代码，并优化这些代码以提高执行速度。</p></li><li><p>多线程</p></li><li><p>动态性</p></li></ul><h2 id="java的运行机制和运行过程">3.Java的运行机制和运行过程</h2><p><code>.java</code>程序通过编译成为<code>.class</code>，<code>.class</code>文件运行在JVM（Java虚拟机、JavaVirtual Machine）中。</p><ul><li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域、负责执行执行，管理数据、内存、寄存器等，包含在<strong>JDK</strong>中</li><li>对于不同的平台，有不同的虚拟机</li><li>Java虚拟机机制屏蔽了底层运行平台的差别，“一次编译、到处运行”</li></ul><p>指令：</p><ul><li><code>javac</code>：编译，从<code>.java</code>编译成<code>.class</code></li><li><code>java</code>：运行</li></ul><h2 id="jdk和jre">4.JDK和JRE</h2><ul><li>JDK：（Java Development Kit Java开发工具包）<ul><li>JDK = JRE + java的开发工具（java、javac、javadoc、javap等）</li><li>提供给java开发人员使用，包括了JRE，无需单独安装</li></ul></li><li>JRE：（Java Runtime Environment Java运行环境）<ul><li>JRE = JVM + Java的核心类库</li><li>只能运行开发好的Java程序（.class），提供给java使用人员使用</li></ul></li></ul><h2 id="hello-world">5.Hello World</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Hello.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>注意事项：</p><ul><li>可能出现控制台的文件编码问题（默认下控制台的编码为GBK）</li><li>java后的指令不需要加<code>.class</code>（默认是运行一个类，类的名字为Hello）</li></ul></li><li><p>细节说明：</p><ul><li>入口程序有固定的书写程序</li><li>严格区分大小写</li><li>语句最后带分号</li><li><strong>一个源文件中最多只能由一个public类，其他类的个数不限</strong><ul><li>编译后每一个类都对应生成一个<code>.class</code>文件</li></ul></li><li><strong>如果源文件中包含一个public类，则文件名必须按照该类的名称来命名</strong></li><li>也可以将main方法写在非public类当中，然后指定运行非public类，这样入口方法就是非public的main方法<ul><li>每个类都可以有自己的入口方法</li></ul></li></ul></li></ul><h1 id="java快速入门">Java快速入门</h1><h2 id="注释">1.注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">单行注释<br>    <span class="hljs-comment">//...</span><br>    <br>多行注释 不允许嵌套<br>    <span class="hljs-comment">/*...</span><br><span class="hljs-comment">    ...</span><br><span class="hljs-comment">    */</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">文档注释 注释内容可以被JDK提供的工具javadoc所解析，生成一套一网页文件形式体现的该程序的说明文档，一般写在类<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span>:xxx</span><br><span class="hljs-comment">* <span class="hljs-doctag">@version</span>:1.0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>基本格式<ul><li>Javadoc标签，不能随便乱写</li></ul></li><li>生成文档注释<ul><li><code>javadoc -d 目标文件夹 -xx -yy java文件</code></li><li>-xx -yy表示对应需要生成的Javadoc标签</li><li>之后会在目标目录下生成一堆html文件</li></ul></li></ul><h2 id="变量相关">2.变量相关</h2><p>Java是一种强类型语言，这意味着必须为每个变量声明一种类型。</p><p>在Java中，一共有8种基本类型，其中有4种整型、2种浮点类型、1种字符类型和1种布尔类型。</p><ul><li><p>基本数据类型</p><ul><li>整数型<ul><li>byte（1）、short（2）、int（4）、long（8）</li></ul></li><li>浮点型<ul><li>float（4）、double（8）</li></ul></li><li>字符型<ul><li>char（2）</li></ul></li><li>布尔型<ul><li>boolean（1）</li></ul></li></ul></li><li><p>引用数据类型</p><ul><li>类（class）</li><li>接口（interface）</li><li>数组（[]）</li></ul></li></ul><blockquote><ul><li><p>数据类型对应的字节数在不同的操作系统上是固定的（JVM）</p></li><li><p>整型常量默认为int，长整型指定需要加l或者L</p></li><li><p>可以为数字字面量增加下划线，如<code>1_000_000</code>。这些下划线只是为了让人更加易读，Java编译器会去除这些下划线</p></li><li><p>不同进制：0b/0B、无、0、0x/0X</p></li><li><p>浮点类型的精度问题同样存在</p></li><li><p>java没有无符号数，都是有符号的</p></li><li><p>java的char是两个字节，c++的char是一个字节</p></li><li><p>java中的char可以直接存放中文，C++中则不可以</p></li><li><p>在C++中，数值甚至是指针可以代替boolean值，即值0相当于布尔值的false，但是在Java中不能够这样</p></li></ul></blockquote><h2 id="常见的字符编码表">3.常见的字符编码表</h2><ul><li>ASCII：一个字节，128个字符</li><li>Unicode：固定大小编码，使用两个字节来表示，字母和汉字都使用两个字节</li><li>UTF-8：大小可变编码，字母使用一个字节，汉字使用3个字节</li><li>gbk：可以表示汉字，而且范围广，字母使用一个字节，汉字使用2个字节</li><li>gb2312：可以表示汉字，gb2312 &lt; gbk</li><li>big5：繁体中文</li></ul><h2 id="类型转换">4.类型转换</h2><p>自动类型转换：按照精度向上自动转换（精度小 -&gt; 精度大）</p><ul><li>byte：把具体的数赋值给byte的时候，先判断该数是否在范围内，如果在范围内就可以进行复制；但是如果是将变量赋值给byte的话，则直接进行类型判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> b; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><ul><li><p>byte（short）、char之间不会进行自动转换（char直接到int层面）</p></li><li><p>byte、short、char可以进行运算，在（单独或者混合）运算的时候直接提升到int，</p></li></ul><p>强制类型转换：需要加上强制转换符（），可能会造成精度降低或者溢出</p><h2 id="基本数据类型和string的转换">5.基本数据类型和String的转换</h2><p>基本数据类型转String：<strong>加双引号</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">n1S</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><p>String转基本数据类型：<strong>通过包装类某某调用parse某某方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">si</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br><span class="hljs-type">double</span> <span class="hljs-variable">sd</span> <span class="hljs-operator">=</span> Double.parseDouble(s);<br><span class="hljs-type">byte</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> Byte.parseByte(s);<br></code></pre></td></tr></table></figure><h2 id="运算符">6.运算符</h2><p>运算符</p><ul><li>算术运算符<ul><li>+、-、*、/、%、++、--</li></ul></li><li>赋值运算符<ul><li>=、+=、-= 、*=、/=、%=</li></ul></li><li>关系运算符（比较）<ul><li>==、!=、&lt;、&gt;、&lt;=、&gt;=、instanceof()</li></ul></li><li>逻辑运算符<ul><li>短路与&amp;&amp; 短路或|| 取反!</li><li>逻辑与&amp; 逻辑或| 逻辑异或^<ul><li>短路与判断到能够得出结果后就不会进行后续的条件判断了</li><li>逻辑与会继续判断所有的条件</li><li>最终结果还是一样的</li></ul></li></ul></li><li>位运算符<ul><li><code>&gt;&gt;</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;&gt;</code>、<code>&amp;</code>、<code>|</code>、<code>~</code>、<code>^</code></li><li><code>&gt;&gt;&gt;</code>：无符号右移，高位补0</li><li><code>&gt;&gt;</code>：算术右移，高位补符号位</li><li><code>&lt;&lt;</code>：算术左移，低位补0</li></ul></li><li>三元运算符<ul><li>条件表达式 ? 表达式1 : 表达式2</li></ul></li></ul><h2 id="标识符命名规范">7.标识符命名规范</h2><ul><li>包名：多单词组成，所有字母都小写，单词之间使用<code>.</code>（aaa.bbb.ccc）</li><li>类名，接口名：所有单词首字母大写（大驼峰）</li><li>变量名，方法名：第一个单词首字母小写，后面的单词首字母大写（小驼峰）</li><li>常量名：所有字母都大写，单词之间使用<code>_</code>（TAX_RATE）</li></ul><h2 id="键盘输入">8.键盘输入</h2><p>需要使用Scanner（类）</p><p>使用步骤：</p><ol type="1"><li>导入该类所在的包，这里是<code>java.util.*</code></li><li>创建该类的对象（声明变量）</li><li>调用里面的功能（使用相关的方法）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> input.nextInt();<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为输入是可见的，所以Scanner类不适用于从控制台读取密码。Java6引入了Console类来实现这个目的，读取密码可以使用下列的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Console</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> System.console();<br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> cons.readLine(<span class="hljs-string">&quot;User name: &quot;</span>);<br><span class="hljs-type">char</span>[] passwd = cons.readPassword(<span class="hljs-string">&quot;Password: &quot;</span>);<br></code></pre></td></tr></table></figure><p>为了安全期间，返回的密码存放在一个字符数组中，而不是字符串中。在对密码处理完成之后，应该马上用一个填充值覆盖数组元素（不保存密码的原文）</p><p>Console对象处理输入，必须每次读取一行输入</p></blockquote><h2 id="标准输出">9.标准输出</h2><p>标准输出使用<code>System.out.println()</code>或者<code>System.out.print()</code></p><p>并且在Java中，还沿用了C中的printf方法提供格式化输出。<code>System.out.printf()</code></p><h2 id="文件输入与输出">10.文件输入与输出</h2><p>读取文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(Path.of(<span class="hljs-string">&quot;xxx.txt&quot;</span>), StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure><p>写入文件：构造一个PrintWriter对象，在构造器中提供文件名和字符编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>, StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure><p>之后就可以调用对象的print、println、printf等方法了。</p><blockquote><p>文件的相对路径是相对于当前的工作目录的。</p><p>对于使用<code>java</code>命令启动的程序，工作目录为启动JVM的位置，即执行该命令的位置</p><p>对于集成开发环境来说，启动目录将由IDE来控制。</p></blockquote><h2 id="原码反码和补码">11.原码、反码和补码</h2><ul><li>计算机内存当中，二进制均以补码的形式存储，<strong>在任何运算的时候都是以补码的方式来进行运算的</strong><ul><li>补码统一了正数和负数的计算</li></ul></li><li>原码和补码：如果是有符号的，首位为符号位，0表示+，1表示-</li><li>原码和补码的相互转换<ul><li>原码-&gt;补码<ul><li>正数：补码与原码相同</li><li>负数：符号位不变，其它位取反+1</li></ul></li><li>补码-&gt;原码<ul><li>首位为0：原码与补码相同</li><li>首位为1：符号位不变，其它位取反+1</li></ul></li></ul></li></ul><blockquote><ul><li>正数的原码、反码和补码都一样（三码合一）</li><li>负数的反码：符号位不变，其它位取反</li><li>负数的补码 = 反码 + 1</li><li>负数的反码 = 补码 - 1</li><li>0的反码，补码都是0</li><li>我们看运算结果的时候需要看他的原码</li></ul></blockquote><h2 id="控制语句">12.控制语句</h2><ul><li><p>顺序控制</p></li><li><p>分支控制</p><ul><li>if、else、else if、switch-case</li></ul></li><li><p>循环控制</p><ul><li>for、while、do-while</li><li>break、continue、return</li></ul></li></ul><blockquote><p>Java中提供了一种带标签的break语句，用于跳出多重嵌套的循环语句</p></blockquote><h2 id="大数">13.大数</h2><p>如果基本的整数和浮点数精度不能满足要求，那么可以使用<code>java.math</code>包中的两个大数类<code>BigInteger</code>和<code>BigDecimal</code>，这两个类可以处理包含任意长度数字序列的数值。</p><p>使用<code>valueOf()</code>将普通的数值转换成大数，或者传入带字符串参数的构造器。不能使用普通的算术运算符进行计算，而应该使用提供的<code>add</code>、<code>multiply</code>方法。</p><h2 id="数组">14.数组</h2><p>数组初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 动态初始化</span><br><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-comment">// 静态初始化</span><br><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// 静态初始化省略格式</span><br><span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// Java中也可以写成C风格的 int a[] = new int[5];</span><br><span class="hljs-comment">// 但是不能直接在第一个[]中指定大小，这点与C不同</span><br><span class="hljs-comment">// Java动态申请的同时进行赋初值中括号中不能写具体的数字，而C++中必须写</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>没有指定初始值，会有默认值</li><li>使用步骤：声明数组并开辟空间、给数组各个元素赋值、使用数组</li><li>引用数据类型拷贝默认情况下是传递地址（<strong>引用传递</strong>）</li><li><code>.length</code>可以获取长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span>[] b = a;<br><span class="hljs-comment">//修改b的话，a也会随之改变（浅拷贝）</span><br></code></pre></td></tr></table></figure><p>二维数组的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><span class="hljs-type">int</span>[][] a = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;&#125;;<br><span class="hljs-comment">//同样可以使用.length来获取长度</span><br><span class="hljs-comment">//也可以这样声明：int[] a[]、int a[][]</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>可以不指定后续的第二个[]中的值，第一个[]必须指定</li><li>可以使用变量来进行初始化</li><li>二维数组的各个一维数组的长度可以相同也可以不相同（不相同的可以在循环中指定）</li></ul><p>快速打印数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 快速打印一维数组</span><br>Arrays.toString(a);<br><br><span class="hljs-comment">// 快速打印多维数组</span><br>Arrays.deepToString(b);<br></code></pre></td></tr></table></figure><h2 id="静态导入">15.静态导入</h2><p>在 JDK 1.5之后，Java增加了一种静态导入的语法，用于导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法。如果一个类中的方法全部是使用static 声明的静态方法，则在导入时就可以直接使用 import static的方式导入。静态导入也有两种语法，分别用于导入指定类的单个静态成员变量、方法和全部静态成员变量、方法。分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">package</span>.ClassName.fieldName|methodName;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">package</span>.ClassName.*;<br></code></pre></td></tr></table></figure><p>使用静态导入之后，之前需要利用类名称来调用的静态方法，现在就可以直接调用了。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL常用函数</title>
    <link href="/2022/08/10/MySQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/2022/08/10/MySQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数学函数">数学函数</h1><ul><li><code>abs(x)</code>：返回x的绝对值</li><li><code>bin(x)/oct(x)/hex(x)</code>：返回x的二进制、八进制和十六进制表示形式</li><li><code>ceiling(x)</code>：返回x向上取整</li><li><code>floor(x)</code>：返回x向下取整</li><li><code>exp(x)</code>：返回<spanclass="math inline">\(e^x\)</span></li><li><code>pow(x,y)</code>：返回<spanclass="math inline">\(x^y\)</span></li><li><code>greatest(x1,x2,...,xn)</code>：返回集合中的最大值</li><li><code>least(x1,x2,...,xn)</code>：返回集合中的最小值</li><li><code>ln(x)</code>：返回x的自然对数</li><li><code>log(x,y)</code>：返回<spanclass="math inline">\(log_xy\)</span></li><li><code>mod(x,y)</code>：返回x对y取余</li><li><code>pi()</code>：返回圆周率<spanclass="math inline">\(\pi\)</span></li><li><code>rand()</code>：返回0到1之间的随机值，可以提供seed种子</li><li><code>round(x,y)</code>：对x进行四舍五入，保留y位位数</li><li><code>sign(x)</code>：返回代表数字x的符号的值</li><li><code>sqrt(x)</code>：返回<spanclass="math inline">\(\sqrt{x}\)</span></li><li><code>truncate(x,y)</code>：返回数字x的截断为y位小数的结果</li></ul><h1 id="字符串函数">字符串函数</h1><ul><li><code>ascii(char)</code>：返回字符的ASCII值</li><li><code>bit_length(str)</code>：返回字符串的比特长度</li><li><code>lenght(str)</code>：返回字符串的字节长度</li><li><code>char_length(str)</code>：返回字符串的字符长度<br /></li><li><code>concat(s1,s2,...,sn)</code>：将多个字符串拼接在一起</li><li><code>concat_ws(sep,s1,s2,...,sn)</code>：将多个字符串拼接在一起，并用sep字符间隔</li><li><code>insert(s1,x,len,s2)</code>：字符串替换函数。将s1中的子串替换为s2。子串位置从x开始，长度为len。（如果x超过了字符串长度，或者为负数，则返回原字符串）</li><li><code>replace(s,s1,s2)</code>：使用字符串s2替换字符串s1中的所有字符串s1</li><li><code>upper(str)/lower(str)</code>：将字符串转成大写或者小写</li><li><code>trim(str)/ltrim(str)/rtrim(str)</code>：去除前后指定的字符，默认去除空格</li><li><code>position(substr,str)</code>：返回子串substr第一次出现的位置</li><li><code>reverse(str)</code>：返回字符串翻转的结果</li><li><code>right(str,x)/left(str,x)</code>：从左边或者右边截取指定位数的字符串</li><li><code>strcmp(s1,s2)</code>：比较两个字符串</li></ul><h1 id="聚合函数">聚合函数</h1><ul><li><code>avg(col)</code>：返回指定列的平均值</li><li><code>count(col)</code>：返回指定列中非NULL值的个数</li><li><code>min(col)</code>：返回指定列的最小值</li><li><code>max(col)</code>：返回指定列的最大值</li><li><code>sum(col)</code>：返回指定列的总和</li><li><code>group_concat(col)</code>：返回指定列值拼接组合而成的结果</li></ul><h1 id="时间函数">时间函数</h1><ul><li><code>curdate()/current_date()</code>：返回当前的日期</li><li><code>curtime()/current_time()</code>：返回当前的时间</li><li><code>now()</code>：返回当前日期+时间</li><li><code>unix_timestamp()</code>：返回unix时间戳</li><li><code>dayofweek(date)</code>：返回date表示一星期中的第几天（1~7）</li><li><code>dayofmonth(date)</code>：返回date是一个月中的第几天（1~31）</li><li><code>dayofyear(date)</code>：返回date是一年中的第几天（1~366）</li><li><code>week(date)</code>：返回date是一年中的第几周（0~53）</li><li><code>quarter(date)</code>：返回date是一年中的第几季度（1~4）</li><li><code>dayname(date)</code>：返回date的星期名称</li><li><code>monthname(date)</code>：返回date的月份名称</li><li><code>year(date)/month(date)/day(date)</code>：返回date的年份/月份/天数</li><li><code>mintu(time)/hour(time)</code>：返回time的分钟数/小时数</li><li><code>date_add(date, interval int keyword)</code>：返回日期增加时间间隔，其中int必须按照关键字进行格式化，eg:<code>date_add(current_date, interval 6 month)、date_add(current_date,interval -5 day)</code></li><li><code>date_sub(date, interval int keyword)</code>：返回日期减少时间</li><li><code>datediff(date1,date2)</code>：计算时间的差，date1-date2，返回天数</li><li><code>date_format(date,fmt)</code>：按照给定的fmt格式格式化日期date值，eg:<code>date_fromat('2019-07-07','%Y-%m')</code></li><li><code>from_unixtime(ts,fmt)</code>：根据指定的fmt格式，格式化unix时间戳ts</li></ul><h1 id="系统信息函数">系统信息函数</h1><ul><li><code>database()</code>：返回当前数据库名称</li><li><code>benchmark(count, expr)</code>：将表达式expr重复运行count次</li><li><code>connection_id()</code>：返回当前客户端的连接id</li><li><code>found_rows()</code>：返回最后一个select查询进行检索的总行数</li><li><code>user()/system_user()</code>：返回当前登录的用户名</li><li><code>version()</code>：返回mysql服务器的版本</li></ul><h1 id="类型转换">类型转换</h1><ul><li><code>cast()</code>：将一个值转化为指定的数据类型，数据类型有binary、char、date、time、datetime、signed、unsigned等。eg：<code>select cast(now() as signed integer)</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在OpenFaas自带的Prometheus中接入k8s集群性能监控</title>
    <link href="/2022/07/30/%E5%9C%A8OpenFaas%E8%87%AA%E5%B8%A6%E7%9A%84Prometheus%E4%B8%AD%E6%8E%A5%E5%85%A5k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    <url>/2022/07/30/%E5%9C%A8OpenFaas%E8%87%AA%E5%B8%A6%E7%9A%84Prometheus%E4%B8%AD%E6%8E%A5%E5%85%A5k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="需求概述">需求概述</h1><p>OpenFaas部署后，自带的Prometheus默认只能监控函数级别的指标，现在想要将k8s集群的监控也接入到OpenFaas自带的Prometheus中，因此需要进行相关的处理。</p><p>除了函数性能之外，我们主要进行三方面的性能监控：</p><ul><li>pod性能：容器的相关性能，使用cadvisor来实现监控</li><li>node性能：物理机节点的相关性能，使用node-exporter来实现监控</li><li>k8s性能：k8s资源对象，包括pod、service、deployment等，使用kube-state-metrics来实现监控</li></ul><h1 id="准备工作">准备工作</h1><p>OpenFaas中的Prometheus，对应的配置文件等存放在<code>fass-netes/yaml</code>目录下，对应有四个文件，分别为<code>prometheus-cfg.yml</code>，<code>prometheus-dep.yml</code>，<code>prometheus-rabc.yml</code>，<code>prometheus-svc.yml</code>。</p><p>默认情况下，OpenFaas中的Prometheus服务并没有向外暴露端口。我们需要修改<code>prometheus-svc.yml</code>，将其类型修改为NodePort，并指定暴露端口。这里向外暴露端口为31119，修改内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">9090</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9090</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">31119</span><br></code></pre></td></tr></table></figure><p>在<code>prometheus-rabc.yml</code>文件中，我们需要修改其中的RoleKind，以及添加相关的规则。主要修改为kind从Role变为ClusterRole、在rules中添加更多的规则、rolebinding的类型从RoleBinding修改为ClusterRoleBinding，以及roleRef的类型修改为ClusterRole。修改后的整体文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">openfaas-prometheus</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;openfaas&quot;</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">openfaas</span><br>    <span class="hljs-attr">component:</span> <span class="hljs-string">prometheus</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">openfaas-prometheus</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;openfaas&quot;</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">openfaas</span><br>    <span class="hljs-attr">component:</span> <span class="hljs-string">prometheus</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">services</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">endpoints</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">pods</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nodes</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nodes/proxy</span><br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>]<br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">configmaps</span><br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>]<br><span class="hljs-bullet">-</span> <span class="hljs-attr">nonResourceURLs:</span> [<span class="hljs-string">&quot;/metrics&quot;</span>]<br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">openfaas-prometheus-fn</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;openfaas-fn&quot;</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">openfaas</span><br>    <span class="hljs-attr">component:</span> <span class="hljs-string">prometheus</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">services</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">endpoints</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">pods</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nodes</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nodes/proxy</span><br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>]<br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">configmaps</span><br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>]<br><span class="hljs-bullet">-</span> <span class="hljs-attr">nonResourceURLs:</span> [<span class="hljs-string">&quot;/metrics&quot;</span>]<br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">openfaas-prometheus</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;openfaas&quot;</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">openfaas</span><br>    <span class="hljs-attr">component:</span> <span class="hljs-string">prometheus</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">openfaas-prometheus</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">openfaas-prometheus</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;openfaas&quot;</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">openfaas-prometheus-fn</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;openfaas-fn&quot;</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">openfaas</span><br>    <span class="hljs-attr">component:</span> <span class="hljs-string">prometheus</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">openfaas-prometheus-fn</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">openfaas-prometheus</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;openfaas&quot;</span><br><br></code></pre></td></tr></table></figure><p><code>prometheus-dep.yml</code>文件不做修改。</p><p><code>prometheus-cfg.yml</code>文件会在后续进行较多的修改，这里就首先简单介绍一下该配置文件中的格式。我们主要关注该文件中data下的<code>prometheus.yml</code>，有如下的结构：</p><ul><li>global：全局的默认配置</li><li>rule_files：获取所有规则文件中的规则，包括报警规则和数据处理的规则</li><li>alerting：定义告警属性，用来管理Alertmanager</li><li>scrape_configs：用于配置拉取数据节点。我们后续的监控数据接入也是在这个部分完成的。每个拉取配置主要包含下面的参数<ul><li>job_name：任务名称</li><li>honor_labels： 用于解决拉取数据标签有冲突，当设置为 true,以拉取数据为准，否则以服务配置为准</li><li>params：数据拉取访问时带的请求参数</li><li>scrape_interval： 拉取时间间隔</li><li>scrape_timeout: 拉取超时时间</li><li>metrics_path： 拉取节点的 metric 路径</li><li>static_configs：配置访问路径前缀，如ip+port，或者域名地址，或者通过服务发现，</li><li>scheme： 拉取数据访问协议，如http</li><li>sample_limit：存储的数据标签个数限制，如果超过限制，该数据将被忽略，不入存储；默认值为0，表示没有限制</li><li>relabel_configs： 拉取数据重置标签配置</li><li>metric_relabel_configs：metric 重置标签配置</li></ul></li></ul><h1 id="cadvisor">cadvisor</h1><p>cadvisor可以对物理机器Node上的资源以及容器进行实时监控和性能数据采集，包括CPU占用、内存使用情况、网络吞吐量以及文件系统使用情况等。在k8s集群上，每个Node机器上都会有一个cadvisor对该机器进行监控。在已有k8s集群的前提下，我们无需额外安装。</p><p>接下来我们需要将监控数据接入OpenFaas下的Prometheus。接入方式就是在<code>prometheus-cfg.yml</code>文件中的scrape_configs中添加相应的任务配置项。在添加过程中我们可以静态指定节点，也可以利用Prometheus对k8s的自动服务发现，包括对node、service、pod、endpoint等的自动服务发现，即自动识别所有在k8s集群中的角色。</p><p>添加的任务配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># k8s的node节点自动发现,自动发现k8s中所有node节点并进行监控</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;kubernetes-cadvisor&#x27;</span><br>       <span class="hljs-attr">scheme:</span> <span class="hljs-string">https</span><br>       <span class="hljs-attr">tls_config:</span><br>         <span class="hljs-attr">ca_file:</span> <span class="hljs-string">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br>       <span class="hljs-attr">bearer_token_file:</span> <span class="hljs-string">/var/run/secrets/kubernetes.io/serviceaccount/token</span><br>       <span class="hljs-attr">kubernetes_sd_configs:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">node</span><br>       <span class="hljs-attr">relabel_configs:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">target_label:</span> <span class="hljs-string">__address__</span><br>         <span class="hljs-attr">replacement:</span> <span class="hljs-string">kubernetes.default.svc:443</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_node_name</span>]<br>         <span class="hljs-attr">regex:</span> <span class="hljs-string">(.+)</span><br>         <span class="hljs-attr">replacement:</span> <span class="hljs-string">/api/v1/nodes/$&#123;1&#125;/proxy/metrics/cadvisor</span><br>         <span class="hljs-attr">target_label:</span> <span class="hljs-string">__metrics_path__</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">action:</span> <span class="hljs-string">labelmap</span><br>         <span class="hljs-attr">regex:</span> <span class="hljs-string">__meta_kubernetes_node_label_(.+)</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_node_name</span>]<br>         <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br>         <span class="hljs-attr">target_label:</span> <span class="hljs-string">node</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_node_label_node</span>]<br>         <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br>         <span class="hljs-attr">target_label:</span> <span class="hljs-string">node_name</span><br></code></pre></td></tr></table></figure><p>添加完配置之后，对服务进行更新。利用kubectlapply重新配置资源，然后重启对应的pod。这里重新启动我们直接删除对应的pod，因为对应的pod创建器没有被删除，因此执行删除操作后，k8s会再次启动一个pod。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f prometheus-cfg.yml<br><br><span class="hljs-comment"># 查看对应的pod名称 prometheus-xxxxxxxxxx-xxxxx</span><br>kubectl get pods -n openfaas<br><br><span class="hljs-comment"># 删除对应的pod</span><br>kubectl delete pod prometheus-xxxxxxxxxx-xxxxx -n openfaas<br></code></pre></td></tr></table></figure><p>之后就可以在Prometheus的前端页面进行查看，在Target页面中会出现<code>kubernetes-cadvisor</code>任务，在查询页面中能够出现容器相关信息即表示配置成功。</p><img src="/2022/07/30/%E5%9C%A8OpenFaas%E8%87%AA%E5%B8%A6%E7%9A%84Prometheus%E4%B8%AD%E6%8E%A5%E5%85%A5k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/cadvisor.png" class="" title="cadvisor"><h1 id="node-exporter">node-exporter</h1><p>node-exporter可以监控物理机系统级别的信息，包括服务器CPU占用、内存、磁盘和IO等信息。使用node-exporter之前我们需要在集群中的每个节点上都进行安装，首先下载对应的可执行文件node-exporter，之后创建对应的配置文件，最后启动服务即可。这里我们可以使用脚本完成安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#批量安装node_exporter</span><br>soft_dir=/root/soft<br><span class="hljs-keyword">if</span> [ ! -e <span class="hljs-variable">$soft_dir</span> ];<span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$soft_dir</span><br><span class="hljs-keyword">fi</span><br> <br>netstat -lnpt | grep 9100<br><span class="hljs-keyword">if</span> [ $? -eq 0 ];<span class="hljs-keyword">then</span><br>        use=`netstat -lnpt | grep 9100 | awk -F/ <span class="hljs-string">&#x27;&#123;print $NF&#125;&#x27;</span>`<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;9100端口已经被占用，占用者是 <span class="hljs-variable">$use</span>&quot;</span><br>        <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br> <br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$soft_dir</span><br>wget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz<br>tar xf node_exporter-1.0.1.linux-amd64.tar.gz<br><span class="hljs-built_in">mv</span> node_exporter-1.0.1.linux-amd64 /usr/local/node_exporter<br> <br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt;/usr/lib/systemd/system/node_exporter.service</span><br><span class="hljs-string">[Unit]</span><br><span class="hljs-string">Description=https://prometheus.io</span><br><span class="hljs-string"> </span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">Restart=on-failure</span><br><span class="hljs-string">ExecStart=/usr/local/node_exporter/node_exporter --collector.systemd --collector.systemd.unit-whitelist=(docker|kubelet|node_exporter).service</span><br><span class="hljs-string"> </span><br><span class="hljs-string">[Install]</span><br><span class="hljs-string">WantedBy=multi-user.target</span><br><span class="hljs-string">EOF</span><br> <br>systemctl daemon-reload<br>systemctl <span class="hljs-built_in">enable</span> node_exporter<br>systemctl restart node_exporter<br> <br>netstat -lnpt | grep 9100<br> <br><span class="hljs-keyword">if</span> [ $? -eq 0 ];<span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;node_eporter install finish...&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>执行完毕之后可以查看对应的9100端口情况<code>netstat -nlpt | grep 9100</code>。</p><p>安装完成之后，需要在Prometheus配置文件中添加任务配置，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># node_exporter服务自动发现</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;kubernetes-node-exporter&#x27;</span><br>        <span class="hljs-attr">kubernetes_sd_configs:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">node</span><br>        <span class="hljs-attr">relabel_configs:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__address__</span>]<br>          <span class="hljs-attr">regex:</span> <span class="hljs-string">&#x27;(.*):10250&#x27;</span><br>          <span class="hljs-attr">replacement:</span> <span class="hljs-string">&#x27;$&#123;1&#125;:9100&#x27;</span><br>          <span class="hljs-attr">target_label:</span> <span class="hljs-string">__address__</span><br>          <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_node_name</span>]<br>          <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br>          <span class="hljs-attr">target_label:</span> <span class="hljs-string">node</span>      <br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">action:</span> <span class="hljs-string">labelmap</span><br>          <span class="hljs-attr">regex:</span> <span class="hljs-string">__meta_kubernetes_node_label_(.+)</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_node_address_InternalIP</span>]<br>          <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br>          <span class="hljs-attr">target_label:</span> <span class="hljs-string">ip</span><br></code></pre></td></tr></table></figure><p>同样重启服务之后在前端进行查看，在Target页面下出现<code>kubernetes-node-exporter</code>，在查询页面中出现节点相关信息则表示配置成功。</p><img src="/2022/07/30/%E5%9C%A8OpenFaas%E8%87%AA%E5%B8%A6%E7%9A%84Prometheus%E4%B8%AD%E6%8E%A5%E5%85%A5k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/node-exporter.png" class="" title="node-exporter"><h1 id="kube-state-metrics">kube-state-metrics</h1><p>kube-state-metrics可以监控k8s内部对象的状态，如nodes、pods、deployments等。在使用之前需要进行部署，需要用到的yaml文件在官方文档中路径录下<code>https://github.com/kubernetes/kube-state-metrics/tree/master/examples/standard</code>。我们需要修改其中的<code>service.yaml</code>，在metadata中添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">prometheus.io/scrape:</span> <span class="hljs-string">&#x27;true&#x27;</span><br></code></pre></td></tr></table></figure><p>之后执行命令进行部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f .<br></code></pre></td></tr></table></figure><p>可以使用<code>kubectl get pods --all-namespaces</code>来查看部署情况，如果全部为running则表示部署成功。但是在kube-state-metrics的部署过程中，可能会出现镜像无法拉取的情况，需要的镜像为<code>registry.k8s.io/kube-state-metrics/kube-state-metrics:v2.5.0</code>，我们可以通过本地拉取镜像之后改名的操作来解决对应的问题。首先<code>docker search</code>进行镜像的搜索，<code>docker pull</code>拉取对应的镜像之后，使用<code>docker tag</code>进行名称修改。</p><blockquote><p>当pod出现错误的时候，我们可以使用如下的错误信息查看指令，错误信息能够帮助我们快速定位和解决。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先查看对应的pod名称</span><br>kubectl get pods -n namespace_name<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看详细信息</span><br>kubectl describe pod pod_name -n namespace_name<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日志</span><br>kubectl logs -f --tail=200 pod_name -n namespace_name<br></code></pre></td></tr></table></figure></blockquote><p>在kube-state-metrics对应的pod运行起来后，向Prometheus配置文件中添加对应的任务配置，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># kube-state-metrics</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;kubernetes-service-endpoints&#x27;</span>      <br>        <span class="hljs-attr">kubernetes_sd_configs:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">endpoints</span><br>        <span class="hljs-attr">relabel_configs:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_service_annotation_prometheus_io_scrape</span>]<br>          <span class="hljs-attr">action:</span> <span class="hljs-string">keep</span><br>          <span class="hljs-attr">regex:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_service_annotation_prometheus_io_scheme</span>]<br>          <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br>          <span class="hljs-attr">target_label:</span> <span class="hljs-string">__scheme__</span><br>          <span class="hljs-attr">regex:</span> <span class="hljs-string">(https?)</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_service_annotation_prometheus_io_path</span>]<br>          <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br>          <span class="hljs-attr">target_label:</span> <span class="hljs-string">__metrics_path__</span><br>          <span class="hljs-attr">regex:</span> <span class="hljs-string">(.+)</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__address__</span>, <span class="hljs-string">__meta_kubernetes_service_annotation_prometheus_io_port</span>]<br>          <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br>          <span class="hljs-attr">target_label:</span> <span class="hljs-string">__address__</span><br>          <span class="hljs-attr">regex:</span> <span class="hljs-string">([^:]+)(?::\d+)?;(\d+)</span><br>          <span class="hljs-attr">replacement:</span> <span class="hljs-string">$1:$2</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">action:</span> <span class="hljs-string">labelmap</span><br>          <span class="hljs-attr">regex:</span> <span class="hljs-string">__meta_kubernetes_service_label_(.+)</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_namespace</span>]<br>          <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br>          <span class="hljs-attr">target_label:</span> <span class="hljs-string">kubernetes_namespace</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_service_name</span>]<br>          <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br>          <span class="hljs-attr">target_label:</span> <span class="hljs-string">kubernetes_name</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_pod_container_port_number</span>]<br>          <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br>          <span class="hljs-attr">target_label:</span> <span class="hljs-string">container_port</span><br></code></pre></td></tr></table></figure><p>同样进行Prometheus服务的重新启动，在Target页面下出现<code>kubernetes-service-endpoints</code>，在查询页面下能够出现kubernetes相关信息即表示配置成功。</p><img src="/2022/07/30/%E5%9C%A8OpenFaas%E8%87%AA%E5%B8%A6%E7%9A%84Prometheus%E4%B8%AD%E6%8E%A5%E5%85%A5k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/kube-state-metrics.png" class="" title="kube-state-metrics"><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://blog.csdn.net/fengge55/article/details/124177943">prometheus监控k8s集群_fengge55的博客-CSDN博客_prometheus监控k8s集群</a></li><li><ahref="https://blog.csdn.net/w2009211777/article/details/124005822">总结：Promethus配置文件_小魏的博客的博客-CSDN博客_prometheus配置文件</a></li><li><ahref="https://blog.csdn.net/XUEJIA2S/article/details/108808568">prometheus监控k8s集群系列之cadvisor篇_一粒菜鸟的博客-CSDN博客_cadvisorprometheus</a></li><li><ahref="https://blog.csdn.net/XUEJIA2S/article/details/110008195?spm=1001.2014.3001.5502">prometheus监控k8s集群系列之node-exporter篇_一粒菜鸟的博客-CSDN博客_k8snode-exporter</a></li><li><ahref="https://blog.csdn.net/XUEJIA2S/article/details/110097152?spm=1001.2014.3001.5502">prometheus监控k8s集群系列之kube-state-metrics_一粒菜鸟的博客-CSDN博客_prometheus-kube-state-metrics</a></li><li><ahref="https://blog.csdn.net/qq_45439217/article/details/123477846">k8s拉取镜像失败处理ImagePullBackOffErrImageNeverPull_车码平川的博客-CSDN博客_k8s拉取镜像失败</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Prometheus</tag>
      
      <tag>OpenFaas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java字符串的常见使用方法</title>
    <link href="/2022/07/26/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/26/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="string">String</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回字符串的长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 判断字符串是否为空</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpyt</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 返回指定索引处的字符</span><br><span class="hljs-type">char</span> <span class="hljs-title function_">charAt</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br><span class="hljs-comment">// 按照字典序比较两个字符串</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(String str)</span>;<br><br><span class="hljs-comment">// 比较两个字符串是否相等</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(String str)</span>;<br><br><span class="hljs-comment">// 返回指定字符在字符串中第一次出现的索引</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span>;<br><br><span class="hljs-comment">// 根据给定正则表达式的匹配拆分字符串</span><br>String[] split(String regex);<br><br><span class="hljs-comment">// 截取子串，左闭右开 </span><br>String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)</span>;<br><br><span class="hljs-comment">// 转成小写</span><br>String <span class="hljs-title function_">toLowerCase</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 返回字符串的副本，忽略左右两边的空白</span><br>String <span class="hljs-title function_">trim</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 对象转化为String</span><br>xxx.toString();<br><br><span class="hljs-comment">// 数字转化为字符串</span><br>String.valueOf();<br><br><span class="hljs-comment">// 字符串转化为数字</span><br>Integer.parseInt(String str);<br><br><span class="hljs-comment">// 字符串转化为字符数组</span><br><span class="hljs-type">char</span>[] arr = str.toCharArray();<br><br><span class="hljs-comment">// 字符数组转为字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr);<br></code></pre></td></tr></table></figure><h1 id="stringbuffer">StringBuffer</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><br><span class="hljs-comment">// 添加字符串</span><br>append(String str);<br><br><span class="hljs-comment">// 返回指定索引的char字符</span><br>charAt(<span class="hljs-type">int</span> index);<br><br><span class="hljs-comment">// 删除子字符串</span><br>delete(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end);<br><br><span class="hljs-comment">// 删除指定位置的字符</span><br>deleteCharAt(<span class="hljs-type">int</span> index);<br><br><span class="hljs-comment">// 反转字符串</span><br>reverse();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合的基本使用</title>
    <link href="/2022/07/26/Java%E9%9B%86%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/26/Java%E9%9B%86%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="集合基本使用">集合基本使用</h1><p>在Java中，集合的接口主要包括Collection和Map，具体继承关系如下所示。使用之前需要导入相应的包<code>java.util.xxx</code></p><img src="/2022/07/26/Java%E9%9B%86%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Java%E9%9B%86%E5%90%88.png" class="" title="Java集合"><h2 id="collection-常见方法">Collection 常见方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 返回集合中元素的个数</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>; <span class="hljs-comment">// 向集合中添加一个元素</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span>; <span class="hljs-comment">// 向集合中添加一组元素</span><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 清空集合中的元素</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>; <span class="hljs-comment">// 删除某个特定元素</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>; <span class="hljs-comment">// 查找一个元素是否存在</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>; <span class="hljs-comment">// 查找一组元素是否存在</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 判断集合是否为空</span><br><br>Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 返回对应迭代器</span><br><br>Object[] toArray(); <span class="hljs-comment">// 以对象数组的形式返回集合内容</span><br><br>T[] toArray(T[] a); <span class="hljs-comment">// 指定对应泛型，返回集合内容</span><br></code></pre></td></tr></table></figure><h3 id="list-常见方法">List 常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>; <span class="hljs-comment">// 将元素添加到指定位置</span><br><br>E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>; <span class="hljs-comment">// 返回指定位置的元素</span><br><br>E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>; <span class="hljs-comment">// 移除指定位置的元素，返回被移除的元素</span><br><br>E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>; <span class="hljs-comment">// 用指定元素替换集合中指定位置的元素</span><br></code></pre></td></tr></table></figure><h4 id="arraylist">ArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 添加元素</span><br>list.add(obj);<br>list.addAll();<br><span class="hljs-comment">// boolean addAll(Collection c);</span><br><br><span class="hljs-comment">// 访问元素，按索引</span><br>obj = list.get(index);<br><br><span class="hljs-comment">// 删除元素，按索引</span><br>list.remove(index);<br><br><span class="hljs-comment">// 删除元素，按内容</span><br>list.remove(obj);<br><br><span class="hljs-comment">// 计算大小</span><br>len = list.size()<br><br><span class="hljs-comment">// 返回元素的索引值</span><br>index = list.indexOf(obj);<br><br><span class="hljs-comment">// 判断是否包含某元素</span><br>list.contains();<br><br><span class="hljs-comment">// 清空</span><br>list.clear();<br><br><span class="hljs-comment">// 判断是否为空</span><br>list.isEmpty();<br></code></pre></td></tr></table></figure><h4 id="linkedlist">LinkedList</h4><p>ArrayList中的方法，LinkedList都能够使用，除此以外还有更多的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建</span><br>LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 元素添加到头部</span><br>list.addFirst(E e);<br><br><span class="hljs-comment">// 元素添加到尾部</span><br>list.addLast(E e);<br><br><span class="hljs-comment">// 删除并返回第一个元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> list.removeFirst();<br><br><span class="hljs-comment">// 删除并返回最后一个元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> list.removeLast();<br></code></pre></td></tr></table></figure><h4 id="stack">Stack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建</span><br>Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br><span class="hljs-comment">// 压栈</span><br>stack.push(<span class="hljs-type">int</span> element);<br><br><span class="hljs-comment">// 弹栈并返回元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br><br><span class="hljs-comment">// 获取栈顶元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.peek();<br><br><span class="hljs-comment">// 判断是否为空</span><br>stack.isEmpty();<br>stack.empty();<br></code></pre></td></tr></table></figure><h3 id="queue-常见方法">Queue 常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 队尾添加元素 </span><br><span class="hljs-comment">// 队列满的时候add抛出异常，offer返回false</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br><span class="hljs-comment">// 弹出队首元素</span><br><span class="hljs-comment">// 队列为空的时候remove抛出异常，poll返回Null</span><br>E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br>E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 查看队首元素</span><br><span class="hljs-comment">// 队列为空的时候element抛出异常，peek返回Null</span><br>E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>;<br>E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h4 id="linkedlist和arraydeque">LinkedList和ArrayDeque</h4><p>双端队列，可以用来模拟栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建</span><br>LinkedList&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>ArrayDeque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br><span class="hljs-comment">// 添加元素</span><br>deque.offer(<span class="hljs-type">int</span> element);<br><br><span class="hljs-comment">// 返回并删除队首元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> deque.poll();<br><br><span class="hljs-comment">// 查看队首元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> deque.peek();<br><br><span class="hljs-comment">// 判空</span><br>deque.isEmpty();<br><br><span class="hljs-comment">// 大小</span><br>deque.size();<br></code></pre></td></tr></table></figure><h4 id="priorityqueue">PriorityQueue</h4><p>优先队列，可以用来模拟堆。默认为小根堆，可以通过比较函数来指定称为大根堆。（比较函数可以通过定义匿名类或者Lambda表达式实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 小根堆</span><br>PriorityQueue&lt;Integer&gt; qmin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><span class="hljs-comment">// 大根堆-匿名类</span><br>PriorityQueue&lt;Integer&gt; qmax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer a, Integer b)</span>&#123;<br>        <span class="hljs-keyword">return</span> b - a;<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 大根堆-lambda表达式</span><br>PriorityQueue&lt;Integer&gt; qmax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>((x, y) -&gt; y - x)<br>    <br><span class="hljs-comment">// 大根堆-使用Collections接口</span><br>PriorityQueue&lt;Integer&gt; qmax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());<br><br><span class="hljs-comment">// 添加</span><br>qmax.offer(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// 返回并删除</span><br>qmax.poll();<br><br><span class="hljs-comment">// 查看堆顶</span><br>qmax.peek();<br></code></pre></td></tr></table></figure><h3 id="set-常见方法">Set 常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回集合中小于等于给定元素的最大元素，不存在则返回null</span><br>floor(E e);<br><br><span class="hljs-comment">// 返回集合中大于等于给定元素的最小元素，不存在则返回null</span><br>ceiling(E e);<br><br><span class="hljs-comment">// 返回集合中小于给定元素的最大元素，不存在则返回null</span><br>lower(E e);<br><br><span class="hljs-comment">// 返回集合中大于给定元素的最小元素，不存在则返回null</span><br>higher(E e);<br></code></pre></td></tr></table></figure><h4 id="hashset">HashSet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建</span><br>HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br><br><span class="hljs-comment">// 基本与ArrayList相同</span><br><span class="hljs-comment">// 添加</span><br>set.add(<span class="hljs-string">&quot;xxx&quot;</span>);<br><br><span class="hljs-comment">// 删除</span><br>set.remove(<span class="hljs-string">&quot;yyy&quot;</span>);<br><br><span class="hljs-comment">// 返回大小</span><br>set.size();<br><br><span class="hljs-comment">// 判断是否包含元素</span><br>set.contains(<span class="hljs-string">&quot;xxx&quot;</span>);<br><br><span class="hljs-comment">// 清空</span><br>set.clear();<br></code></pre></td></tr></table></figure><h2 id="map-常见方法">Map 常见方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 增加或修改键值对</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object key, Object value)</span>;<br><br><span class="hljs-comment">// 根据key值获取对应的值，不存在返回null</span><br>Object <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span>;<br><br><span class="hljs-comment">// 根据key值获取对应的值，没有返回默认值</span><br>Object <span class="hljs-title function_">getOrDefault</span><span class="hljs-params">(Object key, Object defalutValue)</span>;<br><br><span class="hljs-comment">// 判断是否包含该key</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(Object key)</span>;<br><br><span class="hljs-comment">// 判断是否包含某个值</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">containsValue</span><span class="hljs-params">(Object value)</span>;<br><br><span class="hljs-comment">// 返回key的Set视图</span><br>Set <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 返回value的Collection视图</span><br>Collection <span class="hljs-title function_">values</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 返回映射关系的Set视图</span><br>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();<br></code></pre></td></tr></table></figure><p>K-V的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();<br><span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry: entries)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hashmap">HashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建</span><br>HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br><span class="hljs-comment">// 加入键值对</span><br>map.put(key, value);<br><br><span class="hljs-comment">// 按key获取value</span><br>v = map.get(key);<br><br><span class="hljs-comment">// 返回所有key集合</span><br>map.keySet();<br><br><span class="hljs-comment">// 返回所有value集合</span><br>map.values();<br><br><span class="hljs-comment">// 删除</span><br>map.remove(key);<br>map.remove(key, value);<br><br><span class="hljs-comment">// 替换</span><br>map.replace(key, value);<br>map.replace(key, oldValue, newValue);<br><br><span class="hljs-comment">// 判断是否包含key</span><br>map.containsKey(key);<br><span class="hljs-comment">// 判断是否包含value</span><br>map.containsValue(value);<br><br><span class="hljs-comment">// 如果要迭代hashmap的话，可以选择迭代key或value</span><br><span class="hljs-comment">// 通常迭代key会多一些</span><br><span class="hljs-comment">// 使用for each语句即可，例如</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i: map.keySet()) &#123;<br>  ...<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="treemap">TreeMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建</span><br>TreeMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;Integer, Integer&gt;();<br><br><span class="hljs-comment">// 由于TreeMap可以进行对Key的排序，所以可以用下面的操作</span><br><span class="hljs-comment">// 返回大于或等于给定键的最小键，如果没有则返回null</span><br>map.ceilingKey(Integer key);<br><br><span class="hljs-comment">// 返回小于或等于给定键的最大键，如果没有则返回null</span><br>map.floorKey(Integer key);<br></code></pre></td></tr></table></figure><h1 id="工具类">工具类</h1><h2 id="collection工具类">Collection工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 反转</span><br>Collections.reverse(array);<br><br><span class="hljs-comment">// 随机排序</span><br>Collections.shuffle(array);<br><br><span class="hljs-comment">// 交换指定位置上的元素</span><br>Collections.swap(array, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 排序</span><br>Collections.sort(array);<br><br><span class="hljs-comment">// 自定义排序</span><br>Collections.sort(array, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer t1, Integer t2)</span>&#123;<br>        <span class="hljs-keyword">return</span> t2 - t1;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 最大值</span><br>Collections.max(array);<br><br><span class="hljs-comment">// 统计1出现的次数</span><br>Collections.frequency(array, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 二分查找，返回索引</span><br>Collections.binarySearch(array, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="arrays工具类">Arrays工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">54</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>&#125;;<br><br>Arrays.sort(a); <span class="hljs-comment">// 排序</span><br><br>Arrays.asList(T ...p); <span class="hljs-comment">// 生成List</span><br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://blog.csdn.net/qq_44074143/article/details/124801531">Java刷题常用集合类以及函数总结_叶~子的博客-CSDN博客_java集合函数</a></li><li><ahref="https://www.cnblogs.com/JavicxhloWong/p/15879295.html">Java常用容器基础操作汇总- JavicxhloWong - 博客园 (cnblogs.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark学习笔记-SparkSQL(1)-概述以及编程入门</title>
    <link href="/2022/07/26/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkSQL-1-%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/26/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkSQL-1-%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="sparksql概述">SparkSQL概述</h1><p>SparkSQL是Spark用于结构化数据处理的一个模块。SparkSQL可以简化RDD的开发，提高开发效率，并且执行效率高。我们可以在SparkSQL中使用SQL语句来完成查询，同时也可以使用SparkSQL提供的接口来完成开发。</p><p>Spark具有如下特点：</p><ol type="1"><li>易整合：无缝地整合了SQL查询和Spark编程，我们可以很容易在Spark编程中书写SQL语句</li><li>统一的数据访问：我们可以使用相同的方式连接不同的数据源</li><li>兼容Hive：可以在已有的数据仓库上直接运行SQL或者HiveSQL</li><li>标准数据连接：允许通过JDBC或者ODBC来进行连接</li></ol><p>SparkSQL中为我们提供了两个编程抽象，DataFrame和DataSet</p><p>DataFrame是一种以RDD为基础的分布式数据集，类似于传统数据库中的二维表。DataFrame与RDD的主要区别在于，RDD中仅包括数据，而DataFrame中还包括数据schema的信息，即每一列的名称和类型等，即DataFrame携带更多的结构信息，我们可以将它当作数据库中的一张表来对待。</p><p>DataSet是在Spark1.6中添加的一个新抽象，是DataFrame的一个扩展。在RDD中我们关注数据的类型，在DataFrame中我们关注每一列的数据和类型，DataSet则融合了两者的优点，即既有每行数据的类型，又有每列数据的类型。</p><ul><li>使用样例类来定义DataSet中数据的结构信息，样例类中每个属性的名称直接映射到DataSet中的字段名称</li><li>DataSet是强类型的，例如<code>DataSet[Car], DataSet[Person]</code>等，可以理解为表中的每一行都是一个数据类型</li><li>DataFrame是DataSet的一个特例，每一行的数据类型为<code>Row</code>，即<code>DataFrame=DataSet[Row]</code>。Row是一个类型，获取数据的时候需要指定顺序。</li></ul><h1 id="简单演示">简单演示</h1><p>我们可以在Spark的交互式命令行窗口中简单演示SparkSQL的使用。在前面我们执行Spark应用程序，需要首先构建上下文对象SparkContext。SparkSQL可以理解为对SparkCore的一种封装，不仅在模型上进行了封装，而且对上下文环境对象也进行了封装。我们在查询前，需要构建查询起点<code>SparkSession</code>，在命令行中，已经存在有该参数，名称为spark。</p><img src="/2022/07/26/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkSQL-1-%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E5%88%9D%E5%A7%8B%E5%AF%B9%E8%B1%A1.png" class="" title="初始对象"><h2 id="创建dataframe">创建DataFrame</h2><p>创建DataFrame有三种方式：通过Spark的数据源进行创建；从一个存在的RDD进行创建；从Hive进行查询返回。这里我们使用Spark从数据源进行创建，数据源是一个json文件，其中的每一行是一个json表达式。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> df = spark.read.json(<span class="hljs-string">&quot;data.json&quot;</span>)<br>df: org.apache.spark.sql.<span class="hljs-type">DataFrame</span> = [age: bigint, username: string]<br></code></pre></td></tr></table></figure><p>展示效果如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; df.show()<br>+---+--------+<br>|age|username|<br>+---+--------+<br>| <span class="hljs-number">20</span>|zhangsan|<br>| <span class="hljs-number">30</span>|    lisi|<br>| <span class="hljs-number">40</span>|  wangwu|<br>+---+--------+<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果是从内存中获取数据，Spark可以知道具体的数据类型是什么。如果是数字，则默认作为Int处理。如果是从文件中读取的数字，不能确定是什么类型，则使用bigint接收，可以与Long类型进行转换</p></blockquote><h2 id="使用sql进行查询">使用SQL进行查询</h2><p>我们可以在SparkSQL中直接使用SQL进行查询，但是这种风格的查询必须要有视图来进行辅助。视图分为全局视图和临时视图。</p><p>临时视图创建：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; df.createOrReplaceTempView(<span class="hljs-string">&quot;people&quot;</span>)<br></code></pre></td></tr></table></figure><p>使用SQL进行查询：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> sqlDF = spark.sql(<span class="hljs-string">&quot;select * from people&quot;</span>)<br>sqlDF: org.apache.spark.sql.<span class="hljs-type">DataFrame</span> = [age: bigint, username: string]<br><br>scala&gt; sqlDF.show()<br>+---+--------+<br>|age|username|<br>+---+--------+<br>| <span class="hljs-number">20</span>|zhangsan|<br>| <span class="hljs-number">30</span>|    lisi|<br>| <span class="hljs-number">40</span>|  wangwu|<br>+---+--------+<br></code></pre></td></tr></table></figure><p>全局视图创建：</p><p>普通临时表是Session范围内的，如果想要在应用范围内有效，应该使用全局的临时表。在访问的时候，也应该使用全路径进行访问。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; df.createGlobalTempView(<span class="hljs-string">&quot;people1&quot;</span>)<br><br>scala&gt; spark.sql(<span class="hljs-string">&quot;select * from global_temp.people1&quot;</span>).show()<br>+---+--------+<br>|age|username|<br>+---+--------+<br>| <span class="hljs-number">20</span>|zhangsan|<br>| <span class="hljs-number">30</span>|    lisi|<br>| <span class="hljs-number">40</span>|  wangwu|<br>+---+--------+<br><br>scala&gt; spark.newSession().sql(<span class="hljs-string">&quot;select * from global_temp.people1&quot;</span>).show()<br>+---+--------+<br>|age|username|<br>+---+--------+<br>| <span class="hljs-number">20</span>|zhangsan|<br>| <span class="hljs-number">30</span>|    lisi|<br>| <span class="hljs-number">40</span>|  wangwu|<br>+---+--------+<br></code></pre></td></tr></table></figure><h2 id="使用dsl进行查询">使用DSL进行查询</h2><p>DataFrame中还提供一个领域特定语言（Domain-SpecificLanguage，DSL）来管理结构化的数据，可以在Scala、Java、Python和R中使用DSL。使用DSL则没有必要创建临时视图了。</p><p>查看DataFrame的schema信息：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; df.printSchema<br>root<br> |-- age: long (nullable = <span class="hljs-literal">true</span>)<br> |-- username: string (nullable = <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>查看某一列：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; df.select(<span class="hljs-string">&quot;username&quot;</span>).show()<br>+--------+<br>|username|<br>+--------+<br>|zhangsan|<br>|    lisi|<br>|  wangwu|<br>+--------+<br></code></pre></td></tr></table></figure><p>对列进行运算：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; df.select($<span class="hljs-string">&quot;username&quot;</span>, $<span class="hljs-string">&quot;age&quot;</span> + <span class="hljs-number">1</span>).show()<br>+--------+---------+<br>|username|(age + <span class="hljs-number">1</span>)|<br>+--------+---------+<br>|zhangsan|       <span class="hljs-number">21</span>|<br>|    lisi|       <span class="hljs-number">31</span>|<br>|  wangwu|       <span class="hljs-number">41</span>|<br>+--------+---------+<br><br>scala&gt; df.select(&#x27;username, &#x27;age + <span class="hljs-number">2</span>).show()<br>+--------+---------+<br>|username|(age + <span class="hljs-number">2</span>)|<br>+--------+---------+<br>|zhangsan|       <span class="hljs-number">22</span>|<br>|    lisi|       <span class="hljs-number">32</span>|<br>|  wangwu|       <span class="hljs-number">42</span>|<br>+--------+---------+<br></code></pre></td></tr></table></figure><blockquote><p>注意：涉及到对列进行运算的时候，每一列都必须使用$，或者采用引号表达式：<code>单引号+字段</code></p></blockquote><p>还有其他更多的操作，如filter，groupby等。</p><h2 id="创建dataset">创建DataSet</h2><p>DataSet的创建可以使用样例类序列创建，也可以使用基本类型序列创建</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Long</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> caseClassDS = <span class="hljs-type">Seq</span>(<span class="hljs-type">Person</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">300</span>), <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">400</span>)).toDS<br>caseClassDS: org.apache.spark.sql.<span class="hljs-type">Dataset</span>[<span class="hljs-type">Person</span>] = [name: string, age: bigint]<br><br>scala&gt; caseClassDS.show<br>+--------+---+<br>|    name|age|<br>+--------+---+<br>|zhangsan|<span class="hljs-number">300</span>|<br>|    lisi|<span class="hljs-number">400</span>|<br>+--------+---+<br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> seqDS = <span class="hljs-type">Seq</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).toDS<br>seqDS: org.apache.spark.sql.<span class="hljs-type">Dataset</span>[<span class="hljs-type">Int</span>] = [value: int]<br><br>scala&gt; seqDS.show<br>+-----+<br>|value|<br>+-----+<br>|    <span class="hljs-number">1</span>|<br>|    <span class="hljs-number">2</span>|<br>|    <span class="hljs-number">3</span>|<br>|    <span class="hljs-number">4</span>|<br>|    <span class="hljs-number">5</span>|<br>+-----+<br></code></pre></td></tr></table></figure><h1 id="三种抽象之间的关系">三种抽象之间的关系</h1><p>到目前为止，Spark中为我们提供了三种抽象，分别是RDD，DataFrame，DataSet。它们之间有相似之处，也有不同点。</p><p>相同点：</p><ol type="1"><li>都是Spark平台下的分布式弹性数据集，为处理大型数据提供便利</li><li>都具有惰性机制，直到行动算子才会触发执行</li><li>会根据Spark的内存情况进行自动缓存</li><li>都有分区的概念</li><li>DataFrame和DataSet可以使用模式匹配来获取各个字段的值和类型</li></ol><p>不同点：</p><ol type="1"><li>RDD一般和Spark MLlib同时使用，不支持SparkSQL操作</li><li>DataFrame每一行的类型固定为Row，支持SparkSQL操作</li><li>DataSet和DataFrame具有完全相同的成员函数，区别在于每一行的数据类型不同</li></ol><p>它们分别是不同程度的抽象，可以互相转换。</p><blockquote><p>如果需要它们之间的相互操作，需要引入<code>import spark.implicits._</code>。这里的spark不是Scala的包名，而是创建的SparkSession对象的变量名称，所以需要创建SparkSession对象之后再导入。在spark-shell中无需我们手动导入，已经存在。</p><p>注意这里的spark对象不能使用var声明，因为Scala支持val修饰的对象进行导入。</p></blockquote><h2 id="rdd与-dataframe之间的转换">RDD与 DataFrame之间的转换</h2><p>RDD -&gt; DataFrame：<code>toDF</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>((<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">30</span>), (<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">40</span>)))<br>rdd: org.apache.spark.rdd.<span class="hljs-type">RDD</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = <span class="hljs-type">ParallelCollectionRDD</span>[<span class="hljs-number">35</span>] at makeRDD at &lt;console&gt;:<span class="hljs-number">24</span><br><br>scala&gt; rdd.toDF.show()<br>+--------+---+<br>|      _1| _2|<br>+--------+---+<br>|zhangsan| <span class="hljs-number">30</span>|<br>|    lisi| <span class="hljs-number">40</span>|<br>+--------+---+<br><br>scala&gt; rdd.toDF(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>).show()<br>+--------+---+<br>|username|age|<br>+--------+---+<br>|zhangsan| <span class="hljs-number">30</span>|<br>|    lisi| <span class="hljs-number">40</span>|<br>+--------+---+<br></code></pre></td></tr></table></figure><p>DataFrame -&gt; RDD：<code>.rdd</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; df.rdd.collect<br>res22: <span class="hljs-type">Array</span>[org.apache.spark.sql.<span class="hljs-type">Row</span>] = <span class="hljs-type">Array</span>([<span class="hljs-number">20</span>,zhangsan], [<span class="hljs-number">30</span>,lisi], [<span class="hljs-number">40</span>,wangwu])<br></code></pre></td></tr></table></figure><h2 id="dataframe和dataset之间的转换">DataFrame和DataSet之间的转换</h2><p>DataFrame -&gt; DataSet：<code>as</code></p><p>注意需要属性和样例类属性名称保持一致</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Long</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> df = sc.makeRDD(<span class="hljs-type">List</span>((<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">12</span>), (<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">13</span>))).toDF(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>)<br>df: org.apache.spark.sql.<span class="hljs-type">DataFrame</span> = [name: string, age: int]<br><br>scala&gt; <span class="hljs-keyword">val</span> ds = df.as[<span class="hljs-type">Person</span>]<br>ds: org.apache.spark.sql.<span class="hljs-type">Dataset</span>[<span class="hljs-type">Person</span>] = [name: string, age: int<br></code></pre></td></tr></table></figure><p>DataSet -&gt; DataFrame：<code>toDF</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; ds.toDF<br>res32: org.apache.spark.sql.<span class="hljs-type">DataFrame</span> = [name: string, age: int]<br></code></pre></td></tr></table></figure><h2 id="rdd与dataset之间的转换">RDD与DataSet之间的转换</h2><p>RDD -&gt; DataSet：<code>toDS</code>。</p><p>SparkSQL能够自动将包含有case类的RDD转换为DataSet。样例类定义的表的结构，样例类的属性通过反射变为表的列名。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Long</span></span>)</span><br>defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><br>scala&gt; <span class="hljs-keyword">val</span> dataset = sc.makeRDD(<span class="hljs-type">List</span>(<span class="hljs-type">Person</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">11</span>), <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">22</span>))).toDS<br>dataset: org.apache.spark.sql.<span class="hljs-type">Dataset</span>[<span class="hljs-type">Person</span>] = [name: string, age: bigint]<br><br>scala&gt; dataset.show<br>+--------+---+<br>|    name|age|<br>+--------+---+<br>|zhangsan| <span class="hljs-number">11</span>|<br>|    lisi| <span class="hljs-number">22</span>|<br>+--------+---+<br></code></pre></td></tr></table></figure><p>DataSet -&gt; DataFrame：<code>.rdd</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; dataset.rdd.collect<br>res29: <span class="hljs-type">Array</span>[<span class="hljs-type">Person</span>] = <span class="hljs-type">Array</span>(<span class="hljs-type">Person</span>(zhangsan,<span class="hljs-number">11</span>), <span class="hljs-type">Person</span>(lisi,<span class="hljs-number">22</span>))<br></code></pre></td></tr></table></figure><h1 id="idea编程">IDEA编程</h1><p>使用IDEA进行SparkSQL进行编程的话，需要进行依赖的添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.spark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spark-sql_2.12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>简单准备数据环境：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">SQL</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 创建SparkSQL的运行环境</span><br>    <span class="hljs-keyword">val</span> sparkConf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;sparkSQL&quot;</span>)<br>    <span class="hljs-keyword">val</span> spark = <span class="hljs-type">SparkSession</span>.builder().config(sparkConf).getOrCreate()<br>    <span class="hljs-keyword">import</span> spark.implicits._<br><br>    <span class="hljs-comment">// 创建RDD, DataFrame和DataSet</span><br>    <span class="hljs-keyword">val</span> rdd = spark.sparkContext.makeRDD(<span class="hljs-type">List</span>((<span class="hljs-number">1</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">30</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">40</span>)))<br>    <span class="hljs-keyword">val</span> df: <span class="hljs-type">DataFrame</span> = rdd.toDF(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>)<br>    <span class="hljs-keyword">val</span> ds:<span class="hljs-type">Dataset</span>[<span class="hljs-type">Person</span>] = df.as[<span class="hljs-type">Person</span>]<br><br>    df.show()<br>    ds.show()<br><br>    <span class="hljs-comment">// 环境关闭</span><br>    spark.close()<br>  &#125;<br><br>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="用户自定义函数">用户自定义函数</h1><p>用户可以通过spark.udf功能添加自定义函数</p><h2 id="udf">UDF</h2><p>UDF函数只需要进行注册即可使用。例如这里的函数就是给姓名在查询的使用加一个前缀：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 临时视图</span><br>ds.createOrReplaceTempView(<span class="hljs-string">&quot;person&quot;</span>)<br><br><span class="hljs-comment">// 自定义函数UDF</span><br>spark.udf.register(<span class="hljs-string">&quot;myUDF&quot;</span>, (name:<span class="hljs-type">String</span>) =&gt; &#123;<br>    <span class="hljs-string">&quot;Name: &quot;</span> + name<br>&#125;)<br>spark.sql(<span class="hljs-string">&quot;select myUDF(name), age from person&quot;</span>).show()<br></code></pre></td></tr></table></figure><h2 id="udaf">UDAF</h2><p>UDAF指的是聚合操作。对于聚合操作来说，我们可以将它的执行过程分为两个步骤，首先进行遍历，将一些临时数据放在Buffer中，之后再对这些Buffer中的数据进行某种特殊的操作，得到聚合结果。</p><p>在SparkSQL中，实现UDAF也是类似的逻辑。我们需要继承特定的类，然后重写其中的方法，方法的总体逻辑与上面我们说的执行过程类似。这里可供继承的类有<code>UserDefinedAggregateFunction</code>和<code>Aggregator</code>，其中前者是弱类型的，需要使用顺序来确定值，而后者是强类型，可以使用类型名来确定值。前者已经不推荐使用，这里只做简单介绍。下面我们就使用用户自定义聚合函数来实现计算年龄的平均值</p><h3 id="userdefinedaggregatefunction">UserDefinedAggregateFunction</h3><p>自定义类继承<code>UserDefinedAggregateFunction</code>，实现其中的方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAvg_UDAF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserDefinedAggregateFunction</span> </span>&#123;<br>    <span class="hljs-comment">// 输入数据的结构</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inputSchema</span></span>: <span class="hljs-type">StructType</span> = &#123;<br>        <span class="hljs-type">StructType</span>(<br>            <span class="hljs-type">Array</span>(<span class="hljs-type">StructField</span>(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-type">LongType</span>))<br>        )<br>    &#125;<br><br>    <span class="hljs-comment">// buffer的结构</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bufferSchema</span></span>: <span class="hljs-type">StructType</span> = &#123;<br>        <span class="hljs-type">StructType</span>(<br>            <span class="hljs-type">Array</span>(<br>                <span class="hljs-type">StructField</span>(<span class="hljs-string">&quot;total&quot;</span>, <span class="hljs-type">LongType</span>),<br>                <span class="hljs-type">StructField</span>(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-type">LongType</span>)<br>            )<br>        )<br>    &#125;<br><br>    <span class="hljs-comment">// 输出数据的数据类型</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dataType</span></span>: <span class="hljs-type">DataType</span> = <span class="hljs-type">LongType</span><br><br>    <span class="hljs-comment">// 函数稳定性</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deterministic</span></span>: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// 缓冲区buffer初始化</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>(buffer: <span class="hljs-type">MutableAggregationBuffer</span>): <span class="hljs-type">Unit</span> = &#123;<br>        buffer.update(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>L)<br>        buffer.update(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>L)<br>    &#125;<br><br>    <span class="hljs-comment">// 根据输入的值更新buffer数据</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span></span>(buffer: <span class="hljs-type">MutableAggregationBuffer</span>, input: <span class="hljs-type">Row</span>): <span class="hljs-type">Unit</span> = &#123;<br>        buffer.update(<span class="hljs-number">0</span>, buffer.getLong(<span class="hljs-number">0</span>) + input.getLong(<span class="hljs-number">0</span>))<br>        buffer.update(<span class="hljs-number">1</span>, buffer.getLong(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 合并buffer数据,buffer2的数据合并到buffer1中</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span></span>(buffer1: <span class="hljs-type">MutableAggregationBuffer</span>, buffer2: <span class="hljs-type">Row</span>): <span class="hljs-type">Unit</span> = &#123;<br>        buffer1.update(<span class="hljs-number">0</span>, buffer1.getLong(<span class="hljs-number">0</span>) + buffer2.getLong(<span class="hljs-number">0</span>))<br>        buffer1.update(<span class="hljs-number">1</span>, buffer1.getLong(<span class="hljs-number">1</span>) + buffer2.getLong(<span class="hljs-number">1</span>))<br>    &#125;<br><br>    <span class="hljs-comment">// 计算聚合结果</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate</span></span>(buffer: <span class="hljs-type">Row</span>): <span class="hljs-type">Any</span> = &#123;<br>        buffer.getLong(<span class="hljs-number">0</span>) / buffer.getLong(<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后进行注册，在SQL语句中使用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">spark.udf.register(<span class="hljs-string">&quot;myAvg_udaf&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">MyAvg_UDAF</span>())<br>spark.sql(<span class="hljs-string">&quot;select myAvg_udaf(age) from person&quot;</span>).show()<br></code></pre></td></tr></table></figure><h3 id="aggregator">Aggregator</h3><p>可以看到上面的操作涉及到很多位置下标的使用，可读性不好也容易混淆。因此Spark提供了强类型的Aggregator，我们也需要自定义类来继承<code>Aggregator</code>，实现其中的方法。</p><p>注意这里不要导错对象了，正确路径为<code>import org.apache.spark.sql.expression.Aggregator</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 需要指定泛型</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Buffer</span>(<span class="hljs-params">var total: <span class="hljs-type">Long</span>, var count: <span class="hljs-type">Long</span></span>)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAvg_Agg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Aggregator</span>[<span class="hljs-type">Long</span>, <span class="hljs-type">Buffer</span>, <span class="hljs-type">Long</span>] </span>&#123;<br>    <span class="hljs-comment">// 初始值，缓冲区初始化</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zero</span></span>: <span class="hljs-type">Buffer</span> = &#123;<br>        <span class="hljs-type">Buffer</span>(<span class="hljs-number">0</span>L, <span class="hljs-number">0</span>L)<br>    &#125;<br><br>    <span class="hljs-comment">// 根据输入来更新缓冲区</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(buffer: <span class="hljs-type">Buffer</span>, in: <span class="hljs-type">Long</span>): <span class="hljs-type">Buffer</span> = &#123;<br>        buffer.total = buffer.total + in<br>        buffer.count = buffer.count + <span class="hljs-number">1</span><br>        buffer<br>    &#125;<br><br>    <span class="hljs-comment">// 合并缓冲区</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span></span>(buffer1: <span class="hljs-type">Buffer</span>, buffer2: <span class="hljs-type">Buffer</span>): <span class="hljs-type">Buffer</span> = &#123;<br>        buffer1.total = buffer1.total + buffer2.total<br>        buffer1.count = buffer1.count + buffer2.count<br>        buffer1<br>    &#125;<br><br>    <span class="hljs-comment">// 计算结果</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">finish</span></span>(buffer: <span class="hljs-type">Buffer</span>): <span class="hljs-type">Long</span> = &#123;<br>        buffer.total / buffer.count<br>    &#125;<br><br>    <span class="hljs-comment">// 缓冲区的编码操作(基本是固定格式，如果是自定义则为product，如果是系统自带则为scalaxxx)</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bufferEncoder</span></span>: <span class="hljs-type">Encoder</span>[<span class="hljs-type">Buffer</span>] = <span class="hljs-type">Encoders</span>.product<br><br>    <span class="hljs-comment">// 输出的编码操作</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outputEncoder</span></span>: <span class="hljs-type">Encoder</span>[<span class="hljs-type">Long</span>] = <span class="hljs-type">Encoders</span>.scalaLong<br>&#125;<br></code></pre></td></tr></table></figure><p>之后注册使用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">spark.udf.register(<span class="hljs-string">&quot;myAvg_agg&quot;</span>, functions.udaf(<span class="hljs-keyword">new</span> <span class="hljs-type">MyAvg_Agg</span>()))<br>spark.sql(<span class="hljs-string">&quot;select myAvg_agg(age) from person&quot;</span>).show()<br></code></pre></td></tr></table></figure><h1 id="数据加载与保存">数据加载与保存</h1><h2 id="通用方式">通用方式</h2><p>SparkSQL提供通用方式进行数据的保存和加载，通用方式指的是使用相同的API，根据不同的参数读取和保存不同格式的数据。默认情况下，SparkSQL读取和保存的文件格式为parquet。（下面的spark都是SparkSession对象。）</p><p>通用加载：<code>spark.read.load</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">spark.read.format(<span class="hljs-string">&quot;...&quot;</span>)[.option(<span class="hljs-string">&quot;...&quot;</span>)].load(<span class="hljs-string">&quot;...&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>format：指定加载的数据格式，包括csv、jdbc、json、orc、parquet、textFile等</li><li>load：加载路径</li><li>option：传入相关参数</li></ul><p>通用保存：<code>df.write.save</code>(df是一个DataFrame对象)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">df.write.format(<span class="hljs-string">&quot;...&quot;</span>)[.option(<span class="hljs-string">&quot;...&quot;</span>)].save(<span class="hljs-string">&quot;...&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>format：指定保存的数据格式</li><li>save：指定保存数据的路径</li><li>option：传入相关参数</li></ul><h2 id="不同格式">不同格式</h2><p>上面是通过使用format来实现不同文件格式的加载，Spark中也提供专门的操作符来完成这件事：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; spark.read.<br>csv format jdbc json load option options orc parquet schema <br>table text textFile<br></code></pre></td></tr></table></figure><ol type="1"><li>json：要求读取的json文件每一行是一个json串</li><li>csv：在option中配置csv文件的相关信息，如分隔符，是否包含表头等</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">spark.read.format(<span class="hljs-string">&quot;csv&quot;</span>)<br>.option(<span class="hljs-string">&quot;sep&quot;</span>, <span class="hljs-string">&quot;;&quot;</span>)<br>.option(<span class="hljs-string">&quot;inferSchema&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>)<br>.option(<span class="hljs-string">&quot;header&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>)<br>.load(<span class="hljs-string">&quot;data/user.csv&quot;</span>)<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>mysql：在IDEA中通过JDBC对MySQL进行操作</li></ol><p>先引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 读取数据</span><br><span class="hljs-comment">//1.通用方式</span><br>spark.read.format(<span class="hljs-string">&quot;jdbc&quot;</span>)<br>.option(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;jdbc:mysql://xxx&quot;</span>)<br>.option(<span class="hljs-string">&quot;driver&quot;</span>, <span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>)<br>.option(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>.option(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>.option(<span class="hljs-string">&quot;dbtable&quot;</span>, <span class="hljs-string">&quot;user_table&quot;</span>)<br>.load().show<br><br><span class="hljs-comment">//2.使用jdbc方法</span><br><span class="hljs-keyword">val</span> props: <span class="hljs-type">Properties</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Properties</span>()<br>props.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>props.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>)<br><span class="hljs-keyword">val</span> df: <span class="hljs-type">DataFrame</span> = spark.read.jdbc(<span class="hljs-string">&quot;jdbc:mysql://xxx&quot;</span>, <span class="hljs-string">&quot;user_table&quot;</span>, props)<br>df.show<br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 保存数据</span><br><span class="hljs-comment">//1.通用方式</span><br>ds.write<br>.format(<span class="hljs-string">&quot;jdbc&quot;</span>)<br>.option(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;jdbc:mysql://xxx&quot;</span>)<br>.option(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>.option(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>.option(<span class="hljs-string">&quot;dbtable&quot;</span>, <span class="hljs-string">&quot;user_table&quot;</span>)<br>.mode(<span class="hljs-type">SaveMode</span>.<span class="hljs-type">Append</span>)<br>.save()<br><br><span class="hljs-comment">//2.通过jdbc方法</span><br><span class="hljs-keyword">val</span> props: <span class="hljs-type">Properties</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Properties</span>()<br>props.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>props.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>ds.write.mode(<span class="hljs-type">SaveMode</span>.<span class="hljs-type">Append</span>).jdbc(<span class="hljs-string">&quot;jdbc:mysql://xxx&quot;</span>, <span class="hljs-string">&quot;user_table&quot;</span>, props)<br><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>Hive</li></ol><p>SparkSQL可以连接到部署好的Hive上，也可以使用自己的Hive元数据仓库。</p><p>如果需要连接外部Hive，应该将hive-site.xml复制到Spark的配置目录文件目录下<code>$SPARK_HOME/conf</code>。如果没有部署外部Hive，那么SparkSQL会在当前目录中创建自己的Hive元数据仓库，名称为<code>metastore_db</code>。</p><p>内嵌的Hive元数据存储在derby中，默认仓库地址为<code>$SPARK_HOME/spark-warehouse</code>，无需任何配置，直接使用即可。</p><p>外部的Hive连接需要以下操作：</p><ul><li>将<code>hive-site.xml</code>拷贝到<code>conf/</code>目录下</li><li>将MySQL的驱动复制到<code>jars/</code>目录下</li></ul><p>之后可以运行SparkSQLCLI，<code>bin/spark-sql</code>可以开启一个窗口，在其中直接执行SQL语句。</p><p>当然也可以运行Sparkbeeline。与HiveServer2类似，也是通过连接到MetaStore服务来进行元数据的访问。这需要我们启动SparkThrift Server。它的接口和协议与HiveServer2完全一致，可以和HiveMetaStore进行交互。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sbin/start-thriftserver.sh<br>bin/beeline -u jdbc:hive2://xxxx:10000 -n xxx<br></code></pre></td></tr></table></figure><p>也可以在代码中操作Hive，首先需要导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.spark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spark-hive_2.12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hive<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hive-exec<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后将hive-site.xml文件拷贝到resources目录下。</p><p>创建SparkSession对象的时候，需要添加一个参数启动Hive支持</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//创建 SparkSession</span><br><span class="hljs-keyword">val</span> spark: <span class="hljs-type">SparkSession</span> = <span class="hljs-type">SparkSession</span><br> .builder()<br> .enableHiveSupport()<br> .master(<span class="hljs-string">&quot;local[*]&quot;</span>)<br> .appName(<span class="hljs-string">&quot;sql&quot;</span>)<br> .getOrCreate()<br></code></pre></td></tr></table></figure><blockquote><p>默认创建数据库在本地仓库，需要通过参数修改仓库地址</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">config(<span class="hljs-string">&quot;spark.sql.warehouse.dir&quot;</span>, <span class="hljs-string">&quot;hdfs://xxx/xxx/xx&quot;</span>)<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Spark</tag>
      
      <tag>SparkSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark学习笔记-SparkCore(4)-Spark核心运行机制</title>
    <link href="/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="spark核心组件">Spark核心组件</h1><p>Spark的核心组件包括Driver和Executor。</p><p>Driver：Spark的驱动器节点，用于执行Spark任务中的main方法。在作业流程中，Driver主要负责：</p><ul><li>将用户程序转化为作业Job</li><li>在Executor之间进行任务调度（Task）</li><li>跟踪Executor的执行情况</li><li>通过UI展示查询运行情况</li></ul><p>Executor：负责在Spark作业中运行具体的任务Task，任务之间彼此独立。Spark应用启动的时候，ExecutorBackend节点同时启动，其中的Executor对象完成实际的运算工作。如果有ExecutorBackend节点发生故障或者崩溃，Spark应用会将出错节点上的任务调度到其他Executor节点上执行。Executor主要负责：</p><ul><li>负责运行组成Spark应用的任务，并将结果返回给驱动器（Driver）</li><li>通过自身的块管理器为用户程序中要求缓存的RDD提供内存管理。要求缓存的RDD直接缓存在Executor进程中，在任务运行时可以充分利用缓存</li></ul><p>Spark有多种部署模式，但是整体有一个通用的流程概述：</p><ol type="1"><li>程序提交之后，启动Driver程序（Driver的位置可能因提交方式不同而不同）</li><li>Driver向集群管理器注册应用程序</li><li>集群管理器根据任务的配置文件分配Executor并启动，Executor向Driver注册</li><li>Driver中代码执行到行动算子时开始反向推导，根据宽依赖对作业Job进行划分，划分成多个阶段Stage，每个阶段对应一个TaskSet，其中包含多个Task。之后使用可用的Executor执行Task的执行</li><li>根据本地化原则，Task会被分发到指定的Executor去执行。在任务执行的过程中，Executor会不断与Driver进行通信，报告任务的运行情况</li></ol><h1 id="spark部署模式">Spark部署模式</h1><h2 id="部署模式概览">部署模式概览</h2><p>Spark中支持多种部署模式，主要有以下几种：</p><ol type="1"><li>本地模式：不使用集群，而是在本地通过启动多个线程的方式完成并行计算</li><li>Standalone模式：使用Spark原生的集群管理器，可以单独部署到一个集群中而无需依赖其他的资源管理系统</li><li>Yarn模式：使用Yarn资源管理框架进行资源的管理和调度。根据Driver在集群中位置的不同，又可以分为YarnCluster和Yarn Client模式</li><li>ApacheMesos模式：Mesos是一个分布式资源管理框架，可以允许其他的框架部署在它之上。Spark在开发之初就考虑到支持Mesos，Spark运行在Mesos上会更加灵活。分为粗粒度模式和细粒度模式。</li><li>K8S：容器部署模式</li></ol><h2 id="yarn部署模式">Yarn部署模式</h2><p>根据Driver的位置不同，Yarn部署模式分为Yarn Cluster以及YarnClient。在Yarn部署模式下，需要关注ResourceManager、NodeManager以及ApplicationMaster与Driver、Executor之间的关系。</p><h3 id="yarn-cluster模式">Yarn Cluster模式</h3><img src="/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/YarnCluster.png" class="" title="YarnCluster"><p>运行流程如下：</p><ol type="1"><li>利用<code>spark-submit</code>脚本进行程序的提交，启动<code>SparkSubmit</code>的JVM进程</li><li><code>SparkSubmit</code>中的main方法调用<code>YarnClusterApplication</code>对象中的main方法</li><li><code>YarnClusterApplication</code>创建Yarn客户端用来向连接Yarn，向Yarn发送执行指令<code>bin/java ApplicationMaster</code>，即要求运行<code>ApplicationMaster</code></li><li>Yarn框架接收到指令，在对应的<code>NodeManager</code>中启动<code>ApplicationMaster</code></li><li>在<code>ApplicationMaster</code>中启动Driver<strong>线程</strong>，执行用户的程序</li><li><code>ApplicationMaster</code>向<code>ResourceManager</code>注册，进行资源的申请，即获取到可用的<code>NodeManager</code>，在其上运行Container</li><li>获取资源之后，<code>ApplicationMaster</code>向<code>NodeManager</code>发送指令<code>bin/java YarnCoarseGrainedExecutorBackend</code>，该进程用于与Driver的通信，注册已经启动的Executor进程，然后启动计算对象Executor等待接收任务</li><li>Driver线程继续执行完成作业的调度和任务的执行，包括任务的阶段划分等</li><li>Driver进行任务的分配，并监控任务的运行</li></ol><blockquote><p>注意：这里的<code>SparkSubmit</code>、<code>ApplicationMaster</code>、<code>CoarseGrainedExecutorBackend</code>是独立的进程，Driver是独立的线程；<code>Executor</code>是运行在<code>CoarseGrainedExecutorBackend</code>中的对象。我们平常所说的Executor也可能指的是进程<code>CoarseGrainedExecutorBackend</code></p></blockquote><h3 id="yarn-client模式">Yarn Client模式</h3><img src="/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/YarnClient.png" class="" title="YarnClient"><p>Yarn Client的运行流程与YarnCluster类似，只是Driver线程在本地启动，向<code>ResourceManager</code>申请运行<code>ExecutorLauncher</code>。当然<code>ExecutorLauncher</code>实际上还是调用了<code>ApplicationMaster</code>的main方法。</p><p>运行流程如下：</p><ol type="1"><li>利用<code>spark-submit</code>脚本进行程序的提交，启动<code>SparkSubmit</code>的JVM进程</li><li><code>SparkSubmit</code>中的main方法调用用户代码的main方法</li><li>创建Driver<strong>线程</strong>，执行用户的作业，并创建<code>YarnClientScheduleBackend</code></li><li><code>YarnClientScheduleBackend</code>创建Yarn客户端用来向连接Yarn，向Yarn发送执行指令<code>bin/java ExecutorLauncher</code></li><li>Yarn框架接收到指令，在对应的<code>NodeManager</code>中启动<code>ExecutorLauncher</code>（实际上还是调用了<code>ApplicationMaster</code>的main方法）</li><li><code>ApplicationMaster</code>向<code>ResourceManager</code>注册，进行资源的申请</li><li>获取资源之后，<code>ApplicationMaster</code>向<code>NodeManager</code>发送指令<code>bin/java YarnCoarseGrainedExecutorBackend</code>，该进程用于与Driver的通信，注册已经启动的Executor进程，然后启动计算对象Executor等待接收任务（此时的Driver是一个在提交处本地的线程）</li><li>Driver线程继续执行完成作业的调度和任务的执行，包括任务的阶段划分等</li><li>Driver进行任务的分配，并监控任务的运行</li></ol><h2 id="standalone部署模式">Standalone部署模式</h2><p>在Standalone部署模式下，集群中有两个重要组成部分，分别是</p><ul><li>Master：类似于Yarn中的ResourceManager，是一个进程，主要负责资源的调度和分配，并进行集群的监控等职责</li><li>Worker：类似于Yarn中的NodeManager，是一个进程，一个Worker运行在集群中的一台服务器上，主要负责两个职责，一个是用自己的内存存储RDD的某些分区，另一个是启动其他进程和Executor线程，对RDD的分区进行并行计算</li></ul><p>Standalone部署模式下同样有Cluster和Client模式，总体也与Yarn部署模式的运行机制比较类似。</p><h3 id="standalone-cluster模式">Standalone Cluster模式</h3><img src="/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/StandaloneCluster.png" class="" title="StandaloneCluster"><p>流程如下：</p><ol type="1"><li>任务提交，Master找到一个Worker来启动Driver（Driver由集群中的Worker运行）</li><li>Dirver启动后向Master注册，并申请启动Executor</li><li>Master寻找可用资源，启动Worker，并在这些Worker上分配Executor</li><li>Executor启动后向Driver反向注册</li><li>Driver执行到行动算子后，开始划分阶段Stage，每个Stage生成对应的TaskSet，将Task分发到各个Executor上执行</li></ol><h3 id="standalone-client模式">Standalone Client模式</h3><img src="/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/StandaloneClient.png" class="" title="StandaloneClient"><p>Client与Cluster的主要区别在于Driver的启动位置，在Client模式中，Driver在任务提交的本地机器上运行</p><p>流程如下：</p><ol type="1"><li>任务提交，启动Driver（在提交任务的本地机器上）</li><li>Driver启动后向Master注册，申请启动Executor</li><li>Master寻找可用资源，启动Worker，并在这些Worker上分配Executor</li><li>Executor启动后向Driver反向注册</li><li>Driver执行到行动算子后，开始划分阶段Stage，每个Stage生成对应的TaskSet，将Task分发到各个Executor上执行</li></ol><h1 id="spark应用执行">Spark应用执行</h1><h2 id="概述">概述</h2><p>我们首先需要明确几个概念，一个Spark应用程序包括Job、Stage以及Task三个概念：</p><ol type="1"><li>Job以行动算子为界，每遇到一个行动算子，则会触发一个Job</li><li>Stage是Job的划分，以RDD宽依赖为界，每遇到一个Shuffle就进行一次划分</li><li>Task是Stage的划分，以分区数来衡量。Stage中最后一个RDD的分区数即为Task的数量</li></ol><p>Spark应用执行的过程主要是Driver的工作流程。</p><p>Driver线程首先进行SparkContext对象的初始化，准备运行所需的上下文，然后一方面保持与ApplicationMaster的RPC连接，通过ApplicationMaster来申请资源；另一方面，根据用户代码逻辑进行任务的调度，将任务下发到空闲的Executor。这个过程会涉及到阶段Stage的划分、任务Task的切分等。</p><p>当ResourceManager向ApplicationMaster返回Container资源时，ApplicationMaster就尝试在对应的Container上启动Executor进程，启动完成之后反向注册，注册成功之后保持与Driver的心跳，同时等待Driver分发任务。当分发的任务执行完毕之后，将任务状态上报给Driver。</p><p>一个RDD通过转换算子会生成新的RDD，从而形成了RDD血缘关系图。这是一个有向无环图，即DAG。通过行动算子的调用，触发生成Job并调度执行。在执行过程中，会使用到两个调度器，<code>DAGScheduler</code>和<code>TaskScheduler</code></p><ul><li>DAGScheduler：负责Stage级别的调度，主要是将Job切分成若干个Stage，并将每个Stage打包成TaskSet交给TaskScheduler进行调度</li><li>TaskScheduler：负责Task级别的调度，将DAGScheduler得到的TaskSet按照指定的调度策略分发到Executor上执行。调度过程中，ShcedulerBackend负责提供可用资源，其中的SchedulerBackend有多种实现，可以对接不同的资源管理系统</li></ul><p>Driver初始化SparkContext过程中，会分别初始化DAGScheduler，TaskScheduler、SchedulerBackend以及HeartbeatReceiver，并启动SchedulerBackend和HeartbeatReceiver。</p><p>SchedulerBackend通过ApplicationMaster申请资源，并不断从TaskScheduler中拿到合适的Task分发到Executor上执行。</p><p>HeartbeatReceiver负责接收Executor的心跳信息，监控Executor的存活状况，并通知到TaskScheduler</p><h2 id="stage调度">Stage调度</h2><p>DAGScheduler负责Stage级别的调度，主要是将Job切分成若干个Stage，并将每个Stage打包成TaskSet交给TaskScheduler进行调度</p><p>程序运行到行动算子，则会触发一个Job。Job交给DAGScheduler提交，它会根据RDD的血缘关系构成的DAG进行切分，将一个Job划分成若干个Stages。划分策略如下，基本上是一个深度优先搜索算法：</p><ol type="1"><li>首先划分一个最终的Stage，称为ResultStage。它是由行动算子决定的。</li><li>由最终的RDD不断向前回溯，判断父依赖是否是宽依赖，即Shuffle依赖。如果是则继续划分一个Stage，称为ShuffleMapStage。它是由对应的Shuffle转换算子决定的</li></ol><p>最终得到的阶段数目应该等于流程中Shuffle依赖的个数+1（一个ResultStage）。</p><p>Stage的运行是有先后顺序的，只有当前面的Stage运行完成之后，才能提交运行下一个Stage。Stage提交的时候会将Task信息序列化并打包成TaskSet交给TaskScheduler，其中的Task数量与当前Stage中最后一个RDD的分区有关，一个分区对应一个Task。</p><p>DAGScheduler会监控Stage的运行状态，如果Executor丢失，或者Task进行Fetch失败，则需要重新提交对应的Stage。其他情况，则会在TaskScheduler的调度过程中进行出错重试。（即前者情况下，Stage信息丢失，需要重新提交）</p><p>相对来说，DAGScheduler做的事情较为简单，包括在Stage层面划分，提交Stage以及监控其相关状态信息</p><h2 id="task调度">Task调度</h2><p>TaskScheduler负责Task级别的调度，将DAGScheduler得到的TaskSet按照指定的调度策略分发到Executor上执行。</p><p>TaskScheduler将TaskSet封装为TaskSetManager加入调度队列中。一个TaskSetManager负责监控和管理同一个Stage中的Task，而TaskScheduler也是以TaskSetManager为单位进行任务的调度。</p><p>前面提到在TaskScheduler初始化后会启动SchedulerBackend，它负责接收Executor的注册信息，并维护Executor的状态。SchedulerBackend会定时询问TaskScheduler是否需要执行任务。在接收到询问后，TaskScheduler按照指定的调度策略选择出TaskSetManager去执行。之后，TaskScheduler调用SchedulerBackend的方法，经过对应一系列处理之后得到可用资源，TaskSchduler基于这些资源来进行Task的运行。</p><p>TaskScheduler默认支持两种调度策略，FIFO以及FAIR策略。默认为FIFO策略。</p><p>在从调度队列中拿到TaskSetManager后，就需要按照一定的规则取出Task交给TaskScheduler，再由TaskScheduler交给SchedulerBackend，发到对应的Executor上执行。</p><p>在任务调度的过程中，还会涉及到一个<strong>本地化调度</strong>的概念，即确定每个分区应该在哪个Executor上运行。本地化调度指的是Spark倾向于以最好的本地化级别来调度Task，但是可能不是每个Task都能做到最好的本地化级别。假如当前Task无法以最好的本地化级别运行，这可能是因为对应的Executor繁忙，Spark会先等待一段时间，如果还不行就降低本地化级别，重复操作。具体的本地化原则调度原理如下，可以通过调整<code>spark.locality</code>相关参数来调整：</p><ol type="1"><li>默认等待时间为3秒</li><li>若超时，则下降到下一个本地化级别重新分配</li><li>数据发生传输的时候，Task首先从被本地的BlockManager获取数据，若本地没有数据，则调用getRemote方法从数据所在节点的BlockManager获取数据，返回至该节点</li></ol><p>本地化级别由高到低有下面的设置：</p><table><thead><tr class="header"><th>级别</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>PROCESS_LOCAL</td><td>进程本地化，Task和数据在同一个Executor中。性能最好</td></tr><tr class="even"><td>NODE_LOCAL</td><td>节点本地化，Task和数据在同一个节点中，但是Task和数据不在同一Executor中，数据需要在进程间进行传输</td></tr><tr class="odd"><td>RACK_LOACL</td><td>机架本地化，Task和数据在同一个机架的两个节点上，数据需要通过网络在节点之间传输</td></tr><tr class="even"><td>NO_PREF</td><td>对于Task来说，从哪里获取数据性能都相同，无偏好</td></tr><tr class="odd"><td>ANY</td><td>数据在任意地方，性能最差</td></tr></tbody></table><p>TaskScheduler还有失败重试和黑名单机制。简单来说，TaskScheduler会监控Task的执行状态，对于失败的Task，会记录它失败的次数，如果失败次数没有超过最大重试次数，就将其放回调度队列中，否则整个Application时报。在记录失败Task的时候，会记录它上次失败所在的Executor以及节点位置，下次再进行调度的时候，会使用黑名单机制，避免它被调度到上次失败的节点上，起到一定的容错作用。</p><h1 id="spark-shuffle">Spark Shuffle</h1><h2 id="概述-1">概述</h2><p>SparkShuffle发生在ShuffleMapStage中。该阶段的结束伴随着Shuffle文件的写磁盘。宽依赖上游RDD一个分区数据会进入下游RDD的多个分区，数据发生移动，称之为Shuffle。Shuffle一般分为两个阶段，一个是产生Shuffle数据的阶段，即上游RDD写数据到磁盘上；第二个是使用Shuffle数据的阶段，即后续的RDD不同分区获取对应的数据。Map阶段和Reduce阶段通过生产与消费Shuffle中间文件的方式，来完成集群范围内的数据交换。</p><p><strong>Shuffle Write</strong>： Shuffle写入临时文件的过程叫做ShuffleWrite，Spark目前支持三种Writer，分别为<code>SortShuffleWriter</code>、<code>BypassMergeSortShuffleWriter</code>和<code>UnsafeShuffleWriter</code></p><p><strong>Shuffle Read</strong>： Shuffle拉取数据的过程叫做ShuffleRead。对于Map Task生成的中间文件，ReduceTask需要通过网络从不同节点拉取属于自己的数据内容。ShuffleReader的实现被封装在<code>BlockStoreShuffleReader</code>中</p><h2 id="shuffle演变">Shuffle演变</h2><p>Spark中的Shuffle是一个不断演变的过程。在Spark初始版本中，引入HashBased Shuffle，之后基于Hash Shuffle引入文件合并机制，对Hash BasedShuffle进行改进。之后在Spark 1.1版本中引入Sort BasedShuffle，1.4引入Tungsten-Sort Based Shuffle。在Spark2.0版本之后，仅支持Sort和Tungsten-Sort两种Shuffle方式，不再支持基于Hash的Shuffle方式</p><h3 id="hash-based-shuffle">Hash Based Shuffle</h3><img src="/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/HashBasedShuffle.png" class="" title="HashBasedShuffle"><p>在Hash BasedShuffle中，每个分区上，MapTask会根据Reducer的数量创建出对应数量的文件假定为<code>x</code>，假如一共有<code>y</code>个MapTask，则会创建出<spanclass="math inline">\(x \timesy\)</span>个中间文件。可以看出，在这种方式下，生成的小文件太多，对文件系统的压力很大，并且也不利于IO吞吐，会严重影响性能。</p><p>针对小文件的问题，Spark基于Hash Shuffle引入了文件合并FileConsolidation机制，得到优化后的Hash Shuffle。优化的Hash BasedShuffle主要思想就是通过共同输出文件以降低文件数，将在同一个CPU核心上运行的多个MapTask的输出合并到统一文件，这样一个Core输出的文件个数就是<code>x</code>个。在同一个Core上先后运行的两个MapTask的输出对应到同一个文件不同的segment，称为一个FileSegment。</p><img src="/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/%E6%94%B9%E8%BF%9B%E7%9A%84HashShuffle.png" class="" title="改进的HashShuffle"><h3 id="sort-based-shuffle">Sort Based Shuffle</h3><p>虽然HashShuffle引入了文件合并机制，但是还是无法从根本上解决文件数过多的问题，于是引入SortBased Shuffle。SortShuffle有三种运行机制，普通运行机制、bypass机制以及Tungsten运行机制，分别对应三种不同的Shuffle。</p><p>普通模式的工作原理类似于MapReduce中的Shuffle过程。在普通模式下，每个MapTask会先将数据写入内存结构中，当达到某个临界阈值之后，就会将内存中的数据溢写到磁盘上。在溢写之前会对数据进行排序，分批写入磁盘文件。在一个Task将数据写入内存的过程中，会出现多次的磁盘溢写操作，也就会产生多个临时文件，最终会将所有临时文件进行合并，得到一个最终的磁盘文件。最终得到的文件，按照parittionId从小到大排序。</p><p>由于一个Task对应一个磁盘文件，为下游Stage不同Task（下游RDD不同分区）准备的数据都在这一个文件中，所以还会单独写一份索引文件，用来标识下游各个Task的数据在文件中的位置（startoffset和end offset）</p><img src="/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/SortBasedShuffle.png" class="" title="SortBasedShuffle"><h3 id="bypass-sort-based-shuffle">bypass Sort Based Shuffle</h3><p>在Reducer端任务数比较少的情况下，Hash Based Shuffle的效率明显高于SortBased Shuffle，因此基于SortShuffle，Spark还提供了一个回退方案，就是bypass运行机制。它的思想与HashBasedShuffle类似，每个MapTask会为下游的每个ReduceTask生成一个对应的临时磁盘文件，唯一的区别是在最后会将这些文件进行合并，同时生成索引文件，标识对应的位置。</p><p>相比于Hash Based Shuffle，bypass机制提供了更少的最终磁盘文件，Shuffleread的性能更好。</p><p>相比于普通的Sort BasedShuffle，bypass机制为每个ReduceTask生成一个临时文件，只在最后进行一次合并，中间没有排序的操作，也就节省了这部分的性能开销。但是由于会为每个ReduceTask（分区）分配一个临时文件，如果ReduceTask过多的话，会对文件系统造成很大压力，因此bypass机制的触发条件如下：</p><ol type="1"><li>shuffle reducetask的数量小于等于<code>spark.shuffle.sort.bypassMergeThreshold</code>参数的值，默认为200</li><li>不能有map端的聚合（例如reduceByKey，因为它对于临时文件来说）</li></ol><img src="/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/bypassSortShuffle.png" class="" title="bypassSortShuffle"><h3 id="tungsten-sort-based-shuffle">Tungsten-Sort Based Shuffle</h3><p>从Spark1.5开始，Spark启动钨丝计划，目的是优化内存和CPU的使用，从而进一步提高Spark的性能。由于需要基于JDKUnsafe API来使用堆外内存，因此Tungsten-Sort Based Shuffle又称为UnsafeShuffle。</p><p>该Shuffle的做法类似于Sort BasedShuffle，但是将数据记录使用二进制的方式进行存储，直接在序列化的二进制数据上Sort，而不是在Java对象上。这样一方面能够减少内存的使用和GC的开销；另一方面也可以避免Shuffle过程中频繁的序列化和反序列化。</p><p>不过使用Tungsten-Sort Based Shuffle有几个限制条件：</p><ol type="1"><li>Shuffle map阶段不能有聚合操作</li><li>分区数不能超过一定大小（<spanclass="math inline">\(2^{24}-1\)</span>，这是24bit的partitionID的最大表示范围）</li></ol><p>而从Spark 1.6开始，把Sort Shuffle和Tungsten-Sort BasedShuffle全部统一到了Sort Shuffle中，如果检测到满足Tungsten-Sort BasedShuffle条件，会自动采用Tungsten-Sort Based Shuffle，否则采用SortShuffle。</p><blockquote><p>Sort Based Shuffle的优缺点：</p><p>优点：</p><ul><li>小文件的数量大量减少，在Mapper端的内存占用变少</li><li>使得Spark不仅可以处理小规模的数据，对于大规模的数据也不会很容易达到性能瓶颈</li></ul><p>缺点：</p><ul><li>强制在Mapper端进行排序，即使数据本身可能并不需要排序，导致性能损耗</li></ul></blockquote><h1 id="spark-内存管理">Spark 内存管理</h1><h2 id="概述-2">概述</h2><p>作为一个JVM进程，Executor的内存管理建立在JVM的内存管理之上。Spark对堆内（On-Heap）空间进行更加详细的分配，同时，Spark引入了堆外（Off-Heap）内存，使Spark可以直接在系统内存中开辟空间，进一步优化了内存的使用。堆内内存受到JVM的统一管理，我们能够控制的程度有限；堆外内存直接向操作系统进行内存的申请和释放，我们能够控制的程度较高</p><p>堆内内存大小的配置可以通过启动时配置<code>-executor-memory</code>，也可以在配置参数<code>spark.executor.memory</code>中指定。Executor中运行的Task共享堆内内存，其中又被划分成几个部分：</p><ul><li>存储内存：Task缓存RDD数据以及广播数据的时候占用的内存</li><li>执行内存：任务在执行Shuffle的时候占用的内存</li><li>其他内存：对象实例占用的空间等</li></ul><p>堆内内存的管理主要还是通过JVM来完成的，我们无法精确控制堆内内存的申请和释放，但是Spark通过对存储内存和执行内存各自独立的规划管理，决定是否要在存储内存中缓存新的RDD，以及是否为新的任务分配执行内存，一定程度上提高了内存的利用率。</p><p>而为了进一步优化内存的使用，提高Shuffle时的效率，Spark引入了堆外内存，使得Spark可以直接在工作节点的系统内存中开辟空间，存储经过序列化的二进制数据。堆外内存直接受到操作系统管理，减少了不必要的内存开销以及频繁的GC扫描与回收，提升了性能。堆外内存可以被精确的申请和释放。（利用JDKUnsafe API）</p><p>在默认情况下，堆外内存并不启用，可以通过配置<code>spark.memory.offHeap.enabled</code>参数启用，并由参数<code>spark.memory.offHeap.size</code>设定堆外空间的大小。</p><h2 id="内存空间分配">内存空间分配</h2><h3 id="静态内存管理">静态内存管理</h3><p>Spark最初采用静态内存管理机制，存储内存、执行内存和其他内存的大小在应用程序运行期间保持固定，用户在程序启动之前可以进行配置。</p><p>堆内内存划分如下：</p><img src="/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/%E5%A0%86%E5%86%85%E5%86%85%E5%AD%98.png" class="" title="堆内内存"><p>堆内内存主要分为三部分，存储内存、执行内存以及其他内存。</p><ul><li>存储内存：默认占系统内存的60%，该数值对应<code>spark.storage.memoryFraction</code>。存储内存中实际使用的部分并不是全部，预留部分空间防止OOM。实际可以使用的部分所占的比例默认为0.9，该数值对应<code>spark.storage.safetyFraction</code></li><li>执行内存：默认占系统内存的20%，该数值对应<code>spark.shuffle.memoryFraction</code>。同存储内存一样，执行内存也预留了一部分空间，实际使用的空间所占比例默认为0.8，该数值对应<code>spark.shuffle.safetyFraction</code></li><li>其他内存：剩余部分即为其他内存</li></ul><blockquote><p>存储内存和执行内存预留空间的目的是防止OOM，因为Spark堆内内存的大小记录是不准确的，需要留出保险空间。</p><p>对于存储内存和执行内存的预留部分，是一种逻辑上的规划，在具体使用的时候，Spark并没有区别对待，而是和其他内存一样，交给JVM进行管理</p></blockquote><p>堆外内存的分配则较为简单，只划分为存储内存和执行内存。默认存储内存占用50%，该数值对应<code>spark.memory.storageFraction</code>，剩余空间则为执行内存。由于堆外内存占用的空间可以被精确计算，所以不需要再预留空间保险。</p><p>静态内存管理机制实现较为简单，但是如果用户不熟悉Spark的存储机制，没有根据具体的数据规模和计算任务做相应的配置，很容易影响性能。Spark后续引入了新的内存管理机制，而处于兼容的目的，仍然保留的静态内存管理机制</p><h3 id="统一内存管理">统一内存管理</h3><p>Spark1.6之后引入统一内存管理机制，与静态内存管理的区别在于存储内存和执行内存共享同一块空间，可以动态占用对方的空闲空间。堆内存划分如下：</p><img src="/2022/07/21/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-4-Spark%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/%E7%BB%9F%E4%B8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png" class="" title="统一内存管理"><p>主要内存划分如下：</p><ul><li>可用内存（Usable Memory）：等于系统内存减去预留内存<ul><li>统一内存：默认占可用内存的60%，其中包括了存储内存和执行内存<ul><li>存储内存：默认占统一内存的0.5，数值对应<code>spark.stroage.storageFraction</code></li><li>执行内存：默认占统一内存的0.5</li></ul></li><li>其他内存：默认占可用内存的40%</li></ul></li><li>预留内存（Reserved Memory）：默认为300M</li></ul><p>该机制中最重要的优化在于动态占用机制：</p><ol type="1"><li>设置了基本的存储内存和执行内存区域，由<code>spark.storage.storageFraction</code>参数确定</li><li>双方的空间都不足时，则存储到磁盘；若己方空间不足而对方空间剩余时，则可以借用对方的空间</li><li>执行内存的空间被占用后，可以要求对方归还借用的空间</li><li>存储内存的空间被占用后，无法让对方归还借用的空间（主要是考虑到Shuffle过程中的较多因素，实现起来比较复杂）</li></ol><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://www.cnblogs.com/importbigdata/articles/15635281.html">【Spark重点难点】你以为的Shuffle和真正的Shuffle- 王知无 - 博客园 (cnblogs.com)</a></li><li><ahref="https://blog.csdn.net/wendelee/article/details/109818711">彻底搞懂spark的shuffle过程（shufflewrite）_大跃ET的博客-CSDN博客</a></li><li><ahref="https://www.zhihu.com/question/532455741/answer/2516828969">Spark的shuffle过程为什么要排序？- 知乎 (zhihu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux环境变量文件</title>
    <link href="/2022/07/20/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6/"/>
    <url>/2022/07/20/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>在Linux中有多个文件涉及到环境变量，不同文件之间的生效范围不同。可以配置环境变量的文件有<code>/etc/profile</code>，<code>/etc/bashrc</code>，<code>/etc/profile.d/*.sh</code>，<code>~/.bashrc</code>，<code>~/.bash_profile</code>等。它们的读入顺序也有所不同</p><h1 id="etcprofile">/etc/profile</h1><p>该文件为系统级别的环境变量，为每个用户设置环境变量。<strong>当用户第一次登录的时候</strong>，该文件被执行。在执行的时候会读取<code>/etc/profile.d</code>目录下的脚本文件并进行执行，因此我们可以在该目录下新建<code>.sh</code>文件配置我们自己的环境变量，方便管理。</p><h1 id="etcbashrc">/etc/bashrc</h1><p>在执行完<code>/etc/prifile</code>中的内容之后，如果用户运行的是bash，那么接着会执行这个文件。也是系统级别的环境变量。文件中也会读取<code>/etc/profile.d</code>目录下的脚本文件并进行执行。<strong>每当一个新的bashshell被打开时</strong>，会执行此文件。一般来说，如果想要每个使用bash的用户新开一个bash或者每次登录都执行某些操作，可以在这个文件中设置。</p><h1 id="bash_profile">~/.bash_profile</h1><p>该文件属于用户级别的环境变量。当用户登录的时候，该文件仅仅执行一次。默认情况下，它会执行用户的<code>.bashrc</code>文件。该文件的主要特点就是在登录的时候仅执行一次。</p><h1 id="bashrc">~/.bashrc</h1><p>该文件属于用户级别的环境变量，在登录的时候，或者每次打开一个新的shell的时候，会执行该文件。默认情况下，该文件会执行<code>/etc/bashrc</code>文件。</p><h1 id="login-shell与非login-shell">login shell与非login shell</h1><p>这里还有一个login shell和non-loginshell的区别。简单来说，我们通过终端输入用户名密码登录系统之后，得到的就是一个loginshell，而当我们执行<code>ssh xxx command</code>，即只是通过ssh到某个机器执行某条命令，则属于non-loginshell。</p><p>这两种shell的主要区别在于启动的时候会加载不同的配置文件。</p><p>login shell会加载上面所说的所有文件，而non-loginshell只会加载<code>~/.bashrc</code>文件，当然由于文件中的设置关系，也会依次执行到<code>/etc/bashrc</code>，以及<code>/etc/profile.d</code>目录下的脚本文件。</p><p>因此无论哪种shell，在启动的时候都会加载<code>/etc/profile.d/*.sh</code>中设置的环境变量。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pinia状态管理</title>
    <link href="/2022/07/20/Pinia%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <url>/2022/07/20/Pinia%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="pinia状态管理">Pinia状态管理</h1><h2 id="pinia的简介"><strong>1.Pinia的简介</strong></h2><p>Pinia是Vue生态中Vuex的代替者，是一个全新的Vue状态管理库。对比Vuex来说，Pinia有五大优势：</p><ol type="1"><li>对Vue2、Vue3都支持</li><li>抛弃了Mutations操作，只有state、getters和actions，极大简化了状态管理库的使用，让代码编写更加容易直观</li><li>不需要嵌套模块，符合Vue3的Composition API</li><li>完整的TypeScript支持</li><li>代码更加简洁</li></ol><h2 id="pinia的基本使用"><strong>2.Pinia的基本使用</strong></h2><p>首先需要安装pinia，只需要简单执行下面命令即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install pinia<br></code></pre></td></tr></table></figure><p>之后我们需要在<code>main.ts</code>中进行引入，并进行挂载，下面是<code>main.ts</code>的全部内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createApp&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123;createPinia&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./assets/main.css&#x27;</span><br><br><span class="hljs-comment">// 创建pinia实例</span><br><span class="hljs-keyword">const</span> pinia = <span class="hljs-title function_">createPinia</span>()<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br><span class="hljs-comment">// 进行挂载</span><br>app.<span class="hljs-title function_">use</span>(pinia)<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><h2id="store状态管理库的创建"><strong>3.store状态管理库的创建</strong></h2><p>在<code>/src</code>目录下新建<code>store</code>文件夹，再创建一个<code>index.ts</code>文件，在这个文件中，主要完成状态容器的定义，修改容器中的state和仓库中action的使用。该文件的内容基本固定，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mainStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;main&#x27;</span>, &#123;<br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">info</span>: <span class="hljs-string">&#x27;I am Info&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">getters</span>: &#123;&#125;,<br>    <span class="hljs-attr">actions</span>: &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>state：用来存储全局的状态，其中状态的创建与组件中的data类似，</li><li>getters：在获取状态的时候进行某种处理</li><li>actions：用来修改state全局状态数据</li></ul><h2 id="store数据的读取"><strong>4.store数据的读取</strong></h2><p>定义了store状态之后，我们就可以在组件中读取对应的数据。先引入mainStore，然后在setup阶段通过mainStore得到store实例，之后就可以在组件里调用store里state定义的状态数据了，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    I am Test<br>    &lt;h2&gt;&#123;&#123; store.info &#125;&#125;&lt;/h2&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;mainStore&#125; from &quot;@/store&quot;<br><br>export default &#123;<br>  name: &quot;Test&quot;,<br>  setup() &#123;<br>    const store = mainStore()<br><br>    return &#123;<br>      // 您可以返回整个 store 实例以在模板中使用它<br>      store,<br>    &#125;<br>  &#125;,<br><br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="改变状态数据"><strong>5.改变状态数据</strong></h2><p>在Pinia中修改状态数据有多种方式。后续的举例代码中，对state进行操作，所以这里先明确目前state中含有的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">info</span>: <span class="hljs-string">&#x27;I am Info&#x27;</span>,<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">count1</span>: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>第一种方式和函数操作类似，直接在函数逻辑中操作即可。下面的操作就是在一个函数中对store中的数据进行操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;mainStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/store&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;MyButton&quot;</span>,<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">mainStore</span>()<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      store,<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-property">count</span>++;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方式是使用Pinia中的<code>$patch</code>方式，同样是写在method中，但是调用<code>$patch</code>方式。Pinia的官方网站，已经明确表示<code>$patch</code>的方式是经过优化的，会加快修改速度，对程序的性能有很大的好处。所以如果是多条数据同时更新状态数据，推荐使用<code>$patch</code>方式更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">add1</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.$patch(&#123;<br>            <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">count1</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-property">count1</span> + <span class="hljs-number">2</span>,<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三种方式也是使用<code>$patch</code>，上面的操作是传入一个对象，第三种方式是传入一个函数。传入函数的方式适合复杂逻辑的修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">add2</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.$patch(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;<br>        state.<span class="hljs-property">count</span>++<br>        <span class="hljs-keyword">if</span> (state.<span class="hljs-property">info</span> === <span class="hljs-string">&quot;I am Info&quot;</span>) &#123;<br>          state.<span class="hljs-property">info</span> = <span class="hljs-string">&quot;I am not Info&quot;</span><br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>第四种方式是在actions中写好修改逻辑，然后再调用actions。如果一个修改的过程非常复杂，可以先定义好<code>actions</code>中的函数，然后在组件里调用函数。如下过程所示。</p><p>首先在<code>/src/store/index.ts</code>中的<code>actions</code>编写一个<code>changeState()</code>方法（方法名任意），用来改变数据状态，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">changeState</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">info</span> = <span class="hljs-string">&#x27;I am really Info&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在相关组件的method中进行调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">add3</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-title function_">changeState</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="pinia中getters的使用"><strong>6.Pinia中getters的使用</strong></h2><p>Pinia中的getters和Vue中的计算属性类似，就是在获取State的值的时候做一些额外的处理。类似下面的代码逻辑。我们首先在<code>getters</code>中定义下面的修改方法，就是在info后面直接加上haha：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-title function_">hahaInfo</span>(<span class="hljs-params">state</span>)&#123;<br>        <span class="hljs-keyword">return</span> state.<span class="hljs-property">info</span> + <span class="hljs-string">&quot;haha&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义之后，可以直接像使用普通属性一样使用，使用插值表达式<code>&#123;&#123;state.hahInfo&#125;&#125;</code>就可以直接显示在页面上。</p><p>getters是具有缓存特性的。我们可以在其中的方法里面增加一个<code>console.log</code>进行输出，多次调用这个值，只会输出一次。</p><p>在上面的使用中我们是传入了一个state，当然也可以使用this。如果使用的是TypeScript，不传state，它无法自动推导出返回类型，这里标明返回类型即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-title function_">hahaInfo</span>(): <span class="hljs-title class_">String</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">info</span> + <span class="hljs-string">&quot;haha&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分文件的状态管理">7.分文件的状态管理</h2><p>在上面的例子中，我们都是使用store目录下的<code>index.ts</code>进行说明的。而实际上我们也可以在store目录下创建更多的ts文件，来分文件进行全局状态管理。这样更有效果。例如我们可以创建<code>store/counter.ts</code>，其中的内容定义与使用大体相同，只是在引用的时候需要如下使用。而只写这个<code>@/store</code>目录的话，则是去访问<code>index.ts</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// store/counter.ts</span><br><span class="hljs-keyword">import</span> &#123; ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> doubleCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    count.<span class="hljs-property">value</span>++<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123; count, doubleCount, increment &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>下面是使用方式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// usage</span><br><span class="hljs-keyword">import</span> &#123; useCounterStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/counter&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">useCounterStore</span>()<br><br>    counter.<span class="hljs-property">count</span>++<br>    <span class="hljs-comment">// 带自动补全 </span><br>    counter.$patch(&#123; <span class="hljs-attr">count</span>: counter.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;)<br>    <span class="hljs-comment">// 或使用 action 代替</span><br>    counter.<span class="hljs-title function_">increment</span>()<br>      <br>    <span class="hljs-keyword">return</span> &#123;<br>        counter<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><ol type="1"><li><a href="https://pinia.web3doc.top/introduction.html">介绍 | Pinia中文文档 (web3doc.top)</a></li><li><a href="https://jspang.com/article/82">技术胖-Pinia入门视频教程全新一代状态管理工具Pinia -Vue3全家桶系列 (jspang.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Pinia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper学习笔记-入门(3)-Paxos和ZAB协议</title>
    <link href="/2022/07/07/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-3-Paxos%E5%92%8CZAB%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/07/07/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-3-Paxos%E5%92%8CZAB%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="paxos协议">Paxos协议</h1><p>Paxos是一种基于消息传递且具有高度容错性的一致性算法，它主要解决的问题是如何快速正确地在一个分布式系统中对某个数据值达成一致，并且保证无论发生任何异常，都不会破坏整个系统的一致性</p><p>在一个Paxos系统中，节点角色有Proposer、Acceptor和Learner。我们可以将一致性问题简化为集群中所有节点对一个值value达成一致。一个完整的Paxos算法流程分为三个阶段，提案生成、提案接受和Learn学习：</p><p>这里首先明确，Acceptor在整个过程中需要完成的工作就是响应请求和接受提案，一个Acceptor需要保存它响应过的最大请求编号<code>ResN</code>以及接受过的最大提案编号<code>AcceptN</code>和对应的提案值<code>AcceptV</code>。</p><ol type="1"><li>提案生成阶段：<ol type="1"><li>Proposer向多个Acceptor发送Propose请求，proposal编号为N</li><li>如果一个Acceptor收到编号为N的proposal，那么它会比较该编号N和自己的<code>ResN</code>的大小，只有当<code>N&gt;ResN</code>的时候，Acceptor才会响应这个请求，并在响应中返回已经接受过的Pok，最大请求编号和对应的值<code>(Pok,AcceptN,AcceptV)</code>，如果该Acceptor没有接受过提案，则返回null。</li></ol></li><li>提案接受阶段：<ol type="1"><li>如果Proposer接受了超过半数的Acceptor的响应，那么就会生成一个提案，编号为N，值为获取到的响应中编号最大的Value。如果都返回null，则Value为Proposer自己生成的值。之后Proposer将提案发生给Acceptor</li><li>如果没有收到超过半数的Acceptor，则重新获取编号，并回到提案生成阶段</li><li>如果Acceptor收到了一个编号为N的提案，也会比较<code>ResN</code>和N的大小，只有<code>N&gt;ResN</code>，才会接受该提案，并返回Aok</li><li>如果Proposer收到超过半数的Aok，则表示提案被接受，形成决议；否则重新发起请求</li></ol></li><li>Learn学习阶段：Proposer将形成的决议发送给所有的Learners</li></ol><img src="/2022/07/07/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-3-Paxos%E5%92%8CZAB%E5%8D%8F%E8%AE%AE/paxos%E5%8D%8F%E8%AE%AE.png" class="" title="paxos协议"><h1 id="zab协议">ZAB协议</h1><p>由于Paxos系统中可以存在多个Proposer，在网络复杂的情况下，可能很久无法收敛，甚至陷入活锁的情况。这是因为可能出现多个Proposer相互争夺Acceptor，造成迟迟无法达成一致。</p><p>ZAB协议，全称为Zookeeper AtomicBroadcast，借鉴了Paxos算法，是特别为Zookeeper设计的支持崩溃恢复的原子广播协议。</p><p>基于该协议，Zookeeper设计为只有一台客户端，即Leader负责处理外部的写事务请求，然后Leader客户端将数据同步到其他的Follower节点。也就是说，Zookeeper中只有一个Leader可以发起提案。</p><p>Zookeeper 客户端会随机的链接到 zookeeper集群中的一个节点，如果是读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向Leader 提交事务，Leader接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交。</p><p>ZAB协议主要包括两种基本的模式：<strong>消息广播</strong>和<strong>崩溃恢复</strong>。</p><p>消息广播是ZAB协议的正常工作模式：</p><img src="/2022/07/07/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-3-Paxos%E5%92%8CZAB%E5%8D%8F%E8%AE%AE/%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD.png" class="" title="消息广播"><ol type="1"><li>客户端发起一个写请求操作</li><li>Leader服务器将客户端的请求转化为事务proposal提案，同时为每个proposal分配一个全局的zxid</li><li>Leader服务器为每个Follower服务器分配一个单独的队列，然后将需要广播的Proposal依次放入队列，并根据FIFO策略进行消息发送</li><li>Follower接收到proposal后，会首先将其以事务日志的方式写入本地磁盘，写入成功之后向Leader反馈一个ack响应</li><li>Leader接收超过半数以上的Follower的ack响应之后，即认为消息发送成功，继续发送commit消息</li><li>Leader向所有Follower广播commit消息，同时自身也会完成事务提交。Follower接收到commit消息之后，会将上一条事务提交</li></ol><p>消息广播的处理类似于一个两阶段提交的机制，但是这里仅要求超过半数的Acceptor返回了ack即可。</p><p>Zookeeper 采用 Zab 协议的核心，就是只要有一台服务器提交了Proposal，就要确保所有的服务器最终都能正确提交 proposal。这也是 CAP/BASE实现最终一致性的一个体现。</p><p>Leader 服务器与每一个 Follower 服务器之间都维护了一个单独的 FIFO消息队列进行收发消息，使用队列消息可以做到异步解耦。 Leader 和 Follower之间只需要往队列中发消息即可。如果使用同步的方式会引起阻塞，性能要下降很多。</p><p>崩溃恢复则是ZAB协议在异常情况下的工作模式。如果Leader服务器崩溃，或者由于网络原因导致Leader服务器失去了与过半Follower的联系，则进入崩溃恢复模式。在异常情况下，proposal的执行情况会受到影响，ZAB协议中遵循以下原则：</p><ol type="1"><li>已经被Leadercommit提交的proposal，必须最终被所有的follower服务器提交</li><li>被Leader提出的但是没有被提交的proposal，则丢弃</li></ol><p>崩溃恢复模式中主要完成的工作是Leader选举以及数据恢复。</p><p>在Leader选举阶段中，ZAB协议需要保证选举出来的Leader满足以下条件：</p><ol type="1"><li>新选举出来的Leader不能包含未提交的proposal。即新Leader必须都是已经提交了proposal的follower的服务器节点</li><li>新选举的Leader节点中含有最大的zxid（事务id）</li></ol><p>在数据同步阶段中，新选举出来的Leader服务器会首先确认事务日志中的所有proposal是否已经被集群中过半的服务器commit。等到Follower将所有尚未同步的事务proposal都从Leader同步过并应用到内存数据之后，Leader才会把该Follower加入到真正可用的Follower列表当中。</p><blockquote><p>ZAB协议中，zxid设计成为一个64位的整型数字。其中低32位可以看成是一个简单的递增计数器，表示事务请求；而高32位则代表了Leader周期的epoch编号。</p><p>当选举产生了一个新Leader之后，会从该服务器上读取出本地事务日志中最大编号proposal的zxid，从中解析出对应的epoch编号之后，对其+1作为目前Leader的epoch，并将低32位数字归零，重新生成zxid</p></blockquote><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://www.jianshu.com/p/2bceacd60b8a">Zookeeper——一致性协议:Zab协议- 简书 (jianshu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>details</tag>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper学习笔记-入门(2)-客户端操作以及应用举例</title>
    <link href="/2022/07/07/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/"/>
    <url>/2022/07/07/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="客户端命令行操作">客户端命令行操作</h1><h2 id="命令列表">命令列表</h2><p>Zookeeper中对数据的操作就是对ZNode的操作，主要包括ZNode的增删改查等操作。并且前面我们也提到，ZNode分为持久节点和非持久节点，并且节点也可以指定序列属性。</p><table><thead><tr class="header"><th>命令</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>help</td><td>显示所有操作命令</td></tr><tr class="even"><td>ls [path]</td><td>使用ls命令来查看当前ZNode的子节点<br />-w：监听子节点变化<br />-s：附加次级信息</td></tr><tr class="odd"><td>create [path] [data]</td><td>创建节点并指定节点数据<br />-s：设置节点序列属性<br />-e：创建临时节点</td></tr><tr class="even"><td>get [path]</td><td>获得节点的值<br />-w：监听节点内容变化<br />-s：附加次级信息</td></tr><tr class="odd"><td>set [path] [data]</td><td>设置节点的具体值</td></tr><tr class="even"><td>stat [path]</td><td>查看节点状态</td></tr><tr class="odd"><td>delete [path]</td><td>删除节点</td></tr><tr class="even"><td>deleteall [path]</td><td>递归删除节点</td></tr></tbody></table><p>首先我们启动客户端的时候可以指定连接对应的server，之后就可以进行相应的操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">bin/zkCli.sh -server hadoop102:2181<br></code></pre></td></tr></table></figure><p>查看Znode中包含的信息，如果设置了<code>-s</code>属性，会输出当前节点的详细数据，包括如下的信息：</p><ul><li>czxid：创建节点的事务zxid</li><li>ctime：ZNode被创建时的时间戳（从1970年开始）</li><li>mzxid：ZNode最后更新时的事务zxid</li><li>mtime：ZNode最后修改的时间戳</li><li>pZxid：ZNode最后更新的子节点zxid</li><li>cversion：ZNode子节点变化号，ZNode子节点修改次数</li><li>dataversion：ZNode数据变化号</li><li>aclVersion：ZNode访问控制列表的变化号</li><li>ephemeralOwner：如果是临时节点，则为ZNode拥有者的SessionID，否则为0</li><li>dataLength：ZNode的数据长度</li><li>numChildren：ZNode子节点数量</li></ul><h2 id="监听器">监听器</h2><p>客户端连接到Zookeeper之后，可以在客户端上注册监听它关心的目录节点，当目录节点发生变化（数据改变、节点删除、子目录节点增减）时，Zookeeper就会通知客户端。监听机制保证了Zookeeper上保存的任何数据的任何改变都能快速地响应，提示监听了该节点的应用程序，常见的监听包括监听节点数据的变化和监听子节点的增减：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 监听节点数据的变化</span><br>get -w [path]<br><br><span class="hljs-comment"># 监听子节点增减的变化</span><br><span class="hljs-built_in">ls</span> -w [path]<br></code></pre></td></tr></table></figure><p>监听器实现原理如下：</p><ol type="1"><li>首先在客户端上有一个main线程</li><li>在main线程中创建Zookeeper客户端，这时候就会创建两个线程，一个负责网络连接通信（connect），另一个负责监听（listener）</li><li>通过connect线程将注册的监听事件发送给Zookeeper</li><li>在Zookeeper的注册监听器列表中添加对应的监听事件</li><li>Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程</li><li>之后listener线程内部调用process方法</li></ol><p>但是特别需要注意的是，<strong>Zookeeper中监听器注册一次只能监听一次变化，想要再次监听，则需要再次注册</strong>。</p><img src="/2022/07/07/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/%E7%9B%91%E5%90%AC%E5%99%A8%E5%8E%9F%E7%90%86.png" class="" title="监听器原理"><h1 id="java-api操作">Java API操作</h1><h2 id="api举例">API举例</h2><h2 id="数据写入流程">数据写入流程</h2><h1 id="应用案例">应用案例</h1><h2 id="服务器动态上下线">服务器动态上下线</h2><h2 id="分布式锁">分布式锁</h2>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>未完待续</tag>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper学习笔记-入门(1)-概述以及集群搭建</title>
    <link href="/2022/07/07/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/07/07/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache项目。它的设计目标是将复杂且容易出错的分布式一致性服务封装起来，提供一系列简单易用的接口提供给用户使用。</p><p>在设计方面，Zookeeper上存储和管理了数据，观察者可以监听上面的某些数据。一旦这些数据的状态发生变化，Zookeeper就负责通知对应的观察者，触发对应的行为。可以理解为<strong>Zookeeper=文件系统+通知机制</strong></p><p>Zookeeper的特点如下：</p><ol type="1"><li>在集群构成方面，集群中存在一个Leader和多个Follower</li><li>只要集群中有半数以上的节点存活，Zookeeper就能够正常提供服务</li><li>Zookeeper集群中数据保持全局的一致性，集群中每个服务器都保存了相同的数据副本。客户端无论连接到哪个服务器上，数据都是一致的</li><li>客户端也可以对Zookeeper中的数据进行写操作，并且更新请求会保持顺序执行，来自同一个Client的更新请求会按照发送顺序依次执行</li><li>数据更新保证原子性，一次数据更新要么成功要么失败</li><li>在一定时间范围内，Client能够读取到最新的数据</li></ol><p>Zookeeper是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于Zookeeper实现诸如数据发布/订阅、负载均衡、统一命名服务、统一配置管理、分布式协调/通知、统一集群管理、Master选举、分布式锁和分布式队列等功能。</p><blockquote><ul><li>统一配置管理：集群中一般要求所有节点的配置信息是一致的，配置管理可以交由Zookeeper来管理<ul><li>将配置信息写入Zookeeper上的一个Node</li><li>各个客户端服务器监听这个ZNode</li><li>一旦ZNode中的数据被修改，Zookeeper将通知各个客户端服务器</li></ul></li><li>统一集群管理：在分布式环境下，实时掌握每个节点的状态是必要的，而Zookeeper可以实现实时监控节点状态变化<ul><li>节点将自己的信息写入Zookeeper上的一个ZNode</li><li>监听这个ZNode可以获取集群的实时状态</li></ul></li><li>服务器动态上下线：客户端和服务器连接的情形中，客户端希望知道当前服务器的状态<ul><li>服务器向Zookeeper上注册，维护ZNode信息</li><li>客户端监听对应的ZNode</li><li>当服务器动态上下线，ZNode信息发生变化，Zookeeper也会通知对应的客户端</li></ul></li><li>负载均衡：在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求</li></ul></blockquote><h1 id="重要概念">重要概念</h1><h2 id="会话">会话</h2><p>会话Session，指的是客户端与Zookeeper服务器之间的连接。这里的客户端可以是Zookeeper提供的命令行工具，也可以是Java中的API等。</p><p>客户端启动的时候，首先会与服务器建立一个TCP连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向ZooKeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。而我们也可以设置客户端会话的超时时间等。</p><p>在为客户端创建会话之前，服务端首先会为每个客户端分配一个sessionID。由于sessionID是ZooKeeper会话的一个重要标识，许多与会话相关的而运行机制都是基于这个sessionID的，因此，无论是哪台服务器为客户端分配的sessionID,都务必保证全局唯一。</p><h2 id="znode">ZNode</h2><p>Zookeeper中组织数据的模式类似于Unix文件系统，整体上可以看作是一棵树，每个节点称为一个ZNode。（注意这里的节点指的是Zookeeper中的数据存储节点，而不是集群中的服务器节点）<strong>每个ZNode默认存储1MB的数据</strong>，其中会维护一些属性，Zookeeper就根据这些数据来实现特定的功能。这种树形的结构使得每个ZNode都可以通过路径来唯一进行标识。Zookeeper的数据保存在内存中，这意味着Zookeeper可以实现高吞吐量和低延迟。</p><p>在Zookeeper中，ZNode主要可以分为持久节点和临时节点两类。持久节点指的是一旦这个ZNode被创建，除非主动进行ZNode的移除，否则它将会一直保存在Zookeeper上；而临时节点的生命周期与客户端会话绑定，当会话失效后，这个客户端创建的所有临时节点也都会被移除。</p><p>另外，Zookeeper还允许用户为每个节点添加一个特殊的属性<code>SEQUENTIAL</code>，一旦节点被标记上这个属性，那么再被创建的时候，Zookeeper会自动在其节点名称后面追加上一个整型数字，这个整型数字是由父节点维护的一个自增数字。</p><p>Zookeeper向我们提供对数据操作的API，操作的就是ZNode。包括ZNode的创建，数据修改，删除和监听等。</p><h2 id="版本">版本</h2><p>ZooKeeper的每个Znode上都会都会存储数据，对应于每个Znode,ZooKeeper都会为其维护一个叫做Stat的数据结构，Stat中记录了这个Znode的三个数据版本，分别是version(当前Znode的版本)、cversion(当前Znode子节点的版本)和cversion(当前Znode的ACL版本)。</p><h2 id="watcher">Watcher</h2><p>Watcher，事件监听器，是Zookeeper中一个很重要的特性。Zookeeper允许用户在指定节点上注册一些Watcher。在一些特定事件触发的时候，例如ZNode状态改变的时候，Zookeeper服务端会将事件通知到对应的客户端上。这个机制也是Zookeeper实现分布式协调服务的重要特性。</p><h2 id="acl">ACL</h2><p>ACL，AccessControlLists，是Zookeeper用来进行权限控制的策略，类似于UNIX文件系统的权限控制。Zookeeper中定义了如下5种权限：</p><ul><li>create：创建子节点的权限</li><li>read：获取节点数据和子节点列表的权限</li><li>write：更新节点数据的权限</li><li>delete：删除子节点的权限</li><li>admin：设置节点ACL的权限</li></ul><h1 id="集群搭建">集群搭建</h1><p>首先将压缩包解压到对应的目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz -C /opt/module/<br></code></pre></td></tr></table></figure><p>之后在对应目录下创建zkData目录，然后在zkData目录下创建一个名称为myid的文件，在myid文件种添加server对应的编号。例如这里hadoop102，我们给它编号为2。后续这个zkData目录会被配置为Zookeeper数据存储的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir zkData<br><br>cd zkData<br>vim myid<br><br>2<br></code></pre></td></tr></table></figure><p>之后，将Zookeeper安装目录同步到其他集群中，并修改对应myid中的文件内容为3和4。</p><p>下一步需要进行配置文件的配置，将<code>conf</code>目录下的<code>zoo_sample.cfg</code>修改为<code>zoo.cfg</code>，然后修改其中的配置如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改数据存储路径配置</span><br>dataDir=/opt/module/zookeeper-3.5.7/zkData<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">增加集群配置</span><br>server.2=hadoop102:2888:3888<br>server.3=hadoop103:2888:3888<br>server.4=hadoop104:2888:3888<br></code></pre></td></tr></table></figure><p>配置参数格式如<code>server.A=B:C:D</code></p><ul><li>A是一个数字，表示这个是第几号服务器，其中的内容对应myid文件中的内容。Zookeeper在启动的时候会读取配置的<code>dataDir</code>目录下的myid文件，拿到里面的数据与zoo.cfg中的配置信息进行对比，从而判断到底是哪个Server</li><li>B为服务器的地址</li><li>C为服务器Follower与集群中Leader服务器交换信息的端口</li><li>D是在Leader选举时服务器相互通信的端口</li></ul><p>之后将配置文件进行同步即可。</p><p>之后，就可以启动集群了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动集群(在三台机器上分别启动)</span><br>bin/zkServer.sh start<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看集群状态</span><br>bin/zkServer.sh status<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭集群</span><br>bin/zkServer.sh stop<br></code></pre></td></tr></table></figure><p>类似地，我们也可以编写Zookeeper集群的启动停止脚本<code>zk.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br><span class="hljs-string">&quot;start&quot;</span>)&#123;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> hadoop102 hadoop103 hadoop104<br><span class="hljs-keyword">do</span><br> <span class="hljs-built_in">echo</span> ---------- zookeeper <span class="hljs-variable">$i</span> 启动 ------------<br> ssh <span class="hljs-variable">$i</span> <span class="hljs-string">&quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh start&quot;</span><br><span class="hljs-keyword">done</span><br>&#125;;;<br><span class="hljs-string">&quot;stop&quot;</span>)&#123;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> hadoop102 hadoop103 hadoop104<br><span class="hljs-keyword">do</span><br> <span class="hljs-built_in">echo</span> ---------- zookeeper <span class="hljs-variable">$i</span> 停止 ------------ <br> ssh <span class="hljs-variable">$i</span> <span class="hljs-string">&quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh stop&quot;</span><br><span class="hljs-keyword">done</span><br>&#125;;;<br><span class="hljs-string">&quot;status&quot;</span>)&#123;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> hadoop102 hadoop103 hadoop104<br><span class="hljs-keyword">do</span><br> <span class="hljs-built_in">echo</span> ---------- zookeeper <span class="hljs-variable">$i</span> 状态 ------------ <br> ssh <span class="hljs-variable">$i</span> <span class="hljs-string">&quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh status&quot;</span><br><span class="hljs-keyword">done</span><br>&#125;;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><h1 id="选举机制">选举机制</h1><p>Zookeeper中的角色分为Leader和Follower。Leader是通过Zookeeper中的服务选举得来的。而Leader的选举又分为首次启动的选举和非首次启动的选举。</p><p>首先我们明确下面几个概念：</p><ul><li>SID：服务器ID，用来唯一标识Zookeeper集群中的一台机器，与myid一致</li><li>ZXID：事务ID，用来标识一次服务器状态的变更。在某一时刻，集群中每台机器的ZXID值不一定完全一致，这和Zookeeper服务器对于客户端更新请求的处理逻辑有关</li><li>Epoch：每个Leader任期的代号</li></ul><p>首次启动时，肯定会存在不同启动顺序。当服务器启动之后，会首先投自己一票，但是只有一票，不够半数以上，选举无法完成，则服务器状态保持Looking。随着集群其他机器启动，会再次发起选举，服务器在给自己投票之后不超过半数，则和其他机器交换投票信息，推举myid高的那个机器。如果仍然没有机器获得超过半数的票，则均保持Looking状态；如果有机器获得超过半数的票，则被推举为Leader。后续加入服务的机器，在已有Leader的情况下，直接以Follower角色加入。<strong>可以说，Leader的选举由启动顺序和myid共同决定</strong>。</p><p>当Zookeeper集群中的一台服务器出现以下两种情况之一的时候，就会进入Leader选举阶段，分别是服务器初始化启动，以及服务器运行期间无法和Leader保持连接。</p><p>而当一台服务器进入Leader选举流程的时候，当前集群也可能会处于两种状态：分别是集群中已经存在Leader，以及集群中确实不存在Leader。</p><p>如果是第一种状况，集群中已经存在Leader，那么机器试图进行选举的时候，会被告知当前集群的Leader信息，那么当前服务器仅需要和Leader机器进行对接，然后进行状态同步即可</p><p>如果是第二种情况，集群中确实不存在Leader，那么则根据特定的规则进行Leader选举，主要就是利用前面说到的3个值的大小，优先级为Epoch&gt;ZXID&gt;SID，即Epoch大的直接胜出；Epoch相同，则事务ID大的胜出；事务ID相同，则服务器ID大d</p><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://blog.csdn.net/weixin_45569634/article/details/104903030?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-104903030-blog-107553902.pc_relevant_multi_platform_whitelistv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-104903030-blog-107553902.pc_relevant_multi_platform_whitelistv2&amp;utm_relevant_index=2">ZooKeeper的各种各样及各样各种概念_叽里呱啦啦啦。的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive学习笔记-Hive优化(1)-Hive性能优化</title>
    <link href="/2022/07/05/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Hive%E4%BC%98%E5%8C%96-1-Hive%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/07/05/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Hive%E4%BC%98%E5%8C%96-1-Hive%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="hive分区表分桶表和索引">Hive分区表，分桶表和索引</h1><p>Hive的设计思想是通过元数据解析描述后，将HDFS上的文件映射成表。当用户通过HQL语句对Hive中的表进行复杂数据处理和计算时，默认将其转换成分布式计算MapReduce程序，然后读取HDFS中的数据。</p><p>在执行查询计划的时候，<strong>Hive会使用表的最后一级目录作为底层处理数据的输入</strong>。如果没有特殊处理，最后一级目录就是表的目录，里面存放了表中的所有数据，因此这个时候就是全表扫描。通过<code>explain</code>命令可以查看执行计划，其中可以看到实际读取的HDFS文件路径。</p><p><strong>分区表</strong>会将不同分区的数据存放在单独的HDFS目录中，这样在查询的时候，根据查询条件，就可以只读取对应分区的数据作为输入，减少不必要的数据加载，提高程序的性能。</p><p><strong>分桶表</strong>则可以解决Hive中join的问题。这点会在后续join问题部分进行深入介绍。</p><p>在Hive中还存在<strong>索引</strong>的设计。Hive允许用户为字段构建索引，提高数据的查询速率。当为某张表的某个字段创建索引时，Hive中会自动创建一张索引表，该表中记录了该字段的每个值与数据实际物理位置之间的关系，例如数据所在的HDFS文件地址，所在文件中的偏移量offset等信息。</p><p>但是索引功能的支持从Hive0.7版本开始支持，但是到Hive3.0开始不再支持。因为Hive中构建和维护索引的操作过于复杂，首先Hive构建索引的过程是通过一个MapReduce程序来实现的，并且每次Hive中原始数据表的数据发生更新的时候，索引表不会自动更新，而必须手动执行一个alterindex命令来通过MapReduce再次更新索引表，导致整体性能较差，维护相对繁琐。</p><h1 id="hive表数据优化">Hive表数据优化</h1><h2 id="文件格式">文件格式</h2><p>Hive数据的存储底层还是HDFS，所有的数据读写都基于HDFS文件来实现。为了提高对HDFS文件读写的性能，Hive中提供了多种文件存储格式，包括TextFile、SequenceFile、ORC、Parquet等，在建表的时候进行指定。</p><p><strong>TextFile</strong>是Hive中默认的文件格式，存储形式为按行存储。T</p><ul><li>优点：最简单的数据格式，可以直接查看，可以使用任意分隔符进行分割</li><li>缺点：耗费存储空间，IO性能较低。结合压缩的时候Hive不进行数据切分合并，不能进行并行操作，查询效率低。按行存储，读取列的性能差</li></ul><p><strong>SequenceFile</strong>是Hadoop中用来存储序列化键值对的一种文件格式，可以作为MapReduce作业的输入输出，因此Hive也支持这种格式</p><ul><li>优点：以二进制KV形式存储数据，与底层交互更加友好，性能更快。可压缩、可分割、优化磁盘利用率和I/O，可并行操作数据，查询效率高</li><li>缺点：存储空间消耗最大，与Hadoop生态系统之外的工具不兼容</li></ul><p><strong>Parquet</strong>是一种支持嵌套结果的列式存储文件格式，作为大数据系统中OLAP查询的优化方案，它已经被多种查询引擎原生支持，并且部分高性能引擎将其作为默认的文件存储格式</p><ul><li>优点：更高效的压缩和编码，可压缩、可分割、优化磁盘利用率和IO，可用于多种数据处理框架</li><li>缺点：不支持update、insert、delete、ACID</li></ul><p><strong>ORC（OptimizedRCFile）</strong>也是一种Hadoop生态圈中的列式存储格式。最初产生自Hive，用于降低Hadoop数据存储空间和加速Hive查询速度。</p><ul><li>优点：列式存储，存储效率非常高。可压缩，高效的列存取。查询效率高，支持索引，支持矢量化查询</li><li>缺点：加载时性能消耗较大，读取全量数据时性能较差</li></ul><p>需要注意的是，以上的文件格式除了TextFile，都无法直接通过数据导入形成。因为load命令只会完成数据的纯移动或者复制，而不会修改数据的文件格式。正确的方式应该是在创建表的时候指定文件格式，然后利用insert+select从原始表中查询后插入指定了文件格式的表中。</p><h2 id="数据压缩">数据压缩</h2><p>Hive压缩实际上说的就是MapReduce的压缩，可以指定不同阶段的压缩算法。Hadoop中支持的压缩在Hive中都可以直接使用。</p><p>在Hive中使用压缩，需要对MapReduce和Hive进行相应的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs hive">--开启hive中间传输数据压缩功能<br>--1）开启hive中间传输数据压缩功能<br>set hive.exec.compress.intermediate=true;<br>--2）开启mapreduce中map输出压缩功能<br>set mapreduce.map.output.compress=true;<br>--3）设置mapreduce中map输出数据的压缩方式<br>set mapreduce.map.output.compress.codec= org.apache.hadoop.io.compress.SnappyCodec;<br><br>--开启Reduce输出阶段压缩<br>--1）开启hive最终输出数据压缩功能<br>set hive.exec.compress.output=true;<br>--2）开启mapreduce最终输出数据压缩<br>set mapreduce.output.fileoutputformat.compress=true;<br>--3）设置mapreduce最终数据输出压缩方式<br>set mapreduce.output.fileoutputformat.compress.codec = org.apache.hadoop.io.compress.SnappyCodec;<br>--4）设置mapreduce最终数据输出压缩为块压缩<br>set mapreduce.output.fileoutputformat.compress.type=BLOCK;<br></code></pre></td></tr></table></figure><h2 id="存储优化">存储优化</h2><p>存储优化的第一个问题是小文件的问题。</p><p>Hive的存储本质是HDFS，而HDFS并不利于小文件的存储。在使用Hive进行处理分析的时候，要尽量避免小文件的生成。Hive中提供了一个特殊的机制，可以自动判断是否是小文件，如果是小文件可以自动将小文件进行合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hive">-- 如果hive的程序，只有maptask，将MapTask产生的所有小文件进行合并<br>set hive.merge.mapfiles=true;<br>-- 如果hive的程序，有Map和ReduceTask,将ReduceTask产生的所有小文件进行合并<br>set hive.merge.mapredfiles=true;<br>-- 每一个合并的文件的大小（244M）<br>set hive.merge.size.per.task=256000000;<br>-- 平均每个文件的大小，如果小于这个值就会进行合并(15M)<br>set hive.merge.smallfiles.avgsize=16000000<br></code></pre></td></tr></table></figure><p>上面解决的情况是输出为小文件的情况，而Hive中也提供一种输入类<code>CombineHiveInputFormat</code>用于解决输入是小文件的情况，它将小文件进行合并之后再进行处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hive">-- 设置Hive中底层MapReduce读取数据的输入类：将所有文件合并为一个大文件作为输入<br>set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;<br></code></pre></td></tr></table></figure><p>存储优化的第二个问题是ORC的文件索引。</p><p>在使用ORC文件时，为了加快读取ORC文件中的数据内容，ORC提供了两种索引机制：<strong>RowGroup Index</strong> 和 <strong>Bloom FilterIndex</strong>，可以帮助提高查询ORC文件的性能。当用户写入数据时，可以指定构建索引，当用户查询数据时，可以根据索引提前对数据进行过滤，避免不必要的数据扫描。</p><p>一个ORC文件会包含一个或者多个stripes，可以理解为原始数据的一部分。每个stripe中，包含了其中数据的每个column的min/max。当查询中有大小判断的操作时，可以根据最大最小值，跳过一定不包含结果的stripe。这里为每个stripe建立的包含min/max值的索引，就称为RowGroupIndex。建立ORC格式表的时候，指定表参数<code>orc.create.index=true</code>之后就会建立RowGroupIndex。而为了使得该索引有效利用，向表中加载数据的时候，必须对需要使用索引的字段进行排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs hive">---存储优化-ORC文件索引<br>--1、开启索引配置<br>set hive.optimize.index.filter=true;<br>--2、创建表并制定构建索引<br>create table table_name<br>    stored as orc tblproperties (&quot;orc.create.index&quot;=&quot;true&quot;)<br>as select * from table_source<br>    distribute by stime<br>    sort by stime;<br></code></pre></td></tr></table></figure><p>Bloom FilterIndex即为字段建立布隆过滤器的数据结构。当查询条件中包含对该字段的等值过滤时，可以通过布隆过滤器判断该stripe中是否存在，如果返回不存在则直接跳过该stripe。建表的时候通过指定表参数<code>orc.bloom.filter.columns=columnName...</code>来指定为哪些字段建立布隆过滤器索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hive">--创建表指定创建布隆索引<br>create table table_name<br>stored as orc tblproperties (&quot;orc.create.index&quot;=&quot;true&quot;,&quot;orc.bloom.filter.columns&quot;=&quot;stime,userid&quot;)<br>as select * from table_source<br>distribute by stime<br>sort by stime;<br></code></pre></td></tr></table></figure><p>Hive的默认查询执行引擎一次处理一行，而矢量化查询执行是一种Hive针对ORC文件操作的特性，目的是按照每批1024行读取数据，并且一次性对整个记录整合（而不是对单条记录）应用操作，提升了像过滤,联合,聚合等等操作的性能。注意：要使用矢量化查询执行，就必须以<strong>ORC格式</strong>存储数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">-- 开启矢量化查询<br>set hive.vectorized.execution.enabled = true;<br>set hive.vectorized.execution.reduce.enabled = true;<br></code></pre></td></tr></table></figure><h1 id="hive作业执行优化">Hive作业执行优化</h1><h2 id="explain查询计划">explain查询计划</h2><p>explain会解析HQL语句，将整个HQL语句的实现步骤、依赖关系、实现过程都会进行解析返回，可以了解一条HQL语句在底层是如何实现数据的查询及处理的过程，辅助用户对Hive进行优化。</p><p>常用语法命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">explain [formatted|extended|dependency|authorization] query<br></code></pre></td></tr></table></figure><ul><li>formatted：对执行计划进行格式化展示</li><li>extended：提供更详细的信息</li><li>dependency：以json格式返回查询所依赖的表和分区列表</li><li>authorization：列出需要被授权的条目，包括输入和输出</li></ul><p>Hive中每个查询计划由以下几个部分组成：</p><ol type="1"><li>抽象语法树（AST）：Hive使用Antlr解析生成器，可以自动地将HQL生成为抽象语法树</li><li>Stage依赖关系：会列出运行查询划分的stage阶段以及之间的依赖关系</li><li>Stage内容：包含了每个stage非常重要的信息，比如运行时的operator和sortorders等具体的信息</li></ol><h2 id="mapreduce属性优化">MapReduce属性优化</h2><p>MapReduce属性优化包括多个方面，如本地模式，JVM重用和并行执行等。</p><p>本地模式指的是直接在本地计算，允许程序不提交给Yarn。这是指在Hive的过程中，有一些数据量不大的表也会转换成MapReduce进行处理。如果提交到集群，需要申请资源，等待分配，最后再运行的一系列流程，比较繁琐。而本身数据量不大，导致整体效率较低。而本地计算模式，允许程序不提交给Yarn，直接在本地运行以便提高小数据量程序的性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hive">--开启本地模式<br>set hive.exec.mode.local.auto = true;<br></code></pre></td></tr></table></figure><p>Hadoop默认会为每个Task启动一个JVM运行，而在JVM启动的时候内存开销较大。Job数据量大的情况，如果单个Task数据量比较小，也会申请JVM，这就导致了资源紧张及浪费的情况；JVM重用可以使得JVM实例在同一个job中重新使用N次，当一个Task运行结束以后，JVM不会进行释放，而是继续供下一个Task运行，直到运行了N个Task以后，就会释放；N的值可以在Hadoop的mapred-site.xml文件中进行配置，通常在10-20之间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">-- Hadoop3之前的配置，在mapred-site.xml中添加以下参数<br>-- Hadoop3中已不再支持该选项<br>mapreduce.job.jvm.numtasks=10 <br></code></pre></td></tr></table></figure><p>Hive在实现HQL计算运行时，会解析为多个Stage，有时候Stage彼此之间有依赖关系，只能挨个执行，但是在一些别的场景下，很多的Stage之间是没有依赖关系的，例如Union语句，Join语句等等，这些Stage没有依赖关系，但是Hive依旧默认挨个执行每个Stage，这样会导致性能非常差，我们可以通过修改参数，开启并行执行，当多个Stage之间没有依赖关系时，允许多个Stage并行执行，提高性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hive">-- 开启Stage并行化，默认为false<br>set hive.exec.parallel=true;<br>-- 指定并行化线程数，默认为8<br>set hive.exec.parallel.thread.number=16; <br></code></pre></td></tr></table></figure><h2 id="join优化">join优化</h2><p>在Hive中，join的底层通过MapReduce来实现。而为了提高MapReduce的性能，Hive中提供了多种join的方案，例如适合小表join大表的mapjoin；大表join大表的reduce join；大表join的优化方案bucket join等</p><p><strong>mapjoin</strong>适合的场景是小表join大表或者小表join小表。mapjoin会在每个MapTask的内存中都存放一份完整的小表数据，而大表数据通过多个MapTask并行处理，大表的每个部分都可以与小表的完整数据进行join。由于这种方式不需要启动ReduceTask，所以底层不需要经过shuffle，但是需要占用内存空间来存放较小的数据文件。</p><p>在Hive中默认开启了map join，会尽量使用mapjoin来实现join，即能够使用map join的join都使用mapjoin。<code>hive.auto.convert.join=true</code>。在Hive中对于小表的大小限制如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hive">-- 2.0版本之前的控制属性<br>hive.mapjoin.smalltable.filesize=25M<br>-- 2.0版本开始由以下参数控制<br>hive.auto.convert.join.noconditionaltask.size=512000000<br></code></pre></td></tr></table></figure><p><strong>reduce join</strong>的场景是没法使用mapjoin的大表join大表情况。这时候由于内存中无法存放某张大表的所有数据，就没法使用mapjoin。reducejoin指的是在Reduce阶段完成join。两张表按照关联字段进行分组，然后通过shuffle过程进入到同一个ReduceTask完成join操作</p><img src="/2022/07/05/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Hive%E4%BC%98%E5%8C%96-1-Hive%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/ReduceJoin.png" class="" title="reduce join"><p>可以看到上面的reducejoin会经过shuffle阶段，因此效率并不是很高。Hive还提供<strong>bucketjoin</strong>对大表join大表的情况进行优化。这就是前面提到的分桶表。我们首先将两张表都按照相同的字段进行分桶，然后分桶值对应的数据之间进行join，减少了比较次数，提高了性能。</p><p>使用bucketjoin的前提是开启了对应的功能，同时要求分桶字段=join字段，并且两个表桶个数相等或者成倍数（这样才能根据hash规则得到的余数找到对应规则）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hive">--开启bucket join<br>set hive.optimize.bucketmapjoin = true<br></code></pre></td></tr></table></figure><p>bucketjoin又分成两个层次，第一个就是基于分桶的字段进行排序，即是上面提到的。另一个层次更进一步，基于有序的数据进行join，全称为SortMerge BuckerJoin（SMB）。这要求开启下面的配置，同时分桶字段=排序字段=join字段，桶的个数相等或者成倍数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hive">set hive.optimize.bucketmapjoin = true;<br>set hive.auto.convert.sortmerge.join=true;<br>set hive.optimize.bucketmapjoin.sortedmerge = true;<br>set hive.auto.convert.sortmerge.join.noconditionaltask=true;<br></code></pre></td></tr></table></figure><h2 id="优化器">优化器</h2><p>当一个程序中如果有一些操作彼此之间有关联性，是可以在一个MapReduce中实现的，但是Hive会不智能的选择，Hive会使用两个MapReduce来完成这两个操作。例如：当我们执行<code>select …… from table group by id order by id desc</code>。该SQL语句转换为MapReduce时，我们可以有两种方案来实现：</p><ol type="1"><li>第一个MapReduce做groupby，经过shuffle阶段对id做分组；第二个MapReduce对第一个MapReduce的结果做orderby，经过shuffle阶段对id进行排序</li><li>因为都是对id处理，可以使用一个MapReduce的shuffle既可以做分组也可以排序</li></ol><p>显然第二种方式性能较高，但是Hive默认选择第一种方案实现。在Hive中可以开启关联优化，对有关联关系的操作进行解析的时候，可以尽量放在同一个MapReduce任务中实现，配置开启如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">set hive.optimize.correlation=true;<br></code></pre></td></tr></table></figure><p>Hive中的优化器引擎有RBO和CBO：</p><ul><li>RBO，Rule BasicOptimizer：是基于规则的优化器，根据设定好的规则对程序进行优化</li><li>CBO，Cost BasicOptimizer：是基于代价的优化器，根据不同场景所需要付出的代价来合适选择优化的方案，对数据的分布的信息【数值出现的次数，条数，分布】来综合判断用哪种处理的方案是最佳方案</li></ul><p>Hive中默认使用RBO优化器引擎，但是我们也可以配置底层的优化器引擎为CBO引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">set hive.cbo.enable=true;<br>set hive.compute.query.using.stats=true;<br>set hive.stats.fetch.column.stats=true;<br></code></pre></td></tr></table></figure><p>CBO引擎通过Analyze分析器来辅助判断每种方案的计算代价。Analyze分析器用于提前运行一个MapReduce程序将表或者分区的信息构建一些元数据【表的信息、分区信息、列的信息】，搭配CBO引擎一起使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs hive">-- 构建分区信息元数据<br>analyze table tablename<br>[partition(partcol1[=val1], partcol2[=val2], ...)]<br>compute statistics [noscan];<br><br>-- 构建列的元数据<br>analyze table tablename<br>[partition(partcol1[=val1], partcol2[=val2], ...)]<br>compute statistics for columns ( columns name1, columns name2...) [noscan];<br><br>-- 查看元数据<br>desc formatted [tablename] [columnname];<br></code></pre></td></tr></table></figure><h2 id="谓词下推-ppd">谓词下推 PPD</h2><p>谓词下推PredicatePushdown（PPD）基本思想：将过滤表达式尽可能移动至靠近数据源的位置，以使真正执行时能直接跳过无关的数据。简单点说就是<strong>在不影响最终结果的情况下，尽量将过滤条件提前执行</strong>。Hive中谓词下推后，过滤条件会下推到map端，提前执行过滤，减少map到reduce的传输数据，提升整体性能。开启参数如下，默认是开启状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">set hive.optimize.ppd = true<br></code></pre></td></tr></table></figure><h2 id="数据倾斜">数据倾斜</h2><p>分布式计算中最常见，最容易遇到的问题就是数据倾斜。数据倾斜指的是分布式程序中大多数的Task已经运行结束了，而某一个Task一直在运行，由于数据量过大而始终无法结束。导致数据倾斜的原因一般都是数据分配的问题。</p><p>groupby就是一种很有可能导致数据倾斜的操作。如果数据本身是倾斜的，按照MapReduce中Hash分区规则之后，肯定会出现数据倾斜的问题。根本原因是因为分区规则导致的，所以可以通过以下几种方案来解决groupby导致的数据倾斜的问题。</p><p><strong>方案一是开启Map端聚合</strong>。这指的是通过减少shuffle数据量和Reduce计算的执行时间，避免每个Task数差异过大导致数据倾斜。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">set hive.map.aggr=true;<br></code></pre></td></tr></table></figure><p><strong>方案二是实现随机分区</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">select * from table distribute by rand();<br>--distribute by用于指定底层按照哪个字段作为Key实现分区<br>--通过rank函数随机值实现随机分区，避免数据倾斜<br></code></pre></td></tr></table></figure><p><strong>方案三是数据倾斜之后进行自动负载均衡</strong>。开启这个参数之后，当前程序会自动通过两个MapReduce程序来完成。第一个MapReduce将数据自动随机分布到Reducer中，每个Reducer做部分聚合操作输出结果；第二个MapReduce将上一步聚合的结果再按照业务进行处理，保证相同的分布到一起，最终聚合得到结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">set hive.groupby.skewindata=true;<br></code></pre></td></tr></table></figure><p>join操作是另外一个很容易导致数据倾斜的操作。join操作时，如果两张表比较大，无法实现mapJoin，只能走reduceJoin，那么当关联字段中某一种值过多的时候依旧会导致数据倾斜的问题；面对join产生的数据倾斜，核心的思想是尽量避免reduceJoin的产生，优先使用map Join来实现；但往往很多的join场景不满足mapJoin的需求，那么可以以下几种方案来解决join产生的数据倾斜问题。</p><p><strong>方案一是提前过滤。</strong>提前过滤即将大表数据变成小表数据，实现mapjoin。</p><p><strong>方案二是使用bucketjoin。</strong>前面反复提到通过分桶表可以优化join的执行效率，避免数据倾斜。</p><p><strong>方案三是使用skew join。</strong>skewjoin是Hive中一种专门为了避免数据倾斜而设计的特殊的join过程。这种join的原理是将mapjoin和reducejoin进行合并，如果某个值出现了数据倾斜，就会将产生数据倾斜的数据单独使用mapjoin来实现。其他没有产生数据倾斜的数据由reducejoin来实现，这样就避免了reduce join中产生数据倾斜的问题。最终将mapjoin的结果和reduce join的结果进行union合并。配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs hive">-- 开启运行过程中skewjoin<br>set hive.optimize.skewjoin=true;<br>-- 如果这个key的出现的次数超过这个范围<br>set hive.skewjoin.key=100000;<br>-- 在编译时判断是否会产生数据倾斜<br>set hive.optimize.skewjoin.compiletime=true;<br>-- 不合并，提升性能<br>set hive.optimize.union.remove=true;<br>-- 如果Hive的底层走的是MapReduce，必须开启这个属性，才能实现不合并<br>set mapreduce.input.fileinputformat.input.dir.recursive=true;<br></code></pre></td></tr></table></figure><h2 id="fetch抓取">Fetch抓取</h2><p>Hive会将我们写的SQL语句转换成MapReduce程序，但是在某些情况下，Hive的查询没有必要使用MapReduce程序。这就是Fectch抓取。类似于语句<code>select * from table_name</code>，只需要简单读取<code>table_name</code>对应存储目录下的文件，然后输出查询结果即可。不过只有一些简单的查询可以被优化，不能包括子查询、聚合查询、侧视图、join等复杂操作。</p><p>控制该行为的参数是<code>hive.fetch.task.conversion</code>。字段描述如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.fetch.task.conversion<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>more<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>      Expects one of [none, minimal, more].<br>      Some select queries can be converted to single FETCH task minimizing latency.<br>      Currently the query should be single sourced not having any subquery and should not have<br>      any aggregations or distincts (which incurs RS), lateral views and joins.<br>      0. none : disable hive.fetch.task.conversion<br>      1. minimal : SELECT STAR, FILTER on partition columns, LIMIT only<br>      2. more  : SELECT, FILTER, LIMIT only (support TABLESAMPLE and virtual columns)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>若属性为null，则不使用fetch优化，任何语句都会转化成MapReduce程序</li><li>若属性为minimal，则只有<code>select *</code>语句，在分区列上的过滤语句（包括<code>having</code>和<code>where</code>），和<code>limit</code>关键字可以被优化成fetch任务</li><li>若属性为more，则简单的<code>select</code>语句（可以全表查询、特定列查询、或者函数表达式等，包括UDF函数，但是表生成函数UDTF还不支持）、过滤语句（<code>where</code>或<code>having</code>）、和<code>limit</code>关键字可以被优化成fetch任务</li></ul><blockquote><p>在Hive 0.10.0版本开始加入该属性，默认值为minmal；Hive0.14.0之后，默认值为more</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive学习笔记-HiveSQL(4)-Hive函数重要应用案例</title>
    <link href="/2022/07/05/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-4-Hive%E5%87%BD%E6%95%B0%E9%87%8D%E8%A6%81%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <url>/2022/07/05/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-4-Hive%E5%87%BD%E6%95%B0%E9%87%8D%E8%A6%81%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="hive多字节分隔符">Hive多字节分隔符</h1><p>前面我们提到，在Hive加载表的时候可以手动指定不同种类的分隔符，但是这有一个限制，就是只能使用单字节分隔符，即char类型的分隔符。如果我们的<strong>真实数据中分隔符超过单字节</strong>，而我们不做任何处理就直接套用之前的语法，得到的结果将不会符合我们的预期。还有一种情况是在数据的字段内容中包含了分隔符，原本的语法也无法解决这类问题。因此针对多字节分隔符以及分隔符出现在字段中的情况，我们应该进行特殊的处理</p><p>第一种处理方法就是<strong>进行分隔符的替换</strong>。我们利用程序提前对原始数据进行处理，将其中的多字节分隔符替换为单字节分隔符，之后再利用之前的语法</p><p>第二种处理方法是<strong>使用RegexSerDe进行正则加载</strong></p><p>前面我们也提到，默认情况下Hive载入数据的过程中使用的SerDe类是LazySimpleSerDe。实际上Hive还提供了其他多种SerDe用于解析和加载不同类型的数据文件，常用的有ORCSerDe、RegexSerDe、JsonSerDe等，这里我们需要使用到的是RegexSerDe。</p><p>RegexSerDe可以处理加载特殊数据的问题，它使用正则匹配来加载数据。我们通过书写正则表达式，指定列分隔的模式，之后Hive根据这个正则表达式来进行数据的匹配。</p><p>举例来说，我们现在的字段使用<code>||</code>双竖线进行分隔，一共有3个字段，即类似于：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">xxx||xxx||xxx<br></code></pre></td></tr></table></figure><p>则我们可以用如下的正则表达式来定义这一列：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">(.<span class="hljs-symbol">*</span>)\\|<span class="hljs-string">\\</span>|<span class="hljs-string">(.*)\\</span>|<span class="hljs-string">\\</span>|<span class="hljs-string">(.*)</span><br></code></pre></td></tr></table></figure><p>RegexSerDe的使用是在表加载的时候指定。这种情况下，对我们的要求就是要写出符合对应模式的正则表达式。之后再使用load进行数据加载，就能够得到符合预期的结果了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hive">create table table_name(<br>    col1 string,<br>    col2 string,<br>    col3 string<br>)<br>row format serde &#x27;org.apache.hadoop.hive.serde2.RegexSerDe&#x27; --指定RegexSerDe类<br>with serdeproperties(&#x27;input.regex&#x27;=&#x27;(.*)\\|\\|(.*)\\|\\|(.*)&#x27;) --指定正则表达式<br></code></pre></td></tr></table></figure><p>第三种处理方法是<strong>自定义InputFormat</strong>。我们知道Hive在读取底层HDFS文件的时候，还是通过InputFormat来读入的。而我们可以通过自定义InputFormat来修改读入的逻辑，在读入的时候将其中的多字节分隔符和特殊情况进行处理，处理之后的结果能够被Hive的默认行为处理即可</p><p>使用我们自定义的InputFormat需要首先将程序打包成jar包，然后添加到Hive的classpath中，使用<code>add jar</code>命令进行添加，之后在创建表的时候指定InputFormat为自定义的InputFormat，再进行数据加载即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs hive">create table table_name(<br>    col1 string,<br>    col2 string,<br>    col3 string<br>)<br>row format delimited fields terminated by &#x27;|&#x27;<br>--指定使用自定义的类来解析<br>stored as<br>inputformat &#x27;xxx.MyInputFormat&#x27;<br>outputformat &#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;;<br></code></pre></td></tr></table></figure><p>虽然以上三种方式都可以解决问题，但是角度各不同，开发成本也各有高低。整体上推荐使用正则加载的方式来实现对于特殊数据的处理</p><h1 id="url解析函数">URL解析函数</h1><p>Hive中的URL解析函数主要是<code>parse_url</code>和<code>parse_url_tuple</code></p><p><strong>parse_url</strong>函数是Hive中提供的最基本的URL解析函数，可以根据指定的参数从URL中解析出对应的参数进行返回。这是普通的一进一出的UDF函数，因此如果要查询多个字段的话，则需要写多个parse_url函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">--语法<br>parse_url(url, key)<br>--可选的key有:host、path、query、ref、protocol、authority等<br></code></pre></td></tr></table></figure><p><strong>parse_url_tuple</strong>函数则可以通过一次性指定多个参数，从URL中解析出多个参数的值，然后返回多列。在效果表现上，parse_url_tuple接受一行URL，同样会返回一行，但是存在多列，列字段分别为指定查询的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hive">--语法<br>parse_url_tuple(url, key1, key2, ...)<br></code></pre></td></tr></table></figure><p>虽然从表现上看，parse_url_tuple是一进一出，但是<strong>这是一个UDTF表生产函数</strong>。因此在使用的时候，可以配合侧视图进行使用，或者说将其当成简单的UDF函数使用是不行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs hive">--单个lateral view使用<br>select<br>a.url as url,<br>    b.host as host,<br>    b.path as path,<br>    b.query as query<br>from table_url a <br>lateral view parse_url_tuple(url,&quot;HOST&quot;,&quot;PATH&quot;,&quot;QUERY&quot;) b as host,path,query;<br><br>--多个lateral view<br>select<br>a.url as url,<br>    b.host as host,<br>    b.path as path,<br>    c.protocol as protocol,<br>    c.query as query<br>from table_url a<br>         lateral view parse_url_tuple(url,&quot;HOST&quot;,&quot;PATH&quot;) b as host,path<br>         lateral view parse_url_tuple(url,&quot;PROTOCOL&quot;,&quot;QUERY&quot;) c as protocol,query;<br></code></pre></td></tr></table></figure><p>注意侧视图的底层类似于innerjoin，因此如果UDTF不产生数据时，侧视图与原表关联的结果将为空，但是如果加上outer关键字后，就会保留原表数据，类似于outerjoin</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">select ...<br>from ...<br>lateral view outer UDTF(...) as col<br></code></pre></td></tr></table></figure><h1 id="行列转换">行列转换</h1><p>行列转化主要涉及到表形式的问题。在一些场景下，表形式的转换会更适合业务的要求。以下的情况中将表形式抽象为比较简单的模式，而不涉及具体的业务含义</p><h2 id="多行转多列">多行转多列</h2><p>多行转多列，情况如下：</p><img src="/2022/07/05/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-4-Hive%E5%87%BD%E6%95%B0%E9%87%8D%E8%A6%81%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/%E5%A4%9A%E8%A1%8C%E8%BD%AC%E5%A4%9A%E5%88%97.png" class="" title="多行转多列"><p>这种类型我们可以使用case-when函数和groupby来实现。首先对数据进行分组，然后通过查询构造不同的列，针对不同情况进行不同的查询（case-when函数也可以使用if函数代替）。注意由于这里使用了groupby，因此在select之后需要使用聚合函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hive">select<br>col1,<br>max(case col2 when &#x27;c&#x27; then col3 else 0 end) as c,<br>max(case col2 when &#x27;d&#x27; then col3 else 0 end) as d,<br>max(case col2 when &#x27;e&#x27; then col3 else 0 end) as e,<br>from table_name<br>group by col1;<br></code></pre></td></tr></table></figure><h2 id="多行转单列">多行转单列</h2><p>多行转单列，情况如下：</p><img src="/2022/07/05/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-4-Hive%E5%87%BD%E6%95%B0%E9%87%8D%E8%A6%81%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/%E5%A4%9A%E8%A1%8C%E8%BD%AC%E5%8D%95%E5%88%97.png" class="" title="多行转单列"><p>这种类型我们同样使用groupby进行分组，之后使用聚合函数中的数据收集函数。当然这里可能涉及到数据类型的细节问题，具体分析即可</p><p>这里先列出可能会使用到的函数以及对应的简要说明：</p><ul><li>concat函数：实现字符串拼接，但是不可以指定分隔符（<strong>如果任意一个函数为null，结果为null</strong>）</li><li>concat_ws函数：实现字符串拼接，可以指定分隔符，接受单个字符串或者字符串数组（<strong>如果任意一个元素不为null，则结果不为null</strong>）</li><li>collect_list：用于将一列中的多行合并为一行，不进行去重</li><li>collect_set：用于将一列中的多行合并为一行，进行去重</li></ul><p>则应用上面的函数，我们可以写出如下的查询代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hive">select<br>col1, col2,<br>concat_ws(&#x27;,&#x27;,collect_list(cast(col3 as string))) as col3<br>from table_name<br>group by col1, col2;<br></code></pre></td></tr></table></figure><h2 id="多列转多行">多列转多行</h2><p>多列转多行，情况如下：</p><img src="/2022/07/05/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-4-Hive%E5%87%BD%E6%95%B0%E9%87%8D%E8%A6%81%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/%E5%A4%9A%E5%88%97%E8%BD%AC%E5%A4%9A%E8%A1%8C.png" class="" title="多列转多行"><p>这种类型我们需要使用union关键字，查询不同的情况之后进行拼接即可，实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hive">select col1， &#x27;c&#x27; as col2, col2 as col3 from table_name<br>union all<br>select col1， &#x27;d&#x27; as col2, col3 as col3 from table_name<br>union all<br>select col1， &#x27;e&#x27; as col2, col3 as col3 from table_name<br></code></pre></td></tr></table></figure><h2 id="单列转多行">单列转多行</h2><p>单列转多行，情况如下：</p><img src="/2022/07/05/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-4-Hive%E5%87%BD%E6%95%B0%E9%87%8D%E8%A6%81%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/%E5%8D%95%E5%88%97%E8%BD%AC%E5%A4%9A%E8%A1%8C.png" class="" title="单列转多行"><p>这种类型主要就是需要使用到explode函数，它可以将一个复杂类型的字段进行元素展开。实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hive">select<br>col1, col2, <br>sone_name.col3 as col3<br>from table_name<br>lateral view explode(split(col3, &#x27;,&#x27;)) some_name as col3;<br></code></pre></td></tr></table></figure><h1 id="json数据处理">json数据处理</h1><p>Hive中为了实现json格式的数据解析，提供了两种解析数据的方式</p><ol type="1"><li>使用<code>get_json_object</code>和<code>json_tuple</code>函数，这两个函数都可以实现将json数据中的每个字段独立解析出来，构建成表</li><li>使用<code>JsonSerde</code>类，在建表的时候指定Serde，加载json文件到表中。这会自动将文件解析为对应的表格式</li></ol><p><strong>get_json_object</strong>函数可以用于解析json，从json字符串中返回指定某个对象列的值。函数一共有两个参数，第一个参数是要解析的json字符串，第二个参数是指定要返回的字段，可以通过<code>$.columnName</code>的方式来指定path。不过这种方式每次只能返回json对象中一列的值，如果要获取多个字段只能重复使用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hive">--语法<br>get_json_object(json_txt, path)<br><br>--举例<br>select<br>get_json_object(json, &#x27;$.key&#x27;) as key<br>from table_name;<br></code></pre></td></tr></table></figure><p><strong>json_tuple</strong>函数也可以用于json的解析，并且支持指定多个参数从而返回多个列的值。返回的每一列都是字符串类型。这也是一个UDTF表生成函数，一般也是搭配lateralview使用，类似于上面说到的URL解析函数中的parse_url_tuple。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">json_tuple(jsonStr, path1, path2, ...)<br></code></pre></td></tr></table></figure><p>上述解析json的过程是将数据作为一个字符串加载到表中，要使用的时候再通过json解析函数对字符串进行解析，灵活性较高。还可以在数据加载的时候就将json文件直接解析加载，使用的是专门用于解析json文件的Serde解析器。在创建表的时候，只要指定使用JSONSerde，之后加载数据的时候就会自动对Json文件中的每一列进行解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hive">create table(<br>    key1 string,<br>    key2 string<br>)<br>row format serde &#x27;org.apache.hive.hcatalog.data.JsonSerDe&#x27;<br>stored as textfile;<br></code></pre></td></tr></table></figure><p>两种解析json的方式不同，如果数据中每一行只有个别字段是json格式字符串，就可以使用json函数来实现处理，但是如果数据加载的文件整体就是json文件，每一行数据就是一个json数据，那么建议直接使用JsonSerde来实现处理最为方便。</p><h1 id="拉链表的设计与实现">拉链表的设计与实现</h1><p>Hive在实际工作中主要用于构建离线数仓，定期从各种数据源中同步采集数据到Hive中，然后经过分层转换提供数据应用。由于数据定期会更新，那么就存在新数据和老数据如何设计安排的问题。例如在用户状态场景下，可能一天后有些用户的状态发生改变，即出现了新数据，应该如何将新数据进行加载写入，又应该如何处理老数据。</p><p>第一种方案就是在Hive中直接使用新数据覆盖老数据。这种方式实现起来最简单，但是没有历史状态。</p><p>第二种方案是每次数据改变都进行记录，根据日期构建一份全量的快照表，每天一张表。这种方式虽然记录了所有的状态，但是会造成很严重的数据冗余问题，导致数据存储量过大。</p><p>第三种方案是构建拉链表，通过时间来标记每行数据的有效期，记录每个状态的时间周期。一般来说，我们会在表中额外记录两个字段，<code>starttime</code>和<code>endtime</code>，分别记录当前行的有效时间范围。如果当前有效，可以将<code>endtime</code>设置为<code>9999-12-31</code>这样的格式</p><p>拉链表专门用于解决在数据仓库中，数据发生变化之后如何实现数据存储的问题。它的设计是将更新的数据进行状态记录，通过时间进行标记每个状态的生命周期。查询的时候，可以根据需求获取指定时间范围内的数据，同时可以使用<code>9999-12-31</code>等最大值来表示最新状态</p><p>拉链表的实现过程如下：</p><img src="/2022/07/05/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-4-Hive%E5%87%BD%E6%95%B0%E9%87%8D%E8%A6%81%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/%E6%8B%89%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B.png" class="" title="拉链表的实现过程"><p>假设我们现在需要持续更新的表具有字段为id、value、starttime、endtime，那么拉链表的构建如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs hive">--创建DW层拉链表<br>create table dw_zipper(<br>    id int,<br>    value string,<br>    starttime string,<br>    endtime string<br>)<br><br>--创建ODS层增量表<br>create table ods_update(<br>    id int,<br>    value string,<br>    starttime string,<br>    endtime string<br>)<br><br>--创建临时表<br>create table temp(<br>    id int,<br>    value string,<br>    starttime string,<br>    endtime string<br>)<br><br><br>--合并拉链表和增量表<br>insert overwrite table temp<br>select<br>id, value, starttime, endtime<br>from ods_update --查询增量表中的所有数据<br>union all<br>select<br>id, value, starttime, <br>if(b.id is null or a.endtime &lt; &#x27;9999-12-31&#x27;,<br>       a.endtime, date_sub(b.starttime, 1)<br>      ) as entdime<br>    --如果这条id没有更新，或者id更新但是该行不是最新状态，则保留原来的值，否则改为新数据开始时间-1<br>from dw_zipper a <br>left join ods_update b<br>on a.id = b.id <br>--利用join进行查询，完全保留左表的同时可以根据字段判断当前行是否需要更新状态<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive学习笔记-HiveSQL(3)-Hive参数配置 运算符以及函数使用</title>
    <link href="/2022/07/04/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-3-Hive%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/04/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-3-Hive%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="hive-客户端与属性配置">Hive 客户端与属性配置</h1><h2 id="clis客户端和命令">CLIs客户端和命令</h2><p>Hive中的命令行客户端主要分为两种，第一代客户端hive和第二代客户端beeline。</p><p>第一代客户端<code>$HIVE_HOME/bin/hive</code>，主要功能是交互式或批处理执行Hive查询，以及启动hive相关的服务，如Metastore服务和HiveServer2服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">hive # 无参数表示直接进入交互式客户端<br>-e &lt;quoted-query-string&gt; # 执行指定的sql语句，运行完后退出<br>-f &lt;filename&gt; # 执行指定的sql文件，运行完后退出<br>--H,--help # 查看帮助信息<br>-S,--silent # 静默模式<br>-v,-verbose # 详细模式，将执行sql回显<br>-service service_name # 启动hive的相关服务<br>-i # 进入交互模式之前运行初始化脚本<br></code></pre></td></tr></table></figure><p>第二代客户端<code>$HIVE_HOEM/bin/beeline</code>，通过thrift连接到单独的HiveServer2服务上，再连接到Metastore服务。beeline支持的参数可以通过官方文档进行查询：<ahref="https://cwiki.apache.org/confluence/display/Hive/HiveServer2+Clients#HiveServer2Clients-Beeline–NewCommandLineShell">HiveServer2Clients - Apache Hive - Apache Software Foundation</a></p><h2 id="configuration-properties属性配置">ConfigurationProperties属性配置</h2><p>Hivev除了默认的属性配置之外，还支持用户使用时修改配置。修改配置的时候，我们应该关注有哪些属性支持修改，属性的功能和作用，支持何种方式进行修改，修改后的作用时间和作用范围。</p><p>Hive的配置属性再HiveConf.java类中进行管理，详细的配置参数可以参考：<ahref="https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties">ConfigurationProperties - Apache Hive - Apache Software Foundation</a></p><p>配置属性的方法一共有4种，分别如下：</p><p><strong>方式1：hive-site.xml</strong></p><p>在<code>$HIVE_HOME/conf</code>路径下可以添加hive-site.xml文件，可以定义配置属性。该配置文件会全局生效</p><p><strong>方式2：--hiveconf命令行参数</strong></p><p>hiveconf是一个命令行参数，在启动hive或者beeline命令行客户端的时候可以进行指定。该配置在整个会话session过程中有效，会话结束之后即失效</p><p><strong>方式3：set命令</strong></p><p>在会话中使用set命令进行配置，该配置对该会话中，set命令之后所有SQL语句生效</p><p><strong>方式4：服务特定配置文件</strong></p><p>服务特定配置文件主要包括<code>hivemetastore-site.xml</code>和<code>hiveserver2-site.xml</code>，分别表示对应服务特定的配置文件。</p><ul><li>HiveMetastore会加载可用的<code>hive-site.xml</code>以及<code>hivemetastore-site.xml</code>配置文件</li><li>HiveServer2会加载可用的<code>hive-site.xml</code>以及<code>hiveserver2-site.xml</code></li></ul><p>如果HiveServer2以嵌入式模式使用元存储，则还将加载<code>hivemetastore-site.xml</code></p><p>总结来说：</p><ol type="1"><li>配置优先级：set设置 &gt; hiveconf参数 &gt;hive-site.xml配置文件</li><li>Hive也会读入Hadoop配置，Hive的配置会覆盖Hadoop的配置进行生效</li></ol><h1 id="hive-内置运算符">Hive 内置运算符</h1><p>整体上，Hive支持的运算符可以主要可以分为五个种类，关系运算、算术运算和逻辑运算，还有字符串运算符以及复杂类型操作符，官方参考文档地址为：<ahref="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF">LanguageManual UDF - Apache Hive - Apache Software Foundation</a></p><p>可以通过以下命令查看运算符的使用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hive">--显示所有的函数和运算符<br>show functions;<br><br>--查看运算符或者函数的使用说明<br>describe function count;<br><br>--使用extended查看更加详细的使用说明<br>describe function extended count;<br></code></pre></td></tr></table></figure><p>下面对常见的运算符进行列举，基本都可以见名知义，只有一些特殊地方会注释说明</p><p>关系运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs hive">= ==<br>&lt;&gt; !=<br>&lt; &lt;=<br>&gt; &gt;=<br>is null<br>is not null<br>like --like匹配: _表示任意单个字符, %表示任意数量字符<br>rlike --匹配正则表达式，是regexp_like的同义词<br>regexp --功能同rlike <br><br>select 1 from test where &#x27;haha&#x27; like &#x27;ha%&#x27;<br>select 1 from test where &#x27;haha&#x27; rlike &#x27;^h.*a$&#x27;<br>select 1 from test where &#x27;haha&#x27; regexp &#x27;^h.*a$&#x27;<br></code></pre></td></tr></table></figure><p>算术运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">+ - * / % <br>div --取证<br>&amp; | ^ ~  --位运算符<br></code></pre></td></tr></table></figure><p>逻辑运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hive">and or not !<br>in <br>not in<br>exists<br></code></pre></td></tr></table></figure><p>字符串运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">|| --字符串拼接<br></code></pre></td></tr></table></figure><p>复杂类型运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs hive">--复杂类型构造<br>map(key1, value1, ...)<br>struct(val1, val2, ...)<br>named_struct(name1, val1, ...)<br>array(val1, val2, ...)<br>create_union(tag, val1, val2, ...)<br><br>--应用举例<br>select `array`(1, 2, 3) <br>from test<br><br>--复杂类型取值<br>A[n] --array取值<br>M[key] --map取值<br>S.x --struct取值<br></code></pre></td></tr></table></figure><h1 id="hive-函数基础">Hive 函数基础</h1><p>Hive中内置了很多函数，用于满足用户的不同需求。我们可以通过<code>show functions</code>来查看当前可用的所有函数，通过<code>describe function extended func_name</code>来查看函数的使用方式</p><p>Hive中的函数分为两大类：内置函数（Built-inFunctions）和用户定义函数UDF（User-Defined Functions）</p><h2 id="hive-内置函数">Hive 内置函数</h2><p>内置函数根据应用整体可以分为：字符串函数、日期函数、数学函数、集合函数、条件函数、类型转换函数、数据脱敏函数、其他杂项函数。这里只分别介绍常用的函数</p><p>字符串函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs hive">--字符串拼接<br>select concat(&quot;a&quot;,&quot;b&quot;);<br><br>--带分隔符字符串连接函数：concat_ws(separator, [string | array(string)]+)<br>select concat_ws(&#x27;.&#x27;, &#x27;www&#x27;, array(&#x27;a&#x27;, &#x27;cn&#x27;));<br><br>--字符串截取函数：substr(str, pos[, len]) 或者  substring(str, pos[, len])<br>select substr(&quot;hahaha&quot;,-2); --pos是从1开始的索引，可以为负数<br>select substr(&quot;hahaha&quot;,2,2);<br><br>--正则表达式替换函数：regexp_replace(str, regexp, rep)<br>select regexp_replace(&#x27;100-200&#x27;, &#x27;(\\d+)&#x27;, &#x27;num&#x27;);<br><br>--正则表达式解析函数：regexp_extract(str, regexp[, idx]) 提取正则匹配到的指定组内容<br>select regexp_extract(&#x27;100-200&#x27;, &#x27;(\\d+)-(\\d+)&#x27;, 2);<br><br>--URL解析函数：parse_url 注意要想一次解析出多个 可以使用parse_url_tuple这个UDTF函数<br>select parse_url(&#x27;http://www.hahaha.cn/path/p1.php?query=1&#x27;, &#x27;HOST&#x27;);<br><br>--分割字符串函数: split(str, regex)<br>select split(&#x27;apache hive&#x27;, &#x27;\\s+&#x27;);<br><br>--json解析函数：get_json_object(json_txt, path)<br>--path用于指定获取该json对象中的哪一部分，$表示json对象<br>select get_json_object(&#x27;[&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;&#125;,&#123;&quot;key1&quot;:&quot;value3&quot;,&quot;key2&quot;:&quot;value4&quot;&#125;]&#x27;, &#x27;$.[1].key1&#x27;);<br><br>--字符串长度函数：length(str | binary)<br>select length(&quot;hahaha&quot;);<br><br>--字符串反转函数：reverse<br>select reverse(&quot;hahaha&quot;);<br><br>--字符串转大写函数：upper,ucase<br>select upper(&quot;hahaha&quot;);<br>select ucase(&quot;hahaha&quot;);<br><br>--字符串转小写函数：lower,lcase<br>select lower(&quot;HAHAHA&quot;);<br>select lcase(&quot;HAHAHA&quot;);<br><br>--去空格函数：trim 去除左右两边的空格<br>select trim(&quot; hahaha &quot;);<br>--左边去空格函数：ltrim<br>select ltrim(&quot; hahaha &quot;);<br>--右边去空格函数：rtrim<br>select rtrim(&quot; hahaha &quot;);<br><br>--空格字符串函数：space(n) 返回指定个数空格<br>select space(4);<br><br>--重复字符串函数：repeat(str, n) 重复str字符串n次<br>select repeat(&quot;hahaha&quot;,2);<br><br>--首字符ascii函数：ascii<br>select ascii(&quot;hahaha&quot;);  --返回首字符h啊ascii码<br><br>--左补足函数：lpad<br>select lpad(&#x27;hi&#x27;, 5, &#x27;??&#x27;);  --???hi<br>select lpad(&#x27;hi&#x27;, 1, &#x27;??&#x27;);  --h<br><br>--右补足函数：rpad<br>select rpad(&#x27;hi&#x27;, 5, &#x27;??&#x27;);<br><br>--集合查找函数: find_in_set(str,str_array)<br>select find_in_set(&#x27;a&#x27;,&#x27;abc,b,ab,c,def&#x27;);<br></code></pre></td></tr></table></figure><p>日期函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs hive">--获取当前日期: current_date<br>select current_date();<br><br>--获取当前时间戳: current_timestamp<br>--同一查询中对current_timestamp的所有调用均返回相同的值。<br>select current_timestamp();<br><br>--获取当前UNIX时间戳函数: unix_timestamp<br>select unix_timestamp();<br><br>--日期转UNIX时间戳函数: unix_timestamp<br>select unix_timestamp(&quot;2011-12-07 13:01:03&quot;);<br><br>--指定格式日期转UNIX时间戳函数: unix_timestamp<br>select unix_timestamp(&#x27;20111207 13:01:03&#x27;,&#x27;yyyyMMdd HH:mm:ss&#x27;);<br><br>--UNIX时间戳转日期函数: from_unixtime<br>select from_unixtime(1618238391);<br>select from_unixtime(0, &#x27;yyyy-MM-dd HH:mm:ss&#x27;);<br><br>--日期比较函数: datediff  日期格式要求&#x27;yyyy-MM-dd HH:mm:ss&#x27; or &#x27;yyyy-MM-dd&#x27;<br>select datediff(&#x27;2012-12-08&#x27;,&#x27;2012-05-09&#x27;);<br><br>--日期增加函数: date_add<br>select date_add(&#x27;2012-02-28&#x27;,10);<br>--日期减少函数: date_sub<br>select date_sub(&#x27;2012-01-1&#x27;,10);<br><br>--提取日期函数: to_date<br>select to_date(&#x27;2009-07-30 04:17:52&#x27;);<br>--提取年份函数: year<br>select year(&#x27;2009-07-30 04:17:52&#x27;);<br>--提取月份函数: month<br>select month(&#x27;2009-07-30 04:17:52&#x27;);<br>--提起天数函数: day<br>select day(&#x27;2009-07-30 04:17:52&#x27;);<br>--提取小时函数: hour<br>select hour(&#x27;2009-07-30 04:17:52&#x27;);<br>--提取分钟函数: minute<br>select minute(&#x27;2009-07-30 04:17:52&#x27;);<br>--提取秒函数: second<br>select second(&#x27;2009-07-30 04:17:52&#x27;);<br>--提取周函数: weekofyear 返回指定日期所示年份第几周<br>select weekofyear(&#x27;2009-07-30 04:17:52&#x27;);<br></code></pre></td></tr></table></figure><p>数学函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs hive">--取整函数: round  返回double类型的整数值部分 （四舍五入）<br>select round(3.1415926);<br>--指定精度取整函数: round(double a, int d) 返回指定精度d的double类型<br>select round(3.1415926,4);<br><br>--向下取整函数: floor<br>select floor(3.1415926);<br><br>--向上取整函数: ceil<br>select ceil(3.1415926);<br><br>--取随机数函数: rand 每次执行都不一样 返回一个0到1范围内的随机数<br>select rand();<br>--指定种子取随机数函数: rand(int seed) 得到一个稳定的随机数序列<br>select rand(3);<br><br>--二进制函数:  bin(BIGINT a)<br>select bin(18);<br>--进制转换函数: conv(BIGINT num, int from_base, int to_base)<br>select conv(17,10,16);<br>--绝对值函数: abs<br>select abs(-3.9);<br></code></pre></td></tr></table></figure><p>集合函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs hive">--集合元素size函数: size(Map&lt;K.V&gt;) size(Array&lt;T&gt;)<br>select size(`array`(11,22,33));<br>select size(`map`(&quot;id&quot;,10086,&quot;name&quot;,&quot;zhangsan&quot;,&quot;age&quot;,18));<br><br>--取map集合keys函数: map_keys(Map&lt;K.V&gt;)<br>select map_keys(`map`(&quot;id&quot;,10086,&quot;name&quot;,&quot;zhangsan&quot;,&quot;age&quot;,18));<br><br>--取map集合values函数: map_values(Map&lt;K.V&gt;)<br>select map_values(`map`(&quot;id&quot;,10086,&quot;name&quot;,&quot;zhangsan&quot;,&quot;age&quot;,18));<br><br>--判断数组是否包含指定元素: array_contains(Array&lt;T&gt;, value)<br>select array_contains(`array`(11,22,33),11);<br>select array_contains(`array`(11,22,33),66);<br><br>--数组排序函数:sort_array(Array&lt;T&gt;)<br>select sort_array(`array`(12,2,32));<br></code></pre></td></tr></table></figure><p>条件函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs hive">--if条件判断: if(boolean testCondition, T valueTrue, T valueFalseOrNull)<br>--相当于三元运算符<br>select if(1=2,100,200);<br>select if(sex =&#x27;男&#x27;,&#x27;M&#x27;,&#x27;W&#x27;) from student limit 3;<br><br>--空判断函数: isnull( a )<br>select isnull(&quot;allen&quot;);<br>select isnull(null);<br>--非空判断函数: isnotnull ( a )<br>select isnotnull(&quot;allen&quot;);<br>select isnotnull(null);<br><br>--空值转换函数: nvl(T value, T default_value)<br>--如果value为空就将其转换成default_value<br>select nvl(&quot;allen&quot;,&quot;hahaha&quot;);<br>select nvl(null,&quot;hahaha&quot;);<br><br>--非空查找函数: COALESCE(T v1, T v2, ...)<br>--返回参数中的第一个非空值；如果所有值都为NULL，那么返回NULL<br>select COALESCE(null,11,22,33); --11<br>select COALESCE(null,null,null,33); --33<br>select COALESCE(null,null,null); --null<br><br>--条件转换函数: CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END<br>--case when then表达式<br>select case 100 when 50 then &#x27;tom&#x27; when 100 then &#x27;mary&#x27; else &#x27;tim&#x27; end;<br>select case sex when &#x27;男&#x27; then &#x27;male&#x27; else &#x27;female&#x27; end from student limit 3;<br><br>--nullif( a, b ):<br>-- 如果a = b，则返回NULL，否则返回第一个表达式的值<br>select nullif(11,11);<br>select nullif(11,12);<br><br>--assert_true(condition)<br>--如果&#x27;condition&#x27;不为真，则引发异常，否则返回null<br>SELECT assert_true(11 &gt;= 0);<br>SELECT assert_true(-1 &gt;= 0);<br></code></pre></td></tr></table></figure><p>类型转换函数：主要用于显式的数据类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hive">--任意数据类型之间转换:cast<br>select cast(12.14 as bigint);<br>select cast(12.14 as string);<br>select cast(&quot;hello&quot; as int);<br></code></pre></td></tr></table></figure><p>数据脱敏函数：主要完成数据脱敏，屏蔽原始数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs hive">--mask<br>--将查询回的数据，默认大写字母转换为X，小写字母转换为x，数字转换为n。<br>select mask(&quot;abc123DEF&quot;);<br>select mask(&quot;abc123DEF&quot;,&#x27;-&#x27;,&#x27;.&#x27;,&#x27;^&#x27;); --自定义替换的字母<br><br>--mask_first_n(string str[, int n])<br>--对前n个进行脱敏替换<br>select mask_first_n(&quot;abc123DEF&quot;,4);<br>--mask_last_n(string str[, int n])<br>--对后n个进行脱敏替换<br>select mask_last_n(&quot;abc123DEF&quot;,4);<br><br>--mask_show_first_n(string str[, int n])<br>--除了前n个字符，其余进行掩码处理<br>select mask_show_first_n(&quot;abc123DEF&quot;,4);<br>--mask_show_last_n(string str[, int n])<br>select mask_show_last_n(&quot;abc123DEF&quot;,4);<br><br>--mask_hash(string|char|varchar str)<br>--返回字符串的hash编码。<br>select mask_hash(&quot;abc123DEF&quot;);<br></code></pre></td></tr></table></figure><p>其他杂项函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs hive">--如果你要调用的java方法所在的jar包不是hive自带的 可以通过使用add jar命令进行添加<br>--hive调用java方法: java_method(class, method[, arg1[, arg2..]])<br>select java_method(&quot;java.lang.Math&quot;,&quot;max&quot;,11,22);<br>--反射函数: reflect(class, method[, arg1[, arg2..]])<br>select reflect(&quot;java.lang.Math&quot;,&quot;max&quot;,11,22);<br><br>--取哈希值函数:hash<br>select hash(&quot;allen&quot;);<br><br>--current_user()、logged_in_user()、current_database()、version()<br><br>--SHA-1加密: sha1(string/binary)<br>select sha1(&quot;allen&quot;);<br>--SHA-2家族算法加密：sha2(string/binary, int)  (SHA-224, SHA-256, SHA-384, SHA-512)<br>select sha2(&quot;allen&quot;,224);<br>select sha2(&quot;allen&quot;,512);<br>--crc32加密:<br>select crc32(&quot;allen&quot;);<br>--MD5加密: md5(string/binary)<br>select md5(&quot;allen&quot;);<br></code></pre></td></tr></table></figure><h2 id="hive-自定义函数">Hive 自定义函数</h2><p>用户定义函数则可以根据输入输出的行数来分为3类：UDF、UDAF、UDTF</p><ul><li>UDF（User-Defined Function）：普通函数，一进一出</li><li>UDAF（User-Defined <strong>Aggregation</strong>Function）：聚合函数，多进一出</li><li>UDTF（User-Defined <strong>Table-Generating</strong>Function）：表生成函数，一进多出</li></ul><blockquote><p>UDF分类标准扩大化：</p><p>UDF分类标准本来针对的是用户自己编写开发实现的函数，但是现在可以扩大到Hive的所有函数中，包括内置函数和用户自定义函数。因为内置函数也可以满足根据输入输出划分的要求</p></blockquote><p>自定义UDF函数实现步骤：</p><ol type="1"><li>自己写一个Java类，<strong>继承UDF，并重载evaluate方法</strong>，方法中实现函数的业务逻辑（注意重载）</li><li>将程序打包成jar包，上传到服务器环境中（本地或者HDFS）</li><li>在客户端命令行中添加jar包到Hive的classpath中：<code>add jar /.../xxx.jar</code></li><li>注册称为临时函数，即给自定义函数命名：<code>create temporary function 函数名 as 类的全路径</code></li><li>之后就可以在HQL中使用该函数了</li></ol><p>在maven工程中应该引入下面的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hive<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hive-exec<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUDF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UDF</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">evaluate</span><span class="hljs-params">(...)</span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>自定义其他函数如UDTF，规则不尽相同。</p></blockquote><h1 id="hive-函数高级用法">Hive 函数高级用法</h1><h2 id="explode函数和侧视图">explode函数和侧视图</h2><p>explode函数可以接受map、array类型的数据作为输入，然后把输入数据中的每个元素拆开成为一行数据。array类型则一行对应一列，map类型则一行对应两列（Key-Value）</p><p>explode函数是一个UDTF函数，它的执行结果可以理解成为一张虚拟的表，数据来源于源表。我们可以在select中查询源表数据，也可以只查询explode生成的虚拟表数据，但是不能直接查询源表和虚拟表的数据。（不能不做任何处理就查询分别属于两张表的字段）</p><p>explode函数将复杂类型展开之后，展开的每一行和源表的行会有一个对应关系，即源表中一行对应到展开表中的多行，根据这种关系我们可以使用join连接两张表，不过在Hive中给我们提供了侧视图lateralview语法来实现这种效果。explode函数一般会结合侧视图lateralview一起使用</p><img src="/2022/07/04/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-3-Hive%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/%E4%BE%A7%E8%A7%86%E5%9B%BE%E6%95%88%E6%9E%9C.png" class="" title="侧视图效果"><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hive">--单独使用explode函数<br>select explode(col_map) from test_table;<br><br>--UDTF+侧视图<br>select …… from tabelA 别名1 lateral view UDTF(xxx) 别名2 as col1,col2,col3……;<br></code></pre></td></tr></table></figure><p>这里的UDTF可以使用explode函数，当然侧视图的效果可以配合其他的表生成函数一起使用，不仅仅局限于explode函数。</p><ul><li>别名1表示源表的别名</li><li>别名2表示UDTF函数生成的表别名</li><li><code>as col1 col2 col3...</code>表示给生成表中的列取名</li><li>侧视图的底层相当于就是自带条件的inner join</li></ul><h2 id="聚合函数">聚合函数</h2><p>聚合函数的功能是对一组值执行计算并返回单一的值，是典型的UDAF函数，多进一出。通常搭配groupby语法一起使用，在分组之后进行聚合操作</p><p>常见的聚合函数有：</p><ul><li><code>count</code>：统计检索到的总行数</li><li><code>sum</code>：求和</li><li><code>avg</code>：求平均</li><li><code>min</code>：最小值</li><li><code>max</code>：最大值</li><li><code>collect_set(col)</code>：数据收集函数，去重</li><li><code>collect_list(col)</code>：数据收集函数，不qu'chong</li></ul><p>同时Hive来提供增强聚合的方式，包括groupingsets、cube、rollup等函数。增强聚合多用于多维数据分析，它达到的效果是可以综合多个分组后的结果，然后利用字段grouping__id来表示该行是通过哪个分组group得到的。</p><blockquote><p>如果利用已有的方式来达到这样的操作，应该使用union连接多个经过groupby的表，并且需要手动填充null列来保证列数的对应，而使用增强聚合就可以方便地达到这样的效果</p><p>注意<code>grouping__id</code>是双下划线</p></blockquote><p><strong>grouping sets</strong>：</p><p>可以将多个group by逻辑写在一个sql语句中，等价于将不同维度groupby结果集进行union all，grouping__id表示结果数据哪一个分组集合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs hive">select<br>    month,<br>    day,<br>    count(distinct cookieid) as nums,<br>    grouping__id<br>from cookie_info<br>group by month,day<br>grouping sets (month,day) --这里是关键<br>order by grouping__id;<br><br>--等价于<br>--注意这里补充的null，以及grouping__id位置上的1和2<br>select month,null,count(distinct cookieid) as nums,1 as grouping__id from cookie_info group by month<br>union all<br>select null as month,day,count(distinct cookieid) as nums,2 as grouping__id from cookie_info group by day;<br><br></code></pre></td></tr></table></figure><p><strong>cube</strong>：</p><p>cube表示根据group by维度的所有组合进行聚合</p><blockquote><p>例如group by有a bc三个维度，则cube取所有的子集，共8个，注意包括空集，即表示不进行groupby</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs hive">select<br>    month,<br>    day,<br>    count(distinct cookieid) as nums,<br>    grouping__id<br>from cookie_info<br>group by month,day<br>with cube --cube语法，上面group by有两个元素，则最终结果一共有4个grouping__id<br>order by grouping__id;<br><br>--等价于<br><br>select null,null,count(distinct cookieid) as nums,0 as grouping__id from cookie_info<br>union all<br>select month,null,count(distinct cookieid) as nums,1 as grouping__id from cookie_info group by month<br>union all<br>select null,day,count(distinct cookieid) as nums,2 as grouping__id from cookie_info group by day<br>union all<br>select month,day,count(distinct cookieid) as nums,3 as grouping__id from cookie_info group by month,day;<br></code></pre></td></tr></table></figure><p><strong>rollup</strong>：</p><p>rollup是cube的子集，以最左侧的维度为主。只有当左侧维度出现，右侧维度才可能出现。相当于是一个递进的关系</p><blockquote><p>例如group by有a b c三个维度，则rollup取的组合情况有()、(a)、(a,b)、(a, b, c)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs hive">select<br>    month,<br>    day,<br>    count(distinct cookieid) as nums,<br>    grouping__id<br>from cookie_info<br>group by month,day<br>with rollup --rollup语法，聚合维度应该为空、month、month+day三种<br>order by grouping__id;<br><br>--等价于<br><br>select null,null,count(distinct cookieid) as nums,0 as grouping__id from cookie_info<br>union all<br>select month,null,count(distinct cookieid) as nums,1 as grouping__id from cookie_info group by month<br>union all<br>select month,day,count(distinct cookieid) as nums,2 as grouping__id from cookie_info group by month,day;<br></code></pre></td></tr></table></figure><h2 id="窗口函数">窗口函数</h2><h3 id="基本语法">基本语法</h3><p>Hive中的窗口函数也和MySQL中的类似，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">Function(arg1, ...) over ([partition by &lt;...&gt;] [order by &lt;...&gt;][&lt;window_expression&gt;])<br></code></pre></td></tr></table></figure><ul><li>Function表示需要应用的函数，可以是聚合函数（例如sum、max、avg等），可以是排序函数（例如rank、row_number等），可以是分析函数（例如lead、lag、first_value等）</li><li>partition by：分组依据。</li><li>order by：分组内部的排序规则</li><li>window_expression：用于指定窗口的范围</li></ul><blockquote><p>over中的参数是可选的，但是出现与否的效果有所差异：</p><ol type="1"><li>没有partition by，则将整张表看作一个分组</li><li>没有order by没有窗口范围，则计算分组中的所有行</li><li>有order by没有窗口范围，则计算分组中从开始到当前行的范围</li></ol></blockquote><h3 id="窗口表达式">窗口表达式</h3><p>窗口表达式提供给我们一种控制行范围的能力，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hive">--关键字是rows between,可选项有<br>preceding: 往前<br>following: 往后<br>current row: 当前行<br>unbounded preceding: 表示从前面的起点<br>unbounded following: 表示到后面的终点<br></code></pre></td></tr></table></figure><p>举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs hive">--向前3行到当前行，共4行<br>rows between 3 preceding and current row<br><br>--向前3行到向后1行，共5行<br>rows between 3 preceding and 1 following<br><br>--当前行到最后一行<br>rows between current row and unbounded following<br><br>--第一行到最后一行，即分组内的所有行<br>rows between unbounded preceding  and unbounded following<br></code></pre></td></tr></table></figure><h3 id="窗口排序函数">窗口排序函数</h3><p>主要用于给每个分组内的数据打上排序的标号，主要用于TopN的业务分析，<strong>注意窗口排序函数不支持窗口表达式</strong></p><ul><li><code>row_number()</code>：递增，不考虑重复，序号连续</li><li><code>rank()</code>：考虑重复，但是会挤占后续位置，序号可能不连续</li><li><code>dense_rank()</code>：考虑重复，但是不挤占后续位置，序号连续</li></ul><p>窗口排序函数中还有一个<code>ntile()</code>，用于将每个分组内的数据分到指定的若干个桶内，即分为若干个部分，并且为每个桶分配一个桶编号。划分的依据主要是按照顺序平均分配，如果不能平均分配，则优先分配到较小编号的桶中，并且各个桶之间的行数相差最多为1。（对应需求可能是将数据排序后分成几个部分，业务人员只关心其中的一部分）</p><h3 id="窗口分析函数">窗口分析函数</h3><ul><li><code>lag(col, n, default)</code>：返回当前行往上的第n行的对应值，相当于一个数据偏移的操作<ul><li>第一个参数为列名</li><li>第二个参数为n，表示偏移多少行</li><li>第三个参数为默认值，表示如果往上第n行为null的时候，取默认值default。如果不指定，则为null</li></ul></li><li><code>lead(col, n, default)</code>：返回当前行往下的第n行的对应值</li><li><code>first_value()</code>：取分组内排序后的第一个值</li><li><code>last_value()</code>：取分组内排序后的最后一个值</li></ul><p>其中<code>first_value()</code>和<code>last_value()</code>取的是分组范围内的第一个和最后一个，因此窗口范围很重要，要终点关注窗口范围。</p><h2 id="抽样函数">抽样函数</h2><p>抽样是一种用于识别和分析数据中子集的技术，用以发现整个数据集中的模式和趋势。在HQL中，可以通过三种方式来进行数据采样：随机采样，存储桶表采样和块采样</p><p>Random随机采样：</p><ul><li>使用rand()函数确保随机获得数据，使用limit限制抽取的数据个数</li><li>优点是随机，缺点是速度慢<ul><li>推荐使用distribute+sort，底层执行效率更高</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hive">--需求：随机抽取2个学生的情况进行查看<br>select * from student<br>distribute by rand() sort by rand() limit 2;<br><br>--使用order by+rand也可以实现同样的效果 但是效率不高<br>select * from student<br>    order by rand() limit 2;<br></code></pre></td></tr></table></figure><p>Block基于块随机抽样：</p><ul><li>块采样允许随机获取n行数据、百分比数据或者指定大小的数据</li><li>采样粒度是HDFS文件块大小</li><li>优点是速度快，缺点是不随机</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hive">select * from student tablesample(1 rows);<br><br>--根据数据大小百分比抽样<br>select * from student tablesample(50 percent);<br><br>--根据数据大小抽样<br>--支持数据单位 b/b, k/k, m/m, g/g<br>select * from student tablesample(1k);<br></code></pre></td></tr></table></figure><p>Bucket table基于分桶表抽样：</p><ul><li>一种特殊的采样方法，针对分桶表进行优化</li><li>既随机，速度也较快</li></ul><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">tablesample (bucket x out of y [on colname])<br></code></pre></td></tr></table></figure><ol type="1"><li>y必须是table总bucket数的倍数或者因子。hive根据y的大小，决定抽样的比例<ul><li>例如，table总共分了4份（4个bucket），当y=2时，抽取(4/2=)2个bucket的数据，当y=8时，抽取(4/8=)1/2个bucket的数据。</li></ul></li><li>x表示从哪个bucket开始抽取<ul><li>例如，table总bucket数为4，<code>tablesample(bucket 4 out of 4)</code>表示总共抽取（4/4=）1个bucket的数据，抽取第4个bucket的数据</li><li>注意：x的值必须小于等于y的值，否则会报错<code>failed:numerator should not be bigger than denominator in sample clause for table xxx</code></li></ul></li><li>on colname表示基于什么抽<ul><li>on rand()表示随机抽</li><li>on 分桶字段 表示基于分桶字段抽样 效率更高 推荐</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive学习笔记-HiveSQL(2)-数据操控语言DML与数据查询语言DQL</title>
    <link href="/2022/07/04/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-2-%E6%95%B0%E6%8D%AE%E6%93%8D%E6%8E%A7%E8%AF%AD%E8%A8%80DML%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80DQL/"/>
    <url>/2022/07/04/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-2-%E6%95%B0%E6%8D%AE%E6%93%8D%E6%8E%A7%E8%AF%AD%E8%A8%80DML%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80DQL/</url>
    
    <content type="html"><![CDATA[<h1 id="hive-sql-dml">Hive SQL DML</h1><h2 id="load-加载数据">Load 加载数据</h2><p>在前面的笔记中我们看到当我们在Hive中建表成功之后，在HDFS上就会创建一个对应的文件夹，我们可以利用<code>hadoop fs -put</code>直接将数据上传到HDFS上，Hive会自动完成表和底层数据的映射。</p><p>这种方式能够达到目标，但是Hive推荐我们使用Load命令来将数据加载到表中。Load命令能够将数据文件移动到Hive表中对应的位置，在过程中不会对数据内容进行任何转换的操作，保持数据原原本本的状态。</p><p>语法规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hive">load data [local] inpath &#x27;filepath&#x27; [overwrite] <br>into table table_name<br>[partition(part_col1=val1, part_col2=val2,...)]<br>[inputformat &#x27;inputformat&#x27; serde &#x27;serde&#x27;]<br></code></pre></td></tr></table></figure><ul><li><code>filepath</code>：表示待移动的数据的位置，可以是相对路径、绝对路径和具有schema的完整URI。并且需要结合<code>local</code>关键字来确定数据文件的位置，可能是本地数据文件，HDFS数据文件或者其他文件系统下的文件<ul><li>如果没有指定schema，则schema由Hadoop配置文件中的参数<code>fs.default.name</code>指定</li><li><strong>local的本地指的是HiveServer2服务所在的本地Linux文件系统</strong></li></ul></li><li><code>overwrite</code>：覆盖目标表或者分区中已经存在的数据</li><li><code>partition</code>：用于手动指定分区（静态分区操作）</li><li><code>inputformat</code>和<code>serde</code>：用于指定输入格式，例如Text、Orc等</li></ul><blockquote><p>实际常见的数据加载情况有如下的可能：</p><ol type="1"><li>从本地文件系统中加载数据：使用local关键字，本质是<code>hadoop fs -put</code>上传操作</li><li>从HDFS上加载数据：不使用local关键字，本质是<code>hadoop fs -mv</code>移动操作</li></ol></blockquote><p>在Hive3.0之后，Load提供了新特性，在某些场合下会将Load重写为insert asselect。</p><p>具体来说，我们可以利用load来插入分区表。如果在load的时候，表具有分区，但是我们没有在命令中指定分区，则会将load转化为insertasselect，并会假定最后一列作为分区列。这样的话就会要求我们文件的实际列数多于表中的列数，因为最后的列会作为分区列。这也是一种动态分区加载的形式</p><h2 id="insert-插入数据">Insert 插入数据</h2><p>在RDBMS中，我们通常使用insert+values的方式来向表中插入数据，并且执行速度都非常快。在Hive中，我们也可以使用insert+values的方式来插入数据，但是指定的速度非常慢，原因在于Hive的底层会使用MapReduce任务来将数据写入Hive表中，因此我们常用的数据加载方式是使用Load命令而不是insert。</p><p>我们更多的使用方法是insert+select，这表示我们将后面查询返回的结果作为内容插入到指定表中，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs hive">insert into table table_name<br>[partition(part_col1=val1,...)]<br>select 语句<br><br>-- 或者<br><br>insert overwrite table table_name <br>[partition(part_col1=val1,...)]<br>[if not exists]<br>select 语句<br></code></pre></td></tr></table></figure><p>同时Hive中还提供多重插入的功能，Multipleinserts。多重插入指的是一次扫描，多次插入。对应的场景为，我们可能要将一张表中的不同内容插入到不同的表中，按照已有的知识，我们可以使用多个insert+select语句，这样会多次扫描同一张表。<strong>多重插入的思想就是减少扫描的次数，在一次扫描中完成多次的insert操作</strong>，应用举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs hive">--多个insert语句<br>insert into table1<br>select col1 from test_table;<br><br>insert into table2<br>select col2 from test_table;<br><br>--多重插入<br>from test_table<br>insert into table table1<br>select col1<br>insert into table table2<br>select col2<br></code></pre></td></tr></table></figure><p>前面在分区表中，我们也提到过动态分区加载的手段，也是通过insert+select来完成的，详细的细节可以参考前面的的笔记。</p><p>另外，我们可以利用insert来进行数据的导出，将select查询的结果导出成文件存放在文件系统中，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hive">insert overwrite [local] directory directory1<br>    [row format row_format] [stored as file_format]<br>select ... from ...<br><br>--其中的row format如下:<br>row format delimited [fields terminated by char [escaped by char]] [collection items terminated by char]<br>[map keys terminated by char] [lines terminated by char]<br></code></pre></td></tr></table></figure><ul><li>需要注意这里的overwrite会覆盖我们指定的目录</li><li>local表示指定本地文件系统下的目录</li><li>目录可以是完整的指定了scheme的URI，如果没有指定，则同上，使用Hadoop配置变量<code>fs.default.name</code>来决定</li><li>写入文件系统的数据会被序列化为文本，默认列之间使用<code>\001</code>分隔，行之间使用换行符分隔。列也可能是复杂数据类型，则默认会序列化成json的格式。我们也可以在导出的时候自定义指定不同的换行符</li></ul><h2 id="事务表相关操作">事务表相关操作</h2><p>除了Insert之外，常见的DML还有update和delete，但是在前面的笔记中我们也提到，Hive早期是不支持这些操作的，而是在后续的版本迭代中慢慢引入了事务表的支持。在事务表上，我们才可以使用update和delete操作。事务表的背景、创建和局限这里也不再赘述，我们主要关注这些操作的具体原理。</p><p>Hive的文件存储在HDFS上，但是HDFS并不支持对文件的任意修改，则必须采用另外的手段来达成对应的效果。</p><p>事务的操作，会以HDFS文件作为原始的基础数据，用delta文件夹来保存事务操作，记录增量数据。正在执行的事务，会用一个staging开头的文件夹来维护，执行结束之后，得到delta文件，对应事务执行的结果。每执行一次事务操作，都会得到这样一个delta增量文件夹，当访问Hive数据的时候，会根据HDFS原始数据和delta增量文件进行合并，查询最新的数据。</p><p>delta文件夹的具体命名格式为<code>delta前缀_minID_maxID_stmID</code></p><ul><li>delta前缀：如果是insert和update，前缀为delta；如果操作是delete，前缀为delete_delta（update语句采用split-update特性，相当于先删除，后插入）</li><li>minID和maxID：写事务的ID范围</li><li>stmID：语句ID</li></ul><p>在Hive中，会为写事务（insert、update等）创建一个写事务ID，该ID在表范围内唯一；同时有一个语句ID，是在当一个事务中有多条写入语句时使用的，用作唯一标识。</p><p>随着表修改操作的增多，会产生越来越多的delta增量文件，这个时候应该需要进行文件的合并来保证性能。<strong>合并器Compactor</strong>就是一套在HiveMetastore内部运行，用来支持ACID系统的后台进程。所有合并在后台完成，并不会阻止数据的并发读写。合并后，系统将等待所有旧文件读操作完成之后，删除旧文件。</p><p>合并操作分为两种，Minor Compaction和Major Compaction</p><ul><li>MinorCompaction：小合并，将一组delta增量文件重写为单个增量文件，默认触发条件为10个delta文件</li><li>MajorCompaction：大合并，将一个或多个增量文件以及基础文件重写为新的基础文件，默认触发条件为delta文件相应于基础文件超过10%</li></ul><h1 id="hive-sql-dql">Hive SQL DQL</h1><h2 id="select-语法树">select 语法树</h2><p>Hive中的DQL数据查询语言主要指的就是select查询操作，select的语法树如下所示（表名和列名不区分大小写）</p><img src="/2022/07/04/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-2-%E6%95%B0%E6%8D%AE%E6%93%8D%E6%8E%A7%E8%AF%AD%E8%A8%80DML%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80DQL/select%E8%AF%AD%E6%B3%95%E6%A0%91.png" class="" title="select语法树"><h2 id="select-基础查询语法">select 基础查询语法</h2><p>select中的基础查询语法包括如下关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hive">select all distinct ...<br>from ...<br>where ...<br>group by ...<br>having ...<br>limit ...<br></code></pre></td></tr></table></figure><p>这些基础语法的用法与MySQL中的语法类似，这里只简单介绍一下</p><ul><li><p>默认使用all表示不去重，distinct表示去重</p></li><li><p>分区裁剪：在查询的时候可以指定分区进行查询，减少全表扫描（可以将分区的虚字段当成普通字段使用）</p></li><li><p>出现在group by中select的字段，要么是groupby分组的字段，要么是被聚合函数应用的字段</p></li><li><p>where和having的含义与用法与SQL相同</p></li><li><p>limit用于限制select语句返回的行数</p></li><li><p>执行顺序：from &gt; where &gt; group &gt; having &gt; order &gt;select</p></li><li><p>在select语句中可以使用正则表达式来匹配字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hive">--查询匹配正则表达式的所有字段<br>set hive.support.quoted.identifiers=none;<br>--表示反引号不再解释为其他含义，被解释为正则表达式<br>select `^c.*` from table_name<br>--查询所有以c开头的列字段<br></code></pre></td></tr></table></figure></li></ul><h2 id="select-排序相关语法">select 排序相关语法</h2><p>Hive SQL中的排序相关语法在语法树中主要体现为以下关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">order by<br>cluster by<br>distribute by sort by<br></code></pre></td></tr></table></figure><p><strong>order by</strong></p><p>首先是order by语法。Hive SQL中的order by语法也类似于标准SQL中的orderby语法，它会对输出的结果进行全局排序。</p><blockquote><p>这也就意味着当底层是使用MapReduce引擎执行的时候，只有一个ReduceTask执行。如果输出的行数太大，会导致需要很长时间才能完成全局排序</p></blockquote><p>默认的排序顺序为升序asc，也可以指定为降序desc</p><p>在Hive2.1.0之后，也支持在orderby子句中为每个列指定null类型结果排序顺序，关键字为nulls first和nullslast。<strong>asc顺序的默认空排序顺序为nullsfirst、desc顺序的默认空排序顺序为nulls last</strong>。</p><blockquote><p>强烈建议将limit于order by配合使用，以避免数据集行数过大</p><p>当hive.mapred.mode设置为strict严格模式的时候，使用不带limit的orderby会引发异常</p></blockquote><p><strong>cluster by</strong></p><p>前面的order by可以对数据进行全局排序，clusterby达到的效果就是根据字段将数据进行分组，然后每组内再根据该字段进行正序排序（<strong>只能正序</strong>）。总结来说就是根据同一个字段划分，之后再分区内部正序排序</p><p>这里就会涉及到两个重要的问题，如何划分以及划分成多少个区域</p><p>划分的规则与分桶表相同，利用hash散列函数。而划分成多少个区域则取决于启动的ReduceTask任务的个数。如果我们不指定ReduceTask任务的话，默认情况只启动一个Reduce Task，这种情况就和正序的orderby类似；当然我们也可以手动指定Reduce Task的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs hive">--不指定Reduce Task个数，默认为1<br>select * from table_name <br>cluster by col_name<br><br>--手动指定Reduce Task个数<br>set mapreduce.job.reduces=2;<br><br>select * from table_name <br>cluster by col_name<br></code></pre></td></tr></table></figure><p><strong>distribute by sort by</strong></p><p>从前面clusterby的介绍可以看出，虽然达到了分区的效果，但是还是有一定的局限性，即分区和排序只能按照同一个字段进行。而distributeby + sort by的效果就是分区和排序按照不同的字段，distributeby指定分区字段，sort by指定排序字段，同时可以指定正序或者倒序字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">select * from table_name<br>distribute by col1<br>sort by col2 desc<br></code></pre></td></tr></table></figure><p>如果distribute by和sort by指定同一个字段并且使用正序排序，就和clusterby功能相同。</p><blockquote><p>排序相关语法的对比：</p><ol type="1"><li>order by是全局排序，无论配置如何，最终启动的还是只有一个ReduceTask任务</li><li>clusterby完成分组和排序，但是只能按照同一个字段进行，且是正序排序。分组算法为hash散列，分组个数与ReduceTask个数有关，可以手动设置，也可以是使用默认的1</li><li>distribute by + sort by可以看作是升级版的clusterby，分组字段和排序字段可以不同</li></ol></blockquote><h2 id="union-联合查询">union 联合查询</h2><p>union用于将来自多个select语句的结果合并成为一个结果集，后面可以使用all或者distinct关键字，表示是否删除重复的行。默认行为为distinct</p><blockquote><p>SQL中的union默认行为也是distinct</p></blockquote><p>union必须保证每个select语句返回的列数量和名称必须相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hive">select_statement<br>union [all | distinct]<br>select_statement <br>union [all | distinct] <br>select_statement ...;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，使用union的必须是单个select语句，如果要应用orderby，sort by，cluster by，distributeby或limit的话，应该要使用子查询的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">select col1,col2 from (select col1,col2 from table_1 limit 2)  temp1<br>union<br>select col1,col2 from (select col1,col2 from table_2 limit 3) temp2;<br></code></pre></td></tr></table></figure><h2 id="cte使用">CTE使用</h2><p>CTE，全称为Common TableExpressions，意为公共表表达式。这是一个临时结果集，从with子句中的指定查询派生而来。CTE定义临时结果集之后，可以当作一个普通的表来使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs hive">--select语句中的CTE<br>with q1 as (select col1,col2 from table_name where col3 = xxx)<br>select *<br>from q1;<br><br>-- from风格<br>with q1 as (select col1,col2 from table_name where col3 = xxx)<br>from q1<br>select *;<br><br>-- chaining CTEs 链式风格<br>with q1 as (select col1,col2 from table_name where col3 = xxx),<br>     q2 as (select col1,col2 from table_name where col3 = yyy)<br>select * from (select col1 from q2) a;<br></code></pre></td></tr></table></figure><ul><li>CTE仅在单个语句的执行范围内定义</li></ul><h1 id="hive-sql-join-连接操作">Hive SQL join 连接操作</h1><p>在Hive中目前支持6中join语法，分别是inner join（内连接）、leftjoin（左连接）、right join（右连接）、full outer join（全外连接）、leftsemi join（左半开连接）、crossjoin（交叉连接，也叫做笛卡尔乘积）。<strong>join的条件仍然是使用on来指定</strong></p><blockquote><p>从Hive0.13.0开始，支持隐式联接表示法。允许FROM子句连接以逗号分隔的表列表，而省略JOIN关键字。</p><p>从Hive2.2.0开始，支持ON子句中的复杂表达式，支持不相等连接。在此之前，Hive不支持不是相等条件的联接条件。</p></blockquote><p>其中内连接、左连接、右连接、全外连接这些操作和SQL中的定义都相同，我们已经很熟悉了，这里就介绍剩下的左半开连接和交叉连接。</p><p>左半开连接（left semijoin）类似于内连接的逻辑，但是只返回其中在左表的字段。即最终返回的结果行是内连接得到的行，但是字段只有在左表中出现的字段。</p><p>交叉连接（cross join）则会返回两个表的笛卡尔积。</p><blockquote><ul><li>在SQL标准中，笛卡尔积是没有条件的inner join</li><li>在Hive SQL语法中，crossjoin后面可以使用where子句或on条件过滤，但是还是先笛卡尔积，然后根据条件过滤</li></ul></blockquote><p>join的使用注意事项：</p><ol type="1"><li><p>允许使用复杂的连接表达式，支持非等值连接</p></li><li><p>同一个查询中可以连接两个以上的表</p></li><li><p>如果每个表在连接子句中使用相同的列，则Hive会将多个表上的连接转换成单个MapReduce作业</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hive">SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1)<br>--由于联接中仅涉及b的key1列，因此被转换为1个MR作业来执行<br>SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key2)<br>--会转换为两个MR作业，因为在第一个连接条件中使用了b中的key1列，而在第二个连接条件中使用了b中的key2列<br>--第一个map / reduce作业将a与b联接在一起，然后将结果与c联接到第二个map / reduce作业中<br></code></pre></td></tr></table></figure></li><li><p>join时最后一个表会通过Reducer进行流式传输，并在其中缓存之前的其他表（相当于是将最后一个表流式传输，进来一个join一个）。因此将大表放置在最后有助于减少Reducer阶段缓存数据所需要的内存（也是我们通常习惯的<strong>小表接大表</strong>）</p></li><li><p>在join的时候，也可以通过关键字<code>streamtable</code>显式指定需要流式传输的表。如果省略，则Hive将流式传输最右边的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">select streamtable(a) a.val, b.val c.val<br>from a join b on (a.key = b.key1)<br>join c on (c.key = b.key1)<br></code></pre></td></tr></table></figure></li><li><p>如果除了一个要连接的表之外的所有表都很小，则可以将其作为仅map作业执行（mapjoin，没有Reduce阶段）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hive">select mapjoin(b) a.key, a.value <br>from a join b on a.key=b.key<br>--这样就不需要启动reducer，对于a的每个Mapper，b表数据都会被完全读取。<br>--限制是不能执行full/right outer join b<br>--因为full join b或者right outer join b，b表中的一行都要去找所有的a表数据<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive学习笔记-HiveSQL(1)-数据定义语言DDL</title>
    <link href="/2022/07/03/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-1-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL/"/>
    <url>/2022/07/03/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-1-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL/</url>
    
    <content type="html"><![CDATA[<h1 id="数据定义语言概述">数据定义语言概述</h1><p>数据定义语言（Data Definition Language，DDL），是SQL中对数据库内部的对象结构进行创建，删除，修改等操作的语言，核心语法由create、alter和drop三个部分组成，并不涉及表内部数据的操作</p><p>Hive SQL与标准SQL的语法大体相同，在细节处存在少量差异。</p><blockquote><p>推荐使用IDEA中的DataBase来连接Hive，其中需要下载指定对应版本的驱动。</p></blockquote><h1 id="hive-sql-ddl-建表语法">Hive SQL DDL 建表语法</h1><h2 id="完整语法树">完整语法树</h2><p>Hive建表语法的完整语法树如下：</p><img src="/2022/07/03/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-1-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL/Hive%E5%BB%BA%E8%A1%A8%E8%AF%AD%E6%B3%95.png" class="" title="Hive建表语法"><ul><li>蓝色字体是建表语法的关键字，用于指定某些特定的功能</li><li>【】中括号的语法表示可选</li><li><divclass="line-block">表示使用的时候，左右语法需要二选一</div></li><li><strong>建表语法中，语法顺序需要和语法树中的顺序保持一致</strong></li></ul><h2 id="数据类型">数据类型</h2><p>Hive中的数据类型整体上分为原生数据类型和复杂数据类型</p><ul><li>原生数据类型包括：数值类型、时间日期类型、字符串类型、杂项数据类型</li><li>复杂数据类型包括：Array数组、Map映射、Struct结构、Union联合体</li></ul><p>注意事项：</p><ol type="1"><li>HQL中，数据类型<strong>大小写不敏感</strong></li><li>除了SQL数据类型之外，也支持Java数据类型</li><li>复杂数据类型的使用通常需要和分隔符指定语法来配合使用</li><li>如果定义的数据类型和文件中的内容不一致，Hive会尝试隐式转换，但是不保证成功</li><li>也提供显示类型转换的函数CAST</li></ol><h2 id="读写文件机制">读写文件机制</h2><p>首先介绍SerDE。SerDe是Serializer、Deserializer的简称，目的是用于序列化和反序列化。Hive中使用SerDE读取和写入表中的行对象。</p><p>具体来说，在读取HDFS文件的时候，首先通过InputFileFormat以键值对的形式读取一行的数据，然后通过SerDE进行反序列化得到行对象。在写HDFS文件的时候，先通过SerDe进行行对象的序列化，得到键值对的形式，然后通过OutputFileFormat写入HDFS文件中。（需要注意的是键值对中的Key表示行偏移量，在读取的时候会被忽略，在写入的时候key始终是常数，行对象基本存储在value中）</p><p>我们可以通过<code>desc formatted table_name</code>来查看表的相关SerDe的信息。默认情况下：</p><ul><li>SerDe使用的是：<code>org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe</code></li><li>InputFormat使用的是：<code>org.apache.hadoop.mapred.TextInputFormat</code></li><li>OutputFormat使用的是：<code>org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat</code></li></ul><p>在语法树中，相关语法是<code>row format</code>，用于指定使用哪个SerDe类进行序列化，以及如何指定分隔符</p><p>row format是语法关键字，后面需要跟上delimited和serde二选一</p><ul><li>delimited表示使用默认的LazySimpleSerDe类来处理数据，也是默认使用的关键字</li><li>serde表示指定其他的SerDe类，或者自己自定义的SerDE类来处理数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hive">--默认使用delimited<br>row format delimited<br>[fields terminated by &#x27;xxx&#x27;] --指定字段之间的分隔符<br>[collection items terminated by &#x27;xxx&#x27;] --指定集合元素之间的分隔符<br>[map keys terminated by &#x27;xxx&#x27;] --指定Map里面KV之间的分隔符<br>[lines terminated by &#x27;xxx&#x27;] --指定行数据之间的分隔符<br></code></pre></td></tr></table></figure><p>如果在建表的时候如果没有使用rowformat指定分隔符，则采用默认分隔符，默认分隔符为<code>\001</code>，是一种特殊字符，在Vim编辑器中表现为<code>^A</code>，在一些文本编辑器中，可以显示的表示法显示为<code>SOH</code></p><ul><li>这里的分隔符都是单字节，类型为char的分隔符</li></ul><h2 id="数据存储路径">数据存储路径</h2><p>一般情况下，我们使用建表语句创建表之后，会在HDFS中对应目录下创建一个文件夹，代表该表，之后我们向其中上传HDFS文件，如果文件中的内容和表模式匹配上的话，Hive就会帮我们完成文件到表的映射。</p><p>Hive表默认存储路径是由<code>$&#123;HIVE_HOME&#125;/conf/hive-site.xml</code>配置文件的<code>hive.metastore.warehouse.dir</code>属性指定，默认值为：<strong>/user/hive/warehouse</strong>。在该路径下，文件将根据所属的库、表，有规律地存储在对应的文件夹下。</p><p>当然我们也可以不使用默认的存储路径，而在创建表的时候指定该表读取哪个目录下的文件，通过<strong>location</strong>语法来指定数据在HDFS上的存储路径，使得建表加载数据更加灵活方便。</p><blockquote><p>如果指定了数据的路径，那么对应的默认路径下将没有该表的文件夹</p></blockquote><h2 id="hive-内部表和外部表">Hive 内部表和外部表</h2><p>在Hive中存在内部表和外部表的概念。</p><p><strong>内部表</strong>：</p><ul><li>内部表（Internal Table），也称为托管表（Managed Table）</li><li>Hive拥有内部表的结构和文件，完全管理表（元数据+真实数据）的声明周期</li><li><strong>当我们删除表的时候，会删除真实数据以及表的元数据</strong></li><li>默认情况下创建的表属于内部表</li></ul><p><strong>外部表</strong>：</p><ul><li>外部表（ExternalTable），其中的数据不是Hive拥有或者管理的，Hive只管理外部表元数据的生命周期</li><li>创建外部表，只需要在创建表的时候增加<code>external</code>关键字</li><li><strong>删除外部表只会删除元数据，不会删除实际数据</strong>。在Hive外部，HDFS上仍然可以访问到真实数据</li></ul><blockquote><p>通常我们会使用外部表搭配location语法来指定数据的路径，让数据更加安全。但是需要注意的是，location的使用与否与是否是外部表没有绝对的联系。</p></blockquote><h2 id="hive-partitioned-分区表">Hive Partitioned 分区表</h2><p>分区表是Hive中的一种优化手段。当Hive表中的数据量变大，文件个数变多的时候，为了避免查询的时候进行全表扫描，Hive支持根据指定的字段对表进行分区，分区的字段可以是日期、地域、种类等具有标识意义的字段。</p><p>表现在HDFS文件的存储上，表文件夹下会有多个分区文件夹，命名形式为<code>分区字段=分区值</code>，在不同的分区文件夹下，存放了分区对应的数据文件</p><img src="/2022/07/03/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-1-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL/%E5%8D%95%E5%88%86%E5%8C%BA%E5%9C%A8hdfs%E4%B8%8A%E7%9A%84%E5%AD%98%E5%82%A8.png" class="" title="单分区在hdfs上的存储"><p>在建表语法中，分区功能通过<code>partitioned by</code>关键字来完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">partitioned by &#123;col_name data_type [comment col_comment],...&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：<strong>分区字段不能是表中已经存在的字段</strong>，因为分区字段最终会以虚拟字段的形式显示在表结构上</li></ul><p>我们既然不能指定分区字段是表中已经存在的字段，但是总得有一种方式告诉Hive我们的数据是处在哪个分区中。Hive中提供两种分区表数据加载的模式，分别是静态分区和动态分区加载。</p><p>首先明确一个前提，我们已经执行了建表语句，其中指定了分区字段假设为<code>col_name</code>，注意分区字段的名称不和实际字段重复。此时在HDFS上已经存在了对应的表文件夹</p><p><strong>静态分区加载</strong>：</p><p>静态分区指的是我们人为指定某个文件属于哪一个分区，这样我们应该保证在实际场景下，文件中的所有行都是对应分区下的数据。</p><p>使用如下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">load data [local] inpath &lt;file_path&gt; into table &lt;table_name&gt; partition(分区字段=&#x27;分区值&#x27;)<br></code></pre></td></tr></table></figure><ul><li>local参数用于指定待加载的数据是位于本地文件系统还是HDFS文件系统</li><li>需要指定文件路径、表名、该文件下数据对应的分区值</li></ul><p>总结来说，如果使用静态分区加载，我们需要事先准备不同的文件，每个文件下的数据，分区值都是相同的，然后按照分区值手动进行文件加载。这样Hive就会将文件组织成分区文件夹的格式，并且在底层按照分区表来管理数据。</p><p><strong>动态分区加载</strong>：</p><p>动态分区指的是分区的字段值是基于查询结果（参数位置自动推断出来的），核心语法为<strong>insert+select</strong>。具体来说，我们插入表中的结果是从其他的表查询得到的，在查询的过程中根据分区字段的值来划分到不同的分区中，因此，我们需要事先有一张数据表。</p><p>启用Hive动态分区，需要在Hive会话中设置下面两个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hive">--是否开启动态分区<br>set hive.exec.dynamic.partition=ture;<br><br>-- 指定动态分区模式，分为nonstrict非严格模式和strict严格模式<br>-- strict严格模式下，要求至少有一个分区为静态分区<br>set hive.exec.dynamic.partition.mode=nonstrict<br></code></pre></td></tr></table></figure><blockquote><p>严格模式经常和多分区匹配使用，其中至少要有一个分区为jing'tai</p></blockquote><p>之后结合insert和select进行动态分区加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hive">insert into table 动态分区表 partition(role) <br>select tmp.*,tmp.role_main from 查询表 as tmp;<br></code></pre></td></tr></table></figure><ul><li>role为我们指定的分区字段</li><li>role_main为查询表中的具体字段，我们将这个字段的值作为分区的依据</li><li>根据位置进行分区字段的对应，即tmp.role_main对应到分区字段</li></ul><p>总结来说，如果使用动态分区加载，完成的逻辑就是从已有的表中进行查询，然后将需要作为分区依据的字段查询到最后，然后插入分区表中。这样Hive会在查询的过程中判断分区字段，然后存放到不同的分区文件夹中。</p><p>上面说的是单分区，实际上观察建表语句中分区的相关语法，我们可以发现Hive也支持多重分区，只需要在partitionedby后面指定多个分区字段即可。但是分区字段有先后之分，是一种递进的关系。具体来说会在前一个分区文件夹下继续划分子文件夹。</p><p>分区表的本质在于提供了一种将Hive表数据分离成多个目录的方法。不同分区对应不同文件夹，同一分区的数据存储在同一个文件夹下。在查询过滤的时候只需要根据分区值找到对应的文件夹，然后扫描文件夹下本分区的文件即可，这样就避免了全表扫描。这种指定分区查询的方式就叫做<strong>分区裁剪</strong>。</p><p>分区表的使用重点在于，建表的时候要根据业务场景设置合适的分区字段，例如日期、地域、类别等，然后在查询的时候尽量先使用where进行分区过滤，查询指定分区的数据来避免全表扫描。</p><blockquote><p>简单总结：</p><ol type="1"><li>分区表不是建表的必要语法规则，是一种优化手段，可选</li><li>分区字段不能是表中已有的字段，不能重复</li><li>分区字段是虚拟字段，其数据并不存储在底层的文件中</li><li>分区字段值的确定来自于用户手动指定（静态分区）或者根据查询结果位置自动推断（动态分区）</li><li>Hive支持多重分区，也就是说在分区的基础上继续分区，划分更加细粒度</li></ol></blockquote><h2 id="hive-bucketed-分桶表">Hive Bucketed 分桶表</h2><p>分桶表也是Hive中的一种优化方式。分桶表对应的数据文件在HDFS底层会被分解为若干个部分，即被拆分成多个独立的小文件。拆分的依据在建表的时候指定要根据哪个字段将数据分为几个部分。</p><p><img src="/2022/07/03/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HiveSQL-1-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL/%E5%88%86%E6%A1%B6%E8%A1%A8.png" class="" title="分桶表"></p><p>具体语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">clustered by (col_name) <br>[sorted by (xxx desc|asc)]<br>into n buckets;<br></code></pre></td></tr></table></figure><ul><li>分别指定分桶的字段和分成几个桶</li><li>需要注意的是<strong>分桶的字段必须是表中已经存在的字段</strong></li><li>在创建分桶表的时候，还可以指定分桶内的数据排序规则</li><li>分桶规则如下：桶编号相同的数据会被分到一个桶当中</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Bucket number = hash<span class="hljs-emphasis">_function(bucketing_</span>column) mod num<span class="hljs-emphasis">_buckets</span><br></code></pre></td></tr></table></figure><ul><li>哈希方法取决于分桶字段的类型，如果是ini则直接是原值，如果是其他复杂数据类型，哈希方法是从该类型派生出来的某个数字，例如hashcode值</li></ul><p>分桶表的数据加载需要经过如下的流程，核心语法也是<strong>insert+select</strong>：</p><ol type="1"><li><p>开启分桶的功能（从Hive2.0开始不需要设置，默认开启）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">set hive.enforce.bucketing=ture<br></code></pre></td></tr></table></figure></li><li><p>将源数据加载到普通的hive表中，包括hive表创建以及文件上传到HDFS对应路径两个步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">-- 普通hive表这里命名为tmp<br></code></pre></td></tr></table></figure></li><li><p>使用分桶语法创建分桶表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">-- 分桶表这里命名为bucket_table<br></code></pre></td></tr></table></figure></li><li><p>使用insert+select语法将数据加载到分桶表中（类似于分区表的动态架加载）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">insert into bucket_table select * from tmp;<br></code></pre></td></tr></table></figure></li></ol><p>经过以上的流程之后，就可以将数据加载到分桶表中。并且在HDFS上查看对应目录可以发现数据被分成了几个部分，分桶字段一样的数据就一定被分到了同一个桶中。</p><p>分桶表的核心在于原始的数据被拆分成了不同的文件，分桶字段对应值相同的数据进入同一个桶（同一个桶中，数据的对应字段可能不同）</p><p>使用分桶表可以带来下面的好处：</p><ol type="1"><li>基于分桶字段查询的时候，减少全表扫描</li><li>在Join的时候可以提高效率，减少笛卡尔积的数量（基于分桶字段join）</li><li>分桶表数据进行高效抽样</li></ol><h2 id="hive-transactional-事务表">Hive Transactional 事务表</h2><p>Hive本身从设计之初时，就是不支持事务的，因为Hive的核心目标是将已经存在的结构化数据文件映射成为表，然后提供基于表的SQL分析处理，是一款面向分析的工具。且映射的数据通常存储于HDFS上，而HDFS是不支持随机修改文件数据的。这个定位就意味着在早期的Hive的SQL语法中是没有update，delete操作的，也就没有所谓的事务支持了，因为都是select查询分析操作。</p><p>从Hive0.14版本开始，事务开始添加到Hive中，解决一些可能需要事务的场景，例如流式传输数据、数据修正、插入或更新单条记录等场景。</p><p>但是Hive毕竟不是专门用于这类场景的工具，虽然支持了具有ACID性质的事务，在使用的时候还是有很多局限性：</p><ul><li>不支持事务的begin、commit和rollback，操作都是自动提交</li><li>仅支持orc文件格式</li><li>默认情况下事务配置关闭，需要手动配置参数开启</li><li>表参数transactional必须为true</li><li>外部表不能成为ACID表，不允许从非ACID会话读取或写入ACID表</li></ul><p>对于一个普通表，我们执行update、delete和insert操作，只有insert语句可以执行，update和delete操作会报错，这是因为insert操作底层是直接把数据写在了一个新的文件当中</p><p>而开启了事务之后，可以执行update和delete操作，但是底层并不是随机修改的（由于HDFS不支持随机修改），而是通过标记机制来达到对应的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs hive">--Hive中事务表的创建使用<br>--1、开启事务配置（可以使用set设置当前session生效 也可以配置在hive-site.xml中）<br>set hive.support.concurrency = true; --Hive是否支持并发<br>set hive.enforce.bucketing = true; --从Hive2.0开始不再需要  是否开启分桶功能<br>set hive.exec.dynamic.partition.mode = nonstrict; --动态分区模式  非严格<br>set hive.txn.manager = org.apache.hadoop.hive.ql.lockmgr.DbTxnManager; --<br>set hive.compactor.initiator.on = true; --是否在Metastore实例上运行启动线程和清理线程<br>set hive.compactor.worker.threads = 1; --在此metastore实例上运行多少个压缩程序工作线程。<br><br>--2、创建Hive事务表<br>drop table if exists trans_student;<br>create table trans_student(<br>   id int,<br>   name String,<br>   age int<br>)clustered by (id) into 2 buckets stored as orc TBLPROPERTIES(&#x27;transactional&#x27;=&#x27;true&#x27;);<br>--注意 事务表创建几个要素：开启参数、分桶表、存储格式orc、表属性<br></code></pre></td></tr></table></figure><p>关于事务表更加详细的说明可以查看后续的笔记。</p><h2 id="hive-views-视图">Hive Views 视图</h2><p>Hive中的视图View是一张虚拟的表，只保存定义，而不实际存储数据。我们可以将视图看作是一张普通的Hive表</p><ul><li>通常从真实的物理表查询中创建生成视图，也可以从已经存在的视图上创建新视图</li><li>创建视图的时候，会冻结视图的架构。如果删除或更改基础表，则视图失效</li><li>视图是用来简化操作的，不会缓冲记录，也不会提高查询的性能</li></ul><p>视图的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs hive">-- 创建视图<br>create view &lt;视图名称&gt; as select * from xxx;<br><br>-- 删除视图<br>drop view &lt;视图名称&gt;<br><br>-- 更改视图属性<br>alter view &lt;视图名称&gt; set tblproperties(&#x27;comment&#x27;=&#x27;new_comment&#x27;)<br><br>-- 更改视图定义<br>alter view &lt;视图名称&gt; as [新的selet语句]<br></code></pre></td></tr></table></figure><p>使用视图可以将真实表中的特定列数据提供给用户，保护数据的隐私；也可以降低查询的复杂度，优化查询语句。</p><h2 id="hive-materialized-views-物化视图">Hive Materialized Views物化视图</h2><p>物化视图是Hive3.0中的新特性，指的是一个包括查询结果的数据库对象，可以用于预先计算并保存操作的结果。相当于一个预处理和缓存的操作，在执行查询的时候，可以避免进行这些耗时的操作，从而快速地得到结果。</p><p>使用物化视图的目的就是通过预先计算来提高查询性能，当然相应的需要占用一定的存储空间。</p><ul><li>Hive3.0开始尝试引入物化视图，并提供对于物化视图的查询自动重写机制（基于ApacheCalcite实现）</li><li>Hive的物化视图还提供了物化视图存储选择机制，可以本地存储在Hive，也可以通过用户自定义storagehandlers存储在其他系统（如Druid）</li><li>Hive引入物化视图的目的就是为了优化数据查询访问的效率,相当于从数据预处理的角度优化数据访问</li><li>Hive从3.0丢弃了index索引的语法支持，推荐使用物化视图和列式存储文件格式来加快查询的速度</li></ul><blockquote><p>视图 VS 物化视图：</p><ol type="1"><li>视图是虚拟的，只有定义没有存储数据</li><li>物化视图是真实的，里面存储了预计算的数据</li><li>使用物化视图的时候，直接将物化视图当作一张表，将数据缓存</li><li>使用视图的时候，对于用户来说这是可以当作一张表，但是对于Hive来说实际查询的时候还是再去执行SQL去访问实际的数据表</li><li>视图的目的是简化降低查询的复杂度</li><li>物化视图的目的是提高查询性能</li></ol></blockquote><p>物化视图的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hive">create materialized view &lt;物化视图名称&gt;<br>as select语句<br></code></pre></td></tr></table></figure><ul><li><p>物化视图创建之后，会自动执行select来查询。直到查询完成之后物化视图才变成可用状态</p></li><li><p>当数据源发生变更，物化视图也应该需要更新来保持数据的一致性，但是目前需要用户主动触发rebuild进行重构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">alter materialized view &lt;物化视图名称&gt; rebuild;<br></code></pre></td></tr></table></figure></li></ul><p><strong>基于物化视图的查询重写</strong>：这是一种查询的优化手段，物化视图创建之后可以用于相关查询的加速。如果用户提交了一个查询，而这个查询正好和某个物化视图的定义相同，则可以直接通过物化视图返回结果，以实现查询的加速</p><p>是否使用基于物化视图的查询重写可以通过全局参数控制，默认为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">hive.materializedview.rewriting=true;<br></code></pre></td></tr></table></figure><p>用户也可以选择性的控制，指定特定的物化视图用于重写机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">alter materialized view &lt;物化视图名称&gt; enable|disable rewrite;<br></code></pre></td></tr></table></figure><h1 id="hive-sql-ddl-其他语法">Hive SQL DDL 其他语法</h1><h2 id="database-数据库操作">DataBase 数据库操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs hive">--创建数据库<br>create database if not exists test_database<br>comment &quot;数据库注释说明&quot; --指定数据库的注释说明<br>location hdfs_path --指定数据库在hdfs上的存储位置<br>with dbproperties (&#x27;createdBy&#x27;=&#x27;xxx&#x27;); -- 指定数据库的属性配置<br><br>--描述数据库信息<br>describe database test_database;<br>describe database extended test_database; --显示更多信息<br>desc database extended test_database; --简写<br><br>--切换数据库<br>use default;<br>use test_database;<br><br>--删除数据库<br>--注意 CASCADE关键字慎重使用<br>--默认情况下只有在数据库为空的时候才可以删除，使用的是restrict，但是我们可以使用CASCADE来强制删除<br>drop (database|schema) [if exists] database_name [restrict|cascade];<br>drop database test_database cascade ;<br><br>--更改数据库属性<br>alter (database|schema) database_name set dbproperties (property_name=property_value, ...);<br>--更改数据库所有者<br>alter (database|schema) database_name set owner [user|role] user_or_role;<br>--更改数据库位置<br>alter (database|schema) database_name set location hdfs_path;<br></code></pre></td></tr></table></figure><h2 id="table-表操作">Table 表操作</h2><p>Hive中针对表的操作是DDL中的核心操作，包括建表、修改表、删除表、描述表元数据信息，其中的建表语句又是一个核心。</p><blockquote><p>由于Hive建表之后加载映射数据很快，实际中如果建表有问题，更多可以直接删除重建</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hive">--查询指定表的元数据信息<br>describe formatted test_database.test_table;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hive">--删除表<br>--删除表的元数据和数据<br>drop table [if exists] table_name [purge]<br>--清空表(从表中删除所有行，但是保留表的元数据结构)<br>truncate table table_name<br></code></pre></td></tr></table></figure><ul><li>如果配置了垃圾桶但是没有指定purge，则该表对应的数据实际上移动到HDFS垃圾桶，但是元数据完全丢失；如果指定了purge，则表数据跳过HDFS垃圾桶，直接删除实际数据</li><li>删除外部表，只删除元数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs hive">--修改操作<br>--1、更改表名<br>alter table table_name rename to new_table_name;<br><br>--2、更改表属性<br>alter table table_name set tblproperties (property_name = property_value, ... );<br>--更改表注释<br>alter table student set tblproperties (&#x27;comment&#x27; = &quot;new comment for student table&quot;);<br><br>--3、更改serde属性<br>alter table table_name set serde serde_class_name [with serdeproperties (property_name = property_value, ... )];<br>alter table table_name [partition partition_spec] set serdeproperties serde_properties;<br>alter table table_name set serdeproperties (&#x27;field.delim&#x27; = &#x27;,&#x27;);<br>--移除serde属性<br>alter table table_name [partition partition_spec] unset serdeproperties (property_name, ... );<br><br>--4、更改表的文件存储格式 该操作仅更改表元数据。现有数据的任何转换都必须在hive之外进行。<br>alter table table_name  set fileformat file_format;<br>--5、更改表的存储位置路径<br>alter table table_name set location &quot;new location&quot;;<br><br>--6、更改列名称/类型/位置/注释<br>create table test_change (a int, b int, c int);<br>alter table test_change change a a1 int;<br>alter table test_change change a1 a2 string after b;<br>alter table test_change change c c1 int first;<br>alter table test_change change a1 a1 int comment &#x27;this is column a1&#x27;;<br><br>--7、添加/替换列<br>--使用add columns，可以将新列添加到现有列的末尾但在分区列之前。<br>--replace columns 将删除所有现有列，并添加新的列集。<br>alter table table_name add|replace columns (col_name data_type,...);<br></code></pre></td></tr></table></figure><h2 id="partition-分区操作">Partition 分区操作</h2><p>Hive中针对分区Partition的操作主要包括增加分区、删除分区、重命名分区、修复分区和修改分区。</p><p>增加分区：增加分区会更改表的元数据，但是不会加载数据。如果分区位置中不存在数据，则查询的时候不会返回结果。（需要自己将数据加载到增加的分区当中）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hive">--添加分区<br>alter table table_name add partition (分区字段=&#x27;分区值&#x27;) <br>location hdfs_path;<br><br>--一次性添加多个分区<br>alter table table_name add <br>partition (分区字段=&#x27;分区值&#x27;) location hdfs_path<br>partition (分区字段=&#x27;分区值&#x27;) location hdfs_path;<br></code></pre></td></tr></table></figure><p>删除分区：删除分区会删除该分区的数据和元数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hive">alter table table_name drop [if exists] partition (dt=&#x27;2008-08-08&#x27;, country=&#x27;us&#x27;);<br>alter table table_name drop [if exists] partition (dt=&#x27;2008-08-08&#x27;, country=&#x27;us&#x27;) purge; --直接删除数据 不进垃圾桶<br></code></pre></td></tr></table></figure><p>重命名分区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">alter table table_name partition (分区字段 =&quot;旧值&quot;) rename to partition (分期字段 =&quot;新值&quot;);<br></code></pre></td></tr></table></figure><p>修改分区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hive">--更改分区文件存储格式<br>alter table table_name partition (分区字段=&#x27;分区值&#x27;) set fileformat file_format;<br>--更改分区位置<br>alter table table_name partition (分区字段=&#x27;分区值&#x27;) set location &quot;new location&quot;;<br></code></pre></td></tr></table></figure><p>修复分区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hive">msck [repair] table table_name [add/drop/sync partitions];<br></code></pre></td></tr></table></figure><p>在前面我们都是使用Hive来进行分区数据加载，之后Hive会维护元数据，以及在HDFS上有规律地组织文件夹结构。具体表现为在表文件夹下存在对应的分区文件夹。</p><p>那么如果我们直接手动创建或者删除HDFS上的分区文件夹，Metastore将不会意识到分区信息的更改，我们也无法查询到对应的信息。而msck就是MetastoreCheck的缩写，表示元数据检查操作，可以用于元数据的修复。</p><ul><li>msck默认行为为addpartitions：将hdfs上存在但是元数据中不存在的分区添加到metastore（也可以看作是一种数据导入的方法）</li><li>drop partitions：将hdfs上不存在但是元数据中存在的分区信息删除</li><li>sync partitions：同步分区信息，等效于上面两个的综合</li><li>如果存在大量未跟踪的分区，则可以批量运行msck repairtable，以避免内存不足的错误</li></ul><h1 id="hive-show-语法">Hive Show 语法</h1><p>show语法主要功能是展示数据库、数据表的一些相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hive">--显示所有数据库 schemas和databases的用法 功能一样<br>show databases;<br>show schemas;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs hive">--显示当前数据库所有表/视图/物化视图/分区/索引<br>show tables;<br>show tables [in database_name]; --指定某个数据库<br><br>--显示当前数据库下所有视图<br>show views;<br>show views &#x27;test_*&#x27;; --正则匹配，展示所有以test_开头的view<br>show views [in/from database_name]; -- 展示数据库test的所有视图<br><br>--显示当前数据库下所有物化视图<br>show materialized views [in/from database_name];<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs hive">--显示表分区信息，分区按字母顺序列出，不是分区表执行该语句会报错<br>show partitions table_name;<br>show partitions test_database.table_name;<br><br>--显示表/分区的扩展信息<br>show table extended [in|from database_name] like table_name;<br>show table extended like student;<br>describe formatted test_database.table_name;<br><br>--显示表的属性信息<br>show tblproperties table_name;<br><br>--显示表、视图的创建语句<br>show create table ([db_name.]table_name|view_name);<br><br>--显示表中的所有列，包括分区列。<br>show columns (from|in) table_name [(from|in) db_name];<br><br>--显示当前支持的所有自定义和内置的函数<br>show functions;<br><br>--查看表信息<br>desc extended table_name;<br>--查看表信息（格式化美观-以表格形式展示）<br>desc formatted table_name;<br>--查看数据库相关信息<br>describe database database_name;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7中安装MySQL</title>
    <link href="/2022/07/02/CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85MySQL/"/>
    <url>/2022/07/02/CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="安装流程">安装流程</h1><p>（在下面的流程中可能会涉及到需要root权限的地方，使用sudo执行命令即可）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检查当前系统是否安装过MySQL</span><br>[syh@hadoop102 ~]$ rpm -qa | grep mariadb<br>mariadb-libs-5.5.56-2.el7.x86_64<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果安装过则进行卸载</span><br>sudo rpm -e --nodeps mariadb-libs<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在/opt/software上创建mysql文件夹，作为后续安装的目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将MySQL安装包上传到该目录下</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压MySQL安装包</span><br>tar -xvf mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在安装目录下执行rpm安装</span><br>sudo rpm -ivh mysql-community-common-5.7.29-1.el7.x86_64.rpm mysql-community-libs-5.7.29-1.el7.x86_64.rpm mysql-community-client-5.7.29-1.el7.x86_64.rpm mysql-community-server-5.7.29-1.el7.x86_64.rpm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果是最小化安装的话可能会报错，需要先安装缺少的依赖</span><br>yum -y install libaio<br></code></pre></td></tr></table></figure><p>这样MySQL已经安装好了，下面进行MySQL服务相关的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化数据库</span><br>sudo mysqld --initialize --user=mysql<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看临时生成的root用户密码</span><br>sudo cat /var/log/mysqld.log <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动MySQL服务</span><br>sudo systemctl start mysqld<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">登陆MySQL数据库，输入临时生成的密码</span><br>mysql -uroot -p<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">先修改root用户的密码，否则执行其他的操作会报错</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash"><span class="hljs-built_in">set</span> password = password(<span class="hljs-string">&quot;新密码&quot;</span>);</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改mysql库下的user表中的root用户，允许任意ip进行连接</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">update mysql.user <span class="hljs-built_in">set</span> host=<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span>;</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">flush privileges;</span><br></code></pre></td></tr></table></figure><p>推荐将MySQL服务设置为开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">mysql的启动，关闭和状态查看</span><br>systemctl stop mysqld<br>systemctl status mysqld<br>systemctl start mysqld<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将mysql设置为开机自启</span><br>systemctl enable mysqld<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看是否已经设置自启动成功</span><br>systemctl list-unit-files | grep mysqld<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive学习笔记-入门(2)-Hive概述以及集群搭建</title>
    <link href="/2022/07/02/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-Hive%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/07/02/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-Hive%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="hive概述">Hive概述</h1><p>Hive是一款建立在Hadoop之上的开源<strong>数据仓库</strong>系统，可以将存储在<strong>HDFS</strong>中的<strong>结构化</strong>、<strong>半结构化</strong>的数据文件<strong>映射为一张数据库表</strong>。之后基于表提供了一种类SQL的查询模型，称为<strong>Hive查询语言（HQL）</strong>，用于访问和分析存储在HDFS中的大型数据集</p><p>Hive的核心是将HQL转换成MapReduce程序（后续也提供了其他的计算引擎），然后将程序提交的Hadoop集群中执行</p><p>使用Hive的好处：</p><ol type="1"><li>直接使用MapReduce编程，学习成本较高。利用MapReduce实现复杂查询逻辑开发难度较大</li><li>使用Hive提供的HQL语法，学习成本较低，更加简单，容易上手</li><li>支持自定义函数，功能扩展很方便</li><li>依赖于Hadoop，擅长于存储分析海量数据集</li></ol><p>从功能上来说，数据仓库软件至少需要具备<strong>存储数据</strong>和<strong>分析数据</strong>的能力，Hive作为一款大数据时代的数据仓库软件，当然也具备这两种能力，但是这并不是它自己实现的，而是借助于Hadoop来实现的。<strong>Hive利用HDFS来存储数据，利用MapReduce来查询和分析数据</strong>。而Hive本身最大的意义在于能够<strong>让用户专注于编写HQL，然后让Hive将其转换成MapReduce程序，完成对数据的分析</strong></p><h1 id="hive架构和组件">Hive架构和组件</h1><h2 id="架构">架构</h2><p>考虑Hive完成的功能，它能够将HDFS上的数据文件映射成为一张表，并在其上提供HQL的查询功能。</p><ul><li>数据文件到表的映射，需要<strong>记录文件和表之间的对应关系</strong>，这类数据我们称之为元数据信息（描述数据的数据）。具体来说，元信息中可能需要记录表的位置信息、字段的顺序信息、字段之间的分隔符等</li><li>HQL的查询功能，需要提供SQL的语法解析和编译功能。用户写完SQL之后，Hive需要对语句进行语法校验，并根据记录的元数据信息来解读语句的含义，指定执行计划，并将执行计划转换成MapReduce程序来执行，然后将执行结果封装返回给用户</li></ul><p>总体来说，Hive架构如下：</p><img src="/2022/07/02/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-Hive%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/Hive%E6%9E%B6%E6%9E%84.png" class="" title="Hive架构"><p>用户编写查询语句之后，Hive对其进行语法解析，语句编译和执行计划优化。在语句编译的过程中，需要使用到元数据，因此需要从存储元数据的数据库中查询对应的信息。之后Hive将语句转换成MapReduce程序后提交给Yarn进行执行，得到结果后返回给用户。</p><h2 id="组件">组件</h2><p>Hive的组件主要包括如下的内容，如用户接口、元数据存储、Driver驱动程序、执行引擎等，图中还包括与集群的交互等信息</p><img src="/2022/07/02/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-Hive%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/Hive%E7%BB%84%E4%BB%B6.png" class="" title="Hive组件"><ul><li><p>用户接口：包括命令行接口CLI、JDBC/ODBC、WebGUI等。其中，Hive中的Thrift服务器允许外部客户端通过网络与Hive进行交互，类似于JDBC或者ODBC协议；WebGUI则是通过浏览器来访问Hive</p></li><li><p>元数据存储：Hive的元数据通常是存储在关系数据库如MySQL或者derby中。Hive中的元数据包括表的名字、表的列和分区及其属性、表的属性、表数据所在目录等</p></li><li><p>Driver驱动程序：包括语法解析器、计划编译器、优化器、执行器等，主要完成HQL查询语句的词法分析、语法分析、编译、优化，以及查询计划的生成，生成的查询计划存储在HDFS中，并有执行引擎调用执行</p></li><li><p>执行引擎：Hive本身并不处理数据文件，而是通过执行引擎来处理。当前Hive支持MapReduce、Tez、Spark三种执行引擎</p></li></ul><blockquote><p>Tez：是Apache最新的支持DAG作业的开源计算框架，它可以将多个有依赖的作业转换为一个作业从而大幅提升DAG作业的性能。</p></blockquote><h1 id="hive数据模型">Hive数据模型</h1><p>Hive中的数据模型类似于关系型数据库的库表结构，在此基础上还有自己特有的模型，Hive中的数据可以在粒度级别上分成三类：Table表、Partition分区和Bucket分桶。</p><p><strong>Database数据库</strong>：</p><ul><li>Hive作为一个数据仓库，其中也有数据库的概念。每个数据库下有属于自己的表。默认存在数据库为default</li><li>Hive中的数据都是存储在HDFS上的，存储目录和数据模型的对应也比较清晰。默认存在根目录，可以在<code>hive-site.xml</code>中定义参数<code>hive.metastore.warehouse.dir</code>来指定，默认值为<code>/user/hive/warehouse</code></li><li>每个数据库在根目录下占据一项，以数据库名称命名，存储路径为<code>$&#123;hive.metastore.warehouse.dir&#125;/databasename.db</code></li></ul><p><strong>Table表</strong>：</p><ul><li>Hive表于类似于关系数据库中的表。Hive中表所对应的数据通常存储在HDFS中，表相关的元数据存储在另外的RDBMS中</li><li>Hive中表数据在HDFS上的存储路径为：<code>$&#123;hive.metastore.warehouse.dir&#125;/databasename.db/tablename</code></li><li>默认数据库中的表直接存放在根目录下</li></ul><p><strong>Partition分区</strong>：</p><ul><li>Partition分区是对Hive的一种优化手段，指的是根据分区列的值来将表划分为不同的分区（例如按照时间列对表进行划分），这样可以更快地对指定分区数据进行查询</li><li>分区在存储层面上的表现是对应表目录下的子文件夹</li><li>一个文件夹表示一个分区，子文件的命名标准为<code>分区列=分区值</code></li><li>Hive支持分区下继续创建分区，即多重分区</li></ul><p><strong>Bucket分桶</strong>：</p><ul><li>Bucket分桶也是Hive的一种优化手段，指的是根据表中字段的值，经过hash计算规则之后将数据文件划分成若干个小文件</li><li>分桶的好处是可以优化join查询和方便抽样查询</li><li>分桶在存储层面的表示是同一个表目录下数据根据hash散列之后变成了多个文件</li></ul><blockquote><p>Hive虽然具有RDBMS数据库的外表，包括数据模型、SQL语法都十分相似，但应用场景却完全不同。Hive只适合用来做海量数据的离线分析。Hive的定位是数据仓库，面向分析的OLAP系统。Hive不是大型数据库，也不是要取代MySQL承担业务数据处理。</p></blockquote><h1 id="hive部署">Hive部署</h1><h2 id="元数据和元数据服务">元数据和元数据服务</h2><p>元数据：Metadata，又称为中介数据、中继数据，指的是描述数据的数据。它主要是用来描述数据的属性，用来支持相关功能，如指示存储位置、历史数据、资源查找、文件记录等</p><p><strong>HiveMetadata</strong>即Hive中的元数据，其中包含了Hive创建的database、table、表位置、类型、属性、字段顺序、字段类型等元信息。<strong>Hive元数据存储在关系型数据库中</strong>，如Hive内置的Derby，或第三方数据库如MySQL等</p><p><strong>HiveMetastore</strong>即元数据服务，它的作用是管理元数据，对外暴露服务地址，让各种客户端通过连接Metastore服务，再由Metastore去连接MySQL数据库来进行元数据的存取，相当于对元数据的操作有了一个统一的接口</p><blockquote><p>有了Meatstore服务，就可以有多个客户端同时连接，这些客户端不需要知道MySQL数据库的用户名和密码，只需要连接Metastore服务即可，在某种程度上保证了Hive元数据的安全</p></blockquote><h2 id="hive部署-1">Hive部署</h2><p>Hive的部署有三种模式，内嵌模式、本地模式和远程模式。三种模式的区分主要在于两点：</p><ol type="1"><li>Metastore服务是否需要单独配置，单独启动</li><li>Metadata是存储在Hive内置的Derby中，还是第三方的RDBMS如MySQL中</li></ol><table><thead><tr class="header"><th></th><th>内嵌模式</th><th>本地模式</th><th>远程模式</th></tr></thead><tbody><tr class="odd"><td>Metastore单独配置、启动</td><td>❌</td><td>❌</td><td>✔</td></tr><tr class="even"><td>Metadata存储介质</td><td>Derby</td><td>MySQL</td><td>MySQL</td></tr></tbody></table><blockquote><p>Hadoop和Hive之间的版本对应关系可以参考：<ahref="https://hive.apache.org/downloads.html">Downloads(apache.org)</a></p><p>目前集群中使用的Hadoop版本为3.1.3，因此这里选择使用的Hive版本为3.1.2</p></blockquote><p>Hive是一款基于Hadoop的数据仓库软件，因此在部署之前，需要保证服务器的基础环境正常，Hadoop集群健康可用。启动Hive之前必须先启动Hadoop集群，需要等待HDFS安全模式关闭之后再启动运行Hive。Hive不是分布式安装运行的软件，其分布式的特征主要是借由Hadoop完成，包括分布式存储、分布式计算等。</p><p>在部署之前，需要将<strong>Hadoop与Hive进行整合</strong>。我们需要在Hadoop中添加相关配置信息，满足Hive在Hadoop上运行，具体信息如下，配置在core-site.xml中，并同步到集群中的其他节点上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Hadoop与Hive的整合--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.proxyuser.syh.hosts<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.proxyuser.syh.groups<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>该处参考：<ahref="https://www.cnblogs.com/jtotoo/p/15778979.html">错误：hive中beeline连接异常User:***is not allowed to impersonate - Jtotoo - 博客园 (cnblogs.com)</a></p><p>其中syh可以修改为自己对应的用户</p></blockquote><h3 id="内嵌模式">内嵌模式</h3><p>内嵌模式的特征就是不需要配置启动Metastore服务，解压安装包初始化即可测试体验Hive。</p><blockquote><p>Hive3版本需要用户手动进行元数据初始化动作</p></blockquote><p>具体配置过程如下：</p><p>将安装包上传到集群中，然后解压到<code>/opt/module</code>目录下，为了后续方便可以进行名称修改。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -zxvf apache-hive-3.1.2-bin.tar.gz -C /opt/module<br><span class="hljs-built_in">mv</span> apache-hive-3.1.2-bin/ hive-3.1.2<br></code></pre></td></tr></table></figure><p>编辑环境变量<code>/etc/profile.d/my_env.sh</code>，在其中添加Hive对应的目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#HIVE_HOME</span><br><span class="hljs-built_in">export</span> HIVE_HOME=/opt/module/hive-3.1.2<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HIVE_HOME</span>/bin<br></code></pre></td></tr></table></figure><p>之后需要解决hadoop、hive之间的guava版本差异</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /opt/module/hive-3.1.2<br><span class="hljs-built_in">rm</span> -r lib/guava-19.0.jar<br><span class="hljs-built_in">cp</span> /opt/module/hadoop-3.1.3/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/<br></code></pre></td></tr></table></figure><p>然后修改hive环境变量文件<code>hive-env.sh</code>，在其中添加Hadoop的配置，具体位置在<code>$HIVE_HOME/conf</code>目录下，需要将后缀的<code>.template</code>删除，在里面添加如下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> HADOOP_HOME=/opt/module/hadoop-3.1.3<br><span class="hljs-built_in">export</span> HIVE_CONF_DIR=/opt/module/hive-3.1.2/conf<br><span class="hljs-built_in">export</span> HIVE_AUX_JARS_PATH=/opt/module/hive-3.1.2/lib<br></code></pre></td></tr></table></figure><p>配置完成之后，就可以初始化metadata了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /opt/module/hive-3.1.2<br>bin/schematool -dbType derby -initSchema<br></code></pre></td></tr></table></figure><p>这样，Hive的安装就完成了，同时我们可以启动Hive服务，之后进入的就是类似于mysql中那样的命令行画面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">bin/hive<br></code></pre></td></tr></table></figure><p>（以上的操作是Hive的安装过程，在后续的不同部署方式中也是通用的）</p><blockquote><p>在内嵌模式下，判断是否初始化成功的依据是执行命令之后输出信息和执行命令的当前路径下是否有文件产生。</p><p>在不同的目录启动hive，文件产生在不同的目录下，则隔离了不同用户的操作，不同用户之间的操作不是共享的，这也是内嵌模式不被使用在生产场景下的原因，只适合用来测试。</p></blockquote><h3 id="本地模式">本地模式</h3><p>本地模式的特征就是需要安装数据库MySQL来存储元数据，但是不需要配置Metastore服务，Metastore服务随着hive的启动而启动，也就是可能同时出现多个Metastore服务（同样Hive3版本需要用户手动进行元数据初始化操作）</p><img src="/2022/07/02/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-Hive%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F.png" class="" title="本地模式"><p>具体部署过程如下：</p><p>首先需要安装MySQL，具体过程可以参考文章：<ahref="https://evernorif.github.io/2022/07/02/CentOS7中安装MySQL/">CentOS7中安装MySQL- EverNorif</a></p><p>之后需要安装Hive，大致过程和上面内嵌模式类似，但是有一些不同。</p><p>需要将MySQL JDBC驱动移动到<code>$HIVE_HOME/lib</code>目录下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysql-connector-java-5.1.32.jar<br></code></pre></td></tr></table></figure><p>需要在hive的conf目录下新增<code>hive-site.xml</code>文件，其中配置mysql等相关信息。配置信息如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 存储元数据mysql相关配置 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- JDBC连接的URL --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> jdbc:mysql://hadoop102:3306/hive?createDatabaseIfNotExist=true<span class="hljs-symbol">&amp;amp;</span>useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- JDBC连接的Driver --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- JDBC连接的username --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- JDBC连接的密码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>123123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 关闭元数据存储授权  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.event.db.notification.api.auth<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 关闭元数据存储版本的验证 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.schema.verification<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- Hive 默认在 HDFS 的工作目录 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/user/hive/warehouse<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后就可以初始化metadata，然后启动hive服务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">bin/schematool -initSchema -dbType mysql -verbos<br></code></pre></td></tr></table></figure><h3 id="远程模式">远程模式</h3><p>远程模式的特点是需要安装MySQL来存储Hive元数据，并且需要手动单独配置启动Metastore服务。</p><img src="/2022/07/02/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-Hive%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E8%BF%9C%E7%A8%8B%E6%A8%A1%E5%BC%8F.png" class="" title="远程模式"><p>远程模式的安装也和上面的步骤类似，只有部分细节有所差异。</p><p>首先安装MySQL，然后安装Hive，同样需要上传MySQLJDBC驱动，以及新增<code>hive-site.xml</code>配置MySQL等相关信息，配置信息如下，和本地模式不同的是增加了HiveServer2绑定运行以及远程模式部署Metastore服务的地址。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 存储元数据mysql相关配置 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- JDBC连接的URL --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> jdbc:mysql://hadoop102:3306/hive?createDatabaseIfNotExist=true<span class="hljs-symbol">&amp;amp;</span>useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- JDBC连接的Driver --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- JDBC连接的username --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- JDBC连接的密码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>123123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 指定HiveServer2连接的host --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.server2.thrift.bind.host<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop102<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <br>     <span class="hljs-comment">&lt;!-- 指定 hiveserver2 连接的端口号 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.server2.thrift.port<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 远程模式部署metastore 服务地址 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.uris<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>thrift://hadoop102:9083<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 关闭元数据存储授权  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.event.db.notification.api.auth<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 关闭元数据存储版本的验证 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.schema.verification<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- Hive 默认在 HDFS 的工作目录 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/user/hive/warehouse<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后就可以启动运行Hive了。在远程模式下，直接运行Hive服务会报错，必须首先启动HiveMetastore服务之后才可以使用Hive。（在使用前还需要初始化metadata）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">bin/schematool -initSchema -dbType mysql -verbos<br></code></pre></td></tr></table></figure><p>启动Hive Metastore服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HIVE_HOME</span><br><br><span class="hljs-comment"># 前台启动，使用ctrl+c关闭</span><br>bin/hive --service metastore<br><br><span class="hljs-comment"># 前台启动开启debug日志</span><br>bin/hive --service metastore --hiveconf hive.root.logger=DEBUG,console<br><br><span class="hljs-comment"># 后台启动，进程挂起，关闭使用jps+kill</span><br><span class="hljs-comment"># 输入命令回车执行 再次回车 进程将挂起后台</span><br><span class="hljs-built_in">nohup</span> /export/server/hive/bin/hive --service metastore &amp;<br></code></pre></td></tr></table></figure><h1 id="hive客户端">Hive客户端</h1><h2 id="客户端介绍">客户端介绍</h2><p>从Hive远程模式图解中我们可以看到，Hive有两种连接方式的，分别是旧客户端bin/hive以及新客户端bin/beeline</p><p>第一代客户端：<code>$HIVE_HOME/bin/hive</code>，目前已经不推荐使用了。它是一个shellUtil，主要功能是用于以交互式或批处理模式进行Hive查询，以及启动Hive相关的服务，例如metastore</p><p>第二代客户端：<code>$HIVE_HOME/bin/beeline</code>，是一个JDBC客户端，官方推荐使用。与第一代客户端相比，它的性能得到了加强，安全性也得到了提高</p><p>Beeline在嵌入式模式和远程模式下均可以工作。在嵌入模式下，它运行嵌入式Hive，而<strong>远程模式下通过Thrift连接到到单独的HiveServer2服务上</strong>。</p><blockquote><ul><li>HiveServer和HiveServer2是Hive自带的两种服务，允许客户端在不启动命令行的情况下对Hive中的数据进行操作，同时允许远程客户端使用多种编程语言如Java，Python等向Hive提交请求，取回结果</li><li>HiveServer不能处理多余一个客户端的并发请求，因此在Hive-0.11.0版本中重写了代码得到HiveServer2解决该问题。目前HiveServer已经被废弃</li><li>HiveServer2支持多客户端的并发和身份认证，旨在为开放API客户端如JDBC，ODBC等提供更好的支持</li></ul></blockquote><p>第一代客户端hive的启动：直接通过hive命令启动即可。</p><ul><li>如果是远程模式部署，需要手动启动metastore服务；如果是内嵌模式和本地模式，则运行hive的时候，metastore服务会随之一起启动</li><li>可以在启动Hive Metastore服务的机器上直接使用hive客户端</li><li>也可以在其他机器上通过hive访问HiveMetastore服务，只需要在该机器的hive-site.xml中配置metastore服务地址即可</li></ul><p>第二代客户端beeline的启动：需要首先启动metastore服务，然后启动hiveserver2服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 后台启动</span><br><span class="hljs-built_in">nohup</span> hive --service metastore &amp;<br><span class="hljs-built_in">nohup</span> hive --service hiveserver2 &amp;<br></code></pre></td></tr></table></figure><p>之后就可以通过beeline客户端进行连接，协议的地址为<code>jdbc:hive2://hadoop102:10000</code>，需要登陆对应的用户</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 方式1</span><br>beeline<br><br>beeline&gt; ! connect jdbc:hive2://hadoop102:10000<br>Connecting to jdbc:hive2://hadoop102:10000<br>Enter username <span class="hljs-keyword">for</span> jdbc:hive2://hadoop102:10000: syh<br>Enter password <span class="hljs-keyword">for</span> jdbc:hive2://hadoop102:10000: ******<br>Connected to: Apache Hive (version 3.1.2)<br>Driver: Hive JDBC (version 3.1.2)<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 方式2</span><br>beeline -u jdbc:hive2://hadoop102:10000 -n syh<br></code></pre></td></tr></table></figure><h2 id="可能出现的问题">可能出现的问题</h2><p>在连接二代客户端的时候可能会出现以下的问题：</p><ul><li>拒绝连接</li></ul><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali">Could<span class="hljs-built_in"> not </span>open connection to the HS2 server.Please<span class="hljs-built_in"> check </span>the server URI<span class="hljs-built_in"> and </span>if<br>the URI is correct,then ask the administrator to<span class="hljs-built_in"> check </span>the server status.<br>Error:Could<span class="hljs-built_in"> not </span>open client transport with JDBC Uri:<br>idbc:hive2://hadoop102:10000:java.net.ConnectException:Connection refused<br>(Connection refused)(state=08S01,code=0)<br></code></pre></td></tr></table></figure><ul><li>权限不够</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">new</span> session: java.lang.RuntimeException: org.apache.hadoop.ipc.<span class="hljs-constructor">RemoteException(<span class="hljs-params">org</span>.<span class="hljs-params">apache</span>.<span class="hljs-params">hadoop</span>.<span class="hljs-params">security</span>.<span class="hljs-params">authorize</span>.AuthorizationException)</span>: User: syh is not allowed <span class="hljs-keyword">to</span> impersonate syh <br></code></pre></td></tr></table></figure><p>该问题的解决可以参考：<ahref="https://blog.csdn.net/u011495642/article/details/84305944">Beeline连接报错：Couldnot open client transport with JDBC Uri:jdbc:hive2://localhost:10000/default_望隐少年的博客-CSDN博客</a></p><p>其中需要注意的点是HiveServer2服务的启动较慢，只有当我们看到10000端口占用之后，服务才启动完毕。需要等到服务启动完毕之后再连接beeline</p><p>我们也可以通过在<code>hive-site.xml</code>中进行相应的配置来提高HiveServer2服务的启动速度</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- hiveserver2的高可用参数，开启此参数可以提高hiveserver2的启动速度 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.server2.active.passive.ha.enable<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="启动脚本">启动脚本</h2><p>可以编写Hive服务启动脚本<code>myHiveService.sh</code>，分别完成以下功能</p><ul><li>启动Metastore服务和HiveServer2服务</li><li>查看Metastore服务和HiveServer服务状态</li><li>停止Metastore服务和HiveServer2服务</li></ul><p>脚本启动两个服务之后，需要手动查看服务状态，两个服务都正常启动之后才可以连接客户端</p><p>具体内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br>HIVE_LOG_DIR=<span class="hljs-variable">$HIVE_HOME</span>/logs<br><span class="hljs-keyword">if</span> [ ! -d <span class="hljs-variable">$HIVE_LOG_DIR</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HIVE_LOG_DIR</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-comment">#检查进程是否运行正常，参数 1 为进程名，参数 2 为进程端口</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">check_process</span></span>() &#123;<br>    pid=$(ps -ef 2&gt;/dev/null | grep -v grep | grep -i <span class="hljs-variable">$1</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>)<br>    ppid=$(netstat -nltp 2&gt;/dev/null | grep <span class="hljs-variable">$2</span> | awk <span class="hljs-string">&#x27;&#123;print $7&#125;&#x27;</span> | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27;/&#x27;</span> -f 1)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$pid</span><br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$pid</span>&quot;</span> =~ <span class="hljs-string">&quot;<span class="hljs-variable">$ppid</span>&quot;</span> ]] &amp;&amp; [ <span class="hljs-string">&quot;<span class="hljs-variable">$ppid</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">return</span> 0 || <span class="hljs-built_in">return</span> 1<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">hive_start</span></span>() &#123;<br>    metapid=$(check_process HiveMetastore 9083)<br>    cmd=<span class="hljs-string">&quot;nohup hive --service metastore &gt;<span class="hljs-variable">$HIVE_LOG_DIR</span>/metastore.log 2&gt;&amp;1 &amp;&quot;</span><br>    [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$metapid</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">eval</span> <span class="hljs-variable">$cmd</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Metastroe 服务已启动&quot;</span><br>    server2pid=$(check_process HiveServer2 10000)<br>    cmd=<span class="hljs-string">&quot;nohup hiveserver2 &gt;<span class="hljs-variable">$HIVE_LOG_DIR</span>/hiveServer2.log 2&gt;&amp;1 &amp;&quot;</span><br>    [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$server2pid</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">eval</span> <span class="hljs-variable">$cmd</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;HiveServer2 服务已启动&quot;</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">hive_stop</span></span>() &#123;<br>    metapid=$(check_process HiveMetastore 9083)<br>    [ <span class="hljs-string">&quot;<span class="hljs-variable">$metapid</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">kill</span> <span class="hljs-variable">$metapid</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Metastore 服务未启动&quot;</span><br>    server2pid=$(check_process HiveServer2 10000)<br>    [ <span class="hljs-string">&quot;<span class="hljs-variable">$server2pid</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">kill</span> <span class="hljs-variable">$server2pid</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;HiveServer2 服务未启动&quot;</span><br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br><span class="hljs-string">&quot;start&quot;</span>)<br>    hive_start<br>    ;;<br><span class="hljs-string">&quot;stop&quot;</span>)<br>    hive_stop<br>    ;;<br><span class="hljs-string">&quot;restart&quot;</span>)<br>    hive_stop<br>    <span class="hljs-built_in">sleep</span> 2<br>    hive_start<br>    ;;<br><span class="hljs-string">&quot;status&quot;</span>)<br>    check_process HiveMetastore 9083 &gt;/dev/null &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Metastore 服务运行正常&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Metastore 服务运行异常&quot;</span><br>    check_process HiveServer2 10000 &gt;/dev/null &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;HiveServer2 服务运行正常&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;HiveServer2 服务运行异常&quot;</span><br>    ;;<br>*)<br>    <span class="hljs-built_in">echo</span> Invalid Args!<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Usage: &#x27;</span>$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$0</span>)<span class="hljs-string">&#x27; start|stop|restart|status&#x27;</span><br>    ;;<br><span class="hljs-keyword">esac</span><br><br></code></pre></td></tr></table></figure><h1 id="hive初体验">Hive初体验</h1><p><strong>Hive VS MySQL</strong></p><ul><li>Hive SQL的语法和标准的SQL很类似，使得学习成本降低很多</li><li>Hive底层通过MapReduce执行数据插入动作，速度慢</li></ul><p><strong>Hive表映射</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test(<br>    id <span class="hljs-type">int</span>, <br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), <br>    age <span class="hljs-type">int</span>,<br>    city <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>) <span class="hljs-type">row</span> format delimited fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>Hive应该具有自己特有的数据插入表的方式，即从HDFS文件映射成为表</li><li>想在Hive中创建表，并与结构化文件映射成功，需要注意<ul><li>创建表时，字段顺序、字段类型需要和文件中保持一致。类型不一致hive会尝试转换，但是不保证成功。不成功显示null</li><li>文件放置在Hive表对应目录下可以映射成功（但是可能不一定需要放在对应目录？）</li><li>建表的时候需要指定内容分隔符（但是可能不一定需要指定？）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive学习笔记-入门(1)-数据仓库基础理论</title>
    <link href="/2022/07/02/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    <url>/2022/07/02/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="数据仓库概念">数据仓库概念</h1><p>数据仓库（DataWarehouse，简称为数仓，DW），指的是用于<strong>存储</strong>、<strong>分析</strong>、<strong>报告</strong>的数据系统。它的目的是构建<strong>面向分析</strong>的集成化数据环境，分析结果为企业提供决策和支持。</p><ul><li>数据仓库本身<strong>不生产任何数据</strong>，其数据来源于不同的外部系统</li><li>数据仓库自身不需要消费任何数据，其结果开放给各个外部应用使用</li></ul><p>数据仓库的产生对应于企业对于数据分析的需要。数据仓库为了分析数据而来，分析的结果为企业决策提供支撑。在企业中，数据信息往往分为操作型记录的保存和分析型决策的指定。操作性记录即记录用户的操作信息，联机事务处理系统（OLTP）可以用来满足该业务的需求，前台接收的用户数据可以立即传送到后台进行处理，并在很短的时间内给出处理结果。分析型决策指定信息，即需要一个面向分析、支持分析的系统，对应成为联机分析处理系统（OLAP），数据仓库就是OLAP的一种。</p><blockquote><p>联机<strong>事务</strong>处理OLTP（Online<strong>Transaction</strong> Processing）</p><ul><li>主要目标是做数据处理，针对具体业务在数据库联机中的日常操作，通常对少数记录进行查询，修改等</li><li>用户较为关心操作的响应时间、数据的安全性、完整性、并发支持的用户数等</li><li>传统的关系型数据库是数据管理的主要手段</li></ul><p>联机<strong>分析</strong>处理OLAP（Online <strong>Analytical</strong>Processing）</p><ul><li>主要用于分析型处理，目标为数据分析</li><li>针对某些主体的历史数据进行复杂的多维分析，来支持管理和决策</li><li>数据仓库是OLAP系统的一个典型示例，主要用于数据分析</li></ul><table><thead><tr class="header"><th></th><th>OLTP</th><th>OLAP</th></tr></thead><tbody><tr class="odd"><td>数据源</td><td>日常运行的业务数据</td><td>整合来自多个数据源的数据，可能包括OLTP和外部数据来源</td></tr><tr class="even"><td>目的</td><td>面向应用，面向业务，支撑事务</td><td>面向分析，支持分析决策</td></tr><tr class="odd"><td>焦点</td><td>当下</td><td>主要面向历史数据</td></tr><tr class="even"><td>任务</td><td>读写操作</td><td>大量读操作，少量写操作</td></tr><tr class="odd"><td>响应时间</td><td>很快，毫秒级别</td><td>较慢（秒、分钟、小时、天都有可能）</td></tr><tr class="even"><td>数据量</td><td>小数据量（MB，GB）</td><td>大数据量（TB、MB）</td></tr><tr class="odd"><td>典型应用</td><td>关系型数据库</td><td>数据仓库</td></tr></tbody></table></blockquote><p>数据库和数据仓库是两个概念，它们的区别实际上也是OLTP和OLAP的区别</p><ul><li>数据仓库不是大型的数据库，虽然数据仓库存储数据规模大</li><li>数据仓库的出现，并不是要取代数据库</li><li>数据库是面向事务的设计，数据仓库是面向主题设计的</li><li>数据库一般存储业务数据，数据仓库存储的一般是历史数据</li><li>数据库是为捕获数据而设计，数据仓库是为分析数据而设计</li></ul><p>数据仓库概念中，还会涉及到数据集市的概念。可以将数据集市看作是小型的数据仓库。一般在企业中，数据仓库（DataWarehouse）是面向整个企业的数据，而数据集市（DataMart）是面向单个部门的。数据集市通常只涉及一个主题或者领域，相比数据仓库更小但是更加具体，更加易于管理和维护，有更灵活的结构。</p><h1 id="数据仓库主要特征">数据仓库主要特征</h1><p>数据仓库的主要特征包括面向主题、集成性、非易失性和时变性。</p><p>面向主题性：</p><ul><li>在数据库中，最大的特点是<strong>面向应用进行数据的组织</strong>，各个业务系统可能是相互分离的。</li><li>数据仓库则是面向主题的。主题是一个抽象的概念，是<strong>较高层次</strong>上企业信息系统中的数据综合、归类并进行分析利用的抽象。在逻辑意义上，它是对应企业中<strong>某一宏观分析领域所涉及的分析对象</strong>。</li><li>操作型处理（传统数据）对数据的划分并不适用于决策分析。而基于主题组织的数据则不同，它们被划分为各自独立的领域，每个领域有各自的逻辑内涵但互不交叉，在抽象层次上对数据进行完整、一致和准确的描述。</li></ul><p>集成性：</p><ul><li>集成性和面向主体性相关，确定主题之后，需要获取和主题相关的数据。这部分数据可能会分布在多个操作性系统中，彼此之间是分散、独立、异构的</li><li>数据在进入数据仓库之前，需要经过统一的处理，对数据进行抽取、清理、转换和汇总。</li></ul><p>非易失性：</p><ul><li>数据仓库是分析数据的平台，而不是创造数据的平台。数据进入数据仓库之后，稳定并且不会改变</li><li>数据仓库中的数据反映的是一段相当长时间内历史数据的综合</li><li>数据进入数据仓库之后，一般情况下会被长时间保留。数据仓库中一般有大量的查询操作，但是修改和删除操作很少</li></ul><p>时变性：</p><ul><li>数据仓库包含各种粒度的历史数据，可能和某个特定日期、星期、月份、季度或者年份有关</li><li>数据仓库中的数据并不是一成不变的，其中的数据应该随着时间而更新，以适应决策的需要</li></ul><h1 id="数据仓库分层架构">数据仓库分层架构</h1><p>数据仓库的构建一般会遵循分层的架构。每个企业根据自己的业务需求可以分成不同的层次。但是最基础的分层思想，理论上分为三个层：操作型数据层（<strong>ODS</strong>）、数据仓库层(<strong>DW</strong>)和数据应用层(<strong>DA</strong>)。</p><ul><li><p>ODS层（Operation Data Store）</p><ul><li><p>操作型数据层，也被称为源数据层、数据引入层、数据暂存层、临时缓存层</p></li><li><p>此层将未经处理的原始数据存放至数据仓库系统，结构上和与源数据保持一致，是数据仓库的临时准备区</p></li><li><p>主要完成基础数据引入到数仓的职责，和数据源系统进行解耦合，同时记录基础数据的历史变化</p></li></ul></li><li><p>DW层（Data Warehouse）</p><ul><li><p>数据仓库层，由ODS层的数据加工而成</p></li><li><p>主要完成数据加工与整合，建立一致性的维度，构建可以复用的面向分析和统计的明细事实表，汇总公共粒度的指标等</p></li></ul></li><li><p>DA层（Data Application）</p><ul><li><p>数据应用层，面向最终用户，面向业务定制提供给产品和数据分析使用的数据</p></li><li><p>可能包括前端报表、分析图表、KPI、仪表盘、数据挖掘等分析</p></li></ul></li></ul><p>数据仓库分层的主要原因是在管理数据的时候，能够对数据有一个更加清晰的掌控</p><ul><li>清晰的数据结构：每个数据分层都有它的作用域，在使用表的时候能够更加方便地定位和理解</li><li>数据血缘追踪：举例来说，如果最终得到的一张表出现了问题，我们能够根据数据血缘快速定位到问题</li><li>减少重复开发：规范数据分层，开发一些通用的中间层数据，能够减少极大的重复计算</li><li>复杂问题简单化：将复杂的问题分解成多个步骤，每一层只处理单一的步骤，比较简单和容易理解</li><li>屏蔽原始数据的异常：屏蔽业务的影响，不必改一次业务就需要重新接入数据</li></ul><p>在数据仓库分层架构中，还存在一个ETL的操作。数据仓库中，从各个数据源获取数据以及在数据仓库中的数据转换和流动都可以认为是ETL（抽取Extract、转换Transfer、装载Load），但是在实际操作中，将数据加载到数据仓库中产生了两种不同的做法：ETL和ELT</p><p>ETL：首先从数据源中提取数据，这些数据源通常是事务性数据库。数据保存在临时暂存数据库中，然后执行转换操作，将数据结构化并转换成适合目标数据仓库系统的形式，然后将结构化数据加载到仓库中以便分析</p><p>ELT：数据从数据源中提取之后立即加载，没有专门的临时数据库。这也就是说数据会立即加载到单一的集中存储库中，数据在数据仓库系统中进行转换。大数据时代的数仓中，这个特点非常明显</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hive</tag>
      
      <tag>数据仓库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell基础学习笔记</title>
    <link href="/2022/06/29/Shell%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/29/Shell%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Shell是一个命令的解释器，它可以接收应用程序或用户命令，然后调用系统内核。shell也是一个功能强大的脚本语言，易编写，易调试、灵活性强。</p><p>Linux提供的Shell解析器如下，写在<code>/etc/shells</code>中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) [root@EverNorif ~]# cat /etc/shells<br>/bin/sh<br>/bin/bash<br>/usr/bin/sh<br>/usr/bin/bash<br></code></pre></td></tr></table></figure><ul><li>bash和sh即为一个链接的关系，sh -&gt; bash</li><li>CentOS默认的解析器是bash</li></ul><h1 id="基础语法">基础语法</h1><h2 id="入门知识">入门知识</h2><ul><li><p>脚本以<code>#!/bin/bash</code>开头，用以指定解析器</p></li><li><p>脚本的常用执行方式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 方法1</span><br><span class="hljs-comment"># 使用bash或者sh的相对路径或者绝对路径，不需要赋予脚本+x的权限</span><br>bash ./helloworld.sh<br><br><span class="hljs-comment"># 方法2</span><br><span class="hljs-comment"># 直接输入脚本的绝对路径或者相对路径，需要赋予脚本+x的权限</span><br><span class="hljs-built_in">chmod</span> +x helloworld.sh<br><span class="hljs-comment"># 如果直接在脚本文件所在目录里调用，则相对路径格式是./</span><br>./helloworld.sh<br><br><span class="hljs-comment"># 方法3</span><br><span class="hljs-comment"># 在脚本的路径前加上. 或者 source</span><br></code></pre></td></tr></table></figure><ul><li>方法1和方法2，是在当前Shell中打开一个子Shell来执行脚本内容，当脚本内容结束，则子Shell关闭，回到父Shell中</li><li>方法3，可以使得脚本内容在当前Shell里执行，无需打开子Shell</li><li>是否打开子Shell的区别就在于环境变量的继承关系，例如子Shell中设置的当前变量，父Shell是不可见的</li></ul></li></ul><h2 id="变量">变量</h2><p>变量包括系统预定义变量、自定义变量和特殊变量；根据变量的作用范围，可以分为全局的变量和局部的变量。全局指的是对所有的子Shell有效，局部指的是只对自己的Shell有效，对子Shell无效</p><h3 id="系统预定义变量">系统预定义变量</h3><p>常用的系统变量有：<code>$HOME $PWD $SHELL $USER</code>，可以使用echo查看对应的系统变量的值。set命令则可以显示当前Shell中的所有变量；env命令则可以显示当前系统的所有全局变量</p><h3 id="自定义变量">自定义变量</h3><p>基本语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">定义变量，注意等号的前后不能有空格</span><br>A=5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看变量的值</span><br>echo $A<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">撤销变量</span><br>unset A<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">声明只读变量，只读变量不能修改，也不能撤销<span class="hljs-built_in">unset</span></span><br>readonly B=2<br></code></pre></td></tr></table></figure><ul><li>变量定义规则基本同其他的编程语言</li><li><strong>等号两侧不能有空格</strong></li><li>在bash中，变量的默认类型都是字符串类型，无法直接进行数值运算<ul><li>如果想要进行运算，需要使用到后续的运算符</li></ul></li><li>变量的值如果有空格，需要使用引号扩起来</li><li>默认是局部变量，可以使用<code>export 变量名</code>将其提升为全局变量</li><li>对于全局变量的更改，只在当前的Shell中有效，无法影响到父Shell的变量值</li></ul><blockquote><p>echo中引号的区别：</p><p>单引号：直接原封不动地输出引号中的内容，比较傻</p><p>双引号：会解析其中的使用了<code>$</code>解析的变量，比较聪明</p></blockquote><h3 id="特殊变量">特殊变量</h3><p>主要用于脚本的输入参数的获取，处理等</p><ul><li><code>$n</code>：表示脚本的第几个参数<ul><li>其中n表示数字，如果数字超过9，则需要使用大括号进行包裹，如<code>$&#123;10&#125;</code></li><li><code>$0</code>，表示该脚本的名称，根据调用方式的不同而不同</li></ul></li><li><code>$#</code>：获取所有的输入参数个数，常用于循环中的判断，判断参数的个数是否正确</li><li><code>$*</code>：表示命令行中所有参数，将所有参数看作一个整体</li><li><code>$@</code>：表示命令行中的所有参数，但是不是一个整体，可以看作是一个参数集合</li><li><code>$?</code>：相当于返回值，为最后一次执行命令的返回状态<ul><li>如果值为0，证明上一个命令正确执行；非0则表示不正确</li></ul></li></ul><h2 id="运算符">运算符</h2><p>前面提到了变量默认都是字符串类型，计算需要使用运算符。</p><p>运算符的基本语法为<code>$((运算式))</code>或者<code>$[运算式]</code></p><p>如果需要将一个命令的返回结果当作值进行赋值，则使用反引号或者<code>$()</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">a=`<span class="hljs-built_in">ls</span>`<br>b=$(<span class="hljs-built_in">ls</span> -a)<br></code></pre></td></tr></table></figure><h2 id="条件判断">条件判断</h2><p><strong>基本语法</strong>：</p><ul><li><code>test 条件表达式</code></li><li><code>[ 条件表达式 ]</code>，注意这里条件表达式的前后需要有空格</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ $B = 2]<br>echo $?<br></code></pre></td></tr></table></figure><p>执行完命令之后，不会自动打印结果，需要使用<code>$?</code>来获取判断的返回值，如果返回值是0，则条件表达式的值为true，否则为false。并且注意这里的运算符两边也要有空格。以及条件非空即为true，即<code>[ $B ]</code>为true，<code>[ ]</code>为false</p><p><strong>常用判断条件</strong>：</p><ul><li>字符串之间的比较</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">= <br>!=<br><span class="hljs-comment"># 字符串的拼接直接写在一起即可</span><br><span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>_log_$(<span class="hljs-built_in">date</span> +%s)<br></code></pre></td></tr></table></figure><ul><li>整数之间的比较</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">-eq 等于 <br>-ne 不等于<br>-lt 小于<br>-le 小于等于<br>-gt 大于<br>-ge 大于等于<br></code></pre></td></tr></table></figure><ul><li>文件权限判断</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">-r 有读的权限<br>-w 有写权限<br>-x 有执行权限<br><br>[ -r helloworld.sh ]<br></code></pre></td></tr></table></figure><ul><li>文件类型判断</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">-e 文件存在<br>-f 文件存在并且是一个常规的文件<br>-d 文件存在并且是一个目录<br><br>[ -e /root/file]<br></code></pre></td></tr></table></figure><p><strong>多条件判断</strong>：与<code>&amp;&amp;</code>和或<code>||</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">同样具有短路操作的特性，可以用来实现类似?:三元操作符的效果</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&amp;&amp;表示前一条命令执行成功后才执行下一条命令</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">||表示前一条命令执行失败后才执行下一条命令</span><br>[ 条件 ] &amp;&amp; echo yes || echo no<br></code></pre></td></tr></table></figure><p>如果在一个中括号中进行多条件判断，可以使用<code>-a</code>或者<code>-o</code>（andor）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">[ <span class="hljs-variable">$b</span> -gt 18 -a <span class="hljs-variable">$b</span> -lt 35]<br>[ <span class="hljs-variable">$b</span> -gt 18 -o <span class="hljs-variable">$b</span> -lt 35]<br></code></pre></td></tr></table></figure><h2 id="流程控制">流程控制</h2><h3 id="if判断">if判断</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 单分支</span><br><span class="hljs-keyword">if</span> [ 条件表达式 ];<span class="hljs-keyword">then</span><br>程序<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 或者</span><br><span class="hljs-keyword">if</span> [ 条件表达式 ]<br><span class="hljs-keyword">then</span><br>程序<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 多分支</span><br><span class="hljs-keyword">if</span> [ 条件表达式 ]<br><span class="hljs-keyword">then</span><br>程序<br><span class="hljs-keyword">elif</span> [ 条件表达式 ]<br><span class="hljs-keyword">then</span><br>程序<br><span class="hljs-keyword">else</span><br>程序<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><ul><li>分号<code>;</code>表示一行中可以输入多个命令，使用分号隔开</li><li>if后面要有空格</li><li>条件表达式和中括号之间需要有空格</li></ul><h3 id="case语句">case语句</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">case</span> $变量名 <span class="hljs-keyword">in</span><br><span class="hljs-string">&quot;值1&quot;</span>)<br>程序1<br>;;<br><span class="hljs-string">&quot;值2&quot;</span>)<br>程序2<br>;;<br>*)<br>默认走的程序<br>;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><ul><li>case行尾必须为单词<code>in</code>，每个模式匹配必须以<code>)</code>结束</li><li>双分号<code>;;</code>表示命令序列结束，相当于java中的break</li><li>最后的<code>*)</code>表示默认模式，相当于java中的default</li></ul><h3 id="for循环">for循环</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 语法1</span><br><span class="hljs-keyword">for</span> (( 初始值;循环控制条件;变量变化))<br><span class="hljs-keyword">do</span><br>程序<br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># 举例1</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">sum</span>=0<br><span class="hljs-keyword">for</span>((i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">100</span>;i++))<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">sum</span>=$[<span class="hljs-variable">$sum</span>+<span class="hljs-variable">$i</span>]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$sum</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 语法2</span><br><span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 值1 值2 值3...<br><span class="hljs-keyword">do</span><br>程序<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><ul><li>前面说到的<code>$*</code>和<code>$@</code>，如果使用双引号包含的时候，会进行不同的变化，前者作为一个整体，后者展开成为一个序列</li><li>如果没有双引号包裹的话，则没有区别</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;=============$*=============&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;$*&quot;</span><br><span class="hljs-comment">#$*中的所有参数看成是一个整体，所以这个 for 循环只会循环一次</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;haha <span class="hljs-variable">$i</span>&quot;</span><br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;=============$@=============&#x27;</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-comment">#$@中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;haha <span class="hljs-variable">$j</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="while循环">while循环</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">while</span> [ 条件判断式 ]<br><span class="hljs-keyword">do</span> <br>程序<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="read读取控制台输入">read读取控制台输入</h2><p>基本语法：read [选项] [参数]</p><ul><li>选项：<ul><li>-p：指定读取值时的提示符</li><li>-t：指定读取值时等待的时间（单位为秒），如果不加-t则一直等待</li></ul></li><li>参数：<ul><li>变量：指定存放值的变量名</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">read</span> -t 7 -p <span class="hljs-string">&quot;Enter your name in 7 seconds :&quot;</span> name<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span><br></code></pre></td></tr></table></figure><h2 id="函数">函数</h2><p>函数又可以分成系统函数和自定义函数。</p><p>这里举几个系统函数的例子</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">basename</span> [string/pathname] [suffix]<br></code></pre></td></tr></table></figure><ul><li>basename命令会删掉所有的前缀，包括最后一个<code>/</code>字符，然后将字符串显示出来</li><li>可以理解为取出路径中的文件名称</li><li>suffix为后缀，如果被指定了，会将其中的suffix删除</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">dirname</span> 文件绝对路径<br></code></pre></td></tr></table></figure><ul><li>从给定给定包含绝对路径的文件名中去除文件名，返回目录的部分</li></ul><p>我们也可以自定义函数实现，基本语法如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">[<span class="hljs-keyword">function</span>] funname[()]<br>&#123;<br>函数体;<br>[retur int;]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上面的方括号表示可以省略</li><li>函数的形参不需要定义，可以使用<code>$n</code>获取，与脚本类似；也可以有函数返回值，使用<code>$?</code>获取</li><li>因为shell脚本是逐行运行的，所以在调用函数之前需要声明</li><li>如果不写return，会返回最后一条命令的运行结果。并且return后跟数值n，范围为0-255</li><li>一种方法可以绕过返回值的限制，在函数中进行echo，然后用命令替换<code>$()</code>进行捕获</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">sum</span></span>()<br>&#123;<br>s=0<br>s=$[<span class="hljs-variable">$1</span>+<span class="hljs-variable">$2</span>]<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$s</span>&quot;</span><br>&#125;<br><br>res=$(<span class="hljs-built_in">sum</span> 255 255)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$res</span><br></code></pre></td></tr></table></figure><h1 id="应用举例">应用举例</h1><p><code>helloworld.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;helloworld!&quot;</span><br></code></pre></td></tr></table></figure><p><code>acc.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">sum</span>=0<br><span class="hljs-keyword">for</span>((i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">100</span>;i++))<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">sum</span>=$[<span class="hljs-variable">$sum</span>+<span class="hljs-variable">$i</span>]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$sum</span><br></code></pre></td></tr></table></figure><p><code>printHa.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ha haha hahaha<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;I say <span class="hljs-variable">$i</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>笔记</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础学习笔记</title>
    <link href="/2022/06/28/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/28/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础概述">基础概述</h1><h2 id="linux发行版">Linux发行版</h2><p>Linux发行版：主要分为由商业公司维护的收费版本和开源社区维护的免费版本：</p><img src="/2022/06/28/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux%E5%8F%91%E8%A1%8C%E7%89%88.png" class="" title="Linux发行版"><h2 id="文件与目录结构">文件与目录结构</h2><p>Linux中一切皆文件，从根目录开始构成了一棵树，下面介绍了根目录下的文件夹的作用：（目录结构和物理的底层存储没有绝对的关系，是一种逻辑结构。具体的物理存放与挂载位置有关）</p><img src="/2022/06/28/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" class="" title="目录结构"><ul><li><code>/bin</code>：bin -&gt;usr/bin。Binary的缩写，目录中存放了系统中经常使用的命令</li><li><code>/sbin</code>：sbin -&gt; usr/bin。s指的是SuperUser，其中存放了系统管理员使用的系统管理程序</li><li><code>/home</code>：存放普通用户的家目录</li><li><code>/root</code>：该目录为root用户的家目录</li><li><code>/lib</code>：lib -&gt;usr/lib。系统开机时所需要的最基本的动态链接共享库，类似于Windows中的dll文件。几乎所有的应用程序都需要用到这些共享库</li><li><code>/lost+found</code>：一般情况下是空文件夹。当系统非法关机之后，这里就存放了一些文件</li><li><code>/etc</code>：其中存放了所有的系统管理所需要的配置文件和子目录</li><li><code>/usr</code>：非常重要的目录，用户的很多应用程序和文件都存放在该目录下。类似Windows中的programfiles目录</li><li><code>/boot</code>：存放了启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件</li><li><code>/proc</code>：一个虚拟的目录，是系统内存的映射。可以通过直接访问这个目录来获取系统信息</li><li><code>/srv</code>：service的缩写，其中存放了一些服务启动之后需要提取的数据</li><li><code>/sys</code>：系统文件目录</li><li><code>/tmp</code>：存放临时文件</li><li><code>/dev</code>：类似于Windows的设备管理器，将所有的硬件以文件的形式存储</li><li><code>/media</code>：挂载一些移动媒体</li><li><code>/mnt</code>：让用户临时挂载其他的文件系统</li><li><code>/opt</code>：给主机额外安装软件所存放的目录。用户额外安装的软件一般建议存放在该目录下</li><li><code>/var</code>：该目录中存放不断扩充的东西，一般将经常被修改的目录放在该目录下，如各种日志文件等</li></ul><h2 id="vivim编辑器">Vi/Vim编辑器</h2><p>Vi是Unix操作系统和类Unix操作系统中最通用的文本编辑器。</p><p>Vim是从Vi发展出来的一个性能更加强大的文本编辑器，可以主动以字体颜色来辨别语法的正确性，方便程序设计。</p><p>Vim编辑器主要分为三种模式，一般模式，编辑模式以及命令模式。</p><h3 id="一般模式">一般模式</h3><p>使用Vim打开文件则进入一般模式，这是默认的模式。在一般模式中，通常完成的是内容的删除、复制、粘贴等操作。</p><table><thead><tr class="header"><th style="text-align: left;">语法</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">yy</td><td>复制光标所在的当前行（只是复制，还没有粘贴）</td></tr><tr class="even"><td style="text-align: left;">y+数字+y</td><td>复制一段（从当前行开始复制xx行）</td></tr><tr class="odd"><td style="text-align: left;">p</td><td>在当前行进行粘贴</td></tr><tr class="even"><td style="text-align: left;">数字+p</td><td>从当前行开始复制xx次</td></tr><tr class="odd"><td style="text-align: left;">u</td><td>撤销上一步操作</td></tr><tr class="even"><td style="text-align: left;">dd</td><td>删除当前行</td></tr><tr class="odd"><td style="text-align: left;">d+数字+d</td><td>删除一段（从当前行开始删除xx行）</td></tr><tr class="even"><td style="text-align: left;">y+$</td><td>复制从光标位置开始到该行结尾的所有内容</td></tr><tr class="odd"><td style="text-align: left;">y+^</td><td>复制从该行开头到光标位置的所有内容</td></tr><tr class="even"><td style="text-align: left;">yw</td><td>复制一个词</td></tr><tr class="odd"><td style="text-align: left;">dw</td><td>删除一个词</td></tr><tr class="even"><td style="text-align: left;">gg</td><td>移动到文件头部</td></tr><tr class="odd"><td style="text-align: left;">G</td><td>移动到文件末尾</td></tr><tr class="even"><td style="text-align: left;">数字+G</td><td>移动到对应行</td></tr></tbody></table><h3 id="编辑模式">编辑模式</h3><p>在一般模式中无法编辑文件内容，需要按键一些按钮才能进入编辑模式，按键以及对应的含义如下：</p><table><thead><tr class="header"><th>按键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>i</td><td>当前光标前</td></tr><tr class="even"><td>a</td><td>当前光标后</td></tr><tr class="odd"><td>o</td><td>当前光标行的下一行</td></tr><tr class="even"><td>I</td><td>光标所在行的行首</td></tr><tr class="odd"><td>A</td><td>光标所在行的行尾</td></tr><tr class="even"><td>O</td><td>当前光标行的上一行</td></tr></tbody></table><p>一般情况下使用<code>i</code>即可，退出编辑模式则使用<code>Esc</code></p><h3 id="命令模式">命令模式</h3><p>在一般模式中，输入<code>: / ?</code>三个中的任意一个按键，可以进入命令模式。在命令模式中，可以完成一些命令的输入，常用的命令如下：</p><table><thead><tr class="header"><th>命令</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>:w</td><td>保存</td></tr><tr class="even"><td>:q</td><td>退出</td></tr><tr class="odd"><td>:!</td><td>强制执行</td></tr><tr class="even"><td>/要查找的词</td><td>n查找下一个，N查找上一个</td></tr><tr class="odd"><td>:noh</td><td>取消高亮显示</td></tr><tr class="even"><td>:set nu</td><td>显示行号</td></tr><tr class="odd"><td>:set nonu</td><td>关闭行号</td></tr><tr class="even"><td>:s/old/new</td><td>替换当前行匹配到的第一个old为new</td></tr><tr class="odd"><td>:s/old/new/g</td><td>替换当前行匹配到的所有old为new</td></tr><tr class="even"><td>:%s/old/new</td><td>替换文档中每一行匹配到的第一个old为new</td></tr><tr class="odd"><td>:%s/old/new /g</td><td>替换文档中匹配到的所有old为new</td></tr></tbody></table><h1 id="常用shell命令">常用Shell命令</h1><h2 id="帮助命令">帮助命令</h2><ul><li><code>man &lt;命令或配置文件&gt;</code> ：获得帮助信息</li><li><code>help 命令</code>：获取shell内置命令的帮助信息<ul><li>一部分基础功能的系统命令是直接内嵌在shell中的，系统加载启动之后会随着shell一起加载，常驻在系统内存中，这部分命令被称为内置命令；相应的其他命令被称为外部命令</li><li>可以使用<code>type 命令</code>来判断命令的类型</li></ul></li><li><code>命令 --help</code>：获取命令的帮助信息</li></ul><h2 id="文件目录操作">文件目录操作</h2><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>cd</td><td>进入目录<br />cd -：回到上一步所在的目录（反复横跳）<br />-P：进入软链接对应的真实目录</td></tr><tr class="even"><td>pwd</td><td>显示当前的绝对路径</td></tr><tr class="odd"><td>ls</td><td>查看文件目录列表<br />-F：查看目录中的内容<br />-a：查看隐藏文件<br />-l：查看详情列表<br />-lh：增强文件大小的易读性</td></tr><tr class="even"><td>tree</td><td>查看文件和目录的树形结构</td></tr><tr class="odd"><td>mkdir</td><td>创建目录<br />-p：创建多层目录</td></tr><tr class="even"><td>rmdir</td><td>删除空目录</td></tr><tr class="odd"><td>rm</td><td>删除文件或目录<br />-r：递归删除<br />-f：强制执行删除<br />-v：显示指令的详细执行过程</td></tr><tr class="even"><td>cp</td><td>复制文件或目录<br />-r：递归复制整个文件夹</td></tr><tr class="odd"><td>mv</td><td>移动文件与目录，或者重命名</td></tr><tr class="even"><td>echo</td><td>输出内容到控制台<br />-e：支持反斜线控制的字符转换</td></tr><tr class="odd"><td>&gt;</td><td>输出重定向，覆盖写</td></tr><tr class="even"><td>&gt;&gt;</td><td>输出重定向，追加写</td></tr><tr class="odd"><td>ln</td><td>软链接<br />ln -s [原文件或目录][软链接名称]，给原文件创建一个软链接<br />删除软链接：rm -rf软链接名（注意不是rm -rf 软链接名/，这样会删除真实内容）</td></tr><tr class="even"><td>history</td><td>查看已经执行过的历史命令</td></tr></tbody></table><h2 id="文件查看和处理">文件查看和处理</h2><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>touch</td><td>创建空文件</td></tr><tr class="even"><td>cat</td><td>查看文件内容，-n表示显示行号</td></tr><tr class="odd"><td>more</td><td>基于Vi编辑器的文本过滤器，以全屏幕的方式按页显示文本文件的内容</td></tr><tr class="even"><td>less</td><td>比more指令更加强大，根据显示需要加载内容，对于大型文件具有较高的效率</td></tr><tr class="odd"><td>head</td><td>显示文件头部内容，-n表示显示的行数，默认为10</td></tr><tr class="even"><td>tail</td><td>显示文件尾部内容<br />-n：显示的行数，默认为10<br />-f：实时追踪该文档的所有更新</td></tr></tbody></table><h2 id="系统信息和性能">系统信息和性能</h2><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>uname</td><td>查看信息<br />-a：查看内核/OS/CPU信息<br />-r：查看内核版本<br />-m：查看处理器架构</td></tr><tr class="even"><td>arch</td><td>查看处理器架构</td></tr><tr class="odd"><td>hostname</td><td>查看计算机名称（<code>/etc/hostname</code>）</td></tr><tr class="even"><td>uptime</td><td>查看系统运行时间、用户数、负载</td></tr><tr class="odd"><td>env</td><td>查看系统的环境变量</td></tr><tr class="even"><td>iostat</td><td>查看IO读写和CPU使用情况</td></tr><tr class="odd"><td>sar -u 1 10</td><td>查询cpu使用情况（1秒一次，共10次）</td></tr><tr class="even"><td>sar -d 1 10</td><td>查询磁盘性能（1秒一次，共10次）</td></tr></tbody></table><h2 id="用户管理">用户管理</h2><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>useradd [user_name]</td><td>添加新用户<br />useradd -g group_nameuser_name：添加新用户到某个组</td></tr><tr class="even"><td>passwd</td><td>修改用户密码<br />passwd：修改当前用户的密码<br />passwduser_name：修改用户的密码</td></tr><tr class="odd"><td>id user_name</td><td>查看用户是否存在</td></tr><tr class="even"><td>su</td><td>切换用户 switch user<br />suuser_name：切换用户，只能获得用户的执行权限，不能获得环境变量<br />su -user_name：完整地切换到另一个用户环境，可以获得该用户的环境变量和执行权限</td></tr><tr class="odd"><td>userdel [user_name]</td><td>删除用户<br />-r：删除用户的同时，删除与用户相关的所有文件</td></tr><tr class="even"><td>who</td><td>查看登陆用户的信息<br />whoami和who am i的输出不同</td></tr><tr class="odd"><td>sudo</td><td>设置普通用户具有root权限</td></tr><tr class="even"><td>usermod -g group_name user_name</td><td>修改用户的所在组</td></tr></tbody></table><blockquote><p>普通用户能够使用sudo的前提是添加到了sudoers文件中：</p><p>修改<code>/etc/sudoers</code>，添加对应的普通用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Allow root to run any commands anywhere</span></span><br>root ALL=(ALL) ALL<br>myuser ALL=(ALL) ALL<br></code></pre></td></tr></table></figure><p>或者可以配置成采用sudo命令时，不需要输入密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Allow root to run any commands anywhere</span></span><br>root ALL=(ALL) ALL<br>myuser ALL=(ALL) NOPASSWD:ALL<br></code></pre></td></tr></table></figure></blockquote><h2 id="用户组管理">用户组管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。在Linux下，创建用户时，会创建一个和它同名的用户组。用户组的管理涉及用户组的添加、删除和修改，实际上都是对<code>/etc/group</code>文件的更新</p><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>groups user_name</td><td>查看用户所在的组</td></tr><tr class="even"><td>groupadd group_name</td><td>创建用户组</td></tr><tr class="odd"><td>groupdel group_name</td><td>删除用户组</td></tr><tr class="even"><td>groupmod -n new_group old_group</td><td>重命名组的名称</td></tr></tbody></table><h2 id="文件权限">文件权限</h2><p>Linux中，不同的用户处于不同的地位，拥有不同的权限。不同的用户访问同一文件的权限有不同的规定，主要分为文件所属者的权限，文件所属组的权限，其他用户的权限。使用<code>ll</code>命令查看文件的详细信息和权限：</p><img src="/2022/06/28/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.png" class="" title="文件属性"><ul><li>如果没有权限，则使用<code>-</code>表示</li><li>类型字段可能是:<ul><li><code>-</code>：文件</li><li><code>d</code>：目录</li><li><code>l</code>：链接文档</li></ul></li><li>对于文件<ul><li>r：可读，表示可以读取和查看</li><li>w：可写，表示可以修改，但是不代表可以删除该文件。能够删除一个文件的前提是对该文件所在的目录有写权限</li><li>x：可执行，表示可以系统执行</li></ul></li><li>对于目录<ul><li>r：可读，可以读取，ls查看目录内容</li><li>w：可写，可以修改，可以在目录内创建，删除和重命名</li><li>x：可执行，可以进入该目录</li></ul></li></ul><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>chmod</td><td>修改权限 <br />chmod [{ugoa}{+-=}{rwx}]文件/文件夹：变更权限<br />eg： chomd ugo+rwxdir1，表示给所有者u，所有组g和其他用户o添加rwx权限<br />chmod [mode=xxx]文件/文件夹：三个数字分别表示ugo的权限<br /> r=4 w=2x=1（实际是二进制编码）<br />eg： chmod -R 777 dir1：递归指定权限</td></tr><tr class="even"><td>chown</td><td>修改所有者<br />chown user_name 文件/目录<br />-R：递归操作</td></tr><tr class="odd"><td>chgrp</td><td>修改所属组<br />chgrp group_name 文件/目录</td></tr></tbody></table><h2 id="搜索查找">搜索查找</h2><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>find [搜索起点] [选项]</td><td>查找文件或者目录<br />-name：按照文件名或查找模式查找<br />-user：按照所有者进行查找<br />-size：按照指定的文件大小查找（+n大于-n小于 n等于）<br />eg： find /home -size +10M</td></tr><tr class="even"><td>locate</td><td>快速定位文件路径，由于locate指令基于数据库进行查询，所以应该在第一次运行前，使用updatedb指令创建locate数据库</td></tr><tr class="odd"><td>whereis [关键词]</td><td>显示某二进制文件/可执行文件的路径</td></tr><tr class="even"><td>which [关键词]</td><td>查找系统目录下的某二进制文件</td></tr><tr class="odd"><td>|</td><td>管道符，将前一个命令的处理结果输出传递给后面的命令</td></tr><tr class="even"><td>grep [选项] [查找内容] [源文件]</td><td>过滤查找，-n表示显示匹配行以及行号</td></tr></tbody></table><h2 id="压缩解压">压缩解压</h2><table><thead><tr class="header"><th>命令</th><th>作用6</th></tr></thead><tbody><tr class="odd"><td>gzip [文件]</td><td>压缩文件，将文件压缩为.gz文件<br />需要注意：<br />只能压缩文件不能压缩目录；<br />不保留原来的文件；<br />同时压缩多个文件会产生多个压缩包</td></tr><tr class="even"><td>gunzip [文件.gz]</td><td>解压缩文件</td></tr><tr class="odd"><td>zip [选项] [xxx.zip] [需要压缩的内容]</td><td>压缩文件或者目录，可以压缩多个文件和目录<br />-r：压缩目录</td></tr><tr class="even"><td>unzip [选项] xxx.zip</td><td>解压<br />-d：指定解压后文件的存放目录</td></tr><tr class="odd"><td>tar [选项] xxx.tar.gz 将要打包的内容</td><td>打包目录<br />-c：产生.tar打包文件<br />-v：显示详细信息<br />-f：指定压缩后的文件名<br />-z：打包同时压缩<br />-x：解压.tar文件<br />-C：解压到指定目录</td></tr><tr class="even"><td>tar -cvf xxx.tar file</td><td>创建非压缩的tar包</td></tr><tr class="odd"><td>tar -cvf xxx.tar file1 file2 dir1</td><td>将多个文件和目录进行打包</td></tr><tr class="even"><td>tar -xcf xxx.tar</td><td>解压tar包</td></tr><tr class="odd"><td>tar -cvfz xxx.tar.gz dir</td><td>创建gzip压缩包</td></tr><tr class="even"><td>tar -zxvf xxx.tar.gz</td><td>解压gzip压缩包</td></tr></tbody></table><h2 id="磁盘分区">磁盘分区</h2><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>du [目录/文件]</td><td>disk usage查看文件或者目录的大小<br />-h：显示成更加易读的格式<br />-a：不仅查看子目录的大小，还需要包括文件<br />-c：显示所有文件和子目录大小后，再显示总和<br />-s：只显示文件大小总和<br />--max-depth=n：指定子目录的深度</td></tr><tr class="even"><td>df [选项]</td><td>diskfree：查看磁盘的使用情况<br />-h：显示成易读的格式，查看磁盘使用情况以及挂载点</td></tr><tr class="odd"><td>lsblk</td><td>查看设备的挂载情况<br />-f：查看详细的设备挂载情况，显示文件系统信息</td></tr><tr class="even"><td>mount [-t vfstype] [-o options] device dir</td><td>挂载设备<br />-t：指定文件系统的类型，通常不必指定<br />-o：描述设备或档案的挂载方式，常用的参数有<br />loop：把一个文件当成硬盘分区挂载上系统<br />ro：采用只读方式挂接设备<br />rw：采用读写方式挂接设备<br />iocharset：指定访问文件系统所用的字符集</td></tr><tr class="odd"><td>umount 设备文件名或者挂载点</td><td>卸载设备</td></tr><tr class="even"><td>fdisk -l</td><td>查看磁盘的分区详情</td></tr><tr class="odd"><td>fdisk 硬盘设备名</td><td>对新增硬盘进行分区操作</td></tr><tr class="even"><td>swapon -s</td><td>查看磁盘使用情况以及挂载点</td></tr></tbody></table><h2 id="进程线程">进程线程</h2><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>ps</td><td>process status 进程状态<br />举例：<br />ps aux | grepxxx：查看系统中所有的进程<br />ps -ef | grepxxx：可以查看父子进程之间的关系<br />参数说明：<br />a：列出带有终端的所有用户的进程<br />x：列出当前用户的所有进程，包括没有终端的进程<br />u：用户友好的显示风格<br />-e：列出所有进程<br />-u：列出某个用户相关的所有进程<br />-f：显示完整格式的进程列表</td></tr><tr class="even"><td>kill -s name</td><td>根据名称杀死进程<br />-9：表示强迫进程立即停止</td></tr><tr class="odd"><td>kill -s pid</td><td>根据进程号杀死进程</td></tr><tr class="even"><td>killall name</td><td>杀死所有相关的进程</td></tr><tr class="odd"><td>pstree</td><td>查看进程树</td></tr><tr class="even"><td>top</td><td>实时监控系统进程状态</td></tr><tr class="odd"><td>netstat</td><td>显示网络状态和端口占用信息<br />-a：显示所有正在监听和未监听的socket<br />-n：拒绝显示别名，能显示数字的全部转化为数字<br />-l：仅列出在监听的服务状态<br />-p：表示显示哪个进程在调用</td></tr><tr class="even"><td>netstat -anp | grep 进程号</td><td>查看该进程网络信息</td></tr><tr class="odd"><td>netstat -nlp | grep 端口号</td><td>查看网络端口号的占用情况</td></tr></tbody></table><ul><li>ps aux显示信息<ul><li>USER：产生进程的用户</li><li>PID：进程的ID号</li><li>%CPU：该进程占用CPU资源的百分比</li><li>%MEM：该进程占用物理内存的百分比</li><li>VSZ：该进程占用虚拟内存的大小，单位为KB</li><li>RSS：该进程占用实际物理内存的大小，单位为KB</li><li>TTY：该进程是在哪个终端中运行的。<ul><li>对于CentOS来说，tty1为图形化终端，tty2-tty6是本地的字符界面终端</li><li>pts/0-255代表虚拟终端</li></ul></li><li>STAT：进程状态</li><li>START：该进程的启动时间</li><li>TIME：该进程占用CPU的运算时间</li><li>COMMAND：产生此进程的命令名</li></ul></li><li>ps -ef显示信息<ul><li>UID：用户ID</li><li>PID：进程ID</li><li>PPID：父进程ID</li><li>C：CPU用于计算执行优先级的因子，数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是IO密集型运算，执行优先级会提高</li><li>STIME：进程启动的时间</li><li>TTY：完整的终端名称</li><li>CMD：启动进程所用的命令和参数</li></ul></li></ul><h2 id="系统管理">系统管理</h2><ul><li>进程（process）：计算机中一个正在执行的程序和命令</li><li>服务（service）：启动之后常驻内存的进程</li></ul><h3 id="系统管理相关的常用命令">系统管理相关的常用命令</h3><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>chkconfig --list</td><td>列出系统服务</td></tr><tr class="even"><td>service <服务名> status</td><td>查看某个服务</td></tr><tr class="odd"><td>service <服务名> start</td><td>启动某个服务</td></tr><tr class="even"><td>service <服务名> stop</td><td>终止某个服务</td></tr><tr class="odd"><td>service <服务名> restart</td><td>重启某个服务</td></tr><tr class="even"><td>systemctl status <服务名></td><td>查看某个服务</td></tr><tr class="odd"><td>systemctl start <服务名></td><td>启动某个服务</td></tr><tr class="even"><td>systemctl stop <服务名></td><td>终止某个服务</td></tr><tr class="odd"><td>systemctl restart <服务名></td><td>重启某个服务</td></tr><tr class="even"><td>systemctl enable <服务名></td><td>开启服务自启动</td></tr><tr class="odd"><td>systemctl disable <服务名></td><td>关闭服务自启动</td></tr></tbody></table><h3 id="关机重启命令">关机重启命令</h3><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>sync</td><td>将数据由内存同步到硬盘中</td></tr><tr class="even"><td>halt</td><td>停机，关闭系统但是不断电</td></tr><tr class="odd"><td>poweroff</td><td>关机，断电</td></tr><tr class="even"><td>reboot</td><td>重启</td></tr><tr class="odd"><td>shutdown -h now</td><td>现在关机</td></tr><tr class="even"><td>shutdown -h 10</td><td>10分钟后关机</td></tr><tr class="odd"><td>shutdown -h 12:34</td><td>预定时间在12：34关机</td></tr><tr class="even"><td>shutdown -r now</td><td>现在重启</td></tr><tr class="odd"><td>shutdown -r 10</td><td>10分钟后重启</td></tr><tr class="even"><td>shutdown -h 12:34</td><td>预定时间在12：34重启</td></tr><tr class="odd"><td>shutdown -c</td><td>取消预定关机操作</td></tr></tbody></table><h3 id="系统定时任务">系统定时任务</h3><p>使用crontab完成系统定时任务，对应的后台服务为crond服务，可以使用系统管理命令重启查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart crond<br></code></pre></td></tr></table></figure><p>采用crontab进行定时任务设置，基本语法为<code>crontab [option]</code>，可选选项有：</p><ul><li>-e：编辑crontab定时任务</li><li>-l：查询crontab任务</li><li>-r：删除当前用户所有的crontab任务</li></ul><p>使用-e之后会进入crontab编辑页面，会打开vim进行任务编辑，一个例子如下，表示每隔一分钟，向<code>/root/test.txt</code>文件中添加hello</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">*/1 * * * * /bin/echo &quot;hello&quot; &gt;&gt; /root/test.txt<br></code></pre></td></tr></table></figure><h2 id="软件包管理">软件包管理</h2><h3 id="rpm">RPM</h3><p>RPM（RedHat PackageManager），是RedHat的软件包管理工具。软件的安装包为<code>.rpm</code>后缀的文件</p><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>rpm -qa</td><td>查看已经安装的rpm包</td></tr><tr class="even"><td>rpm -q package_name</td><td>查询某个rpm包</td></tr><tr class="odd"><td>rmp -e xxx</td><td>卸载软件包</td></tr><tr class="even"><td>rpm -ivh xxx.rpm</td><td>安装rpm包<br />-i：安装<br />-v：显示详细信息<br />-h：显示进度条<br />--nodeps：安装前不检查依赖</td></tr></tbody></table><h3 id="yum">YUM</h3><p>YUM（全称为Yellow dogUpdater，Modified），是一个在Fedora，RedHat和CentOS中的Shell前端软件包管理器。它基于rpm包管理，能够从指定的服务器自动下载rpm包并且安装，并且可以自动处理依赖性关系，并且一次性安装所有依赖的软件包。</p><p>主要命令格式为<code>yum [选项] [参数]</code></p><p>选项可选有-y，表示对所有的提问都回答”yes“</p><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>yum repolist enabled</td><td>显示可用的源仓库</td></tr><tr class="even"><td>yum search package_name</td><td>搜索软件包</td></tr><tr class="odd"><td>yum install package_name</td><td>下载并安装软件包</td></tr><tr class="even"><td>yun install --downloadonly package_name</td><td>只下载不安装</td></tr><tr class="odd"><td>yum list</td><td>显示所有程序包</td></tr><tr class="even"><td>yum list installed</td><td>查看当前系统已安装包</td></tr><tr class="odd"><td>yum list updates</td><td>查看可以更新的包列表</td></tr><tr class="even"><td>yum check-update</td><td>查看可升级的软件包</td></tr><tr class="odd"><td>yum update</td><td>更新所有软件包</td></tr><tr class="even"><td>yum update package_name</td><td>升级指定软件包</td></tr><tr class="odd"><td>yum deplist package_name</td><td>列出软件包依赖关系</td></tr><tr class="even"><td>yum remove package_name</td><td>删除软件包</td></tr><tr class="odd"><td>yum clean all</td><td>清除缓存</td></tr><tr class="even"><td>yum clean packages</td><td>清除缓存的软件包</td></tr><tr class="odd"><td>yum clean headers</td><td>清除缓存的header</td></tr></tbody></table><h3 id="apt">APT</h3><table><thead><tr class="header"><th>命令</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>apt-cache search package_name</td><td>搜索对应的程序包</td></tr><tr class="even"><td>apt-cache show package_name</td><td>获取包的概览信息</td></tr><tr class="odd"><td>apt-get install package_name</td><td>安装/升级软件包</td></tr><tr class="even"><td>apt-get purge package_name</td><td>卸载软件（包括配置）</td></tr><tr class="odd"><td>apt-get remove package_name</td><td>卸载软件（不包括配置）</td></tr><tr class="even"><td>apt-get update</td><td>更新包索引信息</td></tr><tr class="odd"><td>apt-get upgrade</td><td>更新已安装软件包</td></tr><tr class="even"><td>apt-get clean</td><td>清理缓存</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础笔记</title>
    <link href="/2022/06/27/MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/27/MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql基础笔记">MySQL基础笔记</h1><h2 id="一.常用命令">一.常用命令</h2><p><strong>启动和停止MySQL服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">//windows<br>net start mysql<br>net stop mysql<br>//linux<br>service mysqld start<br>service mysqld stop<br>service mysqld status<br></code></pre></td></tr></table></figure><p><strong>登录mysql</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -h 主机地址 -u 用户名 -p 用户密码 -P 连接端口号<br>mysql -uroot -p<br></code></pre></td></tr></table></figure><p><strong>常用命令</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">修改字符集：<span class="hljs-keyword">set</span> names xxx;<br>展示数据库：<span class="hljs-keyword">show</span> databases;<br>使用某一个数据库：use xxx;<br>展示表：<span class="hljs-keyword">show</span> tables; <span class="hljs-keyword">show</span> tables <span class="hljs-keyword">from</span> xxx;<br>查案当前所在数据库：<span class="hljs-keyword">select</span> database();<br>创建表：<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> xxx(字段名称 数据类型,...);<br>查看表的结构：<span class="hljs-keyword">desc</span> xxx;<br>插入数据：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> xxx <span class="hljs-keyword">values</span>(...);<br>更新数据：<span class="hljs-keyword">update</span> 表名称 <span class="hljs-keyword">set</span> 属性名称 <span class="hljs-operator">=</span> xxx <span class="hljs-keyword">where</span> 字段名称 <span class="hljs-operator">=</span>xx;<br>删除数据：<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名称 <span class="hljs-keyword">where</span> 名称字段<span class="hljs-operator">=</span>xx；<br>修改表结构：<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名称 ...<br>删除表：<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> 表名称;<br>退出客户端：exit<br></code></pre></td></tr></table></figure><p><strong>Linux服务器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">//配置开机自启<br>1.修改文件 添加service mysqld start<br>vim /etc/rc.local<br> <br>2.启动服务：<br>systemctl start mysqld<br><br>3.设置开机自启动：<br>systemctl enable mysqld<br>systemctl daemon-reload<br><br>//配置远程登陆<br>1.在安全组中入规则开放3306端口<br>2.通过shell登录数据库<br>mysql -uroot -p<br>3.查看当前连接规则<br>use mysql;<br>select host,user from user;<br>4.修改连接规则<br>update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;<br>ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;yourpassword&#x27;;<br>5.刷新权限<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><blockquote><p>安装过程：（在Centos8上安装mysql8）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">下载</span><br>wget https://dev.mysql.com/get/mysql80-community-release-el8-1.noarch.rpm<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装数据源</span><br>yum install mysql80-community-release-el8-1.noarch.rpm<br><span class="hljs-meta prompt_">#</span><span class="language-bash">检查数据源</span><br>yum repolist enabled | grep &quot;mysql.*-community.*&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">禁用CentOS8自带mysql模块</span><br>yum module disable mysql<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装数据库</span><br>yum install mysql-community-server<br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动mysql</span><br>service mysqld start<br>service mysqld status<br><span class="hljs-meta prompt_">#</span><span class="language-bash">显示mysql的随机密码</span><br>grep &#x27;temporary password&#x27; /var/log/mysqld.log<br><span class="hljs-meta prompt_">#</span><span class="language-bash">登录mysql</span><br>mysql -u root -p<br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改密码</span><br>ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Test_123456&#x27;;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看密码策略</span><br>SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">开放远程访问</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">1.创建权限用户记录</span><br>create user &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;Test_123456&#x27;;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">2.授权</span><br>grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; with grant option;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">开放3306端口</span><br></code></pre></td></tr></table></figure></blockquote><p>1.创建表的时候指定主键和外键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[CONSTRAINT 外键名]  FOREIGN KEY (外键字段名) REFERENCES  父表名(参照字段名);<br>PRIMARY KEY (主键字段名)<br></code></pre></td></tr></table></figure><p>2.创建表之后指定外键依赖关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 子表名 ADD [CONSTRAINT 外键名] FOREIGN KEY(外键字段名) REFERENCES 父表名(参照字段名);<br></code></pre></td></tr></table></figure><h2 id="二.学习笔记">二.学习笔记</h2><h3 id="数据准备">1. 数据准备</h3><p>导入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">source  sql路径<br></code></pre></td></tr></table></figure><blockquote><p>示例数据：bjpowernode.sql</p><p>表格：show tables；</p><p>dept：部门表</p><p>emp：员工表</p><p>salgrade：工资等级表</p></blockquote><p>大致查看数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查看所有数据：<br>select * from 表名称; <br><br>查看表的结构：<br>desc 表名;<br>describe 表名;<br><br>查看mysql版本：<br>select version();<br><br>查看当前使用的数据库：<br>select database();<br></code></pre></td></tr></table></figure><h3 id="sql语句">2. SQL语句</h3><p>简单分类：</p><ol type="1"><li>DDL（Data Definition Language）：数据定义语言</li><li>DML（Data Manipulation Language）：数据操作语言</li><li>DCL（Data Control Language）：数据控制语言</li><li>DQL（Data Query Language）：数据查询语言</li></ol><h3 id="简单查询">3. 简单查询</h3><p><strong>查询</strong>：<strong>select</strong> ...<strong>from</strong> ... <strong>where</strong>...</p><ul><li>select后面也可以直接跟字面值，例如1，'abc'...</li><li>字面值会借助表结构直接打印出来</li><li><strong>distinct</strong>：去重（select distinct）</li></ul><p><strong>起别名</strong>：使用<strong>as</strong>关键字，或者使用空格</p><blockquote><p>在所有的数据库中，字符串统一使用单引号，单引号是标准。</p><p>双引号在oracle数据库中用不了，在mysql中可以使用。</p></blockquote><p><strong>条件查询</strong>：可以使用比较符号</p><table><thead><tr class="header"><th>条件查询运算符</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>=</td><td>&lt;</td><td>&gt;</td></tr><tr class="even"><td>&lt;&gt; 或者 !=</td><td>&lt;=</td><td>&gt;=</td></tr><tr class="odd"><td>between ... and ...</td><td>is null</td><td>is not null</td></tr><tr class="even"><td>and</td><td>or</td><td>in</td></tr><tr class="odd"><td>not</td><td>like</td><td></td></tr></tbody></table><ul><li>like模糊查询，支持使用<code>%</code>和<code>_</code>进行匹配，前者匹配任意个字符，后者匹配一个字符</li><li>between and：必须左小右大，并且包含观点</li></ul><p><strong>排序</strong>：使用关键字<strong>order by</strong></p><ul><li><p>默认是升序，指定降序需要在后面添加<strong>desc</strong>（升序为<strong>asc</strong>）</p></li><li><p>多个字段排序：使用逗号隔开多个字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">order by sal desc, name asc;<br></code></pre></td></tr></table></figure></li><li><p>也可以使用字段位置- 不建议使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">order by 2;<br>//表示第二列<br></code></pre></td></tr></table></figure></li></ul><h3 id="数据处理函数单行处理函数">4. 数据处理函数（单行处理函数）</h3><p>数据处理函数又称为单行处理函数（一个输入对应一个输出）</p><p>ifnull：在所有数据库的运算当中，只要有null参与运算，结果都是null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ifnull可以进行空处理<br>ifnull(数据， 如果数据是null时候的替代值)<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>字符函数</th><th></th></tr></thead><tbody><tr class="odd"><td>concat(str1, str2,...)</td><td>拼接函数</td></tr><tr class="even"><td>length(str)</td><td>获取字节长度</td></tr><tr class="odd"><td>char_length(str)</td><td>获取字符长度</td></tr><tr class="even"><td>substr(str, 起始索引, 截取长度)</td><td>截取字符（第一个字符索引为1）</td></tr><tr class="odd"><td>instr(str, substr)</td><td>获取字符串第一次出现的索引</td></tr><tr class="even"><td>trim(str)</td><td>去除前后指定的字符，默认去除空格</td></tr><tr class="odd"><td>lpad/rpad(str, 要求字符长度，填充字符长度)</td><td>左填充和右填充</td></tr><tr class="even"><td>upper/lower(str)</td><td>转大小写</td></tr><tr class="odd"><td>strcmp(str1, str2)</td><td>比较两个字符的大小</td></tr><tr class="even"><td>left/right(str, 截取指定长度)</td><td>从左边或者右边截取字符串</td></tr></tbody></table><table><thead><tr class="header"><th>数学函数</th><th></th></tr></thead><tbody><tr class="odd"><td>abs()</td><td>绝对值</td></tr><tr class="even"><td>ceil()/floor()</td><td>向上向下取整</td></tr><tr class="odd"><td>round(数字， 位数)</td><td>四舍五入，可以指定保留位数（位数可以是负数）</td></tr><tr class="even"><td>truncate()</td><td>可以指定小数点后保留位数</td></tr><tr class="odd"><td>mod()</td><td>取余</td></tr></tbody></table><table><thead><tr class="header"><th>时间日期函数</th><th></th></tr></thead><tbody><tr class="odd"><td>now</td><td>当前日期+时间</td></tr><tr class="even"><td>curdate</td><td>当前日期</td></tr><tr class="odd"><td>curtime</td><td>当前时间</td></tr><tr class="even"><td>datediff(expr1, expr2)</td><td>两个时间的查</td></tr><tr class="odd"><td>date_format(expr, fmt)</td><td>日期格式，fmt为格式化字符串</td></tr><tr class="even"><td>str_to_date(expr, fmt)</td><td>根据指定格式解析字符串为日期格式</td></tr></tbody></table><table><thead><tr class="header"><th>流程控制函数</th><th></th></tr></thead><tbody><tr class="odd"><td>if(expr1, expr2, expr3)</td><td>类似于?:运算符</td></tr><tr class="even"><td>case()</td><td>类似于switch-case</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">case 表达式<br>when 值1/条件1 then 结果1<br>when 值2/条件2 then 结果2<br>...<br>eles 结果n<br>end<br></code></pre></td></tr></table></figure><h3 id="分组处理函数多行处理函数">5. 分组处理函数（多行处理函数）</h3><p>sum、avg、max、min、count</p><p>分组处理函数在使用之前必须先进行分组，如果没有进行分组的话，则默认整张表为一个组。</p><ul><li>分组函数自动忽略null</li><li>count(*)和count(具体字段)的区别具体字段中可能会具有null，但是一行中全部为null的情况是不会出现的</li></ul><blockquote><p>已有的关键字的执行顺序：</p><p>from &gt; where &gt; group by &gt; select &gt; order by</p><p>分组函数不能直接用在where之后，因为在where执行的时候还没有进行分组</p></blockquote><p>分组关键字：<strong>group by</strong></p><ul><li>可以有多个分组条件，用逗号隔开</li></ul><p>分组后筛选使用关键字：<strong>having</strong></p><p>分组前筛选使用关键字：<strong>where</strong></p><blockquote><p>优化策略：having和where优先使用where，能用where先过滤的先使用where</p></blockquote><h3 id="连接查询">6. 连接查询</h3><p>连接查询：多表连接</p><p>分类：</p><ul><li>内连接：等值连接、非等值连接、自连接</li><li>外连接：左外连接、右外连接</li><li>全连接</li></ul><blockquote><p>连接查询的时候，应该要想办法降低笛卡尔乘积的次数，减少表的连接次数</p></blockquote><p><strong>内连接</strong>：</p><p>SQ92语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 查询列表<br>from 表名1,表名2,...<br>where 筛选条件 and (其他条件)<br></code></pre></td></tr></table></figure><ul><li>缺点：结构不侵袭，表的连接条件和后续其他筛选条件混在一起</li></ul><p>SQ99语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 查询列表<br>from 表名1 别名1<br>(inner) join 表名2 别名2<br>on 连接条件<br>...join ...<br>on ...<br>where 筛选条件<br></code></pre></td></tr></table></figure><ul><li>等值连接：连接条件是等价关系</li><li>非等值连接：连接条件不是等价关系（例如在范围之间等）</li><li>自连接：自己和自己连接</li></ul><p><strong>外连接</strong>：</p><p>内连接的特点：完全能够匹配才出现在结果中</p><p>外连接：某张表中的内容会全部显示，哪张表全部显示则对应了左右全外连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">left/right/full (outer) join<br></code></pre></td></tr></table></figure><h3 id="子查询">7. 子查询</h3><p>子查询就是select语句嵌套select语句。</p><p>from后面的子查询可以将子查询的结果当作一张临时表</p><blockquote><p>select后面：要求子查询的结果为单行单列</p><p>from后面：要求子查询的结果可以为多行多列</p><p>where或having后面：要求子查询的结果必须为单列</p><p>exists后面：要求子查询结果必须为单列（相关子查询）</p></blockquote><p><strong>union</strong>的用法：union联合查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">(子查询)<br>union<br>(子查询)<br></code></pre></td></tr></table></figure><ul><li><p>当查询结果来自多张表，但是多张表之间没有关联的时候，这个时候往往使用union将表结果进行合并</p></li><li><p>多条查询语句的列数必须一致（相当于在后面拼接）</p><blockquote><p>列的数据类型在mysql中不要求一致，在Oracle中要求一致</p></blockquote></li><li><p>union自动去重，union all可以支持重复项</p></li></ul><blockquote><p>union的效率要高一些，对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积</p><p>union可以满足匹配的次数，在减少匹配次数的情况下，还可以完成两个结果集的拼接</p></blockquote><h3 id="分页查询">8. 分页查询</h3><p>使用<strong>limit</strong>关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">limit 起始条目索引, 显示的条目数<br></code></pre></td></tr></table></figure><ul><li>limit语句放在命令后面，也在最后执行</li><li>起始条目索引从0开始</li></ul><h3 id="表的创建和删除">9. 表的创建和删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名(<br>    字段名1 数据类型,<br>    字段名2 数据类型,<br>    ...,<br>    字段名n 数据类型<br>);<br></code></pre></td></tr></table></figure><ul><li>最后一个没有逗号</li></ul><table><thead><tr class="header"><th>常见的数据类型</th><th></th></tr></thead><tbody><tr class="odd"><td>varchar(n)</td><td>可变长度字符串（根据实际存储决定开辟空间，n表示最多存储字符数，最多255，必须给出）</td></tr><tr class="even"><td>char(n)</td><td>固定长度字符串（无论存储，实际开辟n个字符的空间，n不写默认为1，最多255）</td></tr><tr class="odd"><td>int</td><td>数字中的整数型，java-int</td></tr><tr class="even"><td>bigint</td><td>数字中的长整型，java-long</td></tr><tr class="odd"><td>float</td><td>单精度浮点数</td></tr><tr class="even"><td>double</td><td>双精度浮点数</td></tr><tr class="odd"><td>date</td><td>短日期类型</td></tr><tr class="even"><td>datetime</td><td>长日期类型</td></tr><tr class="odd"><td>clob</td><td>字符大对象，最多可以存储4G的字符串</td></tr><tr class="even"><td>blob</td><td>二进制大对象</td></tr></tbody></table><p>表的删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">删除表<br>drop table 表名;<br>drop table if exists 表名;<br></code></pre></td></tr></table></figure><h3 id="表中数据的操作">10. 表中数据的操作</h3><p><strong>插入数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 (字段名1, 字段名2, ...) values (值1, 值2, ...)<br></code></pre></td></tr></table></figure><ul><li>其中字段名和值需要一一对应</li><li>字段名可以省略，缺省表示匹配全部字段</li><li><code>value</code>为单行插入，<code>values</code>为多行插入</li></ul><p><strong>修改数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update 表名 set 字段1 = 值1, 字段2 = 值2, ... where 条件;<br></code></pre></td></tr></table></figure><ul><li>没有条件限制会导致所有数据全部更新</li></ul><p><strong>删除数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from 表名 where 条件;<br></code></pre></td></tr></table></figure><ul><li>没有条件全部删除</li><li>这种删除数据的方式比较慢：逐个删除，存储空间不释放，后续数据可以回滚</li><li>属于DML语句</li></ul><p><strong>表中数据的快速删除</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">truncate table 表名;<br></code></pre></td></tr></table></figure><ul><li>删除效率较高，物理删除：存储空间释放，后续数据不支持回滚</li><li>属于DDL语句</li><li>不能添加where语句</li></ul><p><strong>表的快速复制</strong>（快速复制表）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 新表名 as select * from 旧表名;<br></code></pre></td></tr></table></figure><ul><li>将一个查询结果当作一张表新建</li></ul><p><strong>将查询结果插入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 被插入的表名 select * from 查询表名;<br></code></pre></td></tr></table></figure><h3 id="对表结构的增删改">11. 对表结构的增删改</h3><p>实际业务当中，需求和表确定了之后，对表结构的修改一般是比较少的。因为成本较高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">添加字段<br>alter table 表名 add 新字段 数据类型;<br><br>修改字段<br>alter table 表名 modify 旧字段 新数据类型;<br><br>删除字段<br>alter table 表名 drop 旧字段;<br></code></pre></td></tr></table></figure><h3 id="约束">12. 约束</h3><p>约束：constraint</p><p>常见约束：</p><ul><li>非空约束：<strong>not null</strong></li><li>唯一性约束：<strong>unique</strong></li><li>主键约束：<strong>primary key</strong>（PK）</li><li>外键约束：<strong>foreign key</strong>（FK）</li><li>检查约束：<strong>check</strong>（mysql不支持，Oracle支持）</li></ul><blockquote><p>.sql文件被称为sql脚本文件，sql脚本文件中编写了大量的sql语句，批量执行sql语句可以使用sql脚本文件</p><p>利用source关键字执行</p></blockquote><p>注意事项：</p><ol type="1"><li><p>唯一性约束的字段可以为null，null和null不算重复</p></li><li><p>两个字段综合起来的唯一性（联合唯一）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table t_test (<br>    id int,<br>    name varchar(255),<br>    email varchar(255),<br>    unique(name, emial)<br>)<br></code></pre></td></tr></table></figure></li><li><p>约束分为列级约束和表级约束</p><ul><li>列级约束：直接添加在字段后面的约束，仅对单个字段的约束</li><li>表级约束：非列级约束，需要对多个字段进行约束</li></ul></li><li><p>not null只有列级约束</p></li><li><p>在mysql中，not null unique 自动变成 primarykey（在Oracle中不一样）</p></li><li><p>修改约束就是修改字段</p></li></ol><p><strong>主键约束</strong></p><ol type="1"><li><p>主键值是每一行记录的唯一标识</p></li><li><p>任何一张表都应该有主键，没有主键的话表是无效的</p></li><li><p>复合主键（是表级约束，但是在实际开发中不建议使用复合主键）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">primary key(id, name)<br></code></pre></td></tr></table></figure></li><li><p>主键值建议使用int、bigint、char等类型，不建议使用varchar</p></li><li><p>主键还可以分为自然主键和业务主键，<strong>自然主键使用比较多</strong></p></li><li><p>在mysql中，可以使用自增机制来帮助自动维护主键值，从1开始自增</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">id int primary key auto_increment<br></code></pre></td></tr></table></figure></li></ol><p><strong>外键约束</strong></p><ol type="1"><li><p>外键需要时刻保证外键值一定在另一张表中存在（涉及到表，数据等的创建和删除顺序）</p></li><li><p>外键约束的写法，写在字段定义的后面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">foreign key(本表字段) references 其他表名(该表字段)<br></code></pre></td></tr></table></figure></li><li><p>外键可以为null，外键在另一张表中一定要具有唯一性，不一定是主键</p></li></ol><h3 id="存储引擎">13. 存储引擎</h3><p>存储引擎是MySQL中特有的一个术语，实际存储引擎指的就是一个表存储和组织数据的方式，不同的存储引擎，表存储数据的方式不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">展示建表的时候的sql语句<br>show create table 表名<br></code></pre></td></tr></table></figure><p>可以在建表的时候指定存储引擎和字符编码方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table t_test (<br>    id int,<br>    name varchar(20)<br>)ENGINE=InnoDB DEFAULE CHARSET=utf8<br></code></pre></td></tr></table></figure><ul><li>mysql默认的存储引擎是：InnoDB</li><li>mysql默认的字符编码方式是：utf8</li></ul><p>服务器可用的引擎依赖于以下因素：</p><ul><li>mysql的版本</li><li>服务器在开发时候的配置</li><li>启动选项</li></ul><p>查看当前可用的存储引擎，使用show engines语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engines \G<br></code></pre></td></tr></table></figure><p><strong>常用的存储引擎</strong></p><p><strong>MyISAM</strong>：</p><ol type="1"><li>MyISAM存储引擎是MySQL最常用的引擎</li><li>使用三个文件来表示每个表<ul><li>格式文件：（mytable.frm）存储表结构的定义</li><li>数据文件：（mytable.MYD）存储表的行内容</li><li>索引文件：（mytable.MYI）存储表上的索引</li></ul></li><li>对于一张表来说，只要是主键，或者加有unique约束的字段上都会自动创建索引</li><li>优势：可用被转换为压缩或只读表来节省存储空间</li><li>不支持事务</li></ol><p><strong>InnoDB</strong>：</p><ol type="1"><li>这是MySQL默认的存储引擎，同时也是一个重量级的引擎</li><li>支持事务，支持数据库崩溃后的自动恢复机制</li><li>最主要的特点就是：非常安全</li><li>它管理的表具有以下特征<ul><li>每个InnoDB表在数据库目录中以.fmt格式文件表示</li><li>InnoDB表空间tablespace中用于存储表的内容（表空间是一个逻辑名称，表空间中存储表数据和索引）</li><li>提供一组用来记录事务性活动的日志文件</li><li>用commit，savepoint和rollback支持事务处理</li><li>提供全ACID兼容</li><li>在MySQL服务器崩溃后自动恢复</li><li>多版本（MVCC）和行级锁定</li><li>支持外键及引用的完整性，包括级联删除和更新</li></ul></li><li>InnoDB最大的特点就是支持事务，以保证数据的安全。因此它的效率不是很高，并且也不能压缩，不能转换为只读，不能很好的节省存储空间</li></ol><p><strong>MEMORY</strong>：</p><ol type="1"><li>数据存储在内存中，且行的长度固定，这使得MEMORY引擎非常快</li><li>MEMORY存储引擎管理的表具有以下特征：<ul><li>在数据库目录中，每个表均以.frm格式的文件表示</li><li>表数据及索引被存储在内存当中</li><li>表级的锁机制</li><li>不能包含text和blob字段</li></ul></li><li>MEMORY存储引擎以前被称为HEAP引擎</li><li>优点：查询效率最高，不需要和硬盘交互</li><li>缺点：不安全，断电后数据消失</li></ol><blockquote><p>引擎的选择：</p><ul><li>MyISAM表最适合存储大量的数据读，少量数据更新的混合操作，另一种适用情形是使用压缩的只读表</li><li>InnoDB引擎适合较多的数据更新操作，其行级锁机制和多版本的支持为数据读取和更新的混合操作提供了良好的并发机制</li><li>MEMORY引擎存储非永久需要的数据，或者是能够从基于硬盘的表中重新生成的数据</li></ul></blockquote><h3 id="事务">14. 事务</h3><p>事务的特性：ACID（原子性，一致性，隔离性，持久性）</p><p>与事务有关的语句是DML语句（insert、delete、update），其他语句与事务无关。</p><p>批量的DML语句同时成功或者同时失败。</p><p>实现原理：InnoDB存储引擎提供一组用来记录事务性活动的日志文件</p><ul><li>提交事务：清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中<ul><li>提交事务标志着事务的<strong>全部成功</strong>的结束</li></ul></li><li>回滚事务：将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件<ul><li>提交事务标志着事务的<strong>全部失败</strong>的结束</li><li>回滚事务只能回滚到上一次事务的提交点</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">事务举例：<br>start transaction;<br><br>...一系列操作<br><br>提交事务：commit;<br>回滚事务：rollback;<br></code></pre></td></tr></table></figure><ul><li>MySQL当中默认支持自动事务提交（每执行一条DML语句，就提交一次）</li><li>如果不用自动提交的话，就需要先执行<code>start transaction</code>开启事务</li></ul><p><strong>事务的隔离性</strong></p><p>事务有不同的隔离级别，一共有4个级别</p><ul><li>读未提交（read uncommitted）-最低级别<ul><li>提交事务之前就能读取到</li><li>事务A可以读取到事务B未提交的数据</li><li>存在问题：脏读</li></ul></li><li>读已提交（read committed）<ul><li>提交事务之后才能读取到</li><li>事务A只能读取到事务B提交之后的数据</li><li>存在问题：不可重复读取数据（事务A每次读取的数据可能是不一致的）</li><li>每次读取到的数据都是真实的</li></ul></li><li>可重复读（repeatable read）<ul><li>提交事务之后也读不到，永远读取的都是刚开启事务时的数据</li><li>其他事务不会改变这个事务读取到的数据</li><li>事务A开启之后，不管是多久，每一次事务A中读取到的数据都是一致的</li><li>存在问题：幻读</li><li>这是mysql中默认的隔离级别</li></ul></li><li>序列化（serializable）-最高级别<ul><li>事务排队，不能并发</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查看目前的事务隔离级别<br>查看当前会话的隔离级别：(8.0后的表达)<br>select @@transaction_isolation;<br>查看全局隔离级别：<br>select @@session.transaction_isolation;<br><br>通过命令设置隔离级别：<br>set transaction isolation level 隔离等级<br></code></pre></td></tr></table></figure><h3 id="索引">15. 索引</h3><p>索引概述：</p><p>索引是在数据库表的字段上添加的，每个字段上都可以添加索引，添加索引可以提高查询效率。</p><blockquote><p>mysql查询的两种方式：</p><ol type="1"><li>全表查询</li><li>根据索引值来查询</li></ol><p>如果在这个字段上有索引，那么mysql就会根据索引值来进行查询，否则进行全表扫描</p></blockquote><p>MyISAM和InnoDB使用B+树作为索引结构（主键，unqiue都会默认添加索引）</p><ul><li><p>在任何数据库中，主键上都会自动添加索引对象；在mysql中，一个字段上如果有unique约束的话，也会自动添加索引对象</p></li><li><p>遵循左小右大原则存放，采用中序遍历</p></li></ul><p>索引实现原理</p><ol type="1"><li>在mysql中，索引是一个单独的对象，不同的存储引擎以不同的形式存在。（前面引擎提到过索引的存放）</li><li>不管存储引擎在哪里，索引在mysql当中都是以一个树的形式存在的（B+树）</li></ol><blockquote><p>mysql中为什么不使用B树而是用B+树？</p><p>B 树与 B+ 树的最大区别就是，B 树可以在非叶结点中存储数据，但是 B+树的所有数据其实都存储在叶子节点中由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机I/O，也是 B 树最大的性能问题。</p><p>B+树中就不存在这个问题了，因为所有的数据行都存储在叶节点中，而这些叶节点可以<strong>通过『指针』依次按顺序连接</strong>，当我们在如下所示的B+ 树遍历数据时可以直接在多个子节点之间进行跳转，这样能够节省大量的磁盘I/O 时间，也不需要在不同层级的节点之间对数据进行拼接和排序；通过一个 B+树最左侧的叶子节点，我们可以像链表一样遍历整个树中的全部数据，我们也可以引入双向链表保证倒序遍历时的性能</p></blockquote><p>在什么条件下考虑给字段添加索引：</p><ol type="1"><li>数据量庞大（到底多少数据量算庞大需要测试，因为硬件环境不同）</li><li>该字段经常出现在where后面，以条件形式存在</li><li>该字段很少的DML操作（因为DML之后，索引需要重新排序）</li><li>建议不要随便添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能，建议通过主键查询，建议通过unique约束的字段进行查询，效率是较高的</li></ol><p>索引使用的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建索引<br>create index 索引对象名 on 表名(字段名); <br><br>删除索引<br>drop index 索引对象名 on 表名;<br><br>查看sql语句是否使用了索引进行查询<br>explain sql语句;<br></code></pre></td></tr></table></figure><p>索引失效：</p><ol type="1"><li>模糊查询中，如果以<code>%</code>开头，不会走索引<ul><li>对应优化模糊查询</li></ul></li><li>使用or的时候会失效。如果使用or那么要求or两边的条件字段都要求有索引，才能走索引<ul><li>对应优化尽量少用 or</li></ul></li><li>使用复合索引的时候，没有使用左侧的列（一级索引）查找，索引失效</li><li>在where当中，索引列参加了运算，索引失效</li><li>在where当中，索引列使用了函数</li></ol><h3 id="视图">16. 视图</h3><p>视图：view，在不同的角度看待同一份数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建视图<br>create view 视图名称 as select语句<br><br>删除视图<br>drop view 视图名称;<br></code></pre></td></tr></table></figure><p>视图的作用：我们可以面向视图对象进行增删改查，对视图对象的增删改查会导致原表被操作</p><h3 id="数据的备份-导出和导入">17.数据的备份 导出和导入</h3><p>数据导出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">在命令行窗口中（不是登录到mysql）<br>mysql dump 数据库名称 &gt; 导出路径 -uroot -p123123<br>导出指定的表<br>mysql dump 数据库名称 数据表名称 &gt; 导出路径 -uroot -p123123<br></code></pre></td></tr></table></figure><p>数据导出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">先登录到mysql<br>source语句<br></code></pre></td></tr></table></figure><h3 id="数据库设计三范式">18. 数据库设计三范式</h3><ol type="1"><li><p>要求任何一张表必须有主键，每个字段原子性不可再分</p></li><li><p>建立在第一范式的基础上，要求所有的非主键字段完全依赖主键，不要产生部分依赖</p><ul><li><p>一般不要复合主键</p></li><li><p>多对多，使用三张表，关系表为两个外键</p></li></ul></li><li><p>建立在第二范式的基础上，要求所有的非主键字段直接依赖主键，不要产生传递依赖</p><ul><li>一对多，拆分成两张表，多的表加外键</li></ul></li></ol><p>设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。</p><p>一张表太大可能会进行拆分，拆分之后添加外键，外键上添加unique约束（一对一，外键唯一）</p><blockquote><p>数据库设计三范式是理论上的，实践和理论有的时候是有偏差的，最终的目的都是为了满足客户的需求。</p><p>有的时候会拿冗余换执行速度，因为在表和表之间连接次数较多，效率会越低。有的时候可能存在冗余，但是为了减少表的连接次数，这样做也是合理的。并且对于开发人员来说，sql语句的编写难度也会降低。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven基础笔记</title>
    <link href="/2022/06/27/Maven%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/27/Maven%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="maven基础">Maven基础</h1><h2 id="一.-简介">一. 简介</h2><p>Maven的作用：</p><ol type="1"><li><p>项目构建：提供标准的、跨平台的自动化项目构建方式</p></li><li><p>依赖管理：方便快捷的管理项目依赖资源（jar包），避免资源之间的版本冲突问题</p></li><li><p>统一开发结构：提供标准的、统一的项目结构</p><img src="/2022/06/27/Maven%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/maven%E7%AE%80%E4%BB%8B.png" class="" title="maven简介"></li></ol><blockquote><p>每一个项目都对应一个项目对象模型（POM），一个项目对象模型通过一份pom.xml文件进行管理，同时依赖管理可以管理项目中需要的依赖。本身这个项目也可以作为一个资源供其他项目作为依赖使用。</p></blockquote><h2 id="二.基础概念">二.基础概念</h2><h3 id="仓库">1. 仓库</h3><p>仓库：用于存储资源，包含各种jar包</p><p>仓库的分类：</p><ul><li>本地仓库：自己电脑上存储资源的仓库，连接远程仓库获取资源</li><li>远程仓库：非本地电脑上的仓库，为本地仓库提供资源<ul><li>中央仓库：Maven团队维护的，存储所有资源的仓库</li><li>私服：部门或公司范围内部存储资源的仓库，从中央仓库获取资源</li></ul></li></ul><p>私服的作用：</p><ol type="1"><li>保存具有版权的资源，包含购买或自主研发的jar包</li><li>一定范围内共享资源，仅对内部开放，不对外共享</li></ol><h3 id="坐标">2. 坐标</h3><p>坐标：Maven中的坐标用于描述仓库中资源的位置</p><p>主要组成：</p><ul><li>groupId：定义当前Maven项目隶属组织的名称（通常是域名反写，org.mybatis）</li><li>aritfactId：定义当前Maven项目的名称，通常为模块名称</li><li>version：当前项目版本号</li><li>packaging：当前该项目的打包方式</li></ul><p>搜索:<a href="https://mvnrepository.com/#/">Maven Repository:Search/Browse/Explore (mvnrepository.com)</a></p><p>作用：使用唯一标识来定位资源的位置，通过该表示可以将资源的识别与下载工作交由机器来完成</p><blockquote><p>本地仓库的配置，在conf里面的setting中配置</p><p>阿里云maven:</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure></p></blockquote><h2 id="三.手工制作maven项目">三.手工制作Maven项目</h2><p>Maven工程目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">- java-project<br>- src<br>- main<br>- java<br>- resources<br>        - test<br>        - java<br>        - resources<br>    - pom.xml<br></code></pre></td></tr></table></figure><ul><li><code>java</code>文件夹中防止类代码</li><li>在<code>src</code>同层目录中创建<code>pom.xml</code></li></ul><p>Maven项目构建命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">首先进入对应的java-project文件夹</span><br>mvn compile# 编译<br>mvn clean# 清理编译后的文件<br>mvn test# 测试<br>mvn package# 打包，包括了编译和测试<br>mvn install# 安装到本地仓库<br></code></pre></td></tr></table></figure><p>可以插件创建Maven项目</p><h2 id="四.idea生成maven项目">四.IDEA生成Maven项目</h2><p>通过配置在IDEA中的设置进行Maven项目的生成</p><h2 id="五.依赖管理">五.依赖管理</h2><p><strong>1.依赖配置</strong></p><p>依赖配置：配置当前项目需要的jar包，一个项目可以设置多个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 设置当前项目所依赖的所有jar--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>&lt;!—设置举例的依赖 --&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>&lt;!—依赖所属群组id--&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>&lt;!—依赖所属项目id--&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>&lt;!—依赖版本号--&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.依赖传递</strong></p><p>依赖传递：使用其他人的资源的时候，那个资源有用到的jar包，当前项目中也能够使用</p><ul><li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li><li>间接依赖：被依赖的资源如果依赖其他资源，那么当前项目间接依赖其他资源</li></ul><p>依赖冲突三原则（决定使用哪一个依赖）</p><ol type="1"><li><strong>路径优先</strong>：当依赖中出现了相同资源的时候，层级越深，优先级越低，层级越浅，优先级越高</li><li><strong>声明优先</strong>：当资源在相同层级的时候，配置顺序靠前的覆盖配置顺序靠后的</li><li><strong>特殊优先</strong>：当同一配置文件中了相同资源的不同版本，后配置的覆盖先配置的</li></ol><p><strong>3.可选依赖</strong></p><p>可选依赖指对外隐藏当前资源所需要的依赖（对外不透明）</p><p>当前项目中配置可选依赖，当其他项目使用当前项目作为资源的时候，其他项目无法看到依赖。</p><p>使用<code>optional</code>关键字</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>4.排除依赖</strong></p><p>排除依赖指主动断开依赖的资源，被排除的依赖无需指定版本（自己不需要）</p><p>当前项目中配置排除依赖，则当前项目中就看不到对应使用资源的依赖</p><p>使用<code>exclusions</code>和<code>exclusion</code>关键字</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hamcrest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hamcrest-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>5.依赖范围</strong></p><p>依赖范围：使用<code>scope</code>关键字，用来指定依赖的允许使用范围，分为以下的范围：</p><ul><li>主程序范围内有效（main文件夹范围）</li><li>测试程序范围内有效（test文件夹范围）</li><li>是否参与打包（package指令范围内）</li></ul><table><thead><tr class="header"><th>scope</th><th>主代码</th><th>测试代码</th><th>打包</th></tr></thead><tbody><tr class="odd"><td>compile（默认）</td><td>√</td><td>√</td><td>√</td></tr><tr class="even"><td>test</td><td></td><td>√</td><td></td></tr><tr class="odd"><td>provide</td><td>√</td><td>√</td><td></td></tr><tr class="even"><td>runtime</td><td></td><td></td><td>√</td></tr></tbody></table><p>依赖范围有特殊的传递性：带有依赖范围的资源在进行传递的时候，作用范围会受到影响：</p><img src="/2022/06/27/Maven%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4%E4%BC%A0%E9%80%92%E6%80%A7.png" class="" title="依赖范围传递性"><p>下面是对scope各种取值的相关解释：</p><ul><li><code>compile</code>：为默认的依赖范围，该依赖在编译、运行和测试时均有效</li><li><code>provide</code>：在编译、测试时有效，但是在运行时无效。例如servlet-api，运行项目的时候容器已经提供了，就不需要重复引入</li><li><code>runtime</code>：在运行、测试时有效，在编译时无效。例如JDBC驱动实现，项目代码编译仅需要JDBC接口，只有在测试或者运行项目的时候才需要实现接口的具体驱动</li><li><code>test</code>：只在测试时有效</li></ul><h2 id="六.生命周期与插件">六.生命周期与插件</h2><p>项目构建生命周期：Maven构建生命周期描述的是一次构建过程中经历了多少个事件。Maven对项目构建的生命周期划分为3套</p><ul><li>clean：清理工作</li><li>default：核心工作，例如编译，测试，打包，部署等</li><li>site：产生报告，发布站点等</li></ul><img src="/2022/06/27/Maven%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/clean.png" class="" title="clean"><img src="/2022/06/27/Maven%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/default.png" class="" title="default"><img src="/2022/06/27/Maven%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/site.png" class="" title="site"><p>插件：</p><ul><li>Maven生命周期的每一个阶段的具体实现都是由Maven插件来实现的。而Maven实际上是一个依赖插件执行的框架</li><li>插件与生命周期内的阶段绑定，在执行到对应生命周期的时候会执行对应的插件功能</li><li>默认maven在各个生命周期上绑定有预设的功能</li><li>通过插件可以自定义功能</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3中常用模块的引入</title>
    <link href="/2022/06/08/Vue3%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BC%95%E5%85%A5/"/>
    <url>/2022/06/08/Vue3%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BC%95%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="echarts的引入">Echarts的引入</h2><ol type="1"><li><p>首先安装Echarts模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install echarts --save<br></code></pre></td></tr></table></figure></li><li><p>之后在<code>main.js</code>中进行引入，部分代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createApp&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br>app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$echarts</span> = echarts<br><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>然后进行使用即可。在使用的过程中，可以利用<code>this.$echarts</code>来获取echarts对象，如下面的例子所示，使用一个官方提供的柱状图代码，函数可以在mounted中挂载，也可以在method中指定，将echarts和dom元素进行绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;div id=&quot;myChart&quot; style=&quot;height: 600px;position: center&quot;&gt;&lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &quot;TestChart&quot;,<br>  mounted() &#123;<br>    var chartDom = document.getElementById(&#x27;myChart&#x27;);<br>    var myChart = this.$echarts.init(chartDom);<br>    var option;<br><br>    option = &#123;<br>      xAxis: &#123;<br>        type: &#x27;category&#x27;,<br>        data: [&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;]<br>      &#125;,<br>      yAxis: &#123;<br>        type: &#x27;value&#x27;<br>      &#125;,<br>      series: [<br>        &#123;<br>          data: [120, 200, 150, 80, 70, 110, 130],<br>          type: &#x27;bar&#x27;<br>        &#125;<br>      ]<br>    &#125;;<br><br>    option &amp;&amp; myChart.setOption(option);<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br><br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，绑定的dom元素必须设置高度height</p></li></ol><h2 id="element-ui的引入">Element UI的引入</h2><ol type="1"><li><p>首先安装Element UI模块，需要注意这里安装的是element-plus</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install element-plus --save<br></code></pre></td></tr></table></figure></li><li><p>然后在<code>main.js</code>中引入，部分代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementPlus</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-plus/dist/index.css&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementPlus</span>)<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>最后就可以按照官方文档中使用方法进行使用</p></li></ol><h2 id="axios的引入">axios的引入</h2><ol type="1"><li><p>首先安装axios模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install axios --save<br></code></pre></td></tr></table></figure></li><li><p>之后在需要用到的组件中按需引入即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="vue-router的引入">vue-router的引入</h2><ol type="1"><li><p>首先安装vue-router模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install vue-router --save<br></code></pre></td></tr></table></figure></li><li><p>之后在src下新建route文件夹，router文件夹内新建index.js，写入如下的代码。（注意名称）具体配置可以参考官方文档</p><p><a href="https://router.vuejs.org/zh/">Home | Vue Router(vuejs.org)</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createRouter, createWebHistory&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> routes = [<br>    &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/TestChart&#x27;</span>)&#125;,<br>]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>    routes<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure></li><li><p>之后在<code>main.js</code>中进行引入，部分代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createApp&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./route&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br>app.<span class="hljs-title function_">use</span>(router)<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="code-mirror的引入">code-mirror的引入</h2><p>CodeMirror是一个前端常用的编辑器组件，我们可以在Vue中很方便的引入它。首先需要安装该模块：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install vue-codemirror --save<br></code></pre></td></tr></table></figure><p>之后需要在组件中按需引入，如下所示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">codemirror</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align: left&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;code&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Code goes here...&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; height: &#x27;400px&#x27; &#125;&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">:autofocus</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">:indent-with-tab</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">:tab-size</span>=<span class="hljs-string">&quot;2&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">:extensions</span>=<span class="hljs-string">&quot;extensions&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>在script标签中则进行如下代码添加，这里编辑器中的内容就与code进行了绑定，而在extensions中可以设置黑暗模式，语言模式等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Codemirror</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-codemirror&#x27;</span><br><span class="hljs-keyword">import</span> &#123;python&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@codemirror/lang-python&quot;</span><br><span class="hljs-keyword">import</span> &#123;oneDark&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@codemirror/theme-one-dark&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">code</span>: <span class="hljs-string">&quot;import times&quot;</span>,<br>      extensions<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>如果需要切换正常和语言模式，则需要动态切换<code>extensions</code>属性。</p><p>我们也可以按照官方案例进行组件添加，不过需要注意的是这里所有额外的东西例如ondark模式，特定的language，都需要额外进行安装。</p><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://blog.csdn.net/m0_54883970/article/details/126080987">前端插件库之vue3使用vue-codemirror插件-CSDN博客</a></li><li><ahref="https://github.com/surmon-china/vue-codemirror">surmon-china/vue-codemirror:<span class="citation" data-cites="codemirror">@codemirror</span> codeeditor component for <span class="citation"data-cites="vuejs">@vuejs</span> (github.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark学习笔记-SparkCore(3)-累加器和广播变量</title>
    <link href="/2022/05/10/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-3-%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%92%8C%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/"/>
    <url>/2022/05/10/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-3-%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%92%8C%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="累加器">累加器</h2><p>现在我们考虑这样的应用场景，我们在Driver即算子的外部创建一个变量，然后在算子内部操作这个变量，但是我们还希望这个变量最终的结果能够返回给Driver。前面的闭包检测能够完成变量的传递，但是由于在不同的Executor上变量其实是一个副本，也无法完成数据的传回以及合并操作，因此就引出累加器的概念。</p><p>Spark中的累加器用来叭Executor端变量的信息聚合到Driver端。在Driver程序中定义的变量，每个Executor端的每个Task都会得到这个变量的一份新的副本，每个Task更新这些副本的值之后，传回Driver端进行merge操作，得到最终的结果。累加器又可以分为系统累加器和自定义累加器。</p><p><strong>系统累加器</strong>：包括<code>longAccumulator</code>，<code>doubleAccumulator</code>，<code>collectionAccumulator</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>), <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 获取系统累加器,后面传入的name参数是该累加器在UI界面的标识符</span><br><span class="hljs-keyword">val</span> sumAcc = sc.longAccumulator(<span class="hljs-string">&quot;sum&quot;</span>)<br><br>rdd.foreach(sumAcc.add(_))<br><br><span class="hljs-comment">// 获取累加器的值</span><br>println(sumAcc.value)<br></code></pre></td></tr></table></figure><p>累加器的执行可能会随着行动算子的执行而触发，可能会出现少加或者多加的情况。在一般情况下，累加器会放置在行动算子中进行操作。</p><ul><li>少加：在转换算子中调用累加器，如果没有行动算子，则累加器也不会执行</li><li>多加：在转换算子中调用累加器，如果有多个行动算子，那么累加器也会执行多次</li></ul><p><strong>自定义累加器</strong>：我们可以自定义累加器，来实现自己的累加逻辑。自定义累加器需要继承<code>AccumulatorV2</code>，设定泛型并重写其中的抽象方法，下面是WordCount的累加器实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.spark.util.<span class="hljs-type">AccumulatorV2</span><br><span class="hljs-keyword">import</span> org.apache.spark.&#123;<span class="hljs-type">SparkConf</span>, <span class="hljs-type">SparkContext</span>&#125;<br><br><span class="hljs-keyword">import</span> scala.collection.mutable<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Rdd_Test</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> sparkConf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;RDD&quot;</span>)<br>    <span class="hljs-keyword">val</span> sc = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkContext</span>(sparkConf)<br><br>    <span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;spark&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;scala&quot;</span>))<br>    <span class="hljs-comment">// 创建自定义累加器</span><br>    <span class="hljs-keyword">val</span> myAccumulator = <span class="hljs-keyword">new</span> <span class="hljs-type">MyAccumulator</span>()<br>    <span class="hljs-comment">// 向Spark进行注册</span><br>    sc.register(myAccumulator)<br>    <span class="hljs-comment">// 在算子中调用自定义累加器</span><br>    rdd.foreach(word =&gt; &#123;<br>      myAccumulator.add(word)<br>    &#125;)<br>    <span class="hljs-comment">// 输出累加器结果</span><br>    println(myAccumulator.value)<br><br>    sc.stop()<br>  &#125;<br><br>  <span class="hljs-comment">// 自定义累加器，继承AccumulatorV2，确定泛型，实现抽象方法</span><br>  <span class="hljs-comment">// 泛型IN：累加器输入的数据类型</span><br>  <span class="hljs-comment">// 泛型OUT：累加器输出的数据类型</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAccumulator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AccumulatorV2</span>[<span class="hljs-type">String</span>, mutable.<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>]] </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> myMap = mutable.<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>]()<br><br>    <span class="hljs-comment">// 判断累加器是否是初始状态</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isZero</span></span>: <span class="hljs-type">Boolean</span> = myMap.isEmpty<br><br>    <span class="hljs-comment">// 累加器的复制</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copy</span></span>(): <span class="hljs-type">AccumulatorV2</span>[<span class="hljs-type">String</span>, mutable.<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>]] = <span class="hljs-keyword">new</span> <span class="hljs-type">MyAccumulator</span>()<br><br>    <span class="hljs-comment">// 重置累加器</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset</span></span>(): <span class="hljs-type">Unit</span> = myMap.clear()<br><br>    <span class="hljs-comment">// 自定义累加逻辑</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(v: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = &#123;<br>      <span class="hljs-keyword">val</span> newCount = myMap.getOrElse(v, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>      myMap.update(v, newCount)<br>    &#125;<br><br>    <span class="hljs-comment">// 不同分区的累加器合并(将other合并到自己)</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span></span>(other: <span class="hljs-type">AccumulatorV2</span>[<span class="hljs-type">String</span>, mutable.<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>]]): <span class="hljs-type">Unit</span> = &#123;<br>      <span class="hljs-keyword">val</span> map1 = <span class="hljs-keyword">this</span>.myMap<br>      <span class="hljs-keyword">val</span> map2 = other.value<br><br>      map2.foreach(&#123;<br>        <span class="hljs-keyword">case</span> (word, count) =&gt; &#123;<br>          <span class="hljs-keyword">val</span> newCount = map1.getOrElse(word, <span class="hljs-number">0</span>) + count<br>          map1.update(word, newCount)<br>        &#125;<br>      &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 返回累加器的值</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">value</span></span>: mutable.<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = myMap<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广播变量">广播变量</h2><p>前面我们反复提到在RDD算子内部的操作在Executor端完成，对应到分区的概念，而算子外部的操作在Driver端完成。并且我们也提到的闭包检测的概念，在算子内部的数据会发送给对应的分区。但是这里的数据分发是以分区为单位的，即以Task为单位。如果一个物理节点Executor上有多个分区，有多个Task，那么会存在数据冗余的现象。</p><p>如果每个分区上只需要一个可读的值，那么可以考虑使用广播变量。广播变量的分发是以Executor为单位的，而不是像闭包数据那样以分区任务为单位，这样就可以明显降低数据冗余。广播变量会将自己保存在Executor中的内存中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> list = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment">// 广播变量的声明</span><br><span class="hljs-keyword">val</span> broadcast = sc.broadcast(list)<br><br><span class="hljs-comment">// 广播变量的使用</span><br>rdd.foreach(_ =&gt; &#123;<br>    println(broadcast.value)<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala匿名函数中下划线简化的注意事项</title>
    <link href="/2022/05/10/Scala%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%AE%80%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2022/05/10/Scala%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%AE%80%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="基本使用与原理">基本使用与原理</h2><p>在使用匿名函数的时候，如果参数在函数体中只出现溢出，则参数可以省略，并且后面的参数可以使用下划线<code>_</code>开代替，并且下划线必须按照顺序进行接收，使用下划线的时候必须省略参数列表和箭头<code>=&gt;</code>。</p><p>在Scala中，下划线简化函数扩展为原本函数的过程称为eta-expansion，并且其中存在就近扩展原则：下划线<code>_</code>组成的表达式遇到括号<code>()</code>，或者抵达了最顶层则会发生函数的扩展。这里需要注意，单个的下划线并不算是下划线表达式。</p><blockquote><p>eta-expansion：将简化函数扩展为匿名函数，举例来说，<code>_+1</code>扩展为<code>x=&gt;&#123;x+1&#125;</code></p></blockquote><h2 id="注意细节">注意细节</h2><p>1.<strong>多个括号嵌套不用下划线简写</strong></p><p>由于下划线表达式遇到括号会发生函数扩展，因此在存在多个括号嵌套的时候可能会发生函数扩展导致的报错。下面举两个常见的错误例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).map(<br>    (_ + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span><br>)<br><span class="hljs-comment">// 编译错误，由于 _ + 1 遇到了括号会进行函数扩展，因此map中的参数被扩展为</span><br><span class="hljs-comment">// x =&gt; &#123;x + 1&#125; * 2</span><br><span class="hljs-comment">// 一个匿名函数和2进行乘法，编译器无法判断乘号在这里的操作，因此报错</span><br><span class="hljs-comment">// 修改为没有简化的匿名函数</span><br><span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).map(<br>    x =&gt; &#123;(x + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>&#125;<br>)<br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).foreach(println) <span class="hljs-comment">// 1.正确</span><br><span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).foreach(println(_)) <span class="hljs-comment">// 2.正确</span><br><span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).foreach(println(_.toString)) <span class="hljs-comment">// 3.报错</span><br><span class="hljs-comment">// 1.正确，其中传入的println是一个函数</span><br><span class="hljs-comment">// 2.正确，由于单个下划线不是下划线表达式，不会发生函数扩展</span><br><span class="hljs-comment">// 3.报错，_.toString不是单个下划线，会发生函数扩展，因此扩展后得到的是如下代码</span><br><span class="hljs-comment">// println(x=&gt;&#123;x.toString&#125;)，println接收了一个匿名函数作为参数，但是println不接受该类型的参数，因此报错</span><br></code></pre></td></tr></table></figure><p>2.<strong>代码块的返回值和匿名函数混淆</strong></p><p>在使用下划线的场景中，我们最终得到的会是很简化的表达，但是这个简化表达往往可能会误导我们，尤其是容易将代码块的返回值和匿名函数混淆。</p><p>例如下面的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> list = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).map(&#123;<br>    println(<span class="hljs-string">&quot;-map-&quot;</span>)<br>    _ + <span class="hljs-number">1</span><br>&#125;)<br>println(list)<br></code></pre></td></tr></table></figure><p>我们容易将整个<code>&#123;&#125;</code>代码块中的内容都看作是传入map中的匿名函数的内容。但是实际上，传入map中的参数是一个代码块，而这个代码块的返回值是一个下划线表达式，这个下划线表达式可以扩展为一个匿名函数，因此最终传入map中的函数应该为<code>x=&gt;&#123;x + 1&#125;</code>，在获得代码块的返回值的过程中，会执行依次<code>println("-map-")</code>，后面都不会执行了，因此上面代码的输出为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-map-<br>List(2, 3, 4, 5)<br></code></pre></td></tr></table></figure><p>如果要实现每个元素操作的时候都输出一次<code>-map-</code>，则还是需要使用没有简化的匿名函数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> list = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).map(num =&gt; &#123;<br>    println(<span class="hljs-string">&quot;-map-&quot;</span>)<br>    num + <span class="hljs-number">1</span><br>&#125;)<br>println(list)<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">-map-<br>-map-<br>-map-<br>-map-<br>List(2, 3, 4, 5)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>details</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark学习笔记-SparkCore(2)-RDD序列化,依赖,持久化以及分区</title>
    <link href="/2022/05/10/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-2-RDD%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BE%9D%E8%B5%96-%E6%8C%81%E4%B9%85%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%88%86%E5%8C%BA/"/>
    <url>/2022/05/10/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-2-RDD%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BE%9D%E8%B5%96-%E6%8C%81%E4%B9%85%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="rdd序列化">RDD序列化</h2><p>我们前面提到过，在RDD算子以外的代码都是在Driver端执行的，而算子内部的代码都是在Executor端执行的。而一个非常常见的情景是，在算子内部提供的函数会使用到算子外的数据，这样就形成了闭包的效果。为了能够正确实现操作，在Driver端的算子外的数据会传输给每个Task，这样在Task执行的时候也能够使用到对应的数据而不会产生错误。</p><p>例如下面的代码，我们在map算子内部使用到了算子外部的数据<code>num</code>，但是程序能够正确执行，因为会将<code>num</code>传送给每个Task。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>))<br><span class="hljs-keyword">val</span> num = <span class="hljs-number">10</span><br><span class="hljs-keyword">val</span> res = rdd.map(_ + num)<br>res.collect().foreach(println)<br></code></pre></td></tr></table></figure><p>既然需要将算子外的数据进行传输，那么就意味着这个数据需要能够序列化，否则就无法传输。举例来说，在下面的代码中，我们定义了一个类，并在算子外部new得到的对应的类，并且在算子内部使用了这个类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.spark.&#123;<span class="hljs-type">SparkConf</span>, <span class="hljs-type">SparkContext</span>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Rdd_Test</span> </span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> num: <span class="hljs-type">Int</span> = <span class="hljs-number">30</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> sparkConf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;RDD&quot;</span>)<br>    <span class="hljs-keyword">val</span> sc = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkContext</span>(sparkConf)<br><br>    <span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>))<br>    <span class="hljs-keyword">val</span> user = <span class="hljs-keyword">new</span> <span class="hljs-type">User</span>()<br>    <span class="hljs-keyword">val</span> res = rdd.map(_ + user.num)<br>    res.collect().foreach(println)<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们自定义的类没有实现序列化，因此无法在网络上传输，运行会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Task not serializable<br></code></pre></td></tr></table></figure><p>于是我们只需要将自定义的类混入序列化特征<code>Serializable</code>即可</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> num: <span class="hljs-type">Int</span> = <span class="hljs-number">30</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然我们也可以使用样例类来完成对应的功能，因为样例类在编译的时候会自动混入序列化特征</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">val</span> num: <span class="hljs-type">Int</span> = <span class="hljs-number">30</span><br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，如果我们的RDD中传入的数据为空，调用上述没有实现序列化的代码依旧会报错，因为上面的闭包检测的过程是在执行任务计算之前的，闭包检测会检测闭包内的对象是否可以进行序列化</p><blockquote><p>Java提供的序列化能够实现任何类的序列化，但是是一个比较重量级的序列化，得到的序列化结果大小较大。Spark处于性能的考虑，在2.0之后开始支持新的Kryo序列化机制。Kyro序列化的速度比Serializable快得多，并且得到的结果大小较小。当RDD在Shuffle数据的时候，简单数据类型、数组、字符串类型等已经在Spark内部使用Kryo来序列化</p><p>要使用Kyro序列化，同样需要实现<code>Serializable</code>特征，同时在创建配置文件的时候进行相关的配置和注册</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> conf: <span class="hljs-type">SparkConf</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>)<br> <span class="hljs-comment">// 替换默认的序列化机制</span><br> .set(<span class="hljs-string">&quot;spark.serializer&quot;</span>,  <span class="hljs-string">&quot;org.apache.spark.serializer.KryoSerializer&quot;</span>)<br> <span class="hljs-comment">// 注册需要使用 kryo 序列化的自定义类</span><br> .registerKryoClasses(<span class="hljs-type">Array</span>(classOf[<span class="hljs-type">User</span>]))<br></code></pre></td></tr></table></figure><p>这里的User类需要实现<code>Serializable</code>特征或者使用样例类</p></blockquote><h2 id="rdd依赖关系">RDD依赖关系</h2><h3 id="依赖与血缘关系">依赖与血缘关系</h3><p>一个RDD通过算子操作后可以得到一个新的RDD，我们可以说这个新的RDD依赖于旧的RDD。这样的关系我们称为依赖关系，即<strong>相邻两个RDD之间的关系称为依赖关系</strong>。而新的RDD又会经过一系列算子的操作，依赖关系彼此相连，形成血缘关系，即<strong>多个连续的RDD的依赖关系称为血缘关系</strong>。</p><p>我们说RDD中不会保存数据，但是为了提高容错性，RDD之间的关系会进行保存，即RDD保存了依赖关系和血缘关系。RDD支持粗粒度的转换，即在大量记录上执行的单个操作，RDD会将创建的一系列依赖关系记录下来，以便可以完成恢复操作，根据这些信息来重新运算，恢复丢失的数据分区。</p><blockquote><p>何为恢复：由于RDD中不保存数据，如果一个RDD中执行出错，由于不保存数据，恢复的操作就是重新执行，因此需要记录前面需要执行的操作，即记录血缘关系。</p></blockquote><p>RDD有两个方法<code>toDebugString</code>和<code>dependencies</code>，可以分别获取当前RDD的血缘关系和依赖关系。</p><p><strong>血缘关系</strong>获取：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> lines = sc.textFile(<span class="hljs-string">&quot;data/1.txt&quot;</span>)<br>println(lines.toDebugString)<br>println()<br><span class="hljs-keyword">val</span> words = lines.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<br>println(words.toDebugString)<br>println()<br><span class="hljs-keyword">val</span> wordToOne = words.map(word =&gt; (word, <span class="hljs-number">1</span>))<br>println(wordToOne.toDebugString)<br>println()<br><span class="hljs-keyword">val</span> res = wordToOne.reduceByKey(_ + _)<br>println(res.toDebugString)<br>println()<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">(2) data/1.txt MapPartitionsRDD[1] at textFile at Rdd_Test.scala:16 []<br> |  data/1.txt HadoopRDD[0] at textFile at Rdd_Test.scala:16 []<br><br>(2) MapPartitionsRDD[2] at flatMap at Rdd_Test.scala:19 []<br> |  data/1.txt MapPartitionsRDD[1] at textFile at Rdd_Test.scala:16 []<br> |  data/1.txt HadoopRDD[0] at textFile at Rdd_Test.scala:16 []<br><br>(2) MapPartitionsRDD[3] at map at Rdd_Test.scala:22 []<br> |  MapPartitionsRDD[2] at flatMap at Rdd_Test.scala:19 []<br> |  data/1.txt MapPartitionsRDD[1] at textFile at Rdd_Test.scala:16 []<br> |  data/1.txt HadoopRDD[0] at textFile at Rdd_Test.scala:16 []<br><br>(2) ShuffledRDD[4] at reduceByKey at Rdd_Test.scala:25 []<br> +-(2) MapPartitionsRDD[3] at map at Rdd_Test.scala:22 []<br>    |  MapPartitionsRDD[2] at flatMap at Rdd_Test.scala:19 []<br>    |  data/1.txt MapPartitionsRDD[1] at textFile at Rdd_Test.scala:16 []<br>    |  data/1.txt HadoopRDD[0] at textFile at Rdd_Test.scala:16 []<br><br></code></pre></td></tr></table></figure><p>其中的数字表示分区数量，并且注意到<code>|</code>和<code>+-</code>符号，表示的含义是否会经过Shuffle过程</p><p><strong>依赖关系</strong>获取：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> lines = sc.textFile(<span class="hljs-string">&quot;data/1.txt&quot;</span>)<br>println(lines.dependencies)<br>println()<br><span class="hljs-keyword">val</span> words = lines.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<br>println(words.dependencies)<br>println()<br><span class="hljs-keyword">val</span> wordToOne = words.map(word =&gt; (word, <span class="hljs-number">1</span>))<br>println(wordToOne.dependencies)<br>println()<br><span class="hljs-keyword">val</span> res = wordToOne.reduceByKey(_ + _)<br>println(res.dependencies)<br>println()<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-type">List</span>(org.apache.spark.<span class="hljs-type">OneToOneDependency</span>@<span class="hljs-number">32e54</span>a9d)<br><br><span class="hljs-type">List</span>(org.apache.spark.<span class="hljs-type">OneToOneDependency</span>@<span class="hljs-number">56</span>da7487)<br><br><span class="hljs-type">List</span>(org.apache.spark.<span class="hljs-type">OneToOneDependency</span>@<span class="hljs-number">59</span>cda16e)<br><br><span class="hljs-type">List</span>(org.apache.spark.<span class="hljs-type">ShuffleDependency</span>@<span class="hljs-number">6e7</span>c351d)<br></code></pre></td></tr></table></figure><h3 id="宽依赖与窄依赖">宽依赖与窄依赖</h3><p>注意到前面在获取依赖的时候，得到的依赖分为两种，<code>OneToOneDependency</code>和<code>ShuffleDependency</code>。依赖是新旧RDD之间的关系，两类依赖之间的差别在于RDD分区之间关系</p><ul><li><code>OneToOneDependency</code>：表示旧的RDD中的一个分区的数据只会传入新RDD的一个分区，不经过Shuffle过程。一对一或者多对一，又被称为<strong>窄依赖</strong></li><li><code>ShuffleDependecy</code>：表示旧的RDD中的一个分区的数据会传入新RDD中的不同分区，经过Shuffle过程。一对多，又被称为<strong>宽依赖</strong></li></ul><blockquote><p>宽窄依赖名称由来：<code>OneToOneDependency</code>类的底层继承了<code>NarrowDependency</code>，而<code>ShuffleDependency</code>类的底层继承了<code>Dependency</code>类，因此我们称第一个为窄依赖，而为了表示对应称第二个为宽依赖</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneToOneDependency</span>[<span class="hljs-type">T</span>](<span class="hljs-params">rdd: <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">NarrowDependency</span>[<span class="hljs-type">T</span>](<span class="hljs-params">rdd</span>)</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="阶段划分">阶段划分</h3><p>在RDD整体的执行流程中，实际上是分为多个阶段的。如果RDD之间的依赖是窄依赖，这就意味着一个分区中的数据无需等待其他分区中的数据处理完成，那么这些处理就可以处于同一个阶段。但是如果RDD之间的依赖是宽依赖，则新的一个分区中的数据依赖于旧的多个分区，因此需要等待其他分区中的数据处理完成。</p><p>Spark根据Shuffle依赖来划分阶段，首先整体的逻辑是一个阶段，然后每遇到一个Shuffle依赖则会增加一个阶段。阶段之间的执行必须按照先后顺序，一个阶段执行完毕之后才能执行下一个阶段。整体流程的阶段数量= Shuffle依赖数量 + 1</p><h3 id="任务划分">任务划分</h3><p>RDD的任务划分，其中会分为如下的部分：Application、Job、Stage和Task</p><ul><li>Application：初始化一个SparkContext即会生成一个Application</li><li>Job：一个行动算子会生成一个Job</li><li>Stage：阶段的数量等于宽依赖数量的个数+1</li><li>Task：在一个Stage中，最后一个RDD的分区数量就是Task的个数</li></ul><h2 id="rdd持久化">RDD持久化</h2><h3 id="重用分析">重用分析</h3><p>在一些场景下，我们可能需要重复利用到一些前置的运算逻辑，然后做不同的行动算子的处理。例如下面的代码，我们需要重用前面map的逻辑，然后使用两次不同的行动算子逻辑进行处理。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">val</span> mapRdd = rdd.map(num =&gt; num+<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">val</span> res1 = mapRdd.reduce(_ + _)<br><span class="hljs-keyword">val</span> res2 = mapRdd.reduce(_ * _)<br><br>println(res1)<br>println(res2)<br></code></pre></td></tr></table></figure><p>我们很容易想到上面的代码，并且上面的代码确实能够得到正确的结果，但是其中的重用逻辑却值得分析。我们知道RDD中不会保存数据，因此我们实际上<strong>重用的不是数据，而是RDD对象，是RDD逻辑</strong>。当执行res1的reduce行动算子的时候，会从数据开始走一遍map的逻辑，执行res2的reduce行动算子的时候，同样也会从数据开始从头走一遍map的逻辑。我们可以在map的传入函数中增加输出功能，如下所示</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> sparkConf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;RDD&quot;</span>)<br><span class="hljs-keyword">val</span> sc = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkContext</span>(sparkConf)<br><br><span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">val</span> mapRdd = rdd.map(<br>    num =&gt; &#123;<br>        println(<span class="hljs-string">&quot;-map-&quot;</span>)<br>        num + <span class="hljs-number">1</span><br>    &#125;<br>)<br><br><span class="hljs-keyword">val</span> res1 = mapRdd.reduce(_ + _)<br><span class="hljs-keyword">val</span> res2 = mapRdd.reduce(_ * _)<br><br>println(<span class="hljs-string">&quot;res1=&quot;</span> + res1)<br>println(<span class="hljs-string">&quot;res2=&quot;</span> + res2)<br></code></pre></td></tr></table></figure><p>输出结果如下，可以看出res1和res2的执行都触发了前面的mapRdd的逻辑执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">-map-<br>-map-<br>-map-<br>-map-<br>res1=5<br>res2=6<br></code></pre></td></tr></table></figure><blockquote><p>注意这里不要将map中的逻辑写成下面的形式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> mapRdd = rdd.map(&#123;<br>    println(<span class="hljs-string">&quot;-map-&quot;</span>)<br>    _ + <span class="hljs-number">1</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>如果写成上面的形式，最终"-map-"只会输出一次，实际传入map的函数只有<code>x=&gt;&#123;x+1&#125;</code>，可以参考<a href="/2022/05/10/Scala%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%AE%80%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" title="Scala匿名函数中下划线简化的注意事项">Scala匿名函数中下划线简化的注意事项</a></p></blockquote><h3 id="临时缓存">临时缓存</h3><p>上面我们分析了重用对象的逻辑，发现数据是没有被重用的。但是我们需要重用也是有办法的，首先介绍临时缓存。具体来说，RDD通过<code>Cache</code>或者<code>Persist</code>方法将前面的计算结果缓存，默认情况下会将数据缓存到JVM的堆内存当中。我们可以修改上面的代码，在调用reduce之前将mapRdd缓存下来。这样在后面调用reduce的时候，就不会重新调用mapRdd以及之前的逻辑，而是会采用缓存中的数据。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">mapRdd.cache()<br><span class="hljs-comment">// 或者</span><br>mapRdd.persist(<span class="hljs-type">StorageLevel</span>.<span class="hljs-type">DISK_ONLY</span>)<br></code></pre></td></tr></table></figure><p>其中cache方法的底层调用的还是persist方法，默认缓存只存放在内存中。而persist方法可以更改存储级别，在StorageLevel中可以查看所有支持的存储级别，大致分为<code>MEMORY_ONLY</code>，<code>MEMORY_ONLY_SER</code>，<code>MEMORY_AND_DISK</code>，<code>MEMORY_AND_DISK_SER</code>，<code>DISK_ONLY</code></p><p>还有其他几个需要注意的点：</p><ul><li>持久化操作是在行动算子执行时候即提交任务时完成的，如果没有行动算子触发任务执行，持久化操作也不会进行</li><li>Spark会自动对一些Shuffle操作的中间数据进行持久化操作（例如reduceByKey），这样做的目的是为了当一个节点Shuffle失败后避免重新计算整个输入，但是在实际应用的时候，如果想要重用数据，仍然建议调用persist或者cache</li></ul><h3 id="持久检查点">持久检查点</h3><p>上面的缓存操作只是临时缓存，而创建检查点可以将RDD的中间结果写入磁盘。在中间阶段做检查点容错，如果检查点之后RDD出现问题，则检查点之间的RDD均不需要再次检查，可以从检查点开始重新检查血缘，减小开销</p><p>同样的，检查点持久化操作需要通过行动算子进行触发。检查点路径保存的文件在作业执行完毕之后不会被删除。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> sparkConf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;RDD&quot;</span>)<br><span class="hljs-keyword">val</span> sc = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkContext</span>(sparkConf)<br>sc.setCheckpointDir(<span class="hljs-string">&quot;./checkpoint&quot;</span>)<br><br><span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">val</span> mapRdd = rdd.map(<br>    num =&gt; &#123;<br>        println(<span class="hljs-string">&quot;-map-&quot;</span>)<br>        num + <span class="hljs-number">1</span><br>    &#125;<br>)<br>mapRdd.checkpoint()<br><br><span class="hljs-keyword">val</span> res1 = mapRdd.reduce(_ + _)<br><span class="hljs-keyword">val</span> res2 = mapRdd.reduce(_ * _)<br><span class="hljs-keyword">val</span> res3 = mapRdd.reduce(_ - _)<br><br>println(<span class="hljs-string">&quot;res1=&quot;</span> + res1)<br>println(<span class="hljs-string">&quot;res2=&quot;</span> + res2)<br>println(<span class="hljs-string">&quot;res3=&quot;</span> + res3)<br></code></pre></td></tr></table></figure><p>需要注意，首先我们需要设置检查点存放的位置，并且注意到这里后续存在三个reduce行动算子，而输出如下。其中输出了四次"-map-"，是因为在checkpoint()方法中会重新触发一个job执行checkpoint。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">-map-<br>-map-<br>-map-<br>-map-<br>res1=5<br>res2=6<br>res3=1<br></code></pre></td></tr></table></figure><p>可以分析上面结果输出的原因，经过reduce行动算子触发之后，首先会过一遍前面的逻辑，直到checkpoint方法，输出了两个<code>-map-</code>。之后在checkpoint方法中会重新创建一个Job执行前面的逻辑来创建checkpoint。因此会再输出两个<code>-map-</code>。后面的三个reduce可以对前面的数据进行重用，因此直接输出最终的结果。我们通常会将cache和checkpoint配合使用，避免重新执行一遍前面的逻辑。增加之后，上面的代码运行只会输出两个<code>-map-</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">mapRDD.cache()<br>mapRdd.checkpoint()<br></code></pre></td></tr></table></figure><h3 id="缓存和检查点的区别">缓存和检查点的区别</h3><ol type="1"><li>cache缓存只是将数据保存起来，不会切断血缘关系，会添加一层cache的依赖。而checkpoints会切断血缘关系，重新建立新的血缘关系</li><li>persist将数据临时存储在磁盘文件中进行数据重用，在涉及到磁盘IO的情况下，性能较低，但是数据安全。如果作业执行完毕，临时保存的数据文件会丢失。</li><li>checkpoint将数据长久地保存在磁盘文件中进行数据重用，一般保存在hdfs中。涉及磁盘IO，性能较低，但是数据安全。并且为了提高效率，通常和<code>cache</code>配合使用</li></ol><h2 id="rdd分区器">RDD分区器</h2><h3 id="spark自带分区器">Spark自带分区器</h3><p>Spark目前支持Hash分区和Range分区，以及用户自定义分区。Hash分区为默认分区。分区器直接决定RDD中分区的个数，RDD中每条数据经过Shuffle后进入哪个分区。</p><ul><li>只有Key-Value类型的RDD才有分区器，非Key-Value类型的RDD分区值为None</li><li>每个RDD的分区ID范围为<code>[0, numPartitions-1)</code>，分别对应numPartitions个分区（类似Hadoop中的分区概念）</li></ul><p>Hash分区：对于给定的Key，计算其hashCode，对分区个数进行取余</p><p>Range分区：将一定范围内的数据映射到一个分区中，尽量保证每个分区数据均匀，而且分区间有序。</p><h3 id="自定义分区器">自定义分区器</h3><p>我们也可以自定义分区器，我们自己实现的类需要继承Partitioner，实现其中的特定方法。下面是示例代码，根据Key的含义进行分区划分</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.spark.&#123;<span class="hljs-type">Partitioner</span>, <span class="hljs-type">SparkConf</span>, <span class="hljs-type">SparkContext</span>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Rdd_Test</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> sparkConf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;RDD&quot;</span>)<br>    <span class="hljs-keyword">val</span> sc = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkContext</span>(sparkConf)<br><br>    <span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>(<br>      (<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;123123&quot;</span>),<br>      (<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;123123&quot;</span>),<br>      (<span class="hljs-string">&quot;xxxx&quot;</span>, <span class="hljs-string">&quot;123123&quot;</span>),<br>      (<span class="hljs-string">&quot;xxxxx&quot;</span>, <span class="hljs-string">&quot;123123&quot;</span>),<br>      (<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;123123&quot;</span>),<br>      (<span class="hljs-string">&quot;xx&quot;</span>, <span class="hljs-string">&quot;123123&quot;</span>),<br>    ))<br>    <span class="hljs-keyword">val</span> partRdd = rdd.partitionBy(<span class="hljs-keyword">new</span> <span class="hljs-type">MyPartitioner</span>)<br><br>    partRdd.saveAsTextFile(<span class="hljs-string">&quot;output&quot;</span>)<br><br>  &#125;<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPartitioner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Partitioner</span> </span>&#123;<br>    <span class="hljs-comment">// 分区数量</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numPartitions</span></span>: <span class="hljs-type">Int</span> = <span class="hljs-number">4</span><br>    <br>    <span class="hljs-comment">// 分区逻辑</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPartition</span></span>(key: <span class="hljs-type">Any</span>): <span class="hljs-type">Int</span> = &#123;<br>      key <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;x&quot;</span> =&gt; <span class="hljs-number">0</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;xx&quot;</span> =&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;xxx&quot;</span> =&gt; <span class="hljs-number">2</span><br>        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">3</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop源码-FileInputFormat在新旧API中切片操作的区别</title>
    <link href="/2022/05/09/Hadoop%E6%BA%90%E7%A0%81-FileInputFormat%E5%9C%A8%E6%96%B0%E6%97%A7API%E4%B8%AD%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/09/Hadoop%E6%BA%90%E7%A0%81-FileInputFormat%E5%9C%A8%E6%96%B0%E6%97%A7API%E4%B8%AD%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="源码对比">源码对比</h2><h3 id="旧api">旧API</h3><p>首先来查看旧API中的<code>getSplits</code>，所在的位置为<code>package org.apache.hadoop.mapred.FileInputFormat</code>，以下代码只保留了核心的切分逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> InputSplit[] getSplits(JobConf job, <span class="hljs-type">int</span> numSplits) <span class="hljs-keyword">throws</span> IOException &#123;<br>    ...<br>    <span class="hljs-type">long</span> <span class="hljs-variable">totalSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                           <span class="hljs-comment">// compute total size</span><br>    ...<br>    <br>    List&lt;FileStatus&gt; files = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(stats.length);<br>    <span class="hljs-keyword">for</span> (FileStatus file: stats) &#123;                <span class="hljs-comment">// check we have valid files</span><br>        ...<br>            files.add(file);<br>            totalSize += file.getLen();<br>        ...<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">goalSize</span> <span class="hljs-operator">=</span> totalSize / (numSplits == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : numSplits);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">minSize</span> <span class="hljs-operator">=</span> Math.max(job.getLong(org.apache.hadoop.mapreduce.lib.input.<br>                                        FileInputFormat.SPLIT_MINSIZE, <span class="hljs-number">1</span>), minSplitSize);<br><br>    ...<br>                <span class="hljs-type">long</span> <span class="hljs-variable">blockSize</span> <span class="hljs-operator">=</span> file.getBlockSize();<br>                <span class="hljs-type">long</span> <span class="hljs-variable">splitSize</span> <span class="hljs-operator">=</span> computeSplitSize(goalSize, minSize, blockSize);<br><br>                <span class="hljs-type">long</span> <span class="hljs-variable">bytesRemaining</span> <span class="hljs-operator">=</span> length;<br>                <span class="hljs-keyword">while</span> (((<span class="hljs-type">double</span>) bytesRemaining)/splitSize &gt; SPLIT_SLOP) &#123;<br>                    String[][] splitHosts = getSplitHostsAndCachedHosts(blkLocations,<br>                                                                        length-bytesRemaining, splitSize, clusterMap);<br>                    splits.add(makeSplit(path, length-bytesRemaining, splitSize,<br>                                         splitHosts[<span class="hljs-number">0</span>], splitHosts[<span class="hljs-number">1</span>]));<br>                    bytesRemaining -= splitSize;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (bytesRemaining != <span class="hljs-number">0</span>) &#123;<br>                    String[][] splitHosts = getSplitHostsAndCachedHosts(blkLocations, length<br>                                                                        - bytesRemaining, bytesRemaining, clusterMap);<br>                    splits.add(makeSplit(path, length - bytesRemaining, bytesRemaining,<br>                                         splitHosts[<span class="hljs-number">0</span>], splitHosts[<span class="hljs-number">1</span>]));<br>                &#125;<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中的重要参数：</p><ul><li><p><code>totalSize</code>：文件夹中所有文件大小总和</p></li><li><p><code>goalSize</code>：目标分区大小，通过<code>totalSize</code>和传入参数<code>numSplits</code>计算得来（<code>totalSize / numSplits</code>）</p></li><li><p><code>minSize</code>：分区最小大小，由配置参数<code>mapreduce.input.fileinputformat.split.minsize</code>，为该配置参数与<code>minSplitSize=1</code>之间的最大值，默认情况下<code>minSize</code>值为1</p></li><li><p><code>blockSize</code>：文件系统的块大小</p></li><li><p><code>splitSize</code>：分区大小，通过以下方法确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> <span class="hljs-title function_">computeSplitSize</span><span class="hljs-params">(<span class="hljs-type">long</span> goalSize, <span class="hljs-type">long</span> minSize, <span class="hljs-type">long</span> blockSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> Math.max(minSize, Math.min(goalSize, blockSize));<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，如果<code>goalSize</code>不超过<code>blockSize</code>，则分区大小为<code>goalSize</code>；否则为<code>blockSize</code>。</p></li></ul><p>确认了分区大小之后，就可以进行切片操作。这里需要注意的是<code>SPLIT_SLOP = 1.1</code>，只有当剩余大小和分区大小的比值大于1.1才能继续切片，否则将剩余内容作为一个完整的切片。</p><h3 id="新api">新API</h3><p>在新的API中，分区大小的计算逻辑进行改善，并且<code>getSplits</code>不再接受<code>int numSplits</code>参数，以下是新API中的<code>getSplits</code>，位置为<code>org.apache.hadoop.mapreduce.lib.input.FileInputFormat</code>，同样以下代码只保留了核心的切片逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;InputSplit&gt; <span class="hljs-title function_">getSplits</span><span class="hljs-params">(JobContext job)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">StopWatch</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>().start();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">minSize</span> <span class="hljs-operator">=</span> Math.max(getFormatMinSplitSize(), getMinSplitSize(job));<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxSize</span> <span class="hljs-operator">=</span> getMaxSplitSize(job);<br><br>    <span class="hljs-comment">// generate splits</span><br>    List&lt;InputSplit&gt; splits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;InputSplit&gt;();<br>    List&lt;FileStatus&gt; files = listStatus(job);<br>    <br>    ...<br>    <br>    <span class="hljs-keyword">for</span> (FileStatus file: files) &#123;<br>...<br>        <span class="hljs-type">long</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> file.getLen();<br><br>        ...<br>                <br>                <span class="hljs-type">long</span> <span class="hljs-variable">blockSize</span> <span class="hljs-operator">=</span> file.getBlockSize();<br>                <span class="hljs-type">long</span> <span class="hljs-variable">splitSize</span> <span class="hljs-operator">=</span> computeSplitSize(blockSize, minSize, maxSize);<br><br>                <span class="hljs-type">long</span> <span class="hljs-variable">bytesRemaining</span> <span class="hljs-operator">=</span> length;<br>                <span class="hljs-keyword">while</span> (((<span class="hljs-type">double</span>) bytesRemaining)/splitSize &gt; SPLIT_SLOP) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">blkIndex</span> <span class="hljs-operator">=</span> getBlockIndex(blkLocations, length-bytesRemaining);<br>                    splits.add(makeSplit(path, length-bytesRemaining, splitSize,<br>                                         blkLocations[blkIndex].getHosts(),<br>                                         blkLocations[blkIndex].getCachedHosts()));<br>                    bytesRemaining -= splitSize;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (bytesRemaining != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">blkIndex</span> <span class="hljs-operator">=</span> getBlockIndex(blkLocations, length-bytesRemaining);<br>                    splits.add(makeSplit(path, length-bytesRemaining, bytesRemaining,<br>                                         blkLocations[blkIndex].getHosts(),<br>                                         blkLocations[blkIndex].getCachedHosts()));<br>                &#125;<br>       <br>        ...<br>       <br>    &#125;<br>    <span class="hljs-keyword">return</span> splits;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的重要参数：</p><ul><li><p><code>minSize</code>：配置参数<code>mapreduce.input.fileinputformat.split.minsize</code>与1的最大值，在不配置的情况下，<code>minSize=1</code></p></li><li><p><code>maxSize</code>：配置参数<code>mapreduce.input.fileinputformat.split.maxsize</code>的值，在不配置的情况下，<code>maxSize=Long.MAX_VALUE</code></p></li><li><p><code>blockSize</code>：文件系统的块大小</p></li><li><p><code>splitSize</code>：分区大小，通过以下方法确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> <span class="hljs-title function_">computeSplitSize</span><span class="hljs-params">(<span class="hljs-type">long</span> blockSize, <span class="hljs-type">long</span> minSize, <span class="hljs-type">long</span> maxSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> Math.max(minSize, Math.min(maxSize, blockSize));<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，分区大小为<code>blockSize</code></p></li></ul><p>新API中的分区逻辑改变不大，只是改变了传入参数，删减了<code>goalSize</code>。当然同样存在<code>SPLIT_SLOP = 1.1</code>的逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>details</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop源码-TextInputFormat解决跨分区的行读取问题</title>
    <link href="/2022/05/09/Hadoop%E6%BA%90%E7%A0%81-TextInputFormat%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%88%86%E5%8C%BA%E7%9A%84%E8%A1%8C%E8%AF%BB%E5%8F%96%E9%97%AE%E9%A2%98/"/>
    <url>/2022/05/09/Hadoop%E6%BA%90%E7%A0%81-TextInputFormat%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%88%86%E5%8C%BA%E7%9A%84%E8%A1%8C%E8%AF%BB%E5%8F%96%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="跨分区场景">跨分区场景</h2><p>我们知道Hadoop中会先对输入数据进行分片操作。针对每个分区，使用<code>RecordReader</code>来读取数据，组织成键值对的形传给Map函数进行处理。默认情况下我们使用的是<code>TextInputFormat</code>，它的读取逻辑是将文件按行读取，以行首字节在文件中的偏移量作为key进行传递。但是很有可能出现的情况是，数据分区的时候会将一行内容从中切开，即一个行记录出现在相邻的两个分区当中。读取到残缺的行显然是会影响实际的业务逻辑的，在Hadoop数据读取的源码中有相应的处理。</p><h2 id="源码解析">源码解析</h2><p><code>TextInputFormat</code>中创建了一个<code>RecordReader</code>，其中new了一个<code>LineRecordReader</code>，该类用于读取一行。其中的关键逻辑是调用了<code>LineReader</code>的readLine方法，该类的所在包为<code>package org.apache.hadoop.util</code></p><p><code>LineReader</code>的readLine方法会根据是否有用户传入的分隔符走不同的逻辑，其中readDefaultLine方法使用的是默认的行分隔符（CR、LF、CRLF）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">readLine</span><span class="hljs-params">(Text str, <span class="hljs-type">int</span> maxLineLength,</span><br><span class="hljs-params">                    <span class="hljs-type">int</span> maxBytesToConsume)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.recordDelimiterBytes != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> readCustomLine(str, maxLineLength, maxBytesToConsume);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> readDefaultLine(str, maxLineLength, maxBytesToConsume);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LineReader</code>的readDefaultLine方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从文件中读取一行，行分隔符是CR(&#x27;\r&#x27;)、LF(&#x27;\n&#x27;)或者CRLF(&#x27;\r\n&#x27;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">readDefaultLine</span><span class="hljs-params">(Text str, <span class="hljs-type">int</span> maxLineLength, <span class="hljs-type">int</span> maxBytesToConsume)</span><br>    <span class="hljs-keyword">throws</span> IOException &#123;<br>    str.clear();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">txtLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//tracks str.getLength(), as an optimization</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newlineLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//行结束符的长度(不同操作系统对此定义不同)</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">prevCharCR</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标记之前的字符是否是CR</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">bytesConsumed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startPosn</span> <span class="hljs-operator">=</span> bufferPosn; <span class="hljs-comment">//starting from where we left off the last time</span><br>        <span class="hljs-comment">// 如果当前在buffer中的数据已经读取完毕，则加载一批数据到buffer中</span><br>        <span class="hljs-keyword">if</span> (bufferPosn &gt;= bufferLength) &#123;<br>            startPosn = bufferPosn = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重置从buffer中读取的起始位置</span><br>            <span class="hljs-keyword">if</span> (prevCharCR) &#123;<br>                ++bytesConsumed; <span class="hljs-comment">//account for CR from previous read</span><br>            &#125;<br>            bufferLength = fillBuffer(in, buffer, prevCharCR);<br>            <span class="hljs-keyword">if</span> (bufferLength &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// EOF</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 获取一行的长度，在这里需要判断行结束符的长度，由于行结束符在不同操作系统中的定义不同，因此需要结合CR进行判断</span><br>        <span class="hljs-keyword">for</span> (; bufferPosn &lt; bufferLength; ++bufferPosn) &#123; <span class="hljs-comment">//search for newline</span><br>            <span class="hljs-keyword">if</span> (buffer[bufferPosn] == LF) &#123;<br>                newlineLength = (prevCharCR) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>                ++bufferPosn; <span class="hljs-comment">// at next invocation proceed from following byte</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (prevCharCR) &#123; <span class="hljs-comment">//CR + notLF, we are at notLF</span><br>                newlineLength = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            prevCharCR = (buffer[bufferPosn] == CR);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readLength</span> <span class="hljs-operator">=</span> bufferPosn - startPosn; <span class="hljs-comment">// 读取一行的长度</span><br>        <span class="hljs-keyword">if</span> (prevCharCR &amp;&amp; newlineLength == <span class="hljs-number">0</span>) &#123;<br>            --readLength; <span class="hljs-comment">//CR at the end of the buffer</span><br>        &#125;<br>        bytesConsumed += readLength;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">appendLength</span> <span class="hljs-operator">=</span> readLength - newlineLength;<br>        <span class="hljs-keyword">if</span> (appendLength &gt; maxLineLength - txtLength) &#123;<br>            appendLength = maxLineLength - txtLength;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (appendLength &gt; <span class="hljs-number">0</span>) &#123;<br>            str.append(buffer, startPosn, appendLength);<br>            txtLength += appendLength;<br>        &#125;<br>        <span class="hljs-comment">// 读取到了一行或者超过读取长度了则退出</span><br>    &#125; <span class="hljs-keyword">while</span> (newlineLength == <span class="hljs-number">0</span> &amp;&amp; bytesConsumed &lt; maxBytesToConsume);<br><br>    <span class="hljs-keyword">if</span> (bytesConsumed &gt; Integer.MAX_VALUE) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Too many bytes before newline: &quot;</span> + bytesConsumed);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)bytesConsumed;<br>&#125;<br></code></pre></td></tr></table></figure><p>在进行readLine的时候，我们总是从buffer中读取数据，如果buffer中的数据读取完毕，我们会加载下一批数据进入buffer。在读取一行的时候，我们会在buffer中寻找行结束符，然后确定一行的长度。注意这里的buffer读取是直接从文件中操作的，并不会受分区的限制，因此在读取的时候是可能跨分区读取的。<strong>因此在读取的时候，如果存在跨分区的行，我们也是会完整的读取</strong>。</p><p>这样的操作就会导致一个问题，即我们需要判断上一个分区是否跨分区读取过，从而避免遗漏或者重复读取处于分区之间的行。</p><p>这里我们首先查看读取文件的<code>LineRecordReader.next()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">next</span><span class="hljs-params">(LongWritable key, Text value)</span><br>    <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    <span class="hljs-comment">// We always read one extra line, which lies outside the upper</span><br>    <span class="hljs-comment">// split limit i.e. (end - 1)</span><br>    <span class="hljs-keyword">while</span> (getFilePosition() &lt;= end || in.needAdditionalRecordAfterSplit()) &#123;<br>        key.set(pos);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">0</span>) &#123;<br>            newSize = skipUtfByteOrderMark(value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            newSize = in.readLine(value, maxLineLength, maxBytesToConsume(pos));<br>            pos += newSize;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (newSize == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (newSize &lt; maxLineLength) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// line too long. try again</span><br>        LOG.info(<span class="hljs-string">&quot;Skipped line of size &quot;</span> + newSize + <span class="hljs-string">&quot; at pos &quot;</span> + (pos - newSize));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的关键在于<strong>while的判断逻辑</strong>。在切片规划中，我们的每个切片规划信息中包含<code>filePath、start、length</code>，三者可以确定当前切片是在哪个文件中哪里起始，长度是多少。这里的<code>end</code>即为<code>start+length</code>。在一般的文件读取当中，我们读取的文件内容，行偏移量范围应该为<code>[start, end)</code>，但是这里的while条件是<code>&lt;=end</code>。具体分析，切分规划有两种可能，一种是恰好切分到行尾，这样的话<code>end</code>偏移量就是下一行的行首，按照while的逻辑我们会将这一行进行读取；另一种是将该分区中的最后一行从中间切开，那么<code>end</code>偏移量还是在本行而不是下一行，按照<code>readLine</code>的逻辑，我们会将这一行读取完毕。可以看到，上面两种逻辑，<strong>我们都读取了下一个分区中的第一行</strong>。</p><p>因此，在<code>LineRecordReader</code>中，除了第一个分区之外，会跳过每一个分区的第一行，从下一行开始读取。源代码中判断逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// If this is not the first split, we always throw away first record</span><br><span class="hljs-comment">// because we always (except the last split) read one extra line in</span><br><span class="hljs-comment">// next() method.</span><br><span class="hljs-keyword">if</span> (start != <span class="hljs-number">0</span>) &#123;<br>    start += in.readLine(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(), <span class="hljs-number">0</span>, maxBytesToConsume(start));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>总结来说，Hadoop中的切片操作是一种<strong>宏观</strong>上的规划，为的是降低数据的规模，但是这是<strong>逻辑上的切片规划</strong>。在实际读取数据到不同切片的时候存在<strong>微观上的差别</strong>。在每个分区的数据读取中，我们会跳过第一行（除了第一个分区），并且读取下一个分区中的第一行（可能完整，也可能不完整），从而保证跨分区数据读取的正确性。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>details</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark学习笔记-SparkCore(1)-RDD以及相关算子</title>
    <link href="/2022/05/08/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-1-RDD%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%AE%97%E5%AD%90/"/>
    <url>/2022/05/08/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SparkCore-1-RDD%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%AE%97%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="rdd">RDD</h1><h2 id="概念">概念</h2><p>RDD（Resilient DistributedDataset），弹性分布式数据集，是Spark中最基本的数据处理模型。在代码中，它是一个抽象类，代表一个弹性的、不可变的、可分区、里面的元素可并行计算的集合。</p><ul><li>弹性：<ul><li>存储的弹性：内存与磁盘的自动切换</li><li>容错的弹性：数据丢失的自动恢复</li><li>计算的弹性：计算出错重试机制</li><li>分片的弹性：可以根据需要重新分片</li></ul></li><li>分布式：数据存储在集群的不同节点上</li><li>数据集：RDD中封装了计算逻辑，并不保存数据</li><li>数据抽象：RDD是一个抽象类，需要子类的具体实现</li><li>不可变：RDD中封装了计算逻辑，是不可以改变的。如果想要改变，只能产生新的RDD，在新的RDD里面封装逻辑</li><li>可分区：分区后进行并行计算</li></ul><blockquote><p>输入数据首先需要组织成RDD的结果，之后可以调用RDD中的方法（后续进行处理）。多个不同功能的算子组合成复杂的业务逻辑，直到调用行动算子，数据进行处理，让数据走过对应的逻辑得到最终的输出。</p><p>RDD中存在分区的概念，由于需要面对分布式计算的场景，实际计算的时候也是将任务分配给其他的Executor来执行。分区机制，即如何将输入数据进行划分，是RDD中一个重要属性。</p></blockquote><h2 id="核心属性">核心属性</h2><p>RDD中有五个核心属性：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-type">Internally</span>, each <span class="hljs-type">RDD</span> is characterized by five main properties:<br>- <span class="hljs-type">A</span> list of partitions<br>- <span class="hljs-type">A</span> function <span class="hljs-keyword">for</span> computing each split<br>- <span class="hljs-type">A</span> list of dependencies on other <span class="hljs-type">RDDs</span><br>- <span class="hljs-type">Optionally</span>, a <span class="hljs-type">Partitioner</span> <span class="hljs-keyword">for</span> key-value <span class="hljs-type">RDDs</span> (e.g. to say that the <span class="hljs-type">RDD</span> is hash-partitioned)<br>- <span class="hljs-type">Optionally</span>, a list of preferred locations to compute each split on (e.g. block locations <span class="hljs-keyword">for</span> an <span class="hljs-type">HDFS</span> file)<br></code></pre></td></tr></table></figure><ul><li><p>分区列表：RDD中的分区列表，用于实现分布式计算</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPartitions</span></span>: <span class="hljs-type">Array</span>[<span class="hljs-type">Partition</span>]<br></code></pre></td></tr></table></figure></li><li><p>分区计算函数：RDD的计算逻辑，Spark在计算的时候，使用分区函数对每个分区中的数据进行处理</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@DeveloperApi</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute</span></span>(split: <span class="hljs-type">Partition</span>, context: <span class="hljs-type">TaskContext</span>): <span class="hljs-type">Iterator</span>[<span class="hljs-type">T</span>]<br></code></pre></td></tr></table></figure></li><li><p>RDD之间的依赖关系：RDD是计算模型的封装，当需要将多个计算模型进行组合的时候，就需要将多个RDD建立依赖关系</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getDependencies</span></span>: <span class="hljs-type">Seq</span>[<span class="hljs-type">Dependency</span>[_]] = deps<br></code></pre></td></tr></table></figure></li><li><p>分区器（可选）：当数据为Key-Value类型数据的时候，可以通过设定分区器自定义数据的分区</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@transient</span> <span class="hljs-keyword">val</span> partitioner: <span class="hljs-type">Option</span>[<span class="hljs-type">Partitioner</span>] = <span class="hljs-type">None</span><br></code></pre></td></tr></table></figure></li><li><p>首选位置（可选）：可以设置分区的物理位置偏好，设定分区优先选择分配给哪个节点</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPreferredLocations</span></span>(split: <span class="hljs-type">Partition</span>): <span class="hljs-type">Seq</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Nil</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="执行原理">执行原理</h2><p>从计算的角度来看，在数据处理的过程中，需要将计算资源（例如内存、CPU等）和计算模型进行协调和整合。Spark框架在执行的时候，先申请资源，然后将应用程序中的数据处理逻辑分解成一个个的计算任务，然后将任务分发到已经分配资源的计算节点上。数据按照指定的计算模型进行处理，得到最终的计算结果。</p><p>以Yarn环境举例来说，首先启动Yarn集群环境，集群中会存在ResourceManager和NodeManager两种角色。之后Spark通过申请资源来创建调度节点和计算节点，分别在对应的节点上得到Driver和Executor。然后Spark框架根据需求将计算逻辑<strong>根据分区</strong>划分成不同的任务，调度节点将不同分区的数据送到不同的Executor上进行处理。RDD在整个流程中主要用于将逻辑进行封装，生成Task发送给Executor节点执行计算。</p><h1 id="基础编程">基础编程</h1><h2 id="rdd创建">RDD创建</h2><p>首先我们需要能够从数据中创建RDD（生成RDD），有以下4种方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 前置环境</span><br><span class="hljs-keyword">val</span> sparkConf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>)<br><span class="hljs-keyword">val</span> sc = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkContext</span>(sparkConf)<br></code></pre></td></tr></table></figure><ul><li>从内存中创建RDD</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 从内存中的集合创建 </span><br><span class="hljs-comment">// makeRDD()方法</span><br><span class="hljs-keyword">val</span> seq = <span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-keyword">val</span> rdd = sc.makeRDD(seq)<br><br><span class="hljs-comment">// parallelize()方法</span><br><span class="hljs-keyword">val</span> rdd = sc.parallelize(seq)<br></code></pre></td></tr></table></figure><p><code>sc.makeRDD()</code>和<code>sc.parallelize()</code>两种方式都能够从内存的集合创建出RDD，其中<code>makeRDD()</code>方法其实只是<code>parallelize()</code>方法的一层封装</p><p>在创建RDD的时候可以传递第二个参数，这个参数表示分区的数量。默认值采用会采用配置参数<code>spark.default.parallelism</code>，如果该配置参数没有被设置的话，则采用当前环境下的最大可用核数。可用使用<code>saveAsTextFile</code>来查看分区效果，默认情况下一个分区会产生一个保存文件，下面的代码最终会在工作目录下的<code>/ouput</code>保存出5个内容文件：<code>part-00000</code>~ <code>part-00004</code></p><p>（具体的分区逻辑会在后面进行说明）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> sparkConf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>)<br>sparkConf.set(<span class="hljs-string">&quot;spark.default.parallelism&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>)<br><span class="hljs-keyword">val</span> sc = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkContext</span>(sparkConf)<br><br><span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))<br><br>rdd.saveAsTextFile(<span class="hljs-string">&quot;output&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>从文件中创建RDD</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 从文件中创建,相对路径默认为工作目录开始</span><br><span class="hljs-comment">// 本地文件</span><br><span class="hljs-keyword">val</span> rdd = sc.textFile(<span class="hljs-string">&quot;input/data.txt&quot;</span>)<br><span class="hljs-comment">// 本地目录</span><br><span class="hljs-keyword">val</span> rdd = sc.textFile(<span class="hljs-string">&quot;input&quot;</span>)<br><span class="hljs-comment">// 使用通配符</span><br><span class="hljs-keyword">val</span> rdd = sc.textFile(<span class="hljs-string">&quot;input/data1*.txt&quot;</span>)<br><span class="hljs-comment">// 分布式存储系统路径</span><br><span class="hljs-keyword">val</span> rdd = sc.textFile(<span class="hljs-string">&quot;hdfs://hadoop102:8020/input&quot;</span>)<br></code></pre></td></tr></table></figure><p>可以有外部存储系统的数据集创建RDD包括：本地的文件系统，所有Hadoop支持的数据系统如HDFS、HBase等。并且其中文件路径有很灵活的使用功能。</p><p>有时候我们希望在读取数据的同时知道这些数据的来源，那么可以使用<code>wholeTextFiles</code>方法，得到的rdd读取结果为元组，第一个元素表示文件路径，第二个元素表示文件内容</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> rdd = sc.wholeTextFiles(<span class="hljs-string">&quot;data&quot;</span>)<br>rdd.collect().foreach(println)<br></code></pre></td></tr></table></figure><p>输出效果如下，其中的折行效果来自于输入文件中的换行符，路径为绝对路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">(file:/D:/Java/Spark/data/1.txt,1<br>1<br>)<br>(file:/D:/Java/Spark/data/2.txt,2<br>2<br>)<br></code></pre></td></tr></table></figure><p>从文件中同样可以指定分区数量，具体逻辑与从内存中创建有所不同，也会在后续进行对比。</p><ul><li>从其他RDD创建</li></ul><p>从其他RDD创建指的是，一个RDD运算完成之后，得到的是一个新的RDD</p><ul><li>直接创建RDD</li></ul><p>直接使用new的方式构造RDD，一般在Spark框架内部使用</p><h2 id="rdd并行度与分区">RDD并行度与分区</h2><p>分区：Spark将一个作业切分成多个任务，发送给Executor节点并行计算</p><p>并行度：能够同时并行计算的任务数量称为并行度。</p><p>从内存中生成RDD和从文件中生成RDD，分区逻辑略有区别，分别体现在默认分区数量以及分区划分上。</p><p>读取<strong>内存</strong>数据：</p><p><code>makeRDD</code>的第二个参数为<code>numSlices</code>，表示分区数量。默认的分区数量采用会采用配置参数<code>spark.default.parallelism</code>，如果该配置参数没有被设置的话，则采用当前环境下的最大可用核数。</p><p>分区划分的核心逻辑如下（<code>org.apache.spark.rdd.ParallelCollectionRDD</code>的<code>slice</code>方法），其中<code>numSlices</code>之前传入的参数，<code>length</code>为构建RDD的序列的长度，经过下面代码可以得到<code>numSlices</code>个tuple。每个tuple中保存了<code>start</code>和<code>end</code>，作为参数调用Array的<code>slice(from: Int, until: Int)</code>方法可以切分子数组，即对应分区中的内容。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">(<span class="hljs-number">0</span> until numSlices).iterator.map &#123; i =&gt;<br>    <span class="hljs-keyword">val</span> start = ((i * length) / numSlices).toInt<br>    <span class="hljs-keyword">val</span> end = (((i + <span class="hljs-number">1</span>) * length) / numSlices).toInt<br>    (start, end)<br>&#125;<br></code></pre></td></tr></table></figure><p>举例来说，下面的代码运行后，在<code>output</code>目录下得到4个输出文件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>), <span class="hljs-number">4</span>)<br><span class="hljs-comment">// numSlices = 4, length = 10</span><br><span class="hljs-comment">// 0: [0, 2)</span><br><span class="hljs-comment">// 1: [2, 5)</span><br><span class="hljs-comment">// 2: [5, 7)</span><br><span class="hljs-comment">// 3: [7, 10)</span><br>rdd.saveAsTextFile(<span class="hljs-string">&quot;output&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">part-00000</span><br>0<br>1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">part-00001</span><br>2<br>3<br>4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">part-00002</span><br>5<br>6<br><span class="hljs-meta prompt_"># </span><span class="language-bash">part-00003</span><br>7<br>8<br>9<br></code></pre></td></tr></table></figure><p>读取<strong>文件</strong>数据：</p><p><code>textFile</code>的第二个参数为<code>minPartitions</code>，表示最小的分区数量，默认值为<code>defalutMinPartitions</code>，定义如下，即该值只能取1或2：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">defaultMinPartitions</span></span>: <span class="hljs-type">Int</span> = math.min(defaultParallelism, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>textFile中返回的RDD是HadoopRDD类，其中使用了FileInputFormat的getPartition方法，并且是旧的API。分区的核心逻辑就在于Hadoop中的FileInputFormat，关于旧API中的getSplits切片逻辑以及行读取的问题可以查看本博客的其他两篇相关文章，这里直接介绍结论</p><ul><li><a href="/2022/05/09/Hadoop%E6%BA%90%E7%A0%81-TextInputFormat%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%88%86%E5%8C%BA%E7%9A%84%E8%A1%8C%E8%AF%BB%E5%8F%96%E9%97%AE%E9%A2%98/" title="Hadoop源码-TextInputFormat解决跨分区的行读取问题">Hadoop源码-TextInputFormat解决跨分区的行读取问题</a></li><li><a href="/2022/05/09/Hadoop%E6%BA%90%E7%A0%81-FileInputFormat%E5%9C%A8%E6%96%B0%E6%97%A7API%E4%B8%AD%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Hadoop源码-FileInputFormat在新旧API中切片操作的区别">Hadoop源码-FileInputFormat在新旧API中切片操作的区别</a></li></ul><p>在读取文件的时候，默认情况下会使用<code>goalSize</code>作为分区大小，<code>goalSize</code>的大小通过我们传入的<code>minPartitions</code>以及所有文件的总大小来确定。<code>goalSize = totalSize / minPartitions</code>。由于存在切片逻辑是对输入的每个文件来说的，每个文件的最终切片大小可能达不到<code>goalSize</code>，因此最终的分片数量可能会高于<code>minPartitions</code>。得到切片规划之后，读取数据到对应分区中的逻辑可以参考TextInputFormat的行读取，总结来说，在每个分区的数据读取中，我们会跳过第一行（除了第一个分区），并且读取下一个分区中的第一行（可能完整，也可能不完整），从而保证跨分区数据读取的正确性。如果是多文件读取，则在<code>totalSize</code>的计算的时候需要计算所有文件的大小总和，而在分区划分的时候则是按照逐个文件单独进行的。</p><p>举例来说，我们存在下面的文件<code>data/1.txt</code>，总大小为19字节（下面显示写出了CR和LF，为Windows操作系统中的行结束符）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">1 CR LF<br>2 CR LF<br>3 CR LF<br>4 CR LF<br>5 CR LF<br>6 CR LF<br>7<br></code></pre></td></tr></table></figure><p>运行下面的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> rdd = sc.textFile(<span class="hljs-string">&quot;data/1.txt&quot;</span>)<br>rdd.saveAsTextFile(<span class="hljs-string">&quot;output&quot;</span>)<br></code></pre></td></tr></table></figure><p>计算得到分区大小为<code>19 / 2 = 9</code>字节，由于<code>10 / 9 = 1.1..... &gt; 1.1</code>，最终会产生三个切片文件，切片规划如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">(fileName: .../data/<span class="hljs-number">1.</span>txt, start: <span class="hljs-number">0</span>, length: <span class="hljs-number">9</span>, ...)<br>(fileName: .../data/<span class="hljs-number">1.</span>txt, start: <span class="hljs-number">9</span>, length: <span class="hljs-number">9</span>, ...)<br>(fileName: .../data/<span class="hljs-number">1.</span>txt, start: <span class="hljs-number">18</span>, length: <span class="hljs-number">1</span>, ...)<br></code></pre></td></tr></table></figure><p>在第一个切片中，我们读取偏移量<code>[0, 9]</code>的所在行（由于while的特殊逻辑，这里会读取到下个分区的第一行），得到如下数据</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-number">1</span> <span class="hljs-type">LF</span><br><span class="hljs-number">2</span> <span class="hljs-type">LF</span><br><span class="hljs-number">3</span> <span class="hljs-type">LF</span><br><span class="hljs-number">4</span> <span class="hljs-type">LF</span><br></code></pre></td></tr></table></figure><p>在第二个切片中，读取偏移量<code>[9, 18]</code>所在行（不是第一个切片，忽略第一行，读取下个分区的第一行），得到如下数据</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-number">5</span> <span class="hljs-type">LF</span><br><span class="hljs-number">6</span> <span class="hljs-type">LF</span><br><span class="hljs-number">7</span> <span class="hljs-type">LF</span><br></code></pre></td></tr></table></figure><p>在第三个切片中，读取偏移量<code>[18,19]</code>所在行，由于忽略了分区中的第一行，已经不存在数据了，因此得到空文件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br></code></pre></td></tr></table></figure><p>实际运行代码，得到的结果和我们分析的是一样的，得到<code>part-00000</code>到<code>part-00002</code>，大小分别为8字节、6字节、0字节</p><blockquote><p>我们还可以利用<code>glom()</code>方法来查看分区数据，glom函数的功能是将同一个分区的数据直接转换为相同类型的内存数组进行处理，分区不变。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> rdd = sc.textFile(<span class="hljs-string">&quot;data/1.txt&quot;</span>)<br>rdd.glom().collect().foreach(arr =&gt; &#123;<br>    println(arr)<br>    println(arr.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br>&#125;)<br></code></pre></td></tr></table></figure><p>其中arr表示分区数组。glom()会得到一个Array列表，其中每个元素都代表一个分区</p></blockquote><h2 id="rdd算子">RDD算子</h2><p>RDD算子即RDD中提供给我们的方法，可以大致梳理出如下脉络。其中RDD转换算子在描述计算逻辑，只有当执行RDD行动算子的时候，才会真正将数据送入，进行执行。RDD算子与普通的方法调用有所不同，RDD算子的外部操作都是在Driver端执行的，而RDD算子内部的操作则是在Executor端</p><ul><li>RDD转换算子：根据数据处理方式的不同将算子整体上分为Value、双Value和Key-Value类型<ul><li>Value类型：map、mapPartitions、mapPartitionsWithIndex、flatMap、glom、groupBy、filter、sample、distinct、coalesce、repartitions、sortBy</li><li>双Value类型：intersection、union、subtract、zip</li><li>Key-Value类型：partitionBy、reduceByKey、groupByKey、aggregateByKey、foldByKey、combineByKey、sortByKey、join、leftOuterJoin、cogroup</li></ul></li><li>RDD行动算子<ul><li>reduce、collect、count、first、take、takeOrdered、aggregate、fold、countByKey、save相关算子、foreach</li></ul></li></ul><h1 id="rdd转换算子">RDD转换算子</h1><h2 id="value类型">value类型</h2><h3 id="map">map</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">U</span>: <span class="hljs-type">ClassTag</span>](f: <span class="hljs-type">T</span> =&gt; <span class="hljs-type">U</span>): <span class="hljs-type">RDD</span>[<span class="hljs-type">U</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>将集合中的数据逐条进行映射转换。<code>T</code>表示集合中的数据类型，<code>U</code>表示转换后的数据类型。</p><p>前面提到RDD中有分区的概念。在分区内，数据是逐个执行相应逻辑的，只有当前面的数据全部逻辑执行完毕之后，才会执行下一个数据，即<strong>分区内数据的执行是有序的</strong>。但是不同分区在不同Executor上执行，执行没有严格的先后顺序，即<strong>分区间的执行是无序的</strong>。</p><h3 id="mappartitions">mapPartitions</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mapPartitions</span></span>[<span class="hljs-type">U</span>: <span class="hljs-type">ClassTag</span>](<br>    f: <span class="hljs-type">Iterator</span>[<span class="hljs-type">T</span>] =&gt; <span class="hljs-type">Iterator</span>[<span class="hljs-type">U</span>],<br>    preservesPartitioning: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>): <span class="hljs-type">RDD</span>[<span class="hljs-type">U</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>将待处理的数据以分区为单位发送到计算节点进行处理。前面的map是分区内的每一条数据进行对应的处理，而mapPartitions是处理分区内的所有数据。</p><p>这里会将整个分区的数据加载到内存中进行引用，如果处理完的数据不被释放，会存在对象的引用。在内存较小，数据量较大的情况下，容易出现内存溢出的情况。</p><p>注意这里的返回数据类型，<code>f</code>函数接受一个迭代器类型，返回一个迭代器类型。下面的代码可以完成分区内最大值的查找，返回的最大值包装成一个列表，然后返回其迭代器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>), <span class="hljs-number">4</span>)<br><span class="hljs-comment">// [0, 1][2, 3, 4][5, 6][7, 8, 9]</span><br><span class="hljs-keyword">val</span> res = rdd.mapPartitions(<br>    iter =&gt;&#123;<br>        <span class="hljs-type">List</span>(iter.max).iterator<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><blockquote><p><strong>map和mapPartitions的区别</strong>：</p><p>从数据处理的角度来看：map算子是逐个处理分区中的数据，mapPartition算子是以分区为单位进行批处理操作</p><p>从功能的角度来看：map算子的主要目的是将数据源中的数据进行转换和改变，但是不会减少或增多数据；mapPartitions算子接受和返回迭代器类型</p></blockquote><p>迭代器的注意事项：需要注意的是Scala中的迭代器具有懒执行的特性，只有需要的时候才会计算，这点在利用<code>mapPartitions</code>的时候尤其需要注意。通常情况下，我们会在<code>mapPartitions</code>中进行数据库连接之类的操作，然后对iter中的每一条进行操作，如下所示。但是这里使用map的话，由于懒执行，真正的执行是被推后了的，也就是说等到真正的执行，我们的数据库实际上已经关闭连接了，一因此这里需要使用foreach来真正进行执行。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">mapPartitions(iter =&gt; &#123;<br>    <span class="hljs-comment">// 连接数据库</span><br>    <span class="hljs-comment">// iter.map(...) 懒执行</span><br>    <span class="hljs-comment">// 应该使用iter.foreach(...)</span><br>    <span class="hljs-comment">// 断开连接</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="mappartitionswithindex">mapPartitionsWithIndex</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mapPartitionsWithIndex</span></span>[<span class="hljs-type">U</span>: <span class="hljs-type">ClassTag</span>](<br>    f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Iterator</span>[<span class="hljs-type">T</span>]) =&gt; <span class="hljs-type">Iterator</span>[<span class="hljs-type">U</span>],<br>    preservesPartitioning: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>): <span class="hljs-type">RDD</span>[<span class="hljs-type">U</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>类似于mapPartitions操作，将整个分区的数据发送给计算节点，不过同时可以获取到当前的索引。函数<code>f</code>的输入类型为一个元组，第一个元素即表示分区的索引，第二个元素迭代器即表示分区的内容</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 代码</span><br><span class="hljs-keyword">val</span> rdd = sc.makeRDD(<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>), <span class="hljs-number">4</span>)<br><span class="hljs-comment">// [0, 1][2, 3, 4][5, 6][7, 8, 9]</span><br><span class="hljs-keyword">val</span> res = rdd.mapPartitionsWithIndex(<br>    (index, data) =&gt; &#123;<br>        data.map((index, _))<br>    &#125;<br>)<br>res.collect().foreach(println)<br><span class="hljs-comment">// 输出内容如下</span><br>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)<br>(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>)<br>(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)<br>(<span class="hljs-number">3</span>,<span class="hljs-number">7</span>)<br>(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>)<br>(<span class="hljs-number">3</span>,<span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure><h3 id="flatmap">flatMap</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">U</span>: <span class="hljs-type">ClassTag</span>](f: <span class="hljs-type">T</span> =&gt; <span class="hljs-type">TraversableOnce</span>[<span class="hljs-type">U</span>]): <span class="hljs-type">RDD</span>[<span class="hljs-type">U</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>首先对数据进行映射处理，之后再进行扁平化操作，因此该算子也称为扁平映射。</p><h3 id="glom">glom</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">glom</span></span>(): <span class="hljs-type">RDD</span>[<span class="hljs-type">Array</span>[<span class="hljs-type">T</span>]]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>将同一个分区的数据直接转换成相同类型的数组进行处理，分区不变。（注意这个算子是转换算子，而不是行动算子）</p><h3 id="groupby">groupBy</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">groupBy</span></span>[<span class="hljs-type">K</span>](<br>      f: <span class="hljs-type">T</span> =&gt; <span class="hljs-type">K</span>,<br>      numPartitions: <span class="hljs-type">Int</span>)(<span class="hljs-keyword">implicit</span> kt: <span class="hljs-type">ClassTag</span>[<span class="hljs-type">K</span>]): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">Iterable</span>[<span class="hljs-type">T</span>])]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>将数据按照指定的规则进行分组，打乱后的数据重新分组。返回的rdd是一个<strong>Key-Value类型的结果</strong>，其中相同key的数据在同一个分组中。groupBy可能发生shuffle操作，其中会满足同一个分组内的数据在一个分区当中，但是并不是说一个分区内只有一个组。在极限情况下，所有数据可能被分在同一个分区。</p><blockquote><p><strong>shuffle</strong>：前面的操作，默认情况下分区不变，指的是本来在一个分区的数据经过处理之后仍然在这个分区，但是groupBy会有一个打乱重新组合的过程，在这个过程中可能存在情况，数据原本在一个分区，经过处理之后被分配到另一个分区中，这个过程就叫做shuffle。我们需要知道跨分区的操作性能是要比分区内的操作低的，所以groupBy的性能较低。</p></blockquote><h3 id="filter">filter</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(f: <span class="hljs-type">T</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>将数据根据指定的规则进行筛选过滤，符合规则的数据保留，不符合规则的数据丢弃。传入的<code>f</code>函数返回一个布尔变量，用于判断是否符合规则。当数据进行筛选过滤之后，分区不变，但是分区内的数据可能不均衡，容易出现数据倾斜。</p><h3 id="sample">sample</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sample</span></span>(<br>    withReplacement: <span class="hljs-type">Boolean</span>,<br>    fraction: <span class="hljs-type">Double</span>,<br>    seed: <span class="hljs-type">Long</span> = <span class="hljs-type">Utils</span>.random.nextLong): <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>] <br></code></pre></td></tr></table></figure><p>函数说明：</p><p>按照指定的规则从数据集中抽取数据，具体的规则可以根据传入的参数进行确定。第一个参数表示是否放回，如果为true，则选择泊松算法；如果为false，则选择伯努利算法。两种算法都需要后面两个参数，但是含义不同</p><p>在有放回的泊松算法中，参数2表示每一个元素被抽取到的次数的数学期望，需要大于等于0，参数3表示随机数种子。</p><p>在无放回的伯努利算法中，参数2表示每一个元素被抽取到的概率，概率在<code>[0, 1]</code>之间，参数3表示随机数种子。</p><p>可以不给随机数种子，默认参数为当前系统时间的时间戳。</p><h3 id="distinct">distinct</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distinct</span></span>(): <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>将数据集中重复的数据去重。</p><blockquote><p><strong>集合的distinct</strong> VS.<strong>RDD算子中的distinct</strong></p><p>distinct完成的功能都是完成数据的去重，但是具体的逻辑有所不同。在集合的distinct中，底层实现使用的是HashSet的结构；在RDD算子中的distinct中，底层使用的是连续的算子调用，核心逻辑如下，利用reduceByKey每次聚合只留其中一个重复。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">map(x =&gt; (x, <span class="hljs-literal">null</span>)).reduceByKey((x, _) =&gt; x, numPartitions).map(_._1)<br></code></pre></td></tr></table></figure></blockquote><h3 id="coalesce">coalesce</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coalesce</span></span>(numPartitions: <span class="hljs-type">Int</span>, shuffle: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>,<br>             partitionCoalescer: <span class="hljs-type">Option</span>[<span class="hljs-type">PartitionCoalescer</span>] = <span class="hljs-type">Option</span>.empty)<br>(<span class="hljs-keyword">implicit</span> ord: <span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>] = <span class="hljs-literal">null</span>): <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>] = withScope <br></code></pre></td></tr></table></figure><p>函数说明：</p><p>改变分区数量。第一个参数为目标分区数量，第二个参数<code>shuffle</code>表示是否经过shuffle过程，如果为false，则不存在打乱重新组合的过程。如果需要缩减分区数量，是否经过shuffle过程都可以完成，没有shuffle的话则相当于合并分区。如果需要扩大分区，则一定需要shuffle过程。</p><h3 id="repartitions">repartitions</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">repartition</span></span>(numPartitions: <span class="hljs-type">Int</span>)(<span class="hljs-keyword">implicit</span> ord: <span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>] = <span class="hljs-literal">null</span>): <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>重新分配分区，该操作内部其实执行的还是<code>coalescs</code>操作，并且其中的shuffle默认值为true。使用<code>repartitions</code>，无论是扩大分区还是缩减分区，都会经过shuffle过程。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">coalesce(numPartitions, shuffle = <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><h3 id="sortby">sortBy</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sortBy</span></span>[<span class="hljs-type">K</span>](<br>    f: (<span class="hljs-type">T</span>) =&gt; <span class="hljs-type">K</span>,<br>    ascending: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>,<br>    numPartitions: <span class="hljs-type">Int</span> = <span class="hljs-keyword">this</span>.partitions.length)<br>(<span class="hljs-keyword">implicit</span> ord: <span class="hljs-type">Ordering</span>[<span class="hljs-type">K</span>], ctag: <span class="hljs-type">ClassTag</span>[<span class="hljs-type">K</span>]): <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>] <br></code></pre></td></tr></table></figure><p>函数说明：</p><p>该操作用于数据排序。在排序之前，可以将数据通过<code>f</code>函数进行处理，之后按照<code>f</code>函数的处理结果进行排序。默认为升序排序，排序后产生的新的RDD分区数目默认与原RDD的分区数一致，其中存在shuffle的过程。分区规则与前面提到的一致。</p><h2 id="双value类型">双value类型</h2><h3 id="intersection">intersection</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection</span></span>(other: <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>返回两个数据集合的交集</p><h3 id="union">union</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span></span>(other: <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>返回两个数据集合的并集。这里的集合是广义上的集合，并集中可能存在重复元素。</p><h3 id="subtract">subtract</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subtract</span></span>(other: <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">RDD</span>[<span class="hljs-type">T</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>返回两个数据集合的差集。</p><h3 id="zip">zip</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zip</span></span>[<span class="hljs-type">U</span>: <span class="hljs-type">ClassTag</span>](other: <span class="hljs-type">RDD</span>[<span class="hljs-type">U</span>]): <span class="hljs-type">RDD</span>[(<span class="hljs-type">T</span>, <span class="hljs-type">U</span>)]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>类似于拉链操作，但是与集合的拉链操作不同，zip算子<strong>要求两个数据源的分区数量保持一致，每个分区中的数据量也要保持一致</strong>。数据类型可以不一致。</p><blockquote><p>上面的双value类型算子中，并、交、差集都要求两个数据源的数据类型保持一致，但是zip算子并不要求类型一致</p></blockquote><h2 id="key-value类型">Key-Value类型</h2><p>在RDD类中并没有Key-Value类型的RDD算子，但是在Scala中存在隐式转换，转换成PairRDDFunctions类则可以找到对应的算子</p><h3 id="partitionby">partitionBy</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partitionBy</span></span>(partitioner: <span class="hljs-type">Partitioner</span>): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">V</span>)]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>将数据按照指定Partitioner重新进行分区。Spark中默认的分区器是HashPartitioner。如果重分区的分区器和当前RDD的分区器一样，底层会有一个判断逻辑，不做任何操作。也可以自定义数据分区器进行数据分区。</p><h3 id="reducebykey">reduceByKey</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduceByKey</span></span>(func: (<span class="hljs-type">V</span>, <span class="hljs-type">V</span>) =&gt; <span class="hljs-type">V</span>): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">V</span>)]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduceByKey</span></span>(func: (<span class="hljs-type">V</span>, <span class="hljs-type">V</span>) =&gt; <span class="hljs-type">V</span>, numPartitions: <span class="hljs-type">Int</span>): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">V</span>)]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>将数据按照相同的Key，对Value进行聚合。注意这里为两两聚合，需要保持数据类型的一致。如果某个key的数据只有一个，那么是不会参与计算的。</p><h3 id="groupbykey">groupByKey</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">groupByKey</span></span>(): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">Iterable</span>[<span class="hljs-type">V</span>])]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">groupByKey</span></span>(numPartitions: <span class="hljs-type">Int</span>): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">Iterable</span>[<span class="hljs-type">V</span>])]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">groupByKey</span></span>(partitioner: <span class="hljs-type">Partitioner</span>): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">Iterable</span>[<span class="hljs-type">V</span>])]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>根据数据源的数据，按照Key对Value进行分组。形成一个对偶元组，元组中的第一个元素为key，第二个元素为相同key的value集合</p><blockquote><p><strong>reduceByKey</strong>与<strong>groupByKey</strong>的区别：</p><p>从Shuffle的角度来看：reduceByKey和groupByKey都存在Shuffle的操作，但是reduceByKey可以在Shuffle之前对分区内相同Key的数据进行<strong>预聚合</strong>（combine）功能，这样可以减少落盘的数据量，性能较高。而groupByKey只是进行分组，不存在数据量减少的问题。</p><p>从功能的角度来看，reduceByKey其实包含了分组和聚合的功能，而groupByKey只能进行分组，不能聚合。</p><p>上面的落盘，指的是在执行过程中，程序在执行完毕之前无法判断自己的分组是否已经没有下一个元素，于是需要等待到执行完毕才能进行下一步的聚合和分区。如果数据量过大，则在内存中等待的数据可能导致内存溢出，因此数据会落盘等待。</p></blockquote><h3 id="aggregatebykey">aggregateByKey</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aggregateByKey</span></span>[<span class="hljs-type">U</span>: <span class="hljs-type">ClassTag</span>](zeroValue: <span class="hljs-type">U</span>)(seqOp: (<span class="hljs-type">U</span>, <span class="hljs-type">V</span>) =&gt; <span class="hljs-type">U</span>,<br>                                              combOp: (<span class="hljs-type">U</span>, <span class="hljs-type">U</span>) =&gt; <span class="hljs-type">U</span>): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">U</span>)]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>将数据根据不同的规则进行分区内计算和分区间计算。在进行分区间计算的时候还提供有初始值。</p><p>第一个参数列表中的参数为初始值，类型（泛型）为<code>U</code>；第二个参数列表中有两个参数，参数1表示分区内的计算规则，参数2表示分区间的计算规则。分区内的计算规则要求最后得到的类型为<code>U</code>，而分区间的计算规则最终也要得到<code>U</code>。aggregateByKey最终的返回数据结果应该和初始值的类型保持一致。（注意这里计算规则的类型指定）</p><h3 id="foldbykey">foldByKey</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldByKey</span></span>(zeroValue: <span class="hljs-type">V</span>)(func: (<span class="hljs-type">V</span>, <span class="hljs-type">V</span>) =&gt; <span class="hljs-type">V</span>): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">V</span>)]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>功能类似于上面的aggregateByKey，当分区内计算规则和分区内计算规则相同的时候，aggregateByKey就可以简化为foldByKey。需要注意的是这里传入的初始值的数据类型和RDD中的数据类型一致</p><h3 id="combinebykey">combineByKey</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combineByKey</span></span>[<span class="hljs-type">C</span>](<br>    createCombiner: <span class="hljs-type">V</span> =&gt; <span class="hljs-type">C</span>,<br>    mergeValue: (<span class="hljs-type">C</span>, <span class="hljs-type">V</span>) =&gt; <span class="hljs-type">C</span>,<br>    mergeCombiners: (<span class="hljs-type">C</span>, <span class="hljs-type">C</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">C</span>)]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>最通用的对于Key-Value类型RDD进行聚集操作的函数，类似于aggregateByKey，但是combineByKey允许用户返回值的类型与输入不一致，并且不设置初始值。有三个重要参数：</p><ul><li><code>createCombiner</code>：将相同Key的第一个参数</li><li><code>mergeValue</code>：分区内的计算规则</li><li><code>mergeCombiners</code>：分区间的计算规则</li></ul><blockquote><p>不同聚集方法的区别和联系：</p><ul><li>reduceByKey：相同的Key，第一个数据不进行任何计算，分区内和分区间的计算规则相同</li><li>foldByKey：相同的Key，第一个数据和初始值进行分区内计算，分区内和分区间的计算规则相同</li><li>aggregateByKey：相同的Key，第一个数据和初始值进行分区内计算，分区内和分区间的计算规则可以不同</li><li>combineByKey：相同的Key，如果第一个数据结构不满足要求，可以转换结构，分区内和分区间的计算规则可以不同</li></ul><p>实际上，它们的底层都是combineByKeyWithClassTag，只是完成了不同程度的封装：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// reduceByKey:</span><br>combineByKeyWithClassTag[<span class="hljs-type">V</span>](<br>    (v: <span class="hljs-type">V</span>) =&gt; v, <span class="hljs-comment">// 第一个值不会参与计算</span><br>    func, <span class="hljs-comment">// 分区内计算规则</span><br>    func, <span class="hljs-comment">// 分区间计算规则</span><br>)<br><br><span class="hljs-comment">//aggregateByKey :</span><br>combineByKeyWithClassTag[<span class="hljs-type">U</span>](<br>    (v: <span class="hljs-type">V</span>) =&gt; cleanedSeqOp(createZero(), v), <span class="hljs-comment">// 初始值和第一个key的value值进行的分区内数据操作</span><br>    cleanedSeqOp, <span class="hljs-comment">// 分区内计算规则</span><br>    combOp,       <span class="hljs-comment">// 分区间计算规则</span><br>)<br><br><span class="hljs-comment">//foldByKey:</span><br>combineByKeyWithClassTag[<span class="hljs-type">V</span>](<br>    (v: <span class="hljs-type">V</span>) =&gt; cleanedFunc(createZero(), v), <span class="hljs-comment">// 初始值和第一个key的value值进行的分区内数据操作</span><br>    cleanedFunc,  <span class="hljs-comment">// 分区内计算规则</span><br>    cleanedFunc,  <span class="hljs-comment">// 分区间计算规则</span><br>)<br><br><span class="hljs-comment">//combineByKey :</span><br>combineByKeyWithClassTag(<br>    createCombiner,  <span class="hljs-comment">// 相同key的第一条数据进行的处理函数</span><br>    mergeValue,      <span class="hljs-comment">// 表示分区内数据的处理函数</span><br>    mergeCombiners,  <span class="hljs-comment">// 表示分区间数据的处理函数</span><br>)<br></code></pre></td></tr></table></figure></blockquote><h3 id="sortbykey">sortByKey</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sortByKey</span></span>(ascending: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>, numPartitions: <span class="hljs-type">Int</span> = self.partitions.length)<br>: <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">V</span>)] <br></code></pre></td></tr></table></figure><p>函数说明：</p><p>在Key-Value类型的RDD上调用，Key必须实现<code>Ordered</code>特征。调用函数返回按照Key排序的RDD</p><h3 id="join">join</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">join</span></span>[<span class="hljs-type">W</span>](other: <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">W</span>)]): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, (<span class="hljs-type">V</span>, <span class="hljs-type">W</span>))]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>类似数据表之间的join操作，在类型为<code>(K, V)</code>和<code>(K, W)</code>的RDD上调用，返回一个相同Key对应所有元素连接在一起的<code>(K, (V, W))</code>的RDD。</p><ul><li>如果Key存在不相同没法匹配，则在最后的结果中也不会出现。</li><li>如果两个数据源中Key有多个相同的，会依次匹配，可能会出现笛卡尔积的现象</li></ul><h3 id="leftouterjoin">leftOuterJoin</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leftOuterJoin</span></span>[<span class="hljs-type">W</span>](other: <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">W</span>)]): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, (<span class="hljs-type">V</span>, <span class="hljs-type">Option</span>[<span class="hljs-type">W</span>]))]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>类似SQL语句的左外连接，当然同时还有右外连接<code>rightOuterJoin</code></p><h3 id="cogroup">cogroup</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cogroup</span></span>[<span class="hljs-type">W</span>](other: <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, <span class="hljs-type">W</span>)]): <span class="hljs-type">RDD</span>[(<span class="hljs-type">K</span>, (<span class="hljs-type">Iterable</span>[<span class="hljs-type">V</span>], <span class="hljs-type">Iterable</span>[<span class="hljs-type">W</span>]))]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>先组内分组，然后进行连接</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> rdd1 = sc.makeRDD(<span class="hljs-type">List</span>((<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>),(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">8</span>), (<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>)))<br><span class="hljs-keyword">val</span> rdd2 = sc.makeRDD(<span class="hljs-type">List</span>((<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">5</span>), (<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">6</span>), (<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">7</span>)))<br><span class="hljs-keyword">val</span> res = rdd1.cogroup(rdd2)<br><br>res.collect().foreach(println)<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(a,(CompactBuffer(1),CompactBuffer(4)))<br>(b,(CompactBuffer(2, 8),CompactBuffer(5)))<br>(c,(CompactBuffer(3),CompactBuffer(6, 7)))<br></code></pre></td></tr></table></figure><h1 id="rdd行动算子">RDD行动算子</h1><h2 id="行动算子">行动算子</h2><p>所谓的行动算子其实就是触发作业Job执行的方法。行动算子的底层代码会调用环境对象的runJob方法，创建ActiveJob并提交执行。</p><h3 id="reduce">reduce</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(f: (<span class="hljs-type">T</span>, <span class="hljs-type">T</span>) =&gt; <span class="hljs-type">T</span>)<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>聚集RDD中所有的数据，先聚合分区内的数据，再聚合分区间的数据。注意这里的类型，参与运算的类型以及生成结果的类型都需要保持一致。</p><h3 id="collect">collect</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">collect</span></span>(): <span class="hljs-type">Array</span>[<span class="hljs-type">T</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>在驱动程序当中以数组Array的形式返回数据集的所有元素</p><h3 id="count">count</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span></span>(): <span class="hljs-type">Long</span><br></code></pre></td></tr></table></figure><p>函数说明：</p><p>返回RDD中元素的个数</p><h3 id="first">first</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">first</span></span>(): <span class="hljs-type">T</span><br></code></pre></td></tr></table></figure><p>函数说明：</p><p>返回RDD中的第一个元素</p><h3 id="take">take</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">take</span></span>(num: <span class="hljs-type">Int</span>): <span class="hljs-type">Array</span>[<span class="hljs-type">T</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>返回一个由RDD的前n个元素组成的数组</p><h3 id="takeordered">takeOrdered</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeOrdered</span></span>(num: <span class="hljs-type">Int</span>)(<span class="hljs-keyword">implicit</span> ord: <span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">Array</span>[<span class="hljs-type">T</span>]<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>返回该RDD排序后的前n个元素组成的数组。默认为升序，如果需要降序，可以传入第二个参数，其中的Int表示比较时采用的泛型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">rdd.takeOrdered(<span class="hljs-number">8</span>)(<span class="hljs-type">Ordering</span>.<span class="hljs-type">Int</span>.reverse)<br></code></pre></td></tr></table></figure><h3 id="aggregate">aggregate</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aggregate</span></span>[<span class="hljs-type">U</span>: <span class="hljs-type">ClassTag</span>](zeroValue: <span class="hljs-type">U</span>)(seqOp: (<span class="hljs-type">U</span>, <span class="hljs-type">T</span>) =&gt; <span class="hljs-type">U</span>, combOp: (<span class="hljs-type">U</span>, <span class="hljs-type">U</span>) =&gt; <span class="hljs-type">U</span>): <span class="hljs-type">U</span><br></code></pre></td></tr></table></figure><p>函数说明：</p><p>分区的数据通过初始值与分区内的数据进行聚合，然后再和初始值进行分区间的数据聚合。可以指定分区内的聚合逻辑和分区间的聚合逻辑。</p><blockquote><p>需要注意的是，这里的初始值会参与分区内计算，也会参与分区间计算，而在转换算子中类似的aggregateByKey，初始值只会参与分区内的计算。</p></blockquote><h3 id="fold">fold</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fold</span></span>(zeroValue: <span class="hljs-type">T</span>)(op: (<span class="hljs-type">T</span>, <span class="hljs-type">T</span>) =&gt; <span class="hljs-type">T</span>): <span class="hljs-type">T</span><br></code></pre></td></tr></table></figure><p>函数说明：</p><p>上面aggregateByKey的简化操作，其中分区内和分区间的计算逻辑相同。</p><h3 id="countbykey">countByKey</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">countByKey</span></span>(): <span class="hljs-type">Map</span>[<span class="hljs-type">K</span>, <span class="hljs-type">Long</span>] <br></code></pre></td></tr></table></figure><p>函数说明：</p><p>统计每种Key的个数</p><h3 id="save相关算子">save相关算子</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">saveAsTextFile</span></span>(path: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">saveAsObjectFile</span></span>(path: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">saveAsSequenceFile</span></span>(<br>    path: <span class="hljs-type">String</span>,<br>    codec: <span class="hljs-type">Option</span>[<span class="hljs-type">Class</span>[_&lt;:<span class="hljs-type">CompressionCodec</span>]] = <span class="hljs-type">None</span>): <span class="hljs-type">Unit</span><br></code></pre></td></tr></table></figure><p>函数说明：</p><p>将数据保存至不同格式的文件中，上面的函数分别表示</p><ul><li>保存成文本文件</li><li>序列化成对象保存在文件中</li><li>保存成Sequencefile文件。这种方式要求数据的格式必须为Key-Value类型</li></ul><h3 id="foreach">foreach</h3><p>函数声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foreach</span></span>(f: <span class="hljs-type">T</span> =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Unit</span> = withScope &#123;<br>    <span class="hljs-keyword">val</span> cleanF = sc.clean(f)<br>    sc.runJob(<span class="hljs-keyword">this</span>, (iter: <span class="hljs-type">Iterator</span>[<span class="hljs-type">T</span>]) =&gt; iter.foreach(cleanF))<br>&#125;<br></code></pre></td></tr></table></figure><p>函数说明：</p><p>分布式遍历RDD中的每个元素，调用指定的函数。注意这里和集合的foreach操作不同。集合的foreach操作其实是在节点中的内存集合的循环遍历，而foreach算子是在Executor端内存数据的循环遍历，是分布式的。分区内的执行有序，而分区间的执行无序。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark学习笔记-入门(2)-Spark运行架构</title>
    <link href="/2022/05/08/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-Spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/05/08/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-Spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="运行架构">运行架构</h2><p>Spark框架的核心是一个计算引擎，采用了标准的主从结构。整体架构中包括Driver以及Executor。其中Driver是Master，负责整个集群中的作业任务调度，而Executor则是Slave（Worker），负责实际的任务执行。</p><p>Spark框架有如下两个核心组件：</p><p><strong>Driver</strong>：Spark驱动节点，用于执行Spark任务中的main方法。所谓的Driver就是驱使整个应用运行起来的程序，也称之为Driver类</p><ul><li>将用户任务转化为作业（Job）</li><li>在Executor之间进行任务调度</li><li>跟踪Executor的执行情况</li><li>通过UI展示查询运行情况</li></ul><p><strong>Executor</strong>： SparkExecutor是集群中工作节点的一个JVM进程，负责在Spark作业中运行具体任务，任务之间彼此独立。如果有Executor节点发生了故障或崩溃，Spark应用也可以继续执行，会将出错节点上的任务调度到其他Executor节点上继续运行</p><ul><li>负责运行Spark应用的任务，并将结果返回给驱动器进程</li><li>通过自身的块管理器为用户程序中要求缓存的RDD提供内存存储。RDD直接缓存在Executor进程当中，因此任务可以在运行时充分利用缓存数据加速运算</li></ul><p>除了上面提到的两个核心组件，Spark中还有以下的组件：</p><p><strong>Master &amp; Worker</strong>：如果Spark集群采用独立部署环境，则不需要其他的资源调度框架，自身已经实现了资源调度的功能。其中：</p><ul><li>Master进程：主要负责资源的调度和分配，并进行集群的监控（类似于Yarn中的ResourceManager）</li><li>Worker进程：一个Worker运行在集群中的一台服务器上，管理集群中的一个节点，由Master分配资源对数据进行并行的处理和计算（类似于Yarn中的NodeManager）</li></ul><p><strong>ApplicationMaster</strong>：如果Spark集群采用Yarn作为资源调度，则在向Yarn集群中提交应用程序的时候，提交程序中应该包含ApplicationMaster，管理当前的应用任务。</p><p>Spark Executor是集群中运行在工作节点（Worker）中的一个JVM进程，是整个集群中专门用于计算的节点。在提交应用中，可以提供参数指定计算节点的个数，以及对应的资源。这里的资源一般指的是工作节点Executor 的内存大小和使用的虚拟CPU核（Core）数量</p><p>应用程序相关的启动参数如下：</p><table><thead><tr class="header"><th>名称</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>--num-executors</code></td><td>配置Executor的数量</td></tr><tr class="even"><td><code>--executor-memory</code></td><td>配置每个Executor的内存大小</td></tr><tr class="odd"><td><code>--executor-cores</code></td><td>配置每个Executor的虚拟CPU核数量</td></tr></tbody></table><h2 id="提交流程">提交流程</h2><p>Spark应用程序在提交到Yarn环境中执行的时候，一般会有两种部署执行的方式：Client与Cluster。这两种模式的主要区别在于Driver程序的运行节点位置</p><p><strong>Yarn Client模式</strong>：</p><p>Client模式将用于监控和调度的Driver模块运行在客户端，而不是集群中，一般用于测试：</p><ul><li>Driver在任务提交的本地机器上运行</li><li>Driver启动后会和Resource Manager通讯申请启动Application Master</li><li>Resource Manager分配Container，在合适的Node Manager上启动ApplicationManager，负责向Resource Manager申请Executor内存</li><li>Resource Manager接受申请，分配Container，然后ApplicationMaster在指定的Node Manager上启动Executor进程</li><li>Executor进程启动后会向Driver反向注册，在Executor全部注册完成之后Driver开始执行main函数</li><li>直到执行到行动算子，才触发一个Job，并根据宽依赖开始划分stage，每个stage生成对应的TaskSet，之后将Task分发到各个Executor上执行</li></ul><p><strong>Yarn Cluster模式</strong>：</p><p>Cluster模式将用于监控和调度的Driver模块运行在Yarn集群中，一般应用于实际生产环境（运行步骤大体上相同，有细节上的差异）</p><ul><li>任务提交后与Resource Manager通讯申请启动Application Master</li><li>Resource Manager分配Container，在合适的Node Manager上启动ApplicationMaster，此时的Application Master就是Driver</li><li>Driver启动后向Resource Manager申请Executor内存</li><li>Resource Manager接受申请，分配Container，然后ApplicationMaster在指定的Node Manager上启动Executor进程</li><li>Executor进程启动后会向Driver反向注册，在Executor全部注册完成之后Driver开始执行main函数</li><li>直到执行到行动算子，才触发一个Job，并根据宽依赖开始划分stage，每个stage生成对应的TaskSet，之后将Task分发到各个Executor上执行</li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark学习笔记-入门(1)-Spark概述以及环境搭建</title>
    <link href="/2022/05/06/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-Spark%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/05/06/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-Spark%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="spark概述">Spark概述</h2><p>Spark是一种基于内存的、快速、可扩展的大数据分析<strong>计算</strong>引擎。</p><p>Hadoop的MapReduce框架和Spark框架都是数据处理引擎，它们之间当然存在一些不同之处。Hadoop的MapReduce框架设计初衷并不是为了满足循环迭代式的数据流处理，因此在许多并行运行的数据可复用场景（例如机器学习、图挖掘算法、交互式数据挖掘算法等）中存在计算效率问题。Spark在传统的MapReduce计算框架的基础上，利用其计算过程的优化大大加快了数据分析、挖掘的运行和读写速度，并将数据单元缩小到更适合并行计算和重复使用的RDD计算模型上。</p><ul><li>Spark和Hadoop的根本差异式多个作业之间的数据通信问题，Spark多个作业之间的数据通信式基于内存的，而Hadoop是基于磁盘的。</li><li>SparkTask的启动时间快，它采用的是fork线程的方式，而Hadoop采用的是创建新进程的方式。</li><li>Spark只有在shuffle的时候将数据写入磁盘，而Hadoop中多个作业之间的数据交互需要依赖于磁盘交互</li></ul><blockquote><p>在绝大多数的数据计算场景中，Spark确实会比MapReduce更有优势，但是Spark是基于内存的，所以在实际的生产环境中，内存资源是一大限制条件。可能会由于内存资源不够而导致Job执行失败</p></blockquote><p>Spark由以下核心模块构成：</p><img src="/2022/05/06/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-Spark%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Spark%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97.png" class="" title="Spark核心模块"><ul><li><strong>Spark Core</strong>： SparkCore中提供了Spark中最基础与最核心的功能，Spark其他的功能如SparkSQL、Spark Streaming、Spark MLlib和Spark GraphX都是在SparkCore的基础上进行扩展的</li><li><strong>Spark SQL</strong>： SparkSQL是Spark用来操作结构化数据的组件，通过SparkSQL，用户可以使用SQL或者Apache Hive版本的HQL来查询数据</li><li><strong>Spark Streaming</strong>： SparkStreaming是Spark平台上针对实时数据进行流式计算的组件，提供了丰富的处理数据流的API</li><li><strong>Spark MLlib</strong>：MLlib是Spark提供的一个机器学习算法库。其中不仅提供了模型评估、数据导入等额外的功能，还提供了一些更底层的机器学习原语</li><li><strong>Spark GraphX</strong>：GraphX是Spark面向图计算提供的框架与算法库</li></ul><h2 id="word-count项目搭建">Word Count项目搭建</h2><p>上面是简要介绍了一些Spark的相关知识，下面可以通过一个入门案例WordCount来开启Spark的学习之路。</p><h3 id="项目环境搭建">项目环境搭建</h3><p>首先我们需要搭建项目的环境。使用IDEA创建对应的Maven环境。由于Spark的底层编写使用的是Scala，后续我们也会使用Scala来进行相关的开发，所以创建项目的时候需要实现Scala的相关配置，详情可以参考另一篇有关Scala的学习笔记<a href="/2022/04/29/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-Scala%E7%AE%80%E4%BB%8B/" title="Scala学习笔记-入门(1)-Scala简介">Scala学习笔记-入门(1)-Scala简介</a></p><p>配置完Scala相关环境之后，还需要引入对应的Maven依赖。这里使用的版本是Spark-3.1.3，依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.spark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spark-core_2.12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里在选择版本的时候需要注意Scala和Spark之间的版本匹配，我们可以参考Maven中的相关说明：<ahref="https://mvnrepository.com/artifact/org.apache.spark/spark-core">MavenRepository: org.apache.spark » spark-core (mvnrepository.com)</a></p><p>这里使用的版本是Spark-3.1.3，对应使用的Scala版本为2.12.15</p><h3 id="word-count实现">Word Count实现</h3><p>WordCount是大数据学科中最常见的案例，我们在项目目录下的<code>data</code>目录中准备了一些文件，其中是以空格分隔的单词。</p><p>下面是Word Count的一种实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 创建Spark运行配置对象</span><br><span class="hljs-keyword">val</span> sparkConf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;WordCount&quot;</span>)<br><br><span class="hljs-comment">// 创建Spark上下文环境对象</span><br><span class="hljs-keyword">val</span> context = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkContext</span>(sparkConf)<br><br><span class="hljs-comment">// 业务操作</span><br><span class="hljs-comment">// 1.读取文件，获取的是一行一行的信息，得到多行lines，每行line是字符串</span><br><span class="hljs-keyword">val</span> lines = context.textFile(<span class="hljs-string">&quot;data&quot;</span>)<br><br><span class="hljs-comment">// 2.将每个字符串进行拆分并扁平化，得到words</span><br><span class="hljs-keyword">val</span> words = lines.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<br><br><span class="hljs-comment">// 3.将words按照内容进行分组，便于统计</span><br><span class="hljs-keyword">val</span> wordsGroup = words.groupBy(word =&gt; word)<br><br><span class="hljs-comment">// 4.统计每个分组内的个数</span><br><span class="hljs-keyword">val</span> resList1 = wordsGroup.map(kv =&gt; &#123;<br>    <span class="hljs-keyword">val</span> word = kv._1<br>    <span class="hljs-keyword">val</span> list = kv._2<br>    (word, list.size)<br>&#125;)<br><span class="hljs-comment">// 还可以使用模式匹配</span><br><span class="hljs-keyword">val</span> resList2 = wordsGroup.map(&#123;<br>    <span class="hljs-keyword">case</span> (str, strings) =&gt; (str, strings.size)<br>&#125;)<br><br><span class="hljs-comment">// 5.打印内容</span><br>resList2.foreach(println)<br><br><span class="hljs-comment">// 关闭Spark连接</span><br>context.stop()<br></code></pre></td></tr></table></figure><p>这里使用的Spark环境是临时创建的，使用后会被删除。在使用Spark的时候，首先需要获取对应的配置对象，创建Spark上下文对象，之后利用相关API执行业务逻辑，最后关闭Spark连接。</p><blockquote><p>这里在运行的时候可能会出现下面的报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Scala signature package has wrong version expected: 5.0 found: 5.2 in packag<br></code></pre></td></tr></table></figure><p>如果出现这种情况，可能是由于Scala的版本问题。引入的Spark-Core依赖可能同时支持Scala2.12和2.13，如果本地Scala的版本是2.12，那么选择一个只支持2.12的版本例如Spark-Core3.1.3可以解决该问题</p></blockquote><p>WordCount还可以利用下面的逻辑实现，这种逻辑更加类似于MapRuduce的二阶段实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 创建Spark运行配置对象</span><br><span class="hljs-keyword">val</span> sparkConf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;WordCount&quot;</span>)<br><br><span class="hljs-comment">// 创建Spark上下文环境对象</span><br><span class="hljs-keyword">val</span> context = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkContext</span>(sparkConf)<br><br><span class="hljs-comment">// 业务操作</span><br><span class="hljs-comment">// 1.读取文件，获取的是一行一行的信息，得到多行lines，每行line是字符串</span><br><span class="hljs-keyword">val</span> lines = context.textFile(<span class="hljs-string">&quot;data&quot;</span>)<br><br><span class="hljs-comment">// 2.将每个字符串进行拆分并扁平化，得到words</span><br><span class="hljs-keyword">val</span> words = lines.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<br><br><span class="hljs-comment">// 3.将words转换数据结构 word =&gt; (word, 1)</span><br><span class="hljs-keyword">val</span> wordsAndOne = words.map((_, <span class="hljs-number">1</span>))<br><br><span class="hljs-comment">// 4.将转换后的数据按照相同的单词进行分组聚合</span><br><span class="hljs-keyword">val</span> wordsGroup = wordsAndOne.groupBy(_._1)<br><span class="hljs-keyword">val</span> wordsAndCount = wordsGroup.map(kv=&gt;&#123;<br>    <span class="hljs-keyword">val</span> list = kv._2<br>    list.reduce((v1, v2)=&gt;&#123;<br>        (v1._1, v1._2 + v2._2)<br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 5.将数据聚合结果采集到内存当中</span><br><span class="hljs-keyword">val</span> resList = wordsAndCount.collect()<br><br><span class="hljs-comment">// 6.打印内容</span><br>resList.foreach(println)<br><br><span class="hljs-comment">// 关闭Spark连接</span><br>context.stop()<br></code></pre></td></tr></table></figure><p>可以看到，在上面的业务逻辑中，我们使用的是在原生Scala中也存在的一些集合高级操作。而Spark提供给我们一些更加方便好用的API，例如上面的步骤4，将集合按照相同单词进行聚合的操作可以调用如下的API：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> wordsAndCount = wordsAndOne.reduceByKey(_ + _)<br></code></pre></td></tr></table></figure><p>该操作可以按照key对后续的value进行操作，类似于MapReduce框架中Reducer进行的操作</p><h3 id="日志输出">日志输出</h3><p>在执行过程中，会产生大量的执行日志。为了更好地查看程序的执行结果，可以在项目的resources目录中创建<code>log4j.properties</code>文件，并添加日志配置信息：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">log4j.rootCategory</span>=<span class="hljs-string">ERROR, console</span><br><span class="hljs-attr">log4j.appender.console</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-attr">log4j.appender.console.target</span>=<span class="hljs-string">System.err</span><br><span class="hljs-attr">log4j.appender.console.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-attr">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;yy/MM/dd HH:mm:ss&#125; %p %c&#123;1&#125;: %m%n</span><br><span class="hljs-comment"># Set the default spark-shell log level to ERROR. When running the spark-shell,</span><br><span class="hljs-attr">the</span><br><span class="hljs-comment"># log level for this class is used to overwrite the root logger&#x27;s log level, so</span><br><span class="hljs-attr">that</span><br><span class="hljs-comment"># the user can have different defaults for the shell and regular Spark apps.</span><br><span class="hljs-attr">log4j.logger.org.apache.spark.repl.Main</span>=<span class="hljs-string">ERROR</span><br><span class="hljs-comment"># Settings to quiet third party logs that are too verbose</span><br><span class="hljs-attr">log4j.logger.org.spark_project.jetty</span>=<span class="hljs-string">ERROR</span><br><span class="hljs-attr">log4j.logger.org.spark_project.jetty.util.component.AbstractLifeCycle</span>=<span class="hljs-string">ERROR</span><br><span class="hljs-attr">log4j.logger.org.apache.spark.repl.SparkIMain$exprTyper</span>=<span class="hljs-string">ERROR</span><br><span class="hljs-attr">log4j.logger.org.apache.spark.repl.SparkILoop$SparkILoopInterpreter</span>=<span class="hljs-string">ERROR</span><br><span class="hljs-attr">log4j.logger.org.apache.parquet</span>=<span class="hljs-string">ERROR</span><br><span class="hljs-attr">log4j.logger.parquet</span>=<span class="hljs-string">ERROR</span><br><span class="hljs-comment"># SPARK-9183: Settings to avoid annoying messages when looking up nonexistent</span><br><span class="hljs-attr">UDFs</span> <span class="hljs-string">in SparkSQL with Hive support</span><br><span class="hljs-attr">log4j.logger.org.apache.hadoop.hive.metastore.RetryingHMSHandler</span>=<span class="hljs-string">FATAL</span><br><span class="hljs-attr">log4j.logger.org.apache.hadoop.hive.ql.exec.FunctionRegistry</span>=<span class="hljs-string">ERROR</span><br></code></pre></td></tr></table></figure><h2 id="环境">环境</h2><p>Spark作为一个数据处理框架和计算引擎，被设计成能够在常见的集群环境中运行。在工作中主流的环境为Yarn，不过容器式环境也逐渐流行。</p><h3 id="local模式">Local模式</h3><h4 id="配置">配置</h4><p>该Local模式不同于之前在IDEA中使用的模式。在IDEA中，我们的环境在使用完成之后会被删除，被称为开发环境。而这个Local模式的资源始终存在。这里，Local模式指的是不需要其他任何节点资源就可以在本地执行Spark代码的环境。</p><p>首先从官网下载对应的Spark文件，这里对应版本下载得到文件：<code>spark-3.1.3-bin-hadoop3.2.tgz</code>，然后将文件上传到集群当中，解压到对应路径中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf spark-3.1.3-bin-hadoop3.2.tgz -C /opt/module<br></code></pre></td></tr></table></figure><p>为了方便，可以将对应文件夹的名称改为<code>spark-3.1.3</code></p><h4 id="命令行工具">命令行工具</h4><p>之后，进入对应下载的Spark路径下，执行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/spark-shell<br></code></pre></td></tr></table></figure><p>可以进入<strong>命令行工具</strong>中。在启用命令行的时候，可以输入网址进行WebUI监控页面的访问，使用端口为4040。（hadoop102:4040）</p><p>可以在data目录下准备对应的<code>word.txt</code>文件，之后用一个简单的wordcount代码来进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">scala&gt; </span><span class="language-bash">sc.textFile(<span class="hljs-string">&quot;data/word.txt&quot;</span>).flatMap(_.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot; &quot;</span>)).map((_, <span class="hljs-number">1</span>)).reduceByKey(_+_).collect()</span><br>res0: Array[(String, Int)] = Array((Hello, 2), (Scala, 1), (Spark, 1))<br></code></pre></td></tr></table></figure><h4 id="提交应用">提交应用</h4><p>也可以采用jar包的形式提交应用运行，下面的命令提交了存在于examples文件夹中的一个示例程序，完成的功能是圆周率Π的计算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/spark-submit \<br>--class org.apache.spark.examples.SparkPi \<br>--master local[2] \<br>./examples/jars/spark-examples_2.12-3.1.3.jar\<br>10<br></code></pre></td></tr></table></figure><ul><li><p><code>--class</code>：表示要执行程序主类</p></li><li><p><code>--master</code>：表示部署模式，默认为本地模式，其中的数字表示分配的虚拟CPU核数量</p></li><li><p><code>./examples/jars/spark-examples_2.12-3.13.jar</code>：运行的应用类所在的jar包位置</p></li><li><p><code>10</code>：程序的入口参数，用于设定当前应用的任务数量</p></li></ul><h3 id="standalone模式">Standalone模式</h3><h4 id="配置-1">配置</h4><p>Standalone指的是独立部署模式，即只使用Spark自身节点运行的集群模式。Spark的Standalone模式是经典的主从模式，规划如下：</p><table><thead><tr class="header"><th></th><th>hadoop102</th><th>hadoop103</th><th>hadoop104</th></tr></thead><tbody><tr class="odd"><td>角色（进程）</td><td>Worker、Master</td><td>Worker</td><td>Worker</td></tr></tbody></table><p>使用独立部署模式需要修改对应的配置文件。</p><blockquote><p>Spark的配置文件都存在于<code>$SPARK_HOME</code>下的conf文件夹中，并且在初始情况下，所有的配置文件的最后后缀都是<code>.template</code>，如果需要对应的配置文件生效，需要删除该后缀</p></blockquote><p>修改<code>workers</code>文件，将其中的localhost修改为Worker节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop102<br>hadoop103<br>hadoop104<br></code></pre></td></tr></table></figure><p>修改<code>spark-env.sh</code>文件，添加JAVA_HOME环境变量以及集群对应的Master节点，默认采用7077端口进行通信</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export JAVA_HOME=/opt/module/jdk1.8.0_212<br><br>SPARK_MASTER_HOST=hadoop102<br>SPARK_MASTER_PORT=7077<br></code></pre></td></tr></table></figure><p>将完成的配置文件目录<code>conf</code>进行分发</p><p>之后可以启动集群查看效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sbin/start-all.sh<br></code></pre></td></tr></table></figure><p>可以查看Master资源监控Web UI界面（hadoop102:8080）</p><h4 id="提交应用-1">提交应用</h4><p>与上面的命令类似，唯一需要改动的地方就是部署模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/spark-submit \<br>--class org.apache.spark.examples.SparkPi \<br>--master spark://hadoop102:7077 \<br>./examples/jars/spark-examples_2.12-3.1.3.jar \<br>10<br></code></pre></td></tr></table></figure><h4 id="配置历史服务">配置历史服务</h4><p>前面会看到，如果spark-shell停掉之后，集群监控的4040页面就看不到历史任务的运行情况，所以在开发的时候都需要配置历史服务器来记录任务运行情况。</p><p>修改<code>spark-defaults.conf</code>文件，配置日志存储路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">spark.eventLog.enabledtrue<br>spark.eventLog.dirhdfs://hadoop102:8020/spark-history<br></code></pre></td></tr></table></figure><p>这里配置的是HDFS文件系统中的位置，需要保证该处的<code>spark-history</code>目录存在，因此需要启动HDFS集群后进行创建</p><p>之后修改<code>spark-env.sh</code>文件，添加日志配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export SPARK_HISTORY_OPTS=&quot;<br>-Dspark.history.ui.port=18080 <br>-Dspark.history.fs.logDirectory=hdfs://hadoop102:8020/spark-history <br>-Dspark.history.retainedApplications=30&quot;<br></code></pre></td></tr></table></figure><ul><li>参数1：指定Web UI的访问端口为18080</li><li>参数2：指定历史服务器的日志存储路径</li><li>参数3：指定保存Application历史记录的个数。如果超过这个值，旧的应用程序信息将被删除。（内存中的应用数，而不是页面上显示的应用数）</li></ul><p>修改完成之后分发配置文件目录<code>conf</code></p><p>重启集群和历史服务查看效果（HDFS集群也要启动）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">HADOOP_HOME</span><br>sbin/start-dfs.sh<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">SPARK_HOME</span><br>sbin/start-all.sh<br>sbin/start-history-server.sh<br></code></pre></td></tr></table></figure><h4 id="配置高可用">配置高可用</h4><p>在没有高可用的情况下，Master节点仅有一个，存在单点故障问题。为了解决单点故障问题，需要在集群中配置多个Master节点，一旦处于活动状态的Master发生故障，由备用的Master提供服务，保证作业继续执行。高可用一般采用Zookeeper设置</p><table style="width:100%;"><thead><tr class="header"><th></th><th>hadoop102</th><th>hadoop103</th><th>hadoop104</th></tr></thead><tbody><tr class="odd"><td>角色</td><td>Master、Zookeeper、Worker</td><td>Master、Zookeeper、Worker</td><td>Zookeeper、Worker</td></tr></tbody></table><p>修改<code>spark-env.sh</code></p><p>注释如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">SPARK_MASTER_HOST=hadoop102</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">SPARK_MASTER_PORT=7077</span><br></code></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">SPARK_MASTER_WEBUI_PORT=8989<br><br>export SPARK_DAEMON_JAVA_OPTS=&quot;<br>-Dspark.deploy.recoveryMode=ZOOKEEPER <br>-Dspark.deploy.zookeeper.url=hadoop102,hadoop103,hadoop104<br>-Dspark.deploy.zookeeper.dir=/spark&quot;<br></code></pre></td></tr></table></figure><p>分发配置文件目录<code>conf</code></p><p>之后启动集群，同时还要启动Zookeeper。此时仍然只有一个Master。需要在另一台非Master的机器例如hadoop103上单独启动Master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">SPARK_HOME</span><br>sbin/start-master.sh<br></code></pre></td></tr></table></figure><p>在高可用情况下的应用提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/spark-submit \<br>--class org.apache.spark.examples.SparkPi \<br>--master spark://hadoop102:7077, hadoop103:7077 \<br>./examples/jars/spark-examples_2.12-3.13.jar \<br>10<br></code></pre></td></tr></table></figure><h3 id="yarn模式">Yarn模式</h3><h4 id="配置-2">配置</h4><p>独立部署（Standalone）模式由 Spark自身提供计算资源，无需其他框架提供资源。这种方式降低了和其他第三方资源框架的耦合性，独立性非常强。但是Spark主要是计算框架，而不是资源调度框架，Spark本身提供的资源调度并不是它的强项，因此可以选择继承其他专业的资源调度框架，例如Yarn</p><p>在学习Hadoop的过程中，我们已经完成了Yarn集群的配置，这里就不再赘述，参考之前的配置流程即可。</p><p>修改<code>spark-env.sh</code>，添加Yarn配置文件的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">YARN_CONF_DIR=/opt/module/hadoop-3.1.3/etc/hadoop<br></code></pre></td></tr></table></figure><h4 id="提交应用-2">提交应用</h4><p>提交应用同样需要修改部署模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/spark-submit \<br>--class org.apache.spark.examples.SparkPi \<br>--master yarn \<br>--deploy-mode cluster \<br>./examples/jars/spark-examples_2.12-3.1.3.jar \<br>10<br></code></pre></td></tr></table></figure><p>（这里的deploy-mode还可以选择client，可能需要配置历史服务，配置方式同前面一致）</p><p>提交完成之后可以在对应的Web页面查看日志（hadoop103:8088）</p><h3 id="容器模式">容器模式</h3><p>（待补充...）</p><h3 id="windows模式">Windows模式</h3><p>Spark提供了在Windows系统下启动本地集群的方式，可以直接在Windows中使用。</p><p>将文件解压到对应的位置，里面的目录同虚拟机中完全一致。<code>sbin/start-shell.cmd</code>可以启动Spark本地环境</p><p>提交应用也是类似的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">spark-submit --class org.apache.spark.examples.SparkPi --master <br>local[2] ../examples/jars/spark-examples_2.12-3.0.0.jar 10<br></code></pre></td></tr></table></figure><h3 id="部署模式对比">部署模式对比</h3><table><thead><tr class="header"><th>模式</th><th>Spark安装机器数</th><th>需要启动的进程</th><th>所属者</th><th>应用场景</th></tr></thead><tbody><tr class="odd"><td>Local</td><td>1</td><td>无</td><td>Spark</td><td>测试</td></tr><tr class="even"><td>Standalone</td><td>3</td><td>Master以及Worker</td><td>Spark</td><td>单独部署</td></tr><tr class="odd"><td>Yarn</td><td>1</td><td>Yarn以及HDFS</td><td>Hadoop</td><td>混合部署</td></tr></tbody></table><h3 id="使用端口说明">使用端口说明</h3><ul><li>Spark查看当前Spark-shell运行任务情况端口号：4040</li><li>Spark Master内部通信服务端口号：7077</li><li>Standalone模式下，Spark Master Web端口号：8080</li><li>Spark历史服务器端口号：18080</li><li>Hadoop Yarn任务运行情况查看端口号：8088</li></ul><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://blog.csdn.net/qq_34319644/article/details/115555522">spark与 scala的对应版本查看_孙砚秋的博客-CSDN博客_spark与scala版本对应</a></li><li><ahref="https://blog.csdn.net/weixin_43867016/article/details/118576270">scalasignature package has wrong version expected: 5.0 found: 5.2 inpackage.class问题记录_盐水鱼的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Spark</tag>
      
      <tag>未完待续</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala学习笔记-其他特性(1)-异常、泛型和隐式转换</title>
    <link href="/2022/05/03/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7-1-%E5%BC%82%E5%B8%B8%E3%80%81%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/05/03/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7-1-%E5%BC%82%E5%B8%B8%E3%80%81%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="异常">异常</h2><p>Scala的异常处理在语法上和Java类似，但是又不尽相同。</p><p>在Java中，异常处理采用<code>try-catch-finally</code>的方式。其中使用多个catch语句来捕获对应的异常，这时候需要将范围小的异常类写在前面，大的异常类写在后面。</p><p>在Scala中同样使用<code>try-catch-finally</code>的方式来获取，其中只有一个catch代码块，在里面通过case进行异常的判定</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">val</span> n = <span class="hljs-number">10</span> / <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-keyword">case</span> e: <span class="hljs-type">ArithmeticException</span> =&gt; &#123;<br>        println(<span class="hljs-string">&quot;发生算术异常&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">case</span> e: <span class="hljs-type">Exception</span> =&gt; &#123;<br>        println(<span class="hljs-string">&quot;发生一般异常&quot;</span>)<br>    &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    println(<span class="hljs-string">&quot;处理结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Scala的异常工作机制与Java一样，但是没有编译时异常，所有的异常都是运行时处理</p></li><li><p>Scala中也是用<code>throw</code>关键字抛出异常，所有异常都是<code>Throwable</code>的子类，<code>throw</code>表达式是有类型的，就是<code>Nothing</code>。<code>Nothing</code>主要用在一个函数总是不能正常工作，总是抛出异常的时候用作返回值类型。</p></li><li><p>Java中提供了throws关键字来声明方法可能引发的异常，在Scala中可以使用throws注解来声明异常</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@throws</span>(classOf[<span class="hljs-type">NumberFormatException</span>])<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f11</span></span>()=&#123;<br> <span class="hljs-string">&quot;abc&quot;</span>.toInt<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="隐式转换">隐式转换</h2><p>总结来说，在Scala中，当编译器第一次编译失败的时候，会在当前的环境中查找能够让代码编译通过的方法，用于将类型进行转换，实现二次编译。当编译错误的时候，编译器会尝试在当前作用域范围内查找能够调用对应功能的转换规则，这个过程由编译器完成，称之为隐式转换或者自动转换。（隐式转换能够在不修改类代码的情况下扩充类的功能）</p><p>首先描述下面场景：</p><p>现在我们完成了一个自定义类<code>MyRichInt</code>，其中实现了自定义的比较大小的方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 自定义类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRichInt</span>(<span class="hljs-params">val value: <span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-comment">// 自定义比较大小的方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myMax</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = <span class="hljs-keyword">if</span> (n &lt; value) value <span class="hljs-keyword">else</span> n<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myMin</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = <span class="hljs-keyword">if</span> (n &gt; value) value <span class="hljs-keyword">else</span> n<br>&#125;<br></code></pre></td></tr></table></figure><p>但是能够调用我们方法的只有<code>MyRichInt</code>对应的对象，如果是一个整数的话，是无法调用我们的自定义比较大小方法的。下面的代码会报错：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">println(<span class="hljs-number">12.</span>myMax(<span class="hljs-number">15</span>))<br></code></pre></td></tr></table></figure><p>隐式转换就能够解决这样的场景。</p><h3 id="隐式函数">隐式函数</h3><p>在函数定义前加上<code>implicit</code>将其声明为隐式转换函数。</p><p>之前Int类型的对象无法调用我们的自定义比较大小方法，但是编译器发现了一个隐式函数，能够完成从Int到MyRichInt的转换，完成转换之后能够调用，因此能够正常运行。</p><p>隐式函数定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 隐式函数</span><br><span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span></span>(num: <span class="hljs-type">Int</span>): <span class="hljs-type">MyRichInt</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">MyRichInt</span>(num)<br></code></pre></td></tr></table></figure><p>有了隐式函数之后，下面代码能够正常运行（当然注意隐式函数需要在下面代码的作用域内，即定义在它之前）</p><blockquote><p>能够运行是因为编译器找到了隐式函数，然后将Int对象转换成了一个MyRichInt对象</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">println(<span class="hljs-number">12.</span>myMax(<span class="hljs-number">15</span>))<br></code></pre></td></tr></table></figure><h3 id="隐式参数">隐式参数</h3><p>普通方法或者函数中的参数可以通过<code>implicit</code>关键字声明为隐式参数，调用该方法的时候，如果传入了，则以传入参数为准，如果没有传入，则编译器在当前作用域寻找符合条件的隐式值。</p><p>关于隐式值：</p><ul><li>在同一个作用域，相同类型的隐式值只能有一个（避免二义性）</li><li>编译器会按照隐式参数的类型去寻找对应的隐式值，与隐式值的名称无关</li><li>隐式参数优于默认参数</li></ul><p>示例代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 指定隐式参数</span><br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> str: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;hello world&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span></span>(<span class="hljs-keyword">implicit</span> arg: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;goodbye world&quot;</span>) = &#123;<br>    println(arg)<br>&#125;<br><br>hello <span class="hljs-comment">// hello world</span><br>hello() <span class="hljs-comment">// goodbye world</span><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hello world<br>goodbye world<br></code></pre></td></tr></table></figure><p>如上所示，如果参数列表中只有一个隐式参数，那么无论这个隐式参数是否提供默认参数，需要使用隐式参数的话，在调用的时候需要将括号一起省略掉。（如同上面的<code>hello</code>）</p><p>如果调用的时候，又想要括号，则可以在函数定义的时候，在隐式参数列表之前添加一个空参数列表<code>()</code>，那么会出现以下情况</p><ul><li><p><code>func</code>：调用隐式参数</p></li><li><p><code>func()</code>：调用隐式参数</p></li><li><p><code>func()()</code>：使用默认参数</p></li><li><p><code>func()(arg)</code>：使用传入参数</p></li></ul><p>示例代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 指定隐式参数</span><br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> str: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;hello world&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span></span>()(<span class="hljs-keyword">implicit</span> arg: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;goodbye world&quot;</span>) = &#123;<br>    println(arg)<br>&#125;<br><br>hello <span class="hljs-comment">// hello world</span><br>hello() <span class="hljs-comment">// hello world</span><br>hello()() <span class="hljs-comment">// goodbye world</span><br>hello()(<span class="hljs-string">&quot;wow&quot;</span>) <span class="hljs-comment">// wow</span><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hello world<br>hello world<br>goodbye world<br>wow<br></code></pre></td></tr></table></figure><p>示例代码可以简写为如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span></span>() = &#123;<br>    println(implicitly[<span class="hljs-type">String</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话就无法传入参数了（这样不像是一个全局变量吗？）</p><h3 id="隐式类">隐式类</h3><p>在Scala2.10之后提供了隐式类。通过<code>implicit</code>来声明类。此时类的构造方法将被声明为隐式转换函数。也就是说，如果第一次编译没有通过，就可能将数据直接传给构造函数转换成对应的类，可以将隐式类看作是隐式函数的一个扩展。</p><p>隐式类的说明：</p><ul><li>所带构造参数有且只能有一个</li><li>隐式类必须定义在“类”或者“伴生对象”或者“包对象”中，即隐式类不能是顶级的</li></ul><p>在同一个作用域中定义隐式转换函数和隐式类会冲突，定义一个就行</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-comment">// 自定义隐式类</span><br>  <span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRichInt</span>(<span class="hljs-params">val value: <span class="hljs-type">Int</span></span>) </span>&#123;<br>    <span class="hljs-comment">// 自定义比较大小的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myMax</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = <span class="hljs-keyword">if</span> (n &lt; value) value <span class="hljs-keyword">else</span> n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myMin</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = <span class="hljs-keyword">if</span> (n &gt; value) value <span class="hljs-keyword">else</span> n<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-number">12.</span>myMax(<span class="hljs-number">15</span>))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="隐式解析机制">隐式解析机制</h3><ul><li>首先在<strong>当前代码作用域下</strong>查找隐式实体（隐式方法、隐式类、隐式对象）。</li><li>如果第一条规查找隐式对象失败，会继续在<strong>隐式参数的类型的作用域</strong>中查找。类型的作用域是指该类型相关联的全部伴生对象以及该类型所在包的包对象。</li></ul><h2 id="泛型">泛型</h2><h3 id="协变和逆变">协变和逆变</h3><p>语法如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>[+<span class="hljs-type">T</span>] </span>&#123;&#125; <span class="hljs-comment">// 协变</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>[-<span class="hljs-type">T</span>] </span>&#123;&#125; <span class="hljs-comment">// 逆变</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>[<span class="hljs-type">T</span>] </span>&#123;&#125; <span class="hljs-comment">// 不变</span><br></code></pre></td></tr></table></figure><p>假设<code>Son</code>和<code>Father</code>是父子关系，<code>Son</code>是子类。</p><ul><li>协变（Covariance）：<code>MyList[Son]</code>是<code>MyList[Father]</code>的子类，协同变化。</li><li>逆变（Contravariance）：<code>MyList[Son]</code>是<code>MyList[Father]</code>的父类，逆向变化。</li><li>不变（Invariant）：<code>MyList[Father] MyList[Son]</code>没有父子关系。</li></ul><h3 id="泛型上下限">泛型上下限</h3><p>规定泛型的上下限，对传入的泛型进行限定</p><ul><li>泛型上限：<code>class MyList[T &lt;: Type]</code>，可以传入<code>Type</code>自身或者子类。</li><li>泛型下限：<code>class MyList[T &gt;: Type]</code>，可以传入<code>Type</code>自身或者父类。</li></ul><h3 id="上下文限定">上下文限定</h3><ul><li><code>def f[A : B](a: A) = println(a)</code>等同于<code>def f[A](a: A)(implicit arg: B[A])</code></li><li>是将泛型和隐式转换结合的产物，使用上下文限定（前者）后，方法内无法使用隐式参数名调用隐式参数，需要通过<code>implicitly[Ordering[A]]</code>获取隐式变量。</li></ul><p>（待补充...）</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala学习笔记-核心特性(4)-模式匹配</title>
    <link href="/2022/05/03/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-4-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <url>/2022/05/03/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-4-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="模式匹配">模式匹配</h2><p>首先回顾一下Java中的switch-case语法，我们可以使用case来指定多分支的执行逻辑，在每个case语句中需要使用break退出。根据情况会首先进入一个case代码块，一直向下执行直到遇见一个break块或者一直向下执行了所有的代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">switch</span> (i) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>        System.out.println(<span class="hljs-string">&quot;10&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>:<br>        System.out.println(<span class="hljs-string">&quot;20&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">30</span>:<br>        System.out.println(<span class="hljs-string">&quot;30&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        System.out.println(<span class="hljs-string">&quot;other number&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">switch</span> (i) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>        System.out.println(<span class="hljs-string">&quot;10-1&quot;</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>:<br>        System.out.println(<span class="hljs-string">&quot;20-1&quot;</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">30</span>:<br>        System.out.println(<span class="hljs-string">&quot;30-1&quot;</span>);<br>    <span class="hljs-keyword">default</span>:<br>        System.out.println(<span class="hljs-string">&quot;other number-1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">20<br>20-1<br>30-1<br>other number-1<br></code></pre></td></tr></table></figure><p>Scala中没有switch关键字，但是提供了模式匹配的功能。下面我们介绍在Scala中模式匹配的基本语法。</p><h3 id="基本语法">基本语法</h3><p>Scala中的模式匹配语法采用<code>match-case</code>结构。模式匹配采用match关键字声明，每个分支采用case关键字进行声明。匹配会进入对应的case代码块，如果所有的case都没有匹配，则进入<code>case _</code>分支（类似Java中的default）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">value <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> caseVal1 =&gt; returnVal1<br>    <span class="hljs-keyword">case</span> caseVal2 =&gt; returnVal2<br>    ...<br>    <span class="hljs-keyword">case</span> _ =&gt; defaultVal<br>&#125;<br></code></pre></td></tr></table></figure><p>与Java中不同的是，模式匹配的每个case分支中不用写break语句（Scala中也没有break关键字），在执行的时候，执行完了一个case分支，就直接跳出整个模式匹配的后面（不会像Java中一样还会向后继续执行case分支）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> i:<span class="hljs-type">Int</span> = <span class="hljs-number">20</span><br>i <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span> =&gt; println(<span class="hljs-string">&quot;10&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">20</span> =&gt; println(<span class="hljs-string">&quot;20&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">30</span> =&gt; println(<span class="hljs-string">&quot;30&quot;</span>)<br>    <span class="hljs-keyword">case</span> _ =&gt; println(<span class="hljs-string">&quot;other number&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的运行结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">20<br></code></pre></td></tr></table></figure><ul><li>match case语句可以匹配任何类型，而不只是字面量。后面会提到这点</li><li><code>=&gt;</code>后面的代码块，直到下一个case语句之前的代码是作为一个整体执行，可以使用<code>&#123;&#125;</code>进行包裹，也可以不使用</li></ul><h3 id="模式守卫">模式守卫</h3><p>如果想要表达式匹配某个范围内的数据，则可以在模式匹配中增加条件守卫，即使用条件表达式，例如下面的代码实现了求整数绝对值的功能</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">abs</span></span>(num: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    num <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> i <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> =&gt; i<br>        <span class="hljs-keyword">case</span> i <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> =&gt; -i<br>    &#125;<br>&#125;<br>println(abs(<span class="hljs-number">-29</span>))<br></code></pre></td></tr></table></figure><h2 id="模式匹配类型">模式匹配类型</h2><p>在Scala中，模式匹配的功能比其他语言中的<code>switch-case</code>语句要更加强大，它提供了更多的模式匹配类型，包括匹配常量、类型、数组、列表、元组以及对象等。（注意以下的匹配方式都可以混用）</p><h3 id="匹配常量">匹配常量</h3><p>Scala中，模式匹配支持匹配所有的字面量，包括字符串、字符、数字、布尔值等，可以通过传入Any类型的变量来进行匹配</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matchConst</span></span>(x: <span class="hljs-type">Any</span>): <span class="hljs-type">String</span> = &#123;<br>    x <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> =&gt; <span class="hljs-string">&quot;Int One&quot;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> =&gt; <span class="hljs-string">&quot;String hello&quot;</span><br>        <span class="hljs-keyword">case</span> &#x27;+&#x27; =&gt; <span class="hljs-string">&quot;Char +&quot;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-literal">true</span> =&gt; <span class="hljs-string">&quot;Boolean true&quot;</span><br>        <span class="hljs-keyword">case</span> a =&gt; <span class="hljs-string">&quot;other &quot;</span> + a<br>    &#125;<br>&#125;<br><br>println(matchConst(<span class="hljs-number">1</span>))<br>println(matchConst(<span class="hljs-number">2</span>))<br>println(matchConst(<span class="hljs-literal">true</span>))<br></code></pre></td></tr></table></figure><p>注意，这里没有<code>case _</code>，但是同样存在defalut的情况，就是最后一个case代码块。<code>case _</code>的情况是在不需要变量的值的时候建议这么做，当然也可以使用一个变量的值来承接，就像这里的<code>case a</code>，这里的<code>a</code>承接了不匹配的其他所有的值，应该是<code>Any</code>类型</p><h3 id="匹配类型">匹配类型</h3><p>需要进行类型判断的时候，可以使用前面说到过的<code>isInstanceOf</code>和<code>asInstanceOf</code>，也可以使用模式匹配来匹配类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matchType</span></span>(x: <span class="hljs-type">Any</span>): <span class="hljs-type">String</span> = &#123;<br>    x <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> i: <span class="hljs-type">Int</span> =&gt; <span class="hljs-string">&quot;Int &quot;</span> + i<br>        <span class="hljs-keyword">case</span> s: <span class="hljs-type">String</span> =&gt; <span class="hljs-string">&quot;String &quot;</span> + s<br>        <span class="hljs-keyword">case</span> list: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] =&gt; <span class="hljs-string">&quot;List &quot;</span> + list<br>        <span class="hljs-keyword">case</span> array: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] =&gt; <span class="hljs-string">&quot;Array[Int] &quot;</span> + array.mkString(<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">case</span> somethingElse =&gt; <span class="hljs-string">&quot;SomethingElse &quot;</span> + somethingElse<br>    &#125;<br>&#125;<br>println(matchType(<span class="hljs-number">10</span>))<br>println(matchType(<span class="hljs-string">&quot;hello&quot;</span>))<br>println(matchType(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)))<br>println(matchType(<span class="hljs-type">List</span>(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)))<br>println(matchType(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)))<br>println(matchType(<span class="hljs-type">Array</span>(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)))<br>println(matchType(&#x27;c&#x27;))<br></code></pre></td></tr></table></figure><p>以上代码的运行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Int 10<br>String hello<br>List List(1, 2, 3, 4, 5)<br>List List(hi, hello)<br>Array[Int] 1 2 3 4 5<br>SomethingElse [Ljava.lang.String;@6bdf28bb<br>SomethingElse c<br></code></pre></td></tr></table></figure><p>需要注意的是输出结果的第4行和第6行，第4行中List的泛型和我们定义的不匹配，但是仍旧输出了对应的case语句，而第6行中Array的泛型不匹配，就走了最后一行的default。这里涉及到Scala中泛型擦除的现象，即在类型匹配的时候由于泛型擦除，可能并不能严格匹配泛型的类型参数。但是由于Array是基本数据类型，对应于Java中的原生数组类型，能够匹配泛型类型参数。</p><h3 id="匹配数组">匹配数组</h3><p>Scala中的模式匹配可以对集合进行精确的匹配。可以对数组定义多种匹配方式，例如模糊的元素类型匹配、元素数量匹配或者精确到某个数组元素值匹配，功能非常强大</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matchArray</span></span>(array: <span class="hljs-type">Any</span>): <span class="hljs-type">String</span> = &#123;<br>    array <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(<span class="hljs-number">0</span>) =&gt; <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-comment">// 匹配特定数组Array(0)</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">&quot;Array(1, 0)&quot;</span> <span class="hljs-comment">// 匹配特定数组Array(1, 0)</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) =&gt; <span class="hljs-string">&quot;Array: &quot;</span> + x + <span class="hljs-string">&quot; &quot;</span> + y <span class="hljs-comment">// 匹配两整型元素数组</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(<span class="hljs-number">0</span>, _*) =&gt; <span class="hljs-string">&quot;以0开头的数组&quot;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(x, <span class="hljs-number">1</span>, z) =&gt; <span class="hljs-string">&quot;中间为1的三元素数组&quot;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Array</span>(x: <span class="hljs-type">String</span>, _*) =&gt; <span class="hljs-string">&quot;第一个元素为字符串的数组&quot;</span><br>        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Something Else&quot;</span><br>    &#125;<br>&#125;<br><br>println(matchArray(<span class="hljs-type">Array</span>(<span class="hljs-number">0</span>)))<br>println(matchArray(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)))<br>println(matchArray(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)))<br>println(matchArray(<span class="hljs-type">Array</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)))<br>println(matchArray(<span class="hljs-type">Array</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)))<br>println(matchArray(<span class="hljs-type">Array</span>(<span class="hljs-string">&quot;String&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)))<br></code></pre></td></tr></table></figure><h3 id="匹配列表">匹配列表</h3><p>列表匹配和数组匹配类似，其中可以混入集合类中灵活的运算符</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matchList</span></span>(list: <span class="hljs-type">Any</span>): <span class="hljs-type">String</span> = &#123;<br>    list <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>(<span class="hljs-number">0</span>) =&gt; <span class="hljs-string">&quot;0&quot;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>(x, y) =&gt; <span class="hljs-string">&quot;List(x, y) &quot;</span> + x + <span class="hljs-string">&quot;,&quot;</span> + y<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">List</span>(<span class="hljs-number">0</span>, _*) =&gt; <span class="hljs-string">&quot;List(0, ...)&quot;</span><br>        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Something Else&quot;</span><br>    &#125;<br>&#125;<br>println(matchList(<span class="hljs-type">List</span>(<span class="hljs-number">0</span>)))<br>println(matchList(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)))<br>println(matchList(<span class="hljs-type">List</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)))<br>println(matchList(<span class="hljs-type">List</span>(<span class="hljs-string">&quot;hello&quot;</span>)))<br></code></pre></td></tr></table></figure><p>注意混入集合运算符的用法。下面的代码匹配数组的第一个元素、第二个元素和其余元素</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matchList1</span></span>(list: <span class="hljs-type">Any</span>): <span class="hljs-type">String</span> = &#123;<br>    list <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> first :: second::rest =&gt;<span class="hljs-string">s&quot;first:<span class="hljs-subst">$&#123;first&#125;</span> second:<span class="hljs-subst">$&#123;second&#125;</span> rest:<span class="hljs-subst">$&#123;rest&#125;</span>&quot;</span><br>        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Something Else&quot;</span><br>    &#125;<br>&#125;<br><br>println(matchList1(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)))<br>println(matchList1(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)))<br>println(matchList1(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><p>以上代码的输出结果如下，如果rest为空也是能够匹配的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">first:1 second:2 rest:List(3, 4, 5, 6)<br>first:1 second:2 rest:List()<br>Something Else<br></code></pre></td></tr></table></figure><h3 id="匹配元组">匹配元组</h3><p>匹配元素类似于其他的集合匹配，可以匹配n元组、元素类型、元素值等。由于元组的大小固定，因此不能使用<code>_*</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matchTuple</span></span>(tuple: <span class="hljs-type">Any</span>): <span class="hljs-type">String</span> = &#123;<br>    tuple <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> (a, b) =&gt; <span class="hljs-string">&quot;(&quot;</span> + a + <span class="hljs-string">&quot;,&quot;</span> + b + <span class="hljs-string">&quot;)&quot;</span><br>        <span class="hljs-comment">// case (0, _*) =&gt; &quot;(0,...)&quot; // 此行报错</span><br>        <span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, _) =&gt; <span class="hljs-string">&quot;(0,_)&quot;</span><br>        <span class="hljs-keyword">case</span> (x, <span class="hljs-number">1</span>, z) =&gt; <span class="hljs-string">&quot;(x, y, z):&quot;</span> + x + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-number">1</span> + <span class="hljs-string">&quot; &quot;</span> + z<br>        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Something Else&quot;</span><br>    &#125;<br>&#125;<br><br>println(matchTuple((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)))<br>println(matchTuple((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)))<br>println(matchTuple((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)))<br>println(matchTuple((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)))<br>println(matchTuple((<span class="hljs-string">&quot;ture&quot;</span>, &#x27;<span class="hljs-number">1</span>&#x27;, <span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><p>元组的模式匹配可以用在变量声明以及for推导式中，在后面的应用场景提及到了</p><h3 id="匹配对象以及样例类">匹配对象以及样例类</h3><p>Scala的模式匹配还能够匹配对象，我们希望完成的是对象的内容匹配。直接在<code>match-case</code>中匹配对应的引用变量，语法是存在问题的。编译报错信息提示我们需要使用样例类或者实现<code>unapply</code>方法</p><p>要完成对象匹配，我们应该实现伴生对象中的<code>apply</code>方法和<code>unapply</code>方法，其中<code>unapply</code>方法也是一个特殊的方法，用来对对象的属性进行拆解</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, val age: <span class="hljs-type">Int</span></span>)</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>): <span class="hljs-type">Student</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(name, age)<br><br>  <span class="hljs-comment">// 实现unapply方法，用来对对象属性进行拆解</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unapply</span></span>(student: <span class="hljs-type">Student</span>): <span class="hljs-type">Option</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = &#123;<br>    <span class="hljs-keyword">if</span> (student == <span class="hljs-literal">null</span>) <span class="hljs-type">None</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-type">Some</span>((student.name, student.age))<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> student = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">21</span>)<br><br>    <span class="hljs-comment">// 针对对象实例的内容进行匹配</span><br>    <span class="hljs-keyword">val</span> result = student <span class="hljs-keyword">match</span> &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">21</span>) =&gt; <span class="hljs-string">&quot;xxx, 21&quot;</span><br>      <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Else&quot;</span><br>    &#125;<br>    println(result)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>在case后面的<code>Student("xxx", 21)</code>，实际上是调用了伴生对象的<code>apply</code>方法</li><li>当写在case后面，会默认调用<code>unapply</code>方法（对象提取器），Student对象作为<code>unapply</code>方法的参数，它将对象的<code>name</code>和<code>age</code>属性进行提取，然后与前面的case对象进行匹配</li><li><code>unapply</code>方法返回Some对象，只有所有属性都一致才算返回成功。属性不一致或者返回None，则匹配失败</li><li>以下是一些模板<ul><li>只提取对象的一个属性：<code>unapply(obj:Obj):Option[T]</code></li><li>提取对象的多个属性：<code>unapply(obj:Obj):Option[T1, T2, T3,...]</code></li><li>提取对象的可变个属性：<code>unapplySeq(obj:Obj):Option[Seq[T]]</code></li></ul></li></ul><p>也可以使用<strong>样例类</strong>的方式来完成，利用case声明一个样例类。样例类是为模式匹配而优化的类，其中自动生成了伴生对象，并且自动提供一些常用的方法，默认提供了如<code>apply</code>、<code>unapply</code>、<code>toString</code>、<code>equals</code>、<code>hashCode</code>、<code>copy</code>等方法，因此无需自己实现<code>unapply</code>方法。样例类中的每个参数都是val，除非它被显式地声明为var</p><p>这样上面的代码可以修改成下面的代码，同样能够完成对应的功能。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, val age: <span class="hljs-type">Int</span></span>)</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> student = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">21</span>)<br><br>    <span class="hljs-comment">// 针对对象实例的内容进行匹配</span><br>    <span class="hljs-keyword">val</span> result = student <span class="hljs-keyword">match</span> &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">21</span>) =&gt; <span class="hljs-string">&quot;xxx, 21&quot;</span><br>      <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;Else&quot;</span><br>    &#125;<br>    println(result)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一些应用场景">一些应用场景</h2><h3 id="变量声明中的模式匹配">变量声明中的模式匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> (x, y) = (<span class="hljs-number">10</span>, <span class="hljs-string">&quot;hello&quot;</span>)<br>println(<span class="hljs-string">s&quot;x: <span class="hljs-subst">$x</span>, y: <span class="hljs-subst">$y</span>&quot;</span>)<br><br><span class="hljs-keyword">val</span> <span class="hljs-type">List</span>(first, second, _*) = <span class="hljs-type">List</span>(<span class="hljs-number">23</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">78</span>)<br>println(<span class="hljs-string">s&quot;first: <span class="hljs-subst">$first</span>, second: <span class="hljs-subst">$second</span>&quot;</span>)<br><br><span class="hljs-keyword">val</span> fir :: sec :: rest = <span class="hljs-type">List</span>(<span class="hljs-number">23</span>, <span class="hljs-number">15</span> , <span class="hljs-number">9</span>, <span class="hljs-number">78</span>)<br>println(<span class="hljs-string">s&quot;first: <span class="hljs-subst">$fir</span>, second: <span class="hljs-subst">$sec</span>, rest: <span class="hljs-subst">$rest</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="for表达式中的模式匹配">for表达式中的模式匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> list: <span class="hljs-type">List</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = <span class="hljs-type">List</span>((<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">12</span>), (<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">35</span>), (<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">27</span>), (<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">13</span>))<br><br><span class="hljs-comment">// 原本的遍历方式</span><br><span class="hljs-keyword">for</span> (elem &lt;- list)&#123;<br>    println(elem._1 + <span class="hljs-string">&quot; &quot;</span> + elem._2)<br>&#125;<br><br><span class="hljs-comment">// 将List的元素直接定义为元组，对变量赋值</span><br><span class="hljs-keyword">for</span> ((word, count) &lt;- list )&#123;<br>    println(word + <span class="hljs-string">&quot;: &quot;</span> + count)<br>&#125;<br><br>println(<span class="hljs-string">&quot;-----------------------&quot;</span>)<br><span class="hljs-comment">// 可以不考虑某个位置的变量，只遍历key或者value</span><br><span class="hljs-keyword">for</span> ((word, _) &lt;- list)<br>println(word)<br><br>println(<span class="hljs-string">&quot;-----------------------&quot;</span>)<br><br><span class="hljs-comment">// 可以指定某个位置的值必须是多少</span><br><span class="hljs-keyword">for</span> ((<span class="hljs-string">&quot;a&quot;</span>, count) &lt;- list)&#123;<br>    println(count)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="偏函数中的模式匹配">偏函数中的模式匹配</h3><p>偏函数是函数的一种，通过偏函数我们可以方便地对输入参数做更精确的检查，内部就是通过模式匹配来实现的，举例如下</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> partialFuncName: <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>], <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]] = &#123;<br>    <span class="hljs-keyword">case</span> x :: y :: _ =&gt; <span class="hljs-type">Some</span>(y)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过一个变量定义方式定义，<code>PartialFunction</code>的泛型类型中，前者是参数类型，后者是返回值类型。函数体中用一个<code>case</code>语句来进行模式匹配。上面例子返回输入的<code>List</code>集合中的第二个元素。</li><li>一般一个偏函数只能处理输入的一部分场景，实际中往往需要定义多个偏函数用以组合使用。</li><li>偏函数能够实现case条件语句的复用？</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> list: <span class="hljs-type">List</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = <span class="hljs-type">List</span>((<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">12</span>), (<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">10</span>), (<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">100</span>), (<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">5</span>))<br><br><span class="hljs-comment">// map转换，实现key不变，value变成2倍</span><br><span class="hljs-keyword">val</span> newList = list.map(tuple =&gt; (tuple._1, tuple._2 * <span class="hljs-number">2</span>))<br>println(newList)<br><br><span class="hljs-comment">// 用模式匹配对元组元素赋值 实现功能</span><br><span class="hljs-keyword">val</span> newList1 = list.map(<br>    tuple =&gt; &#123;<br>        tuple <span class="hljs-keyword">match</span> &#123;<br>            <span class="hljs-keyword">case</span> (x, y) =&gt; (x, y * <span class="hljs-number">2</span>)<br>        &#125;<br>    &#125;<br>)<br>println(newList1)<br><br><span class="hljs-comment">// 简化表达</span><br><span class="hljs-keyword">val</span> newList2 = list.map &#123;<br>    <span class="hljs-keyword">case</span> (x, y) =&gt; (x, y * <span class="hljs-number">2</span>) <span class="hljs-comment">// this is a partial function</span><br>&#125;<br>println(newList2)<br><br><span class="hljs-comment">// 偏函数的应用，求绝对值</span><br><span class="hljs-keyword">val</span> positiveAbs: <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>] = &#123;<br>    <span class="hljs-keyword">case</span> x <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> =&gt; x<br>&#125;<br><span class="hljs-keyword">val</span> negativeAbs: <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>] = &#123;<br>    <span class="hljs-keyword">case</span> x <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> =&gt; -x<br>&#125;<br><span class="hljs-keyword">val</span> zeroAbs: <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>] = &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">abs</span></span>(x: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = (positiveAbs orElse negativeAbs orElse zeroAbs) (x)<br>println(abs(<span class="hljs-number">-13</span>))<br>println(abs(<span class="hljs-number">30</span>))<br>println(abs(<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala学习笔记-核心特性(3)-集合</title>
    <link href="/2022/05/02/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-3-%E9%9B%86%E5%90%88/"/>
    <url>/2022/05/02/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-3-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="集合总览">集合总览</h2><h3 id="简介">简介</h3><p>在Scala中，集合主要分为三大类型：序列（Seq）、集合（Set）以及映射（Map），并且所有的集合都扩展自Iterable特征。</p><p>对于几乎所有集合类，Scala中都同时提供了<strong>可变</strong>和<strong>不可变</strong>版本，区分主要是按照集合的位置来区分：</p><ul><li>不可变集合：<code>scala.collection.immutable</code></li><li>可变集合：<code>scala.collection.mutable</code></li></ul><blockquote><p>可变与不可变指的是引用是否可变，类比Java中的String和StringBuilder。String是不可变的，在对String进行修改的时候，实际上是返回了一个新的对象；StringBuilder是可变的，对它进行修改的时候是在对原对象进行修改。</p><p>对于不可变集合，集合的长度数量不可修改，每次修改（比如增删元素）都会返回一个新的对象，而不会修改源对象。</p><p>可变集合可以对源对象任意修改，一般也提供不可变集合相同的返回新对象的方法，但也可以用其他方法来修改源对象。</p></blockquote><p>一般情况下一个集合类的可变和不可变版本的名称不同，但是有时候也可能相同，这时候就需要按照集合所属的包来进行区分。后面我们会介绍一些典型集合的操作方式，一般建议是：<strong>在操作集合的时候，不可变集合使用符号操作，可变集合使用方法操作</strong></p><h3 id="不可变集合总览">不可变集合总览</h3><img src="/2022/05/02/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-3-%E9%9B%86%E5%90%88/%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" class="" title="不可变集合继承关系"><ul><li>Set和Map是Java中也有的集合，对应的特点也和Java中相同</li><li>在Scala的Map体系中有一个SortedMap，支持排序</li><li>Seq是Java中没有的特征，其中分为随机访问序列（IndexedSeq）和线性序列（LinearSeq）<ul><li>IndexedSeq通过索引来查找和定位，因此速度快</li><li>LinearSeq是线性的，有头尾的概念，这种数据结构一般通过遍历来查找（像这里队列，栈等被归类到了LinearSeq，因为我们一般只关注它们的首尾元素，操作的也是首尾元素）</li></ul></li><li>前面我们学习的for语法，底层对应的就是IndexedSeq下的Range</li><li>图中的Array和String使用虚线连接，它们其实对应的就是Java中的数组和<code>java.lang.String</code>，和Scala中的集合并没有直接关系。但是通过可以通过隐式转换成为一个包装类型之后就可以当作集合了</li><li>Scala中更多地推荐使用不可变集合，能使用不可变就使用不可变</li></ul><h3 id="可变集合总览">可变集合总览</h3><img src="/2022/05/02/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-3-%E9%9B%86%E5%90%88/%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" class="" title="可变集合继承关系"><p>可变集合相较于不可变集合中多出了Buffer特征，其余的整体结构相差不大</p><h2 id="数组">数组</h2><h3 id="不可变数组-array">不可变数组 Array</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 两种创建方式</span><br><span class="hljs-keyword">val</span> arr1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">5</span>)<br><span class="hljs-keyword">val</span> arr2 = <span class="hljs-type">Array</span>(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 赋值和访问</span><br><span class="hljs-comment">// 采用符号=进行赋值</span><br><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">0</span> until arr1.length) arr1(i) = i<br><span class="hljs-comment">// 调用方法update进行赋值</span><br>arr2.update(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)<br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-comment">// 下标遍历</span><br><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">0</span> until arr1.length) print(arr1(i) + <span class="hljs-string">&quot; &quot;</span>)<br>println()<br><span class="hljs-comment">// 元素遍历</span><br><span class="hljs-keyword">for</span> (elem &lt;- arr1) print(elem + <span class="hljs-string">&quot; &quot;</span>)<br>println()<br><span class="hljs-comment">// 迭代器遍历</span><br><span class="hljs-keyword">val</span> iterator = arr2.iterator<br><span class="hljs-keyword">while</span> (iterator.hasNext) &#123;<br>    print(iterator.next() + <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br>println()<br><span class="hljs-comment">// foreach方法遍历</span><br>arr2.foreach((elem: <span class="hljs-type">Int</span>) =&gt; &#123;<br>    print(<span class="hljs-string">s&quot;<span class="hljs-subst">$&#123;elem&#125;</span> &quot;</span>)<br>&#125;)<br>println()<br><span class="hljs-comment">// mkString方法</span><br>println(arr2.mkString(<span class="hljs-string">&quot; &quot;</span>))<br><br><span class="hljs-comment">// 增加元素</span><br><span class="hljs-keyword">val</span> newArr1 = arr1 :+ <span class="hljs-number">10</span> <span class="hljs-comment">// 在末尾添加(调用方法或者省略成符号)</span><br><span class="hljs-keyword">val</span> newArr2 = arr1.+:(<span class="hljs-number">20</span>) <span class="hljs-comment">// 调用方法在首部添加</span><br><span class="hljs-keyword">val</span> newArr3 = <span class="hljs-number">30</span> +: arr2 <span class="hljs-comment">// 省略成符号在首部添加 需要注意顺序</span><br><span class="hljs-keyword">val</span> newArr4 = <span class="hljs-number">20</span> +: <span class="hljs-number">10</span> +: arr2 :+ <span class="hljs-number">30</span> :+ <span class="hljs-number">40</span> <span class="hljs-comment">// 完全使用符号，:需要朝向数组对象</span><br><br>println(newArr1.mkString(<span class="hljs-string">&quot; &quot;</span>))<br>println(newArr2.mkString(<span class="hljs-string">&quot; &quot;</span>))<br>println(newArr3.mkString(<span class="hljs-string">&quot; &quot;</span>))<br>println(newArr4.mkString(<span class="hljs-string">&quot; &quot;</span>))<br></code></pre></td></tr></table></figure><ul><li>不可变数组在创建的时候有两种方式<ul><li>方式1：指定大小，不指定初值</li><li>方式2：直接指定初值</li></ul></li><li>不可变数组的值赋值和修改是不会返回新对象的，但是增删元素是会返回新对象的</li><li>需要注意这里添加符号的使用<code>:+</code>和<code>+:</code>，<code>:</code>始终朝向对象</li><li>遍历方式对于集合类型来说基本上都是通用的</li><li>下标越界会抛出异常，在使用之前应该注意</li><li><strong>建议不可变集合使用符号来操作</strong></li></ul><h3 id="可变数组-arraybuffer">可变数组 ArrayBuffer</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 两种创建方式</span><br><span class="hljs-keyword">val</span> arr1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Int</span>]()<br><span class="hljs-keyword">val</span> arr2 = <span class="hljs-type">ArrayBuffer</span>(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><br><br><span class="hljs-comment">// 增加元素</span><br>arr1 += <span class="hljs-number">10</span> <span class="hljs-comment">// 使用符号添加元素</span><br>arr2.append(<span class="hljs-number">30</span>) <span class="hljs-comment">// 调用append方法</span><br>arr2.insert(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>) <span class="hljs-comment">// insert方法向指定位置插入数据</span><br><span class="hljs-comment">// 使用类似于不可变数组的方式</span><br><span class="hljs-comment">// 但是这种方式不会修改源数组，而是需要新变量接收</span><br><span class="hljs-keyword">val</span> arr3 = arr1 :+ <span class="hljs-number">22</span><br><span class="hljs-keyword">val</span> arr4 = <span class="hljs-number">33</span> +: arr1<br><br><span class="hljs-comment">// 删除元素</span><br>arr1.remove(<span class="hljs-number">0</span>) <span class="hljs-comment">// 调用remove方法(从哪个下标开始删除，删除多少个)</span><br>arr2 -= <span class="hljs-number">1</span> <span class="hljs-comment">// 使用符号删除元素(遇到符合条件的即删除，执行一次)</span><br></code></pre></td></tr></table></figure><ul><li><p>两种创建方式，不指定大小默认初始大小为16</p></li><li><p>注意可变和不可变的理念，一个是在源数组上修改，另一个是返回一个新的修改后的数组</p></li><li><p><strong>建议可变集合使用方法调用来操作</strong></p></li></ul><p>可变数组和不可变数组之间可以相互转化，转化不会修改本身的类型，而是返回一个结果</p><ul><li>Array -&gt; ArrayBuffer：<code>toBuffer()</code></li><li>ArrayBuffer -&gt; Array：<code>toArray()</code></li></ul><h3 id="多维数组-array.ofdim">多维数组 Array.ofDim</h3><p>多维数组可以使用<code>Array.ofDim[Type]来指定维度</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 创建一个二维数组，2行3列</span><br><span class="hljs-keyword">val</span> array = <span class="hljs-type">Array</span>.ofDim[<span class="hljs-type">Int</span>](<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 访问和修改元素</span><br>array(<span class="hljs-number">0</span>)(<span class="hljs-number">2</span>) = <span class="hljs-number">10</span><br>array(<span class="hljs-number">1</span>)(<span class="hljs-number">0</span>) = <span class="hljs-number">25</span><br><br><span class="hljs-comment">// 遍历</span><br>array.foreach(line =&gt;&#123;<br>    line.foreach(print)<br>&#125;)<br></code></pre></td></tr></table></figure><p>Scala中<code>ofDim</code>方法最多支持到构造5维的数组，更多维度的数组不支持</p><h2 id="列表">列表</h2><h3 id="不可变列表-list">不可变列表 List</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 创建一个List(不能直接new，需要使用伴生对象的apply方法)</span><br><span class="hljs-keyword">val</span> list1 = <span class="hljs-type">List</span>(<span class="hljs-number">92</span>, <span class="hljs-number">39</span>, <span class="hljs-number">52</span>, <span class="hljs-number">23</span>)<br><br><span class="hljs-comment">// 访问和遍历元素</span><br>println(list1(<span class="hljs-number">1</span>))<br>list1.foreach(elem =&gt; print(<span class="hljs-string">s&quot;<span class="hljs-subst">$&#123;elem&#125;</span> &quot;</span>))<br>println()<br><br><span class="hljs-comment">// 添加元素(返回新列表)</span><br><span class="hljs-keyword">val</span> list2 = <span class="hljs-number">10</span> +: list1 <span class="hljs-comment">// 添加到首部</span><br><span class="hljs-keyword">val</span> list3 = list1 :+ <span class="hljs-number">10</span> <span class="hljs-comment">// 添加到尾部</span><br>println(list1)<br>println(list2)<br>println(list3)<br><br><span class="hljs-comment">// ::符号的使用</span><br><span class="hljs-keyword">val</span> list4 = list1.::(<span class="hljs-number">49</span>) <span class="hljs-comment">// 添加元素到列表头部</span><br><span class="hljs-keyword">val</span> list5 = <span class="hljs-number">49</span> :: list1<br>println(list4)<br>println(list5)<br><br><span class="hljs-comment">// 利用::来构造新列表,Nil表示空列表</span><br><span class="hljs-keyword">val</span> list6 = <span class="hljs-number">12</span> :: <span class="hljs-number">123</span> :: <span class="hljs-number">23</span> :: <span class="hljs-number">98</span> :: <span class="hljs-type">Nil</span><br>println(list6)<br><br><span class="hljs-comment">// 合并列表</span><br><span class="hljs-keyword">val</span> list7 = list1 :: list6 <span class="hljs-comment">// 这种方式会将list1当作一个整体添加到list6的首部</span><br><span class="hljs-keyword">val</span> list8 = list1 :::list6<br><span class="hljs-keyword">val</span> list9 = list1 ++ list6<br>println(list7)<br>println(list8)<br>println(list9)<br></code></pre></td></tr></table></figure><ul><li>List是抽象类，本身不能直接new，需要调用伴生对象的apply创建对象</li><li>支持<code>+:</code>和<code>:+</code>向首尾添加元素</li><li><code>Nil</code>表示空列表，<code>::</code>添加元素到表头</li><li>合并列表使用<code>:::</code>或者<code>++</code></li><li>List本身可以使用apply进行随机访问，但是不能进行update更改，即不能通过类似<code>list1(0) = 1</code>的方式进行修改</li></ul><h3 id="可变列表-listbuffer">可变列表 ListBuffer</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 创建可变列表</span><br><span class="hljs-keyword">val</span> list1 = <span class="hljs-keyword">new</span> <span class="hljs-type">ListBuffer</span>[<span class="hljs-type">Int</span>]()<br><span class="hljs-keyword">val</span> list2 = <span class="hljs-type">ListBuffer</span>(<span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">44</span>, <span class="hljs-number">53</span>)<br><br><span class="hljs-comment">// 添加元素</span><br>list1.append(<span class="hljs-number">32</span>) <span class="hljs-comment">// 添加到末尾</span><br>list2.prepend(<span class="hljs-number">46</span>) <span class="hljs-comment">// 添加到首部</span><br>list1.insert(<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">32</span>) <span class="hljs-comment">// 在指定位置插入</span><br><span class="hljs-comment">// 利用符号+=:添加到首部</span><br><span class="hljs-number">10</span> +=: <span class="hljs-number">11</span>+=: list1 += <span class="hljs-number">12</span> += <span class="hljs-number">13</span><br>println(list1)<br>println(list2)<br><br><span class="hljs-comment">// 修改元素</span><br>list1(<span class="hljs-number">1</span>) = <span class="hljs-number">11</span><br>list2.update(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)<br>println(list1)<br>println(list2)<br><br><span class="hljs-comment">// 删除元素</span><br>list1.remove(<span class="hljs-number">0</span>)<br>list2 -= <span class="hljs-number">46</span><br>println(list1)<br>println(list2)<br><br><span class="hljs-comment">// 合并列表</span><br><span class="hljs-keyword">val</span> list4 = list1 ++ list2 <span class="hljs-comment">// ++合并成新列表</span><br>println(list4)<br>println(list1)<br>println(list2)<br><br>list1 ++= list2 <span class="hljs-comment">// 合并到前面的列表</span><br>println(list1)<br>println(list2)<br></code></pre></td></tr></table></figure><ul><li><p>可变列表<code>ListBuffer</code>的操作与可变数组<code>ArrayBuffer</code>类似</p></li><li><p>有两种方式进行对象的创建</p></li><li><p>常用方法：<code>append prepend insert remove</code></p></li><li><p>添加元素到头部或者尾部：<code>+=: +=</code></p></li><li><p>合并列表：<code>++ ++=</code></p></li></ul><h2 id="集合">集合</h2><p>在Scala中，集合的可变和不可变版本的名称都是Set。默认情况下，Scala使用的是不可变集合，如果想要使用可变集合，则需要引用<code>scala.collection.mutable.Set</code>，建议在使用的时候，不可变集合使用<code>Set</code>，可变集合使用<code>mutable.Set</code></p><h3 id="不可变集合-set">不可变集合 Set</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 创建Set</span><br><span class="hljs-keyword">val</span> set1 = <span class="hljs-type">Set</span>(<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">21</span>,<span class="hljs-number">12</span>,<span class="hljs-number">123</span>,<span class="hljs-number">43</span>,<span class="hljs-number">53</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">// 添加元素</span><br><span class="hljs-keyword">val</span> set2 = set1 + <span class="hljs-number">111</span><br>println(set1)<br>println(set2)<br><br><span class="hljs-comment">// 删除元素</span><br><span class="hljs-keyword">val</span> set3 = set1 - <span class="hljs-number">123</span><br>println(set1)<br>println(set3)<br><br><span class="hljs-comment">// 合并Set</span><br><span class="hljs-keyword">val</span> set4 = set1 ++ set2<br>println(set4)<br></code></pre></td></tr></table></figure><ul><li>数据无序且不可重复</li><li>添加元素：<code>+</code></li><li>删除元素：<code>-</code></li><li>合并：<code>++</code></li><li>操作返回一个新的集合，不会修改源集合</li></ul><h3 id="可变集合-mutable.set">可变集合 mutable.Set</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 创建Set</span><br><span class="hljs-keyword">val</span> set1 = mutable.<span class="hljs-type">Set</span>(<span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">54</span>, <span class="hljs-number">65</span>, <span class="hljs-number">23</span>)<br><br><span class="hljs-comment">// 添加元素</span><br>set1 += <span class="hljs-number">11</span><br><br><span class="hljs-comment">// 返回结果为一个布尔值，表示是否执行成功</span><br><span class="hljs-keyword">val</span> flag1 = set1.add(<span class="hljs-number">33</span>)<br><span class="hljs-keyword">val</span> flag2 = set1.add(<span class="hljs-number">33</span>)<br>println(flag1)<br>println(flag2)<br>println(set1)<br><br><span class="hljs-comment">// 删除元素</span><br>set1 -= <span class="hljs-number">11</span><br><br><span class="hljs-keyword">val</span> flag3 = set1.remove(<span class="hljs-number">12</span>)<br><span class="hljs-keyword">val</span> flag4 = set1.remove(<span class="hljs-number">12</span>)<br>println(flag3)<br>println(flag4)<br>println(set1)<br><br><span class="hljs-comment">// 合并Set</span><br><span class="hljs-keyword">val</span> set2 = mutable.<span class="hljs-type">Set</span>(<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">23</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>set1 ++= set2<br>println(set1)<br><br></code></pre></td></tr></table></figure><ul><li>操作在源集合上</li><li>添加元素：<code>+ add</code></li><li>删除元素：<code>- remove</code></li><li>方法调用会返回操作是否成功的布尔值</li><li>合并操作：<code>++</code></li></ul><h2 id="映射">映射</h2><p>Scala中的Map和Java中的类似，存储的内容是键值对。与Set相同，Map的可变与不可变类型的名称相同，只是存在不同的包中。默认的Map是不可变类型的，可变类型建议使用<code>mutable.Map</code>加以区别</p><h3 id="不可变映射-map">不可变映射 Map</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 创建Map</span><br><span class="hljs-keyword">val</span> map1: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Map</span>(<span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-number">2</span>, <span class="hljs-string">&quot;c&quot;</span> -&gt; <span class="hljs-number">3</span>)<br>println(map1)<br><br><span class="hljs-comment">// 遍历元素，打印键值对</span><br>map1.foreach(println)<br>map1.foreach((kv: (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)) =&gt; println(kv))<br><br><span class="hljs-comment">// 取出Map中所有的Key或者Value</span><br><span class="hljs-keyword">for</span>(key &lt;- map1.keys) println(<span class="hljs-string">s&quot;<span class="hljs-subst">$&#123;key&#125;</span> -&gt; <span class="hljs-subst">$&#123;map1.get(key)&#125;</span>&quot;</span>)<br><span class="hljs-keyword">for</span>(value &lt;-map1.values) println(<span class="hljs-string">s&quot;<span class="hljs-subst">$&#123;value&#125;</span> &quot;</span>)<br><br><span class="hljs-comment">// 通过key来访问value</span><br>println(map1.get(<span class="hljs-string">&quot;a&quot;</span>)) <span class="hljs-comment">// 得到Some对象</span><br>println(map1.get(<span class="hljs-string">&quot;a&quot;</span>).get) <span class="hljs-comment">// 得到确切的值</span><br>println(map1.get(<span class="hljs-string">&quot;d&quot;</span>).get) <span class="hljs-comment">// 先get(&quot;d&quot;)得到None，再进行get会报错</span><br>println(map1.getOrElse(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">0</span>)) <span class="hljs-comment">// 普通get没有会得到None，再进行get会报错，getOrElse不会，可以设置默认值</span><br><br>println(map1(<span class="hljs-string">&quot;c&quot;</span>)) <span class="hljs-comment">// 直接得到确切的值，没有则报错</span><br><br><span class="hljs-comment">// 合并Map</span><br><span class="hljs-keyword">val</span> map2 = map1 ++ <span class="hljs-type">Map</span>(<span class="hljs-string">&quot;d&quot;</span>-&gt;<span class="hljs-number">4</span>)<br>println(map2)<br></code></pre></td></tr></table></figure><ul><li>通过<code>get(key)</code>得到的是一个Some对象，如果没有找到则返回None</li><li>Some对象通过get可以得到确切的值</li></ul><h3 id="可变映射-mutable.map">可变映射 mutable.Map</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 创建map</span><br><span class="hljs-keyword">val</span> map1:mutable.<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = mutable.<span class="hljs-type">Map</span>(<span class="hljs-string">&quot;a&quot;</span>-&gt;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span>-&gt;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;c&quot;</span>-&gt;<span class="hljs-number">3</span>)<br>println(map1)<br><br><span class="hljs-comment">// 添加元素</span><br>map1.put(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">4</span>)<br>map1 += ((<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 注意是两个括号</span><br>println(map1)<br><br><span class="hljs-comment">// 删除元素</span><br>map1.remove(<span class="hljs-string">&quot;c&quot;</span>)<br>map1 -= <span class="hljs-string">&quot;d&quot;</span><br>println(map1)<br><br><span class="hljs-comment">// 修改元素</span><br>map1.put(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">-1</span>)<br>map1.update(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">-2</span>)<br>println(map1)<br><br><span class="hljs-comment">// 合并Map,合并的时候，相同的key，value以后面的为准，进行覆盖</span><br><span class="hljs-keyword">val</span> map2:mutable.<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = mutable.<span class="hljs-type">Map</span>(<span class="hljs-string">&quot;a&quot;</span>-&gt;<span class="hljs-number">11</span>, <span class="hljs-string">&quot;b&quot;</span>-&gt;<span class="hljs-number">22</span>, <span class="hljs-string">&quot;c&quot;</span>-&gt;<span class="hljs-number">33</span>)<br>map1 ++= map2<br>println(map1)<br></code></pre></td></tr></table></figure><ul><li><p>不可变中的访问等机制都支持</p></li><li><p>put方式会可能会进行覆盖，返回值是一个Option对象，可以得到返回之前的值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> maybeInt: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = map1.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">11</span>)<br>println(maybeInt.getOrELse(<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure></li></ul><h2 id="元组">元组</h2><p>元组可以理解为是一个容器，其中可以存放相同和不同类型的数据。在Scala中，元组最多只能有22个元素</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 构建元组</span><br><span class="hljs-keyword">val</span> tuple:(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Boolean</span>) = (<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-literal">true</span>)<br>println(tuple)<br><br><span class="hljs-comment">// 访问元组的元素(注意下标是从1开始)</span><br>println(tuple._1)<br>println(tuple._2)<br>println(tuple._3)<br><br><span class="hljs-comment">// 此处的下标为0</span><br>println(tuple.productElement(<span class="hljs-number">0</span>))<br><br><span class="hljs-comment">// 遍历元组数据</span><br><span class="hljs-keyword">for</span>(elem &lt;- tuple.productIterator) println(elem)<br></code></pre></td></tr></table></figure><ul><li>Map中存放的就是二元元组，<code>-&gt;</code>可以用来构建二元组</li><li>元组可以嵌套定义</li></ul><h2 id="队列">队列</h2><p>队列也分为可变和不可变，名称相同均为<code>Queue</code>，同样是存在的包不同。默认为不可变队列，可变队列为<code>mutable.Queue</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 创建队列</span><br><span class="hljs-keyword">val</span> que = <span class="hljs-keyword">new</span> mutable.<span class="hljs-type">Queue</span>[<span class="hljs-type">String</span>]()<br><br><span class="hljs-comment">// 入队</span><br>que.enqueue(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<br><br><span class="hljs-comment">// 出队</span><br>println(que.dequeue())<br></code></pre></td></tr></table></figure><h2 id="并行集合">并行集合</h2><p>Scala为了充分使用多核CPU，提供了并行集合，用于多核环境的并行计算。使用并行集合之后，在执行的时候会调用多个线程来加速执行。只需要在使用的集合类后添加<code>.par</code>方法即可。并行集合依赖于<code>scala.collection.parallel.immutable/mutable</code>，2.13版本之后不再通过标准库提供，需要单独下载。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> result1 = (<span class="hljs-number">0</span> to <span class="hljs-number">100</span>).map(_ =&gt; <span class="hljs-type">Thread</span>.currentThread.getName)<br><span class="hljs-keyword">val</span> result2 = (<span class="hljs-number">0</span> to <span class="hljs-number">100</span>).par.map(_ =&gt; <span class="hljs-type">Thread</span>.currentThread.getName)<br>println(result1)<br>println(result2)<br></code></pre></td></tr></table></figure><h2 id="集合常用函数">集合常用函数</h2><h3 id="基本属性和常用操作">基本属性和常用操作</h3><ul><li><code>length</code>：获取集合长度（线性序列才有长度）</li><li><code>size</code>：获取集合大小（所有集合类型都有大小）</li><li>遍历方式：下标遍历、元素遍历、迭代器遍历、<code>foreach</code></li><li><code>iterator</code>：迭代器</li><li><code>mkString</code>：生成字符串</li><li><code>contains</code>：是否包含</li></ul><h3 id="衍生集合">衍生集合</h3><p>衍生集合方法指的是调用操作之后得到的结果可能是一个集合</p><ul><li>获取集合的头元素<code>head</code>（元素）和剩下的尾<code>tail</code>（除去第一个元素构成的集合）。</li><li>集合最后一个元素<code>last</code>（元素）和除去最后一个元素的初始数据<code>init</code>（集合）。</li><li>反转<code>reverse</code>。</li><li>取前后n个元素<code>take(n) takeRight(n)</code></li><li>去掉前后n个元素<code>drop(n) dropRight(n)</code></li><li>交集<code>intersect</code></li><li>并集<code>union</code>，线性序列的话已废弃用<code>concat</code>连接。</li><li>差集<code>diff</code>，得到属于自己、不属于传入参数的部分。</li><li>拉链<code>zip</code>，得到两个集合对应位置元素组合起来构成二元组的集合，大小不匹配会丢掉其中一个集合不匹配的多余部分。（类似Python的zip）</li><li>滑窗<code>sliding(n, step = 1)</code>，框住特定个数元素，方便移动和操作。得到迭代器，可以用来遍历，每个迭代的元素都是一个n个元素集合。步长大于1的话最后一个窗口元素数量可能个数会少一些。</li></ul><h3 id="集合计算简单函数">集合计算简单函数</h3><ul><li><p>求和<code>sum</code> 求乘积<code>product</code>最小值<code>min</code> 最大值<code>max</code></p></li><li><p><code>maxBy(func)</code>支持传入一个函数获取元素并返回比较依据的值</p><blockquote><p>举例来说，元组默认就只会判断第一个元素，如果需要根据第二个元素判断，则返回第二个元素就行<code>xxx.maxBy(_._2)</code>。</p></blockquote></li><li><p>排序<code>sorted</code>，默认从小到大排序。从大到小排序<code>sorted(Ordering[Int].reverse)</code>。</p></li><li><p>按元素排序<code>sortBy(func)</code>，指定要用来做排序的字段。也可以再传一个隐式参数逆序<code>sortBy(func)(Ordering[Int].reverse)</code></p></li><li><p>自定义比较器<code>sortWith(cmp)</code>，比如按元素升序排列<code>sortWith((a, b) =&gt; a &lt; b)</code>或者<code>sortWith(_ &lt; _)</code>，按元组元素第二个元素升序<code>sortWith(_._2 &gt; _._2)</code>。</p></li></ul><h3 id="集合计算高级函数">集合计算高级函数</h3><ul><li>filter：遍历一个集合，并从中获取符合条件的元素组成一个新的集合</li><li>map：将集合中的每个元素通过某种映射关系得到另一个元素</li><li>flatten：将元素打散扁平化</li><li>flatMap：相当于先对每个集合进行map操作，然后再进行flatten操作</li><li>group：按照指定的规则对集合进行分组</li><li>reduce：依次将集合中的元素进行规约，最终得到一个输出</li><li>fold：与reduce类似，但是具有初始值</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> list = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment">// filter</span><br><span class="hljs-comment">// 选取偶数</span><br><span class="hljs-keyword">val</span> evenList = list.filter((elem: <span class="hljs-type">Int</span>) =&gt; &#123;<br>    elem % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>&#125;)<br>println(evenList)<br><span class="hljs-comment">// 选取奇数</span><br>println(list.filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>))<br><br><span class="hljs-comment">// map</span><br><span class="hljs-comment">// 把集合中每个数都乘2 / 都进行平方</span><br>println(list.map(_ * <span class="hljs-number">2</span>))<br>println(list.map(x =&gt; x * x))<br><br><span class="hljs-comment">// flatten</span><br><span class="hljs-keyword">val</span> nestedList: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">List</span>(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-type">List</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>), <span class="hljs-type">List</span>(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>))<br>println(nestedList.flatten)<br><br><span class="hljs-comment">// faltMap</span><br><span class="hljs-comment">// 将一组字符串进行分词，并保存成单词的列表</span><br><span class="hljs-keyword">val</span> strings: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(<span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-string">&quot;Hello Java&quot;</span>, <span class="hljs-string">&quot;Hello Scala&quot;</span>)<br>println(strings.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>)))<br><br><span class="hljs-comment">// groupBy</span><br><span class="hljs-comment">// 将list分成奇偶两组,得到的是一个Map结构</span><br><span class="hljs-keyword">val</span> groupMap: <span class="hljs-type">Map</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]] = list.groupBy(_ % <span class="hljs-number">2</span>)<br>println(groupMap)<br><br><span class="hljs-comment">// reduce</span><br><span class="hljs-comment">// 逐个相加,以下结果都是一样的</span><br>println(list.reduce(_ + _)) <span class="hljs-comment">// 1 + 2 + 3 + 4 = 10</span><br>println(list.reduceLeft(_ + _)) <span class="hljs-comment">// 1 + 2 + 3 + 4 = 10</span><br>println(list.reduceRight(_ + _)) <span class="hljs-comment">// (1 + (2 + (3 + 4))) = 10</span><br><span class="hljs-comment">// 逐个相减，注意顺序</span><br>println(list.reduce(_ - _)) <span class="hljs-comment">// 1 - 2 - 3 - 4 = -8</span><br>println(list.reduceLeft(_ - _)) <span class="hljs-comment">// 1 - 2 - 3 - 4 = -8</span><br>println(list.reduceRight(_ - _)) <span class="hljs-comment">// (1 - (2 - (3 - 4))) = -2</span><br><br><span class="hljs-comment">// fold，类似于reduce，但是可以指定初值，并且注意初值的位置</span><br>println(list.fold(<span class="hljs-number">10</span>)(_ + _)) <span class="hljs-comment">// 10 + 1 + 2 + 3 + 4 = 20</span><br>println(list.foldLeft(<span class="hljs-number">10</span>)(_ - _)) <span class="hljs-comment">// 10 - 1 - 2 - 3 - 4 = 0</span><br>println(list.foldRight(<span class="hljs-number">10</span>)(_ - _)) <span class="hljs-comment">// (1 - (2 - (3 - (4 - 10)))) = 8</span><br></code></pre></td></tr></table></figure><ul><li>注意foldRight和reduceRight的顺序</li><li>fold提供的初始值必须是同一类型，foldLeft中可以传入不同类型的初始值</li></ul><h2 id="集合应用案例">集合应用案例</h2><h3 id="定制map合并">定制Map合并</h3><p>Map的默认合并操作是使用后面的相同Key中的value进行覆盖，现在需要定制一个合并方式，逻辑为相同的Key进行value的叠加</p><p>（注意这里<code>foldLeft</code>的选用逻辑）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> map1 = <span class="hljs-type">Map</span>(<span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span> -&gt; <span class="hljs-number">4</span>)<br><span class="hljs-comment">// 注意map2应该是可变Map</span><br><span class="hljs-keyword">val</span> map2 = mutable.<span class="hljs-type">Map</span>(<span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-number">6</span>, <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-number">1</span>, <span class="hljs-string">&quot;c&quot;</span> -&gt; <span class="hljs-number">9</span>, <span class="hljs-string">&quot;d&quot;</span> -&gt; <span class="hljs-number">10</span>)<br><span class="hljs-comment">// 如果是res = xxx.fold(a)(op(x, y)),每次进行的操作是op(x, y)</span><br><span class="hljs-comment">// y是集合中的每个元素，x是之前得到结果，如果是第一次则是传入的a</span><br><span class="hljs-keyword">val</span> map3 = map1.foldLeft(map2)(<br>    (mergedMap, kv) =&gt; &#123;<br>        <span class="hljs-keyword">val</span> key = kv._1<br>        <span class="hljs-keyword">val</span> value = kv._2<br>        mergedMap(key) = mergedMap.getOrElse(key, <span class="hljs-number">0</span>) + value<br>        mergedMap<br>    &#125;<br>)<br><br>println(map3)<br></code></pre></td></tr></table></figure><h3 id="简单word-count">简单Word Count</h3><p>对字符串进行切分，之后统计每个词出现的次数，并取其中排名前三的结果</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> stringList = <span class="hljs-type">List</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-string">&quot;hello scala&quot;</span>, <span class="hljs-string">&quot;hello spark from scala&quot;</span>, <span class="hljs-string">&quot;hello flink form scala&quot;</span>)<br><br><span class="hljs-comment">// 对每个字符串进行切分，一个字符串得到一个word列表 map</span><br><span class="hljs-comment">// 将得到的列表进行扁平化 flatten</span><br><span class="hljs-comment">// 按照每个word进行分类 group</span><br><span class="hljs-comment">// 得到的Map可以计算出每个word的出现次数 map</span><br><span class="hljs-comment">// 得到一个Map(Word -&gt; times)，将其转换成list，排序取前3</span><br><span class="hljs-keyword">val</span> res = stringList<br>.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<br>.groupBy(word =&gt; word)<br>.map((kv: (<span class="hljs-type">String</span>, <span class="hljs-type">List</span>[<span class="hljs-type">String</span>])) =&gt; (kv._1, kv._2.length))<br>.toList<br>.sortWith(_._2 &gt; _._2)<br>.take(<span class="hljs-number">3</span>)<br>println(res)<br></code></pre></td></tr></table></figure><h3 id="进阶word-count">进阶Word Count</h3><p>原始输入中以及提供了部分出现次数的信息，利用这些信息，同样是完成上面WordCount的操作</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> tupleList: <span class="hljs-type">List</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = <span class="hljs-type">List</span>(<br>    (<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>),<br>    (<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-number">2</span>),<br>    (<span class="hljs-string">&quot;hello scala&quot;</span>, <span class="hljs-number">3</span>),<br>    (<span class="hljs-string">&quot;hello spark from scala&quot;</span>, <span class="hljs-number">1</span>),<br>    (<span class="hljs-string">&quot;hello flink from scala&quot;</span>, <span class="hljs-number">2</span>)<br>)<br><span class="hljs-comment">// 第一次map需要将词进行划分，并且带上自己的计数，同时需要进行扁平化</span><br><span class="hljs-keyword">val</span> res = tupleList<br>.flatMap((content: (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)) =&gt; &#123;<br>    <span class="hljs-keyword">val</span> strings = content._1.split(<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-comment">// 对分出来的每个词都需要生成一个描述计数(word, count)</span><br>    strings.map(word =&gt; (word, content._2))<br>&#125;)<br>.groupBy(content =&gt; content._1)<br>.map(content =&gt; &#123;<br>    <span class="hljs-keyword">val</span> word = content._1<br>    <span class="hljs-keyword">val</span> countList = content._2<br>    <span class="hljs-comment">// 计算countList中第二位的值的合计</span><br>    <span class="hljs-keyword">val</span> sum = countList.map(_._2).sum<br>    (word, sum)<br>&#125;).toList.sortWith(_._2 &gt; _._2).take(<span class="hljs-number">3</span>)<br><br>println(res)<br></code></pre></td></tr></table></figure><h1 id="scala与java中的容器转换">Scala与Java中的容器转换</h1><p>在Scala中我们经常会调用Java中的方法，但是这些方法可能返回的是Java中的容器对象。Scala中的容器与Java中的容器是可以相互转换的，这些转换可以通过一些方法很容易的完成。不过首先需要我们引入对应包：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.collection.<span class="hljs-type">JavaConverters</span>._<br></code></pre></td></tr></table></figure><p>之后可以调用对应的<code>asScala</code>和<code>asJava</code>方法，Java中的容器对象可以使用<code>asScala</code>方法，而Scala中的容器对象可以使用<code>asJava</code>方法。之后调用对应的<code>toxxx</code>方法就可以完成。举例来说，我现在有一个Java中的List数组，我想把它转化为Scala中的Array，则需要通过如下方式进行：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.collection.<span class="hljs-type">JavaConverters</span>._<br><br><span class="hljs-keyword">val</span> listInJava: java.util.<span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>(); <br><span class="hljs-comment">// Java中的ArrayList</span><br><br><span class="hljs-keyword">val</span> arrayInScala = listInJava.asScala.toArray;<br></code></pre></td></tr></table></figure><p>当然一些容器之间可以直接相互转换，而另一些容器之间则只支持单向的转换。转换关系如下，其中左边的是Scala中的容器对象，右边则是Java中的容器对象：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 双向转换</span><br><span class="hljs-type">Iterator</span>               &lt;=&gt;     java.util.<span class="hljs-type">Iterator</span><br><span class="hljs-type">Iterator</span>               &lt;=&gt;     java.util.<span class="hljs-type">Enumeration</span><br><span class="hljs-type">Iterable</span>               &lt;=&gt;     java.lang.<span class="hljs-type">Iterable</span><br><span class="hljs-type">Iterable</span>               &lt;=&gt;     java.util.<span class="hljs-type">Collection</span><br>mutable.<span class="hljs-type">Buffer</span>         &lt;=&gt;     java.util.<span class="hljs-type">List</span><br>mutable.<span class="hljs-type">Set</span>            &lt;=&gt;     java.util.<span class="hljs-type">Set</span><br>mutable.<span class="hljs-type">Map</span>            &lt;=&gt;     java.util.<span class="hljs-type">Map</span><br>mutable.<span class="hljs-type">ConcurrentMap</span>  &lt;=&gt;     java.util.concurrent.<span class="hljs-type">ConcurrentMap</span><br><br><span class="hljs-comment">// 单向转换</span><br><span class="hljs-type">Seq</span>           =&gt;    java.util.<span class="hljs-type">List</span><br>mutable.<span class="hljs-type">Seq</span>   =&gt;    java.util.<span class="hljs-type">List</span><br><span class="hljs-type">Set</span>           =&gt;    java.util.<span class="hljs-type">Set</span><br><span class="hljs-type">Map</span>           =&gt;    java.util.<span class="hljs-type">Map</span><br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><p><ahref="https://docs.scala-lang.org/zh-cn/overviews/collections/conversions-between-java-and-scala-collections.html">scala-lang-docs</a></p></li><li><p><ahref="http://xueai8.com/blog/21">Java中的List转化为Scala中的Array</a></p></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala学习笔记-核心特性(2)-面向对象</title>
    <link href="/2022/05/01/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/05/01/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="包管理">包管理</h2><h3 id="包声明">包声明</h3><p>在Scala中，同样存在包的概念。同Java一样，Scala的包具有如下的作用：</p><ul><li>区分相同名称的类</li><li>当类数量众多的时候，可以很好地管理类</li><li>能够控制访问范围</li></ul><p><strong>包声明语句</strong>：</p><p>Scala中有两种包管理的风格。</p><p>一种方式和Java的包管理风格相同，每个源文件属于一个包（这里并不要求包名和源文件所在路径一致），如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.syh.scala<br></code></pre></td></tr></table></figure><p>另一种方式是通过嵌套的风格表示层级关系，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com&#123;<br>    <span class="hljs-keyword">package</span> syh&#123;<br>        <span class="hljs-keyword">package</span> scala&#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种风格有如下特点：</p><ul><li>一个源文件中可以声明多个package</li><li>子包中的类可以直接访问父包中的内容，而无需导入包</li></ul><p>在下面的代码中，子包中访问父包的对象可以直接访问，父包访问子包的对象需要进行包的导入</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com &#123;<br><br>  <span class="hljs-keyword">import</span> com.syh.scala.<span class="hljs-type">Inner</span><br>  <span class="hljs-comment">// 父包访问子包的内容需要进行包的导入</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;xxx&quot;</span><br>    println(<span class="hljs-type">Inner</span>.id)<br>  &#125;<br>  <span class="hljs-keyword">package</span> syh &#123;<br>    <span class="hljs-keyword">package</span> scala &#123;<br>      <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> id = <span class="hljs-number">1</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>          <span class="hljs-comment">// 子包访问父包的内容无需进行包的导入</span><br>          println(<span class="hljs-type">Outer</span>.name)<br>        &#125;<br>      &#125;<br>    &#125;<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="包对象">包对象</h3><p>在Scala中可以为每个包定义一个<strong>同名</strong>的包对象，定义在这个包对象中的成员，可以作为对应包下所有class和object的共享变量，可以直接被访问</p><p>举例来说，现在为包<code>com.syh.scala</code>定义一个包变量</p><p>如果采用Java的包管理风格，则包对象一般定义在其对应包下的<code>pacakge.scala</code>文件中，包名是为前面的层级，其中包对象名称与报名保持一致，如下</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.syh<br><br><span class="hljs-keyword">package</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">scala</span></span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果采用嵌套方式管理包，则包对象可以定义在同一文件中，但是需要保证包对象与包声明在同一作用域中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com &#123;<br>  <span class="hljs-keyword">package</span> syh &#123;<br>    <span class="hljs-keyword">package</span> scala &#123;<br>      <br>    &#125;<br><br>    <span class="hljs-keyword">package</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">scala</span> </span>&#123;<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="包导入">包导入</h3><p>可以在任意位置导入（局部导入作用于代码块级别），也可以设置别名，可以选择性导入想要导入的内容，可以屏蔽某个类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> users._ <span class="hljs-comment">// 引入users包下的所有类</span><br><span class="hljs-keyword">import</span> users.<span class="hljs-type">User</span> <span class="hljs-comment">// 引入单个类</span><br><span class="hljs-keyword">import</span> user.&#123;<span class="hljs-type">User</span>, <span class="hljs-type">UserPreferences</span>&#125; <span class="hljs-comment">// 引入多个类</span><br><span class="hljs-keyword">import</span> users.&#123;<span class="hljs-type">UserPreferences</span> =&gt; <span class="hljs-type">UPrefs</span>&#125; <span class="hljs-comment">// 给引入的类取别名</span><br><span class="hljs-keyword">import</span> users.&#123;<span class="hljs-type">User</span> =&gt; _,_&#125; <span class="hljs-comment">// 屏蔽某个类，这里屏蔽了User</span><br></code></pre></td></tr></table></figure><p>所有的scala源文件默认导入以下的包：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> java.lang._<br><span class="hljs-keyword">import</span> scala._<br><span class="hljs-keyword">import</span> scala.<span class="hljs-type">Predef</span>._<br></code></pre></td></tr></table></figure><h2 id="面向对象">面向对象</h2><h3 id="类属性以及方法">类、属性以及方法</h3><p>回顾Java中的类定义，一个java源文件中只能有一个public的类，并且需要和文件同名。而在Scala中，一个scala源文件可以写多个类，并且没有public的类（scala中没有<code>public</code>关键字，后续会提到其中的权限控制细节）</p><p>Scala中的类定义基本语法如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">[访问修饰符] <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">类名</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>访问修饰符可选项有：private、protected以及默认，默认就是公有访问权限，无<code>pubilc</code>关键字</li></ul><p><strong>属性</strong>是类的一个组成部分，注意事项如下：</p><ul><li>属性也可以设置访问修饰符，默认为公有</li><li>如果需要设置规范的<code>setXXX</code>和<code>getXXX</code>方法，可以在属性前增加<code>@BeanProperty</code>注解，每个注解对应一个属性</li><li>公有属性可以直接被赋值和获取，但是在scala底层还是通过类似get和set的机制来完成的</li><li>成员变量在赋值的时候可以给值<code>_</code>，这表示给变量赋值为默认值。定义常量值则不能使用<code>_</code>，必须在定义的时候给定</li></ul><blockquote><p>封装：</p><ul><li>Java中的封装：将属性私有化，提供get和set方法</li><li>Scala中的封装：解决了Java中的冗余。scala中的公有属性，底层还是private，并通过get方法<code>obj.field()</code>和set方法<code>obj.field_=(value)</code>对其进行操作。因此在scala中并不推荐将属性设置为private。</li></ul><p>但是在Java中许多框架需要提供满足规范的getter和setter方法，这时候可以增加<code>@BeanProperty</code>注解来生成</p></blockquote><p><strong>方法</strong>也是类的一部分，注意事项如下：</p><ul><li><p>基本设置方法与函数定义一致</p></li><li><p>可以设置访问修饰符，放在def的前面</p></li></ul><p>完成类的定义之后，可以使用new来创建对象，语法相对简单。需要注意的是，如果使用了自动推导变量，则无法完成多态。使用多态需要显式声明。</p><h3 id="访问权限">访问权限</h3><p>在Java中，访问权限分为public、private、protected和默认。</p><p>在Scala中，访问权限分为private、protected和默认，权限描述如下：</p><ul><li>属性和方法的默认权限为public，但是无public关键字</li><li>private为私有权限，只有在类的内部和类的伴生对象可以访问</li><li>protected为受保护权限，Scala中的受保护权限比Java中更加严格，类内，子类可以访问，但是同一个包下无法访问</li><li>可以使用private[包名]来增加包访问权限，这样可以在对应包中访问</li></ul><h3 id="构造器">构造器</h3><p>Scala中类的构造器包括了<strong>主构造器</strong>和<strong>辅助构造器</strong></p><p><strong>主构造器</strong>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">类名</span>(<span class="hljs-params">形参列表</span>)</span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>主构造器即在类定义的右边就开始写了，需要注意的是，类内部的所有可执行语句都是主构造器的一部分。如果主构造器没有参数，则小括号可以省略。<strong>主构造器也可以添加访问修饰符，添加到参数列表<code>()</code>之前</strong>。</p><p><strong>主构造器参数</strong>：主构造器的形参包括以下三种类型</p><ul><li>未使用任何修饰符修饰，这个参数就是一个局部变量（相当于传入Java构造器方法中的变量）</li><li><code>var</code>修饰参数，表示参数作为类的成员属性使用，可以修改</li><li><code>val</code>修饰参数，表示参数作为类的只读属性使用，不可以修改</li></ul><p><strong>辅助构造器</strong>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">类名</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(形参列表)&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>辅助构造器的名称固定为this，可以有多个，编译器通过参数的个数和类型来进行区分。<strong>辅助构造器方法不能直接构建对象，必须直接或者间接调用主构造方法。</strong>构造器之间可以相互调用，但是被调用的构造器必须定义在前面。</p><p>注意事项：</p><ul><li>主构造器写在类定义上，一定是构造时最先被调用的构造器，方法体就是类定义</li><li>主构造器和辅助构造器是重载的方法，所以参数列表不能一致</li><li>可以定义和类名同名的方法，但是这就是一个普通方法</li><li>推荐使用scala风格的主构造器来编写参数</li><li>如果需要多种重载的构造器，则使用新的辅助构造器</li></ul><h2 id="继承和多态">继承和多态</h2><h3 id="继承">继承</h3><p>Scala中继承的语法与Java中相同，如下</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类名</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">父类名</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>子类会继承父类的属性和方法</li><li>同Java一样，Scala也是单继承的机制</li><li>在继承中，构造器的调用顺序为父类构造器 -&gt; 子类构造器</li></ul><blockquote><p>在子类中可以重写父类的方法和属性，使用override关键字修饰。但是只能使用override重写常量属性即<code>val</code>，变量属性<code>var</code>需要直接利用赋值<code>=</code>来修改</p></blockquote><h3 id="多态">多态</h3><p>在Scala中也有多态的实现，底层实现借助了动态绑定的机制。但是具体细节与Java中存在不同</p><ul><li>Java中：属性为静态绑定，方法为动态绑定</li><li>Scala中：属性和方法均为动态绑定</li></ul><h2 id="特殊类">特殊类</h2><h3 id="抽象类">抽象类</h3><p>抽象类的基本语法：</p><ul><li>定义抽象类：使用abstract关键字</li><li>定义抽象属性：一个属性没有初始化，则为抽象属性（一般属性必须要初始化）</li><li>定义抽象方法：只声明而没有实现的方法就是抽象方法</li></ul><p>注意事项：</p><ul><li><p>如果父类为抽象类，那么子类需要将抽象的属性和方法实现，否则子类也需要声明为抽象类</p></li><li><p>抽象类中可以有一般的方法和属性</p></li><li><p>需要区别<strong>实现</strong>和<strong>重写</strong>，实现抽象类的抽象方法不需要使用override关键字，重写非抽象方法需要使用override（当然可以都使用override关键字）</p></li><li><p>被实现的抽象属性可以是<code>val</code>也可以是<code>var</code>，被重写的一般属性只能是<code>var</code></p></li><li><p>子类中调用父类的方法需要使用<code>super</code>关键字</p></li></ul><h3 id="匿名子类">匿名子类</h3><p>与Java中的一致，可以通过包含带有定义或者重写的代码块方式来创建一个匿名的子类，举例如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span>/<span class="hljs-keyword">var</span> p: baseClass = <span class="hljs-keyword">new</span> baseClass &#123;<br>   <span class="hljs-keyword">override</span>...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="伴生对象">伴生对象</h3><p>Scala语言是完全面向对象的语言，其中没有静态的操作。但是为了能够和Java语言交互，就产生了一种特殊的对象来模拟静态，该对象为单例对象，且对象名与类名一致。这个单例对象称为这个类的伴生对象。类中所有的“静态”内容都可以放置在它的伴生对象中声明，由于对象名和类名一致，所以在使用的时候看似是“通过类名调用”</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">val</span> school = <span class="hljs-string">&quot;xxx&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过伴生对象，我们可以实现单例模式。实现单例模式的关键在于将构造器私有化，然后提供一个公共的静态方法来获取这个单例的类对象，此时我们可以将这个静态方法放在伴生对象中。并且我们可以使用一个特殊的方法<code>apply</code>，这个方法在调用的时候可以省略<code>.apply</code>（一个语法糖，只要是apply方法就可以省略，无论是伴生对象还是一般new的对象）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">var</span> person1:<span class="hljs-type">Person</span> = <span class="hljs-type">Person</span>()<br>    <span class="hljs-keyword">var</span> person2:<span class="hljs-type">Person</span> = <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;hahaha&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-title">private</span>(<span class="hljs-params">var name: <span class="hljs-type">String</span></span>)</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(): <span class="hljs-type">Person</span> = &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;xx&quot;</span>)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">Person</span> = &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(name)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中第三行和第四行中实际上是调用了Person伴生对象的apply方法，通过参数类型和个数来区别</p><h3 id="枚举类">枚举类</h3><p>需要继承<code>Enumeration</code>，其中使用Value类型来定义枚举值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">WorkDay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enumeration</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">MONDAY</span> = <span class="hljs-type">Value</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Monday&quot;</span>)<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">TUESDAY</span> = <span class="hljs-type">Value</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>)<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">THURSDAy</span> = <span class="hljs-type">Value</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Thrusday&quot;</span>)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">EnumClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-type">WorkDay</span>.<span class="hljs-type">MONDAY</span>) <span class="hljs-comment">// Monday</span><br>        println(<span class="hljs-type">WorkDay</span>.<span class="hljs-type">TUESDAY</span>) <span class="hljs-comment">// Tuesday</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用类">应用类</h3><p>需要继承<code>App</code>，其中包装了main方法，因此不需要显式定义main方法了，可以直接执行</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>    println(<span class="hljs-string">&quot;hello,world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="密封类">密封类</h3><p>在定义类的时候使用<code>sealed</code>进行修饰，这样这个类的子类必须和该类定义在同一个文件中</p><h2 id="特征trait">特征（Trait）</h2><p>在Scala中，采用特征（Trait）来代替接口的概念。</p><p>Scala中的Trait可以有抽象属性和方法，也可以有具体的属性和方法，一个类可以混入（mixin）多个特征。Scala中引入特质，一可以代替Java中的接口，第二也是对单继承机制的一种补充</p><h3 id="特征声明与基本语法">特征声明与基本语法</h3><p>特征声明语法如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">特征名</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>特征引入语法，分为有无父类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 没有父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">类名</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">特征1</span> <span class="hljs-keyword">with</span> <span class="hljs-title">特征2</span> <span class="hljs-keyword">with</span> <span class="hljs-title">特征3</span></span><br><br><span class="hljs-comment">// 有父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">类名</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">父类</span> <span class="hljs-keyword">with</span> <span class="hljs-title">特征1</span> <span class="hljs-keyword">with</span> <span class="hljs-title">特征2</span> <span class="hljs-keyword">with</span> <span class="hljs-title">特征3</span></span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li><p>父类和特征是同等地位</p></li><li><p>在特征中可以声明抽象属性、抽象方法、一般属性、一般方法</p></li><li><p>所有的Java接口都可以当作Scala的特征使用</p></li><li><p>匿名子类也可以引入特征</p></li><li><p>特征和基类或者多个特征中存在重名的属性或者方法，则需要在子类中进行覆写来进行冲突解决</p></li></ul><blockquote><p>特征和抽象类的区别：</p><ul><li>优先使用特征，一个类扩展多个特征是很方便的，但是只能扩展一个抽象类</li><li>如果需要构造函数参数，则使用抽象类。因为抽象类可以定义带参数的构造函数，而特征不行</li></ul></blockquote><h3 id="特征叠加">特征叠加</h3><p>由于一个类可以混多个trait，并且trait中可以有具体的属性和方法，如果混入的特征中具有相同的方法，必然会出现继承冲突问题，冲突分为以下两种：</p><p><strong>简单冲突</strong>：一个类混入的两个特征中具有相同的方法，且两个特征之间没有任何关系。解决这类冲突问题，直接在类中重写冲突的方法，可以写自己的逻辑，也可以通过<code>super</code>调用对应特征的方法</p><img src="/2022/05/01/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AE%80%E5%8D%95%E5%86%B2%E7%AA%81.png" class="" title="简单冲突"><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">TraitA</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>() = &#123;<br>    println(<span class="hljs-string">&quot;I am TraitA&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">TraitB</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>() = &#123;<br>    println(<span class="hljs-string">&quot;I am TraitB&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TraitA</span> <span class="hljs-keyword">with</span> <span class="hljs-title">TraitB</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-string">&quot;I am Sub&quot;</span>)<br>  &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> sub = <span class="hljs-keyword">new</span> <span class="hljs-type">Sub</span><br>    sub.sayHi()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序通过重写自己的逻辑来解决冲突，输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">I am Sub<br></code></pre></td></tr></table></figure><p>输出符合我们的直觉。前面提到还有另一种方式，即可以利用super来调用特征的实现，这样我们就很自然要联想到这样会调用哪一个实现，下面将代码进行修改，仅修改Sub类中的实现如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TraitA</span> <span class="hljs-keyword">with</span> <span class="hljs-title">TraitB</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">super</span>.sayHi()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的输出如下，我们可以看到实际上默认的调用是调用了最后一个with进来的特征的实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">I am TraitB<br></code></pre></td></tr></table></figure><p>当然我们还可以在调用super的时候通过方括号<code>[]</code>来显式指定调用哪一个实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TraitA</span> <span class="hljs-keyword">with</span> <span class="hljs-title">TraitB</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">super</span>[<span class="hljs-type">TraitA</span>].sayHi()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自然得到输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">I am TraitA<br></code></pre></td></tr></table></figure><p><strong>菱形继承</strong>：一个类混入的两个特征中具有相同的方法，并且这两个特征继承自相同的特征，即所谓的菱形继承问题。解决这类冲突问题，Scala采用了特征叠加的策略。</p><img src="/2022/05/01/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF.png" class="" title="菱形继承"><p>考察如下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">TraitC</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>() = &#123;<br>    println(<span class="hljs-string">&quot;I am TraitC&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">TraitA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TraitC</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>() = &#123;<br>    <span class="hljs-keyword">super</span>.sayHi()<br>    println(<span class="hljs-string">&quot;I am TraitA&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">TraitB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TraitC</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>() = &#123;<br>    <span class="hljs-keyword">super</span>.sayHi()<br>    println(<span class="hljs-string">&quot;I am TraitB&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TraitA</span> <span class="hljs-keyword">with</span> <span class="hljs-title">TraitB</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">super</span>.sayHi()<br>  &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> sub = <span class="hljs-keyword">new</span> <span class="hljs-type">Sub</span><br>    sub.sayHi()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然我们可以在Sub中实现自己的逻辑，那么就正常按照逻辑输出。这里我们考虑的是在使用super的默认场景，我们得到的输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">I am TraitC<br>I am TraitA<br>I am TraitB<br></code></pre></td></tr></table></figure><p>看起来是都运行了，并且顺序也有所讲究。实际上，Scala中对这种情况的处理采用了特征叠加的策略，当一个类混入多个特征的时候，Scala会对其所有的特征以及其父特征按照一定的顺序进行排序，按照举例代码来说，排序规则如下：</p><ol type="1"><li>列出混入的第一个特征的继承关系，作为临时叠加顺序：<code>TraitA -&gt; TraitC</code></li><li>列出混入的第二个特征的继承关系，并将该顺序叠加到上一步顺序的前面，其中已经出现的特征将不再重复：<code>TraitB -&gt; TraitA -&gt; TraitC</code></li><li>之后将子类放在临时叠加顺序的最后一个，得到最终的叠加顺序：<code>Sub -&gt; TraitB -&gt; TraitA -&gt; TraitC</code></li></ol><p>之后代码执行的时候，其中的<code>super</code>并不是标识父对象，而是表示在叠加顺序中的下一个。</p><p>当然，如果要指定调用某一个混入特征中的方法，同样可以利用<code>[]</code>来增加约束，但是需要注意只能指定有直接关系的特征。（不能指定TraitC）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TraitA</span> <span class="hljs-keyword">with</span> <span class="hljs-title">TraitB</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">super</span>[<span class="hljs-type">TraitA</span>].sayHi()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">I am TraitC<br>I am TraitA<br></code></pre></td></tr></table></figure><h3 id="特征自身类型">特征自身类型</h3><p>特征的自身类型能够实现依赖注入的功能。一个类或者特征指定了自身类型的话，它的对象和子类对象就会拥有这个自身类型中所有的属性和方法。这种方式是将一个类或者特征插入到另一个类或者特征中，属性和方法就像直接复制插入过来一样，能够直接使用，但<strong>不是继承</strong>，也不能使用多态。</p><p>举例如下：这里的语法中，<code>_</code>位置是别名定义，也可以是其他任何的字符</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, val password: <span class="hljs-type">String</span></span>)</span><br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>  _: <span class="hljs-type">User</span> =&gt;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span></span>() = &#123;<br>    println(<span class="hljs-string">s&quot;insert into db: <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;password&#125;</span>&quot;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterUser</span>(<span class="hljs-params">name:<span class="hljs-type">String</span>, password:<span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, password</span>) <span class="hljs-keyword">with</span> <span class="hljs-title">UserDao</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> user = <span class="hljs-keyword">new</span> <span class="hljs-type">RegisterUser</span>(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>)<br>    user.insert()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">insert into db: xxx 123456<br></code></pre></td></tr></table></figure><p>由于特征UserDao中指定的特征自身类型为User，因此它可以访问其中的成员变量。但是在extends的时候，不能单独extendsUserDao特征，还需要一个User对象才是合法操作</p><h2 id="扩展">扩展</h2><h3 id="类型检查和转换">类型检查和转换</h3><ul><li>判断类型：<code>obj.isInstanceOf[T]</code>，确切匹配的类型或者父类都返回true。</li><li>转换类型：<code>obj.asInstance[T]</code>，转换为目标类型。</li><li>获取类名：<code>classOf[T]</code>，得到类对应的<code>Class</code>对象<code>Class[T]</code>，转字符串结果是<code>class package.xxx.className</code>。</li><li>获取对象的类：<code>obj.getClass</code></li></ul><blockquote><p>检查的都是运行时类型</p></blockquote><h3 id="定义类型别名">定义类型别名</h3><p>使用type关键字可以定义新的数据类型名称，本质上是一个类型的别名</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">myString</span> </span>= <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> s: myString = <span class="hljs-string">&quot;abc&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala学习笔记-核心特性(1)-函数式编程</title>
    <link href="/2022/04/30/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/04/30/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="函数式编程简介">函数式编程简介</h2><p>不同范式的对比：</p><ul><li>面向过程：按照步骤按照顺序解决问题</li><li>面向对象：分解对象、行为、属性，然后通过对象关系以及行为调用来解决问题。耦合低，复用性高，可维护性强</li><li>函数式编程：面向对象和面向过程都是命令式编程，但是函数式编程并不关心具体的运行过程，更加关心数据之间的映射关系。纯粹的函数式编程语言中没有变量的概念，所有的量都是常量。整个执行过程就是在不停的进行表达式的求值，每一段程序都有返回值。（易于编程人员理解，相对地编译器处理起来比较复杂）</li></ul><blockquote><p>函数式编程的编程效率更高，并且由于函数式编程的不可变性，对于函数来说，输入固定则输出固定，与环境上下文等无关。利于并行处理，所以特别适用于大数据处理领域。</p><p>Scala将函数式编程和面向对象编程融合在一起。</p></blockquote><h2 id="函数基本语法">函数基本语法</h2><h3 id="基本语法">基本语法</h3><p>在Scala中，函数定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span></span>(arg1: <span class="hljs-type">Type1</span>, arg2:<span class="hljs-type">Type2</span>, ...): <span class="hljs-type">ReturnType</span> = &#123;<br>    ...<br>&#125;<br><span class="hljs-comment">// 举例</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    x + y<br>&#125;<br></code></pre></td></tr></table></figure><p>其中包括函数名称、函数参数和对应的类型、函数返回类型以及函数体。</p><blockquote><p>函数和方法的区别：</p><ul><li>完成某一功能的程序语句的集合称为函数</li><li>类中的函数称为方法</li><li>函数并没有重载和重写的概念，但是方法有</li></ul></blockquote><p>注意事项：</p><ol type="1"><li>Scala语言可以在任何的语法结构中声明任何的语法</li><li>Scala中函数可以嵌套定义，在Java中方法中不能再写方法</li><li>函数式编程语言中，函数是一等公民，可以像对象一样赋值，作为参数返回值等，可以在任何代码块中定义函数</li></ol><h3 id="函数参数">函数参数</h3><p>函数参数的情形：有参、无参、有返回值、无返回值（Unit）</p><p><strong>可变参数</strong>的写法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>(strs: <span class="hljs-type">String</span>*): <span class="hljs-type">Unit</span> = &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果参数列表存在多个参数，则将可变参数放置在最后</li></ul><blockquote><p>在Java中，如果一个方法的参数是可变参数，那么传入一个数组对象也是能够接收的，不过在Scala中，是不能将数组对象传入可变参数，需要而是需要增加<code>:_*</code>进行解析，例如我们希望能够使用可变参数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    test(args:_*)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>默认参数</strong>和<strong>具名参数</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>(a :<span class="hljs-type">Int</span> ,b :<span class="hljs-type">Int</span> = <span class="hljs-number">1</span>): <span class="hljs-type">Int</span> = &#123;<br>    a + b<br>&#125;<br><span class="hljs-comment">// 调用</span><br>test(a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><ul><li>一般情况下，将有默认值的参数放置在参数列表的后面（不满足顺序也不会报错）</li><li><strong>在Scala中有默认参数以及具名参数，但是在Java中没有类似的用法</strong></li></ul><h3 id="函数至简原则">函数至简原则</h3><ol type="1"><li>return可以省略、Scala会使用函数体的最后一行代码作为返回值</li><li>如果函数体只有一行代码，可以省略花括号</li><li>如果返回值类型能够推断出来，则可以省略</li><li>如果有return，则不能省略返回值类型，必须指定</li><li>如果函数中明确声明了返回Unit，那么即使函数体中使用了return关键字也不起作用</li><li>Scala如果期望是无返回值类型，可以省略等号（废弃）</li><li>无参函数声明可以不加括号，调用也可以不加（废弃）</li><li>不关心函数名称的时候，函数名称和def也可以省略</li></ol><h2 id="高阶函数">高阶函数</h2><p>在Scala中，函数是一等公民，我们可以<strong>定义函数</strong>、<strong>调用函数</strong>、将<strong>函数作为值传递</strong>、将<strong>函数作为参数</strong>进行传递、将<strong>函数作为返回值</strong></p><ul><li>注意这里函数作为参数，接收的类型该如何书写</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 定义函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-string">&quot;调用函数test1&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 调用函数</span><br>test1()<br><br><span class="hljs-comment">// 调用函数得到返回值并打印</span><br><span class="hljs-keyword">val</span> f: <span class="hljs-type">Unit</span> = test1()<br>println(f)<br><span class="hljs-comment">// 将函数整体作为值进行传递（得到一个Lambda函数对象）</span><br><span class="hljs-comment">// 需要加上下划线_,相当于把函数test1当成一个整体传入</span><br><span class="hljs-keyword">val</span> f1 = test1 _<br>println(f1)<br><span class="hljs-comment">// 如果明确变量类型，那么不使用下划线也可以</span><br><span class="hljs-keyword">val</span> f2: () =&gt; <span class="hljs-type">Unit</span> = test1<br>println(f2)<br><br><span class="hljs-comment">// 函数作为参数传递</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func1</span></span>(f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    f(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    a + b<br>&#125;<br><span class="hljs-comment">// func1需要传入一个函数作为参数，add是我们传进去的作为参数的函数</span><br><span class="hljs-comment">// 可以传入add _表示函数对象，但是由于类型确定，可以推断出这不是函数调用，因此可以不用冗余的_</span><br>println(func1(add _))<br>println(func1(add))<br><br><span class="hljs-comment">// 函数作为函数返回值返回</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func2</span></span>() = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func3</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;调用func3&quot;</span>)<br>    &#125;<br><br>    func3 _<br>&#125;<br><span class="hljs-comment">// 调用func2()得到返回值还是一个函数</span><br><span class="hljs-keyword">val</span> f3 = func2()<br><span class="hljs-comment">// f3是一个函数，还能够进行调用</span><br>println(f3)<br>f3()<br></code></pre></td></tr></table></figure><h2 id="匿名函数">匿名函数</h2><p>没有名称的函数就是匿名函数，也称为Lambda表达式，格式如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">(参数列表) =&gt; &#123;函数体&#125;<br></code></pre></td></tr></table></figure><ul><li>匿名函数定义的时候不能有函数的返回值类型</li><li>参数列表中的类型可以省略，会根据进行自动的类型推导</li><li>类型省略之后发现只有一个参数，则圆括号可以省略</li><li>匿名函数如果只有一行，则大括号也可以省略</li><li>如果参数在函数体中只出现一次，则参数省略，且后面的参数可以使用<code>_</code>进行代替</li><li><code>_</code>下划线必须按照顺序进行接收，使用下划线的时候必须省略参数列表和箭头</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myOP</span></span>(op: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    println(op(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>    op(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>&#125;<br><br>println(<span class="hljs-string">&quot;The Return Of myOp Is &quot;</span> + myOP((x, y) =&gt; &#123;<br>    x + y<br>&#125;))<br>println(<span class="hljs-string">&quot;The Return Of myOp Is &quot;</span> + myOP(&#123;<br>    _ + _<br>&#125;))<br></code></pre></td></tr></table></figure><h2 id="闭包和函数柯里化">闭包和函数柯里化</h2><p>闭包：如果一个函数，访问到了它的外部的局部变量的值，那么这个函数和它所处的环境包括那个变量称为闭包。</p><p>观察如下示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// f1的返回值是一个函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span></span>() = &#123;<br><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span></span>(b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>a + b<br>&#125;<br><br>f2 _<br>&#125;<br><br><span class="hljs-keyword">val</span> f = f1()<br>println(f(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p>函数<code>f1</code>的返回值是一个函数，通过f接收这个返回值后可以进行函数调用，因此最后得到的结果是<code>5+10=15</code>。但是按照常规分析，这里是存在问题的。上面存在函数的嵌套定义，但是并不存在函数的嵌套调用。我们在调用<code>f1()</code>的时候，并没有执行<code>f2</code>，只是得到了<code>f2</code>作为一个函数的返回值，因此此时<code>f1</code>的栈帧应该已经弹出了，后面再调用<code>f2</code>的时候理应无法访问到<code>f1</code>的局部变量，但是这里确确实实访问到了，这就是闭包的效果。</p><p>在Scala中，一切皆对象，因此一个函数实际上也是对象。我们调用一个函数，实际上在JVM的堆内存上有一个函数对象，里面存放了局部变量。后续调用<code>f2</code>的时候，虽然栈帧弹出了，但是堆上的对象还是存在的，因此能够访问到。这里堆上的函数对象，清除的工作依赖于GC机制。</p><p>与闭包概念一起出现的还有函数柯里化的概念。</p><p>函数柯里化（Currying）：指的是将一个参数列表的多个参数，变成多个参数列表的过程。也就是将普通的多参数函数变成高阶函数的过程。例如，上面的函数<code>f1</code>也可以进行柯里化，写成下面的样子，之后就可以连续调用。这样的写法更符合阅读习惯。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span></span>()(b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br>    a + b<br>&#125;<br><br><span class="hljs-keyword">val</span> f = f1()(<span class="hljs-number">5</span>)<br>println(f)<br></code></pre></td></tr></table></figure><h2 id="函数递归">函数递归</h2><p>递归：函数调用自身</p><ul><li>函数调用自身</li><li>必须要有跳出的逻辑</li><li>scala中的递归必须声明函数返回值类型</li></ul><p>在递归过程中，往往会导致栈中空间被大量占用。但是在一种情况下，Scala中可以对栈的占用进行优化，即尾递归的情形。</p><p>在传统的递归中，典型的模型是首先执行递归调用，然后获取递归调用的返回值并计算结果。这种方式下，在每次递归调用返回之前，我们并不能得到计算结果。如果一个函数所有的递归形式的调用都出现在函数的末尾，则这种情况称为尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性可以使得在递归过程中没有保存栈帧的必要，可以通过覆盖当前的栈帧而不是在其之上重新添加，因此所使用的栈空间就大大缩减，这使得实际的运行效率更高。</p><p>对尾递归的优化依赖于语言，递归可以写成尾递归的形式，在Scala中会对尾递归进行优化，Java中并没有这样的机制。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 正常递归计算阶乘</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> factorial(n - <span class="hljs-number">1</span>) * n<br>&#125;<br><br><span class="hljs-comment">// 改进成尾递归的形式</span><br><span class="hljs-meta">@tailrec</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tailFact</span></span>(n: <span class="hljs-type">Int</span>, res: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> tailFact(n - <span class="hljs-number">1</span>, res * n)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的注解<code>tailrec</code>会检查下面的递归函数是否满足尾递归的形式，如果不满足则会报错。在IDEA中也会智能检查尾递归和普通递归，函数旁边会显示不同的标志。</p><h2 id="控制抽象">控制抽象</h2><p>在Scala中存在值调用和名调用两种方式</p><ul><li>值调用：按值传递参数，计算值之后再进行传递</li><li>名调用：按名称传递参数，直接使用实参替换函数中使用形参的地方，相当于直接在预处理的时候替换，可以传递代码块</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 值传递</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f0</span></span>(a: <span class="hljs-type">Int</span>) = &#123;<br>    println(<span class="hljs-string">&quot;f0被调用&quot;</span>)<br>    println(<span class="hljs-string">&quot;a = &quot;</span> + a)<br>&#125;<br><br>f0(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// 名传递</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span></span>(a: =&gt; <span class="hljs-type">Int</span>) = &#123;<br>    println(<span class="hljs-string">&quot;f1被调用&quot;</span>)<br>    println(<span class="hljs-string">&quot;a=&quot;</span> + a)<br>    println(<span class="hljs-string">&quot;a=&quot;</span> + a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span></span>(): <span class="hljs-type">Int</span> = &#123;<br>    println(<span class="hljs-string">&quot;f2被调用&quot;</span>)<br>    <span class="hljs-number">2</span><br>&#125;<br><br>f1(<span class="hljs-number">10</span>)<br>f1(f2())<br>f1(&#123;<br>    println(<span class="hljs-string">&quot;代码块调用&quot;</span>)<br>    <span class="hljs-number">5</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>对应的输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">f0被调用<br>a = 10<br>f1被调用<br>a=10<br>a=10<br>f1被调用<br>f2被调用<br>a=2<br>f2被调用<br>a=2<br>f1被调用<br>代码块调用<br>a=5<br>代码块调用<br>a=5<br></code></pre></td></tr></table></figure><p>注意这里名调用中参数类型的指定，需要使用<code>=&gt;</code>，并且需要<strong>指定代码块或者参数的返回值</strong></p><p>我们可以利用名传递来实现一个while关键字的功能，见后面的应用举例</p><h2 id="惰性加载">惰性加载</h2><p>当函数返回值被声明为lazy的时候，函数的执行将被推迟，直到我们首次使用这个值，该函数才会被执行。这种函数被称为惰性函数。（注意，lazy不能修饰var类型的变量，只能修饰函数的返回值）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(n1: <span class="hljs-type">Int</span>, n2: <span class="hljs-type">Int</span>) = &#123;<br>    println(<span class="hljs-string">&quot;sum被执行&quot;</span>)<br>    n1 + n2<br>&#125;<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> res = sum(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>)<br>println(<span class="hljs-string">&quot;--------&quot;</span>)<br>println(<span class="hljs-string">&quot;res = &quot;</span> + res)<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">--------<br>sum被执行<br>res = <span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><h2 id="函数应用举例">函数应用举例</h2><h3id="模拟map映射filter过滤和reduce聚合">模拟Map映射、Filter过滤和Reduce聚合</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// map，将列表中的每个值映射为另外一个值</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(array: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>], op: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>): <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = &#123;<br>    <span class="hljs-keyword">for</span> (element &lt;- array) <span class="hljs-keyword">yield</span> op(element)<br>&#125;<br><br><span class="hljs-comment">// filter， 查看每个值是否能够加入列表</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(array: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>], op: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = &#123;<br>    <span class="hljs-keyword">for</span> (element &lt;- array <span class="hljs-keyword">if</span> op(element)) <span class="hljs-keyword">yield</span> element<br>&#125;<br><br><span class="hljs-comment">// reduce，将列表中的所有值进行两两规约</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(array: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>], op: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">var</span> res: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (element &lt;- array) res = op(res, element)<br>    res<br>&#125;<br><br><span class="hljs-comment">// 调用上面的函数，将列表中所有的值执行+1操作，去除其中的偶数，最后将它们全部相加</span><br><span class="hljs-keyword">val</span> array = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>println(map(array, (x: <span class="hljs-type">Int</span>) =&gt; &#123;<br>    x + <span class="hljs-number">1</span><br>&#125;).mkString(<span class="hljs-string">&quot;Array(&quot;</span>, <span class="hljs-string">&quot;, &quot;</span>, <span class="hljs-string">&quot;)&quot;</span>))<br>println(filter(array, (x: <span class="hljs-type">Int</span>) =&gt; &#123;<br>    x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span><br>&#125;).mkString(<span class="hljs-string">&quot;Array(&quot;</span>, <span class="hljs-string">&quot;, &quot;</span>, <span class="hljs-string">&quot;)&quot;</span>))<br>println(reduce(array, &#123;<br>    _ + _<br>&#125;))<br></code></pre></td></tr></table></figure><h3id="利用同一个函数实现在整数上的四则运算">利用同一个函数实现在整数上的四则运算</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intCalculate</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>, op: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    println(op(a, b))<br>    op(a, b)<br>&#125;<br><span class="hljs-comment">//实现加减乘除</span><br>intCalculate(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, (a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>) =&gt; &#123;<br>    a + b<br>&#125;)<br>intCalculate(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, (a, b) =&gt; &#123;<br>    a - b<br>&#125;)<br>intCalculate(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, &#123;<br>    _ * _<br>&#125;)<br>intCalculate(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>, &#123;<br>    _ / _<br>&#125;)<br></code></pre></td></tr></table></figure><h3id="利用名传递实现while关键字的功能">利用名传递实现while关键字的功能</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 内置的while</span><br><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span><br><span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">1</span>) &#123;<br>    print(n + <span class="hljs-string">&quot; &quot;</span>)<br>    n -= <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 自己实现while</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myWhile</span></span>(condition: =&gt; <span class="hljs-type">Boolean</span>)(op: =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">if</span> (condition) &#123;<br>        op<br>        myWhile(condition)(op)<br>    &#125;<br>&#125;<br><br>n = <span class="hljs-number">10</span><br>myWhile(n &gt;= <span class="hljs-number">1</span>) &#123;<br>    print(n + <span class="hljs-string">&quot; &quot;</span>)<br>    n -= <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala学习笔记-入门(2)-Scala基础语法</title>
    <link href="/2022/04/29/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-Scala%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/04/29/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-Scala%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="注释">注释</h2><p>Scala中的注释和Java中的完全一样，具有单行注释、多行注释和文档注释</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala">单行注释<br>    <span class="hljs-comment">//...</span><br>    <br>多行注释 不允许嵌套<br>    <span class="hljs-comment">/*...</span><br><span class="hljs-comment">    ...</span><br><span class="hljs-comment">    */</span><br><br>文档注释 注释内容可以被<span class="hljs-type">JDK</span>提供的工具javadoc所解析，生成一套一网页文件形式体现的该程序的说明文档，一般写在类<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* @author:xxx</span><br><span class="hljs-comment">* @version:1.0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="变量和常量">变量和常量</h2><p>在Java中，变量和常量语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 常量</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>在Scala中，变量和常量的语法如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 变量[variable]</span><br><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br><span class="hljs-comment">// 常量[value]</span><br><span class="hljs-keyword">val</span> b: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>在Scala中，变量和常量有如下的特点：</p><ul><li><p>声明变量的时候，类型可以省略，编译器会自动推导，即<strong>类型推导</strong></p></li><li><p>类型确定之后，就不能修改，该变量的类型不再改变</p></li><li><p><strong>变量声明的时候，必须要有初始值</strong></p></li><li><p>常量使用val声明，常量特性与Java中使用final关键字修饰的常量一致</p></li><li><p>引用类型的常量，不能改变常量指向的对象，但是可以改变对象的字段</p></li><li><p>建议：<strong>能够使用常量的地方就使用常量而不使用变量</strong></p></li></ul><blockquote><p>关于强数据类型、弱数据类型、动态类型和静态类型：</p><ul><li>强弱数据类型指的是语言对类型检查的严格程度：弱类型相对于强类型来说类型检查更不严格，会允许一些变量类型的隐式转换等</li><li>静态类型指编译器在编译阶段进行类型检查，动态类型指在执行过程中进行类型检查</li></ul></blockquote><h2 id="标识符的命名规范">标识符的命名规范</h2><p>在Scala中，标识符的命名规范比Java中多出了两条，具体命名规则如下：</p><ol type="1"><li>以字母或者下划线开头，后面可以接字母、数字、下划线（这点和和Java是一样的）</li><li>可以以操作符开头，但是必须只包含操作符（后续会看到这样做能够导致超级灵活的运算符重载）</li><li>使用反引号包括的任意字符串都可以作为标识符，即使是Scala中的关键字也可以</li></ol><blockquote><p>Scala中的关键字：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span><span class="hljs-keyword">import</span><span class="hljs-class"><span class="hljs-keyword">class</span><span class="hljs-title">object</span><span class="hljs-title">trait</span><span class="hljs-keyword">extends</span><span class="hljs-keyword">with</span><span class="hljs-title">type</span><span class="hljs-title">for</span></span><br><span class="hljs-keyword">private</span><span class="hljs-keyword">protected</span><span class="hljs-keyword">abstract</span><span class="hljs-keyword">sealed</span><span class="hljs-keyword">final</span><span class="hljs-keyword">implicit</span><span class="hljs-keyword">lazy</span><span class="hljs-keyword">override</span><br><span class="hljs-keyword">try</span><span class="hljs-keyword">catch</span><span class="hljs-keyword">finally</span><span class="hljs-keyword">throw</span><br><span class="hljs-keyword">if</span><span class="hljs-keyword">else</span><span class="hljs-keyword">match</span><span class="hljs-keyword">case</span><span class="hljs-keyword">do</span><span class="hljs-keyword">while</span><span class="hljs-keyword">return</span><span class="hljs-keyword">yield</span><br><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">val</span><span class="hljs-title">var</span></span><br><span class="hljs-keyword">this</span><span class="hljs-keyword">super</span><br><span class="hljs-keyword">new</span><br><span class="hljs-literal">true</span><span class="hljs-literal">false</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>其中Java没有的关键字：<code>object trait with implicit match yield def val var</code></p></blockquote><h2 id="字符串输出">字符串输出</h2><p>字符串的输出有三种基本方式：</p><ul><li>通过+号进行连接</li><li>利用printf输出模板字符串：通过<code>%</code>占位</li><li>使用插值字符串，通过<code>$&#123;&#125;</code>来获取变量值，插值表达式中可以进行变量的运算</li></ul><p>以上三种方式可以将变量值与字符串进行拼接，同时可以综合使用单行和多行的字符串</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> words: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;HaHa&quot;</span><br><span class="hljs-keyword">val</span> age: <span class="hljs-type">Int</span> = <span class="hljs-number">18</span><br><br><span class="hljs-comment">// 使用 + 拼接</span><br>println(<span class="hljs-string">&quot;I say &quot;</span> + words + <span class="hljs-string">&quot; I am &quot;</span> + age)<br><br><span class="hljs-comment">// 可以使用 * 重复多个字符串</span><br>println(words * <span class="hljs-number">4</span>)<br><br><span class="hljs-comment">// 使用字符串模板</span><br>printf(<span class="hljs-string">&quot;I say %s I am %d&quot;</span>, words, age)<br>println()<br><br><span class="hljs-comment">// 使用插值字符串,使用s开头</span><br>println(<span class="hljs-string">s&quot;I say <span class="hljs-subst">$&#123;words&#125;</span> I am <span class="hljs-subst">$&#123;age + 2&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>在scala中提供的两种特殊字符串，s字符串和raw字符串。在s字符串中，可以使用插值表达式。而raw字符串与s字符串类似，同样可以使用插值表达式，只不过raw字符串不会进行转义。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> num: <span class="hljs-type">Double</span> = <span class="hljs-number">1.23456</span><br>println(<span class="hljs-string">s&quot;num = <span class="hljs-subst">$&#123;num&#125;</span> \n 1&quot;</span>)<br>println(<span class="hljs-string">raw&quot;num = <span class="hljs-subst">$&#123;num&#125;</span> \n 1&quot;</span>)<br></code></pre></td></tr></table></figure><p>对应输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">num = 1.23456<br> 1<br>num = 1.23456 \n 1<br></code></pre></td></tr></table></figure><p>还可以使用多行字符串<code>"""..."""</code>，获得更加格式化的输出：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-keyword">val</span> age: <span class="hljs-type">Int</span> = <span class="hljs-number">18</span><br><span class="hljs-keyword">val</span> s =<br><span class="hljs-string">s&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">        |select</span><br><span class="hljs-string">        |    name,</span><br><span class="hljs-string">        |    age</span><br><span class="hljs-string">        |from user</span><br><span class="hljs-string">        |     where name = $&#123;name&#125; and age = $&#123;age + 2&#125;</span><br><span class="hljs-string">        |&quot;</span><span class="hljs-string">&quot;&quot;</span>.stripMargin<br>println(s)<br></code></pre></td></tr></table></figure><p>其中<code>|</code>表示每一行的开头，<code>.stripMargin</code>为一个方法调用，输出结果如下，注意第一行的空行对应上面代码的第四行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>select<br>    name,<br>    age<br>from user<br>     where name = xxx and age = 20<br></code></pre></td></tr></table></figure><h2 id="输入">输入</h2><h3 id="键盘输入">键盘输入</h3><p>基本语法，利用<code>StdIn</code>提供的方法，例如<code>StdIn.readLine()</code>、<code>StdIn.readShort()</code>、<code>StdIn.readDounle()</code>等，需要引入包<code>scala.io.StdIn</code></p><h3 id="文件输入和输出">文件输入和输出</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> java.io.<span class="hljs-type">File</span>, <br><span class="hljs-keyword">import</span> java.io.<span class="hljs-type">PrintWriter</span><br><span class="hljs-keyword">import</span> scala.io.<span class="hljs-type">Source</span><br><span class="hljs-comment">// 读取文件</span><br><span class="hljs-type">Source</span>.fromFile(<span class="hljs-string">&quot;xxx&quot;</span>).foreach(print)<br><br><span class="hljs-comment">// 写入文件</span><br><span class="hljs-keyword">val</span> writer = <span class="hljs-keyword">new</span> <span class="hljs-type">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">File</span>(<span class="hljs-string">&quot;xxxx&quot;</span>))<br>writer.write(<span class="hljs-string">&quot;content&quot;</span>)<br>writer.close()<br></code></pre></td></tr></table></figure><h2 id="数据类型">数据类型</h2><h3 id="数据类型概览">数据类型概览</h3><p>在Java中，数据类型分为基本数据类型和引用类型，基本数据类型对应还有包装类。由于基本数据类型的存在，Java可以认为并不是完全意义上的面向对象，Java中基本类型和引用类型并没有共同的祖先，包装类和引用数据类型的共同祖先才是Object类</p><p>在Scala中，一切数据都是对象。</p><img src="/2022/04/29/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-Scala%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Scala%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" class="" title="Scala数据类型"><ul><li>一切数据都是对象，都是Any的子类</li><li>在Scala中数据类型分为两大类：数值类型（AnyVal）和引用类型（AnyRef），但是两者都是对象</li><li>图中，实线表示继承关系，而虚线表示隐式的自动类型转换</li><li><code>String</code>属于引用类型（AnyRef），而在Scala中设置了一个<code>StringOps</code>，属于数值类型，是对Java中String的增强</li><li>Unit属于AnyVal中的空值、Null属于AnyRef中的空值，是所有AnyRef的子类</li><li>Noting是所有数据类型的子类</li></ul><h3 id="整数类型">整数类型</h3><ul><li>Byte：1字节</li><li>Short：2字节</li><li>Int：4字节（不同于Java中的Integer）</li><li>Long：8字节</li></ul><blockquote><p>整数默认为Int</p></blockquote><h3 id="浮点类型">浮点类型</h3><ul><li>Float：4字节</li><li>Double：8字节</li></ul><blockquote><p>浮点数默认为Double</p></blockquote><h3 id="字符类型">字符类型</h3><ul><li>Char：2字节</li></ul><h3 id="布尔类型">布尔类型</h3><ul><li>Boolean：1字节，允许取值true和false</li></ul><h3 id="空类型">空类型</h3><table><thead><tr class="header"><th>数据类型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>Unit</td><td>表示没有值，等同于void，用作不返回任何结果的方法和结果类型。Unit只有一个实例值，输出成<code>()</code></td></tr><tr class="even"><td>Null</td><td>表示空引用，只有一个实例<code>null</code></td></tr><tr class="odd"><td>Nothing</td><td>Nothing类型是其他任何类型的子类型，当一个函数确定没有<strong>正常</strong>的返回值，如抛出异常等，就可以利用Noting来指定返回类型</td></tr></tbody></table><ul><li><strong>Unit</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doNoting</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>println(<span class="hljs-string">&quot;Do Nothing&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">val</span> unit: <span class="hljs-type">Unit</span> = doNoting()<br>println(unit)<br></code></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Do Nothing<br>()<br></code></pre></td></tr></table></figure><ul><li><strong>Null</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> str = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(<span class="hljs-string">&quot;haha&quot;</span>)<br>str = <span class="hljs-literal">null</span> <span class="hljs-comment">// 正确</span><br><br><span class="hljs-keyword">var</span> n: <span class="hljs-type">Int</span> = <span class="hljs-literal">null</span> <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><ul><li><strong>Nothing</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>: <span class="hljs-type">Nothing</span> = &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型转换">类型转换</h3><p>当Scala程序在进行赋值或者运算的时候，精度小的类型会自动转换成精度大的数值类型，这就是自动类型转换（隐式转换）。与Java中类似。</p><ul><li>自动类型提升：多种数据类型混合运算，自动提升到精度最大的数据类型。</li><li>高精度赋值到低精度，直接报错。</li><li>除了图中的隐式类型转换，都需要强制类型转换。</li><li><code>Byte Short Char</code>计算时会直接提升为<code>Int</code>。</li><li><code>Boolean</code>不能参与整数浮点运算，不能隐式转换为整数。</li></ul><h3 id="强制类型转换">强制类型转换</h3><p>强制类型将数据由高精度转换为低精度，可能造成精度降低或者溢出。</p><p>强制类型转换利用到<code>.toXXX</code>，实际上也是一个方法调用的形式，此时的数值均为对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 数值类型转换</span><br><span class="hljs-keyword">var</span> n1: <span class="hljs-type">Double</span> = <span class="hljs-number">5.4321</span><br><span class="hljs-keyword">var</span> n2: <span class="hljs-type">Int</span> = n1.toInt<br><br><span class="hljs-comment">// 数值类型转化为String</span><br><span class="hljs-keyword">val</span> s1 = n1.toString<br><span class="hljs-keyword">val</span> s2 = n2.toString<br><span class="hljs-keyword">val</span> s3 = n1 + <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment">// String转化为数值类型</span><br><span class="hljs-keyword">val</span> n3 = s1.toDouble<br><span class="hljs-keyword">val</span> n4 = s2.toInt<br></code></pre></td></tr></table></figure><h2 id="运算符">运算符</h2><h3 id="基本运算符">基本运算符</h3><p>Scala中的运算符与Java基本相同，只有个别在细节上存在不同</p><ul><li><p>算术运算符：<code>+ -  * / %</code></p><blockquote><p><code>*</code>可以利用在字符串重复上</p></blockquote></li><li><p>关系运算：<code>== != &lt; &gt; &lt;= &gt;=</code></p><blockquote><p><code>==</code>的测试：</p><ul><li>在Java中，<code>==</code>可以比较两个基本数据类型的值，也可以比较两个引用类型的地址</li><li>在Scala中，<code>==</code>相当于equals的调用，比较的更多是值（看对应的equals的实现）</li><li>如果需要比较地址的话，需要使用<code>eq</code></li></ul><p>测试代码（注意这里的new）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> s1: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-keyword">val</span> s2: <span class="hljs-type">String</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(<span class="hljs-string">&quot;123&quot;</span>)<br><br>println(s1==s2)<br>println(s1.equals(s2))<br>println(s1.eq(s2))<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">true<br>true<br>false<br></code></pre></td></tr></table></figure></blockquote></li><li><p>逻辑运算：<code>&amp;&amp; || !</code>，支持短路运算</p></li><li><p>赋值运算：<code>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= !=</code></p><blockquote><p><strong>注意</strong>：在Scala中没有<code>++ --</code>操作符，相关功能使用<code>+= -=</code>来实现</p></blockquote></li><li><p>位运算：<code>&amp; | ^ ~ &lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></p></li></ul><h3 id="运算符的本质">运算符的本质</h3><p>在Scala中其实是没有运算符的，所有的运算符都是方法调用</p><ul><li>当调用对象的方法时，<code>.</code>可以省略</li><li>如果函数参数只有一个或者没有的时候，<code>()</code>可以省略</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> n: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br><span class="hljs-comment">// 标准的加法运算</span><br>println(n.+(<span class="hljs-number">1</span>))<br>println(n + (<span class="hljs-number">1</span>))<br>println(n + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p>在Scala中还有一个非常常用的运算符<code>:=</code>。这个运算符并不是内置的运算符，通常使用者会将它进行重载，将其定义为任何他们喜欢的意思。这个符号在其他语言中经常被用作赋值运算符。</p></blockquote><h2 id="流程控制">流程控制</h2><h3 id="分支控制">分支控制</h3><p><code>if- else if -else</code> 代码块，使用方式基本与Java相同</p><ul><li>与Java不同之处，Scala中<code>if-else</code>语句有返回值，返回值定义为执行到的最后一个语句的返回值</li><li>可以强制要求返回Unit类型，此时忽略最后一个表达式的值，直接返回Unit</li><li>Scala中没有三元条件运算符<code>?:</code>，可以直接使用一行<code>if else</code>来完成</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> n: <span class="hljs-type">Int</span> = <span class="hljs-number">18</span><br><span class="hljs-comment">// if-else语句返回值</span><br><span class="hljs-keyword">val</span> s1 = <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">10</span>) &#123;<br>    println(<span class="hljs-string">&quot;into if&quot;</span>)<br>    <span class="hljs-string">&quot;IF&quot;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    println(<span class="hljs-string">&quot;into else&quot;</span>)<br>    <span class="hljs-string">&quot;ELSE&quot;</span><br>&#125;<br>println(<span class="hljs-string">&quot;s1=&quot;</span> + s1)<br>println(<span class="hljs-string">&quot;======&quot;</span>)<br><br><span class="hljs-comment">// 强制返回Unit</span><br><span class="hljs-keyword">val</span> s2: <span class="hljs-type">Unit</span> = <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">10</span>) &#123;<br>    println(<span class="hljs-string">&quot;into if&quot;</span>)<br>    <span class="hljs-string">&quot;IF&quot;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    println(<span class="hljs-string">&quot;into else&quot;</span>)<br>    <span class="hljs-string">&quot;ELSE&quot;</span><br>&#125;<br>println(<span class="hljs-string">&quot;s2=&quot;</span> + s2)<br>println(<span class="hljs-string">&quot;======&quot;</span>)<br><br><span class="hljs-comment">// if-else代替?:</span><br><span class="hljs-keyword">val</span> a: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">val</span> b: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span><br><span class="hljs-keyword">val</span> max = <span class="hljs-keyword">if</span> (a &gt; b) a <span class="hljs-keyword">else</span> b<br>println(<span class="hljs-string">s&quot;max of <span class="hljs-subst">$&#123;a&#125;</span> and <span class="hljs-subst">$&#123;b&#125;</span> is <span class="hljs-subst">$&#123;max&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">into if<br>s1=IF<br>======<br>into if<br>s2=()<br>======<br>max of 1 and 2 is 2<br></code></pre></td></tr></table></figure><blockquote><p>Scala中没有Switch，而是使用模式匹配来处理，这部分会在后面进行讲解</p></blockquote><h3 id="循环控制">循环控制</h3><h4 id="for循环">For循环</h4><p>Scala中为for循环这一常见的控制结构提供了非常多的特性，这些for循环的特性被成为for推导式</p><ul><li><p><strong>范围数据循环</strong></p><p>范围数据循环可以对比Python中的Range，下面的循环背后是得到了一个Range对象，每次给循环变量赋值对应的值。可以指定是否包含对应的右边界，可以指定步长</p><p><strong>to</strong>：包含右边界</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) &#123;<br>    print(i)<br>&#125;<br><span class="hljs-comment">// 结果为:12345678910</span><br></code></pre></td></tr></table></figure><p><strong>until</strong>：不包含右边界</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> until  <span class="hljs-number">10</span>) &#123;<br>    print(i)<br>&#125;<br><span class="hljs-comment">// 结果为:123456789</span><br></code></pre></td></tr></table></figure><p>上面的代码等价于</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-keyword">new</span> <span class="hljs-type">Range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>)) &#123;<br>    print(i)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>循环步长</strong></p><p>在循环中可以指定步长，通过<strong>by</strong>（步长不能为0）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span> by <span class="hljs-number">2</span>) &#123;<br>    print(i)<br>&#125;<br><span class="hljs-comment">// 结果为:13579</span><br></code></pre></td></tr></table></figure><p>可以指定负数步长，利用负数步长可以完成逆序输出</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span> by <span class="hljs-number">-1</span>) &#123;<br>    print(i)<br>&#125;<br><span class="hljs-comment">// 结果为:(空，啥也没有)</span><br><br><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">10</span> to <span class="hljs-number">1</span> by <span class="hljs-number">-1</span>) &#123;<br>    print(i)<br>&#125;<br><span class="hljs-comment">// 结果为:10987654321</span><br></code></pre></td></tr></table></figure><p>也可以利用reverse指定逆序输出</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span> by <span class="hljs-number">2</span> reverse) &#123;<br>    print(i)<br>&#125;<br><span class="hljs-comment">// 结果为:97531</span><br></code></pre></td></tr></table></figure><p>步长可以设置为浮点数，但是需要指定循环范围的类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span>(i &lt;- <span class="hljs-number">1.0</span> to <span class="hljs-number">5.0</span> by <span class="hljs-number">0.5</span>)&#123;<br>    print(i + <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br><span class="hljs-comment">// 结果为:1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>循环守卫</strong></p><p>循环守卫，即循环保护式，也称条件判断式，只有满足条件才进入循环体内部，否则不进入。相当于在进入循环之前就进行判断，类似于<code>continue</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span> <span class="hljs-keyword">if</span> i != <span class="hljs-number">2</span>) &#123;<br>    print(i)<br>&#125;<br><span class="hljs-comment">// 结果为:1345</span><br></code></pre></td></tr></table></figure></li><li><p><strong>嵌套循环</strong></p><p>嵌套循环可以类似于Java中嵌套实现，也可以将嵌套合并到一个for中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span>) &#123;<br>    <span class="hljs-keyword">for</span> (j &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span>) &#123;<br>        print(i + j + <span class="hljs-string">&quot; &quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 结果为:2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9 6 7 8 9 10 </span><br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span>; j &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span>) &#123;<br>    print(i + j + <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>引入变量</strong></p><p>可以在for推导式中引入变量</p><ul><li>for推导式中一行有多个表达式时，使用<code>;</code>来隔断逻辑</li><li>for推导式中，当只包含单一表达式的时候使用圆括号<code>()</code>，当有多个条件的时候使用花括号<code>&#123;&#125;</code>，并且每一行一个表达式</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span>; j = <span class="hljs-number">5</span> - i) &#123;<br>    print(j + <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br><span class="hljs-comment">// 结果为:4 3 2 1 0</span><br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> &#123;<br>    i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span><br>    j = <span class="hljs-number">5</span> - i<br>&#125; &#123;<br>    print(j + <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>循环返回值</strong></p><p>单独循环表达式的返回值是Unit，但是可以使用yield来在循环中返回，可以类比Python中的列表推导（注意：与Python中的yield不同）。在循环中使用yield，会将每次循环的结果加入一个List中，循环完毕之后再返回。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> res = <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span>) &#123;<br>&#125;<br>print(res)<br><span class="hljs-comment">// 结果为:()</span><br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> res = <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span>) <span class="hljs-keyword">yield</span> i<br>print(res)<br><span class="hljs-comment">// 结果为:Vector(1, 2, 3, 4, 5)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="while循环">While循环</h4><p><code>while</code>和<code>do while</code>：</p><ul><li>这两个关键字的用法与Java中是一模一样的，结果类型是<code>Unit</code></li><li>这两个关键字是为了保持对Java的兼容，在Scala中不推荐使用</li></ul><h4 id="循环中断">循环中断</h4><p>Scala内置控制结果中特地去除了<code>break</code>和<code>continue</code>关键字，为了更好地适应函数式编程。在Scala中推荐使用函数式的风格来解决break和continue的功能。</p><ul><li><strong>实现break</strong></li></ul><p>采用异常方式退出循环：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) &#123;<br>        print(i + <span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-keyword">case</span> e =&gt;<br>&#125;<br>println(<span class="hljs-string">&quot;执行循环体后的代码&quot;</span>)<br><span class="hljs-comment">// 结果为:1 2 3 4 5 执行循环体后的代码</span><br></code></pre></td></tr></table></figure><p>采用Scala自带的函数退出循环（底层还是使用的<code>try-catch</code>的解决方案）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.util.control.<span class="hljs-type">Breaks</span><br><br><span class="hljs-type">Breaks</span>.breakable(<br>    <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) &#123;<br>        print(i + <span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) <span class="hljs-type">Breaks</span>.<span class="hljs-keyword">break</span>()<br>    &#125;<br>)<br>println(<span class="hljs-string">&quot;执行循环体后的代码&quot;</span>)<br></code></pre></td></tr></table></figure><p>对Breaks进行省略：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.util.control.<span class="hljs-type">Breaks</span>._<br><br>breakable(<br>    <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) &#123;<br>        print(i + <span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) <span class="hljs-keyword">break</span>()<br>    &#125;<br>)<br>println(<span class="hljs-string">&quot;执行循环体后的代码&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><strong>实现continue</strong></li></ul><p>可以利用前面提到的循环守卫的方式，也可以利用if判断的方式做到</p><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://www.zhihu.com/question/19918532">弱类型、强类型、动态类型、静态类型语言的区别是什么？- 知乎 (zhihu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala学习笔记-入门(1)-Scala简介</title>
    <link href="/2022/04/29/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-Scala%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/04/29/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-Scala%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="scala简介">Scala简介</h2><p>Scala是一门以JVM为运行环境，并将面向对象和函数式编程的最佳特性结合在一起的一种静态类型编程语言。</p><ul><li><p>Scala是一门多范式的编程语言，支持面向对象和函数式编程</p><blockquote><p>多范式指多种编程方式，如面向过程、面向对象、泛型、函数式编程等</p></blockquote></li><li><p>Scala的源代码会被编译成字节码，然后运行在JVM上，并且可以调用现有的Java类库，实现两种语言的无缝对接</p></li></ul><p>在学习Scala的过程中，应当多加注意Scala与Java的区别。</p><p>在编译运行过程中，Java使用<code>javac</code>和<code>java</code>命令。由于同样是运行在JVM之上，Scala也有对应的过程。Scala的源代码文件后缀为<code>.scala</code>，通过<code>scalac</code>命令可以将源代码编译成字节码文件<code>.class</code>，之后使用<code>scala</code>命令进行运行。但是具体细节有所不同，这点在后续的HelloWorld原理对比中会进行说明。</p><h2 id="环境搭建">环境搭建</h2><h3 id="本地环境搭建">本地环境搭建</h3><ol type="1"><li>确保JDK 1.8安装成功</li><li>下载对应的Scala安装文件，这里选择的是scala2.12版本</li><li>之后解压到某个路径</li><li>将对应路径配置为<code>SCALA_HOME</code>，并将对应的bin目录配置到path环境变量中</li></ol><p>完成上面步骤之后，可以进入命令行输入<code>scala</code>，之后就可以看到Scala的版本并进入交互式命令行模式，在里面可以尝试简单的指令。通过<code>:quit</code>命令退出。</p><img src="/2022/04/29/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-Scala%E7%AE%80%E4%BB%8B/scala%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%AA%97%E5%8F%A3.png" class="" title="scala交互式窗口"><h3 id="idea开发环境配置">IDEA开发环境配置</h3><ol type="1"><li>正常创建一个Maven项目</li><li>默认情况下IDEA不支持Scala的开发，需要安装Scala插件</li><li>之后需要关联Scala的依赖包，具体路径：<code>File</code>-&gt;<code>Project Structure</code>-&gt;<code>Platfrom Settings</code>-&gt;<code>Global Libraries</code>-&gt;<code>+</code>，在其中关联对应路径，应选择<code>SCALA_HOME</code></li><li>为项目添加框架依赖，右键项目目录，选择<code>Add Framework Support</code>，之后添加其中的Scala即可</li></ol><p>如果在<code>Global Libraries</code>中已经关联了对应的依赖，可以右键选择添加到对应的Module上。</p><p>目前我们的项目中已经可以书写Scala代码了。在Maven项目中，我们的Java源代码写在java目录下，为了规范，我们也可以创建对应的源文件目录。在main目录下新建一个文件夹，命名为scala，然后将这个文件夹标记为<code>Sources Root</code>。原本的java目录可以删除，但是建议保留。因为Scala可以和Java代码无缝连接，后续项目中的Java代码可以写在对应的文件夹中，便于管理。这样就可以进入HelloWorld的编写了。</p><h3 id="关联源码">关联源码</h3><ol type="1"><li>首先在官网下载源码包<code>scala-sources-2.12.15.tar.gz</code></li><li>然后将其拷贝到对应<code>SCALA_HOME/lib</code>目录下，并解压为<code>scala-source-2.12.15</code>文件夹</li><li>之后Attach Sources选择对应文件夹即可关联源码</li></ol><h2 id="helloworld以及原理对比">HelloWorld以及原理对比</h2><h3 id="helloworld">HelloWorld</h3><p>下面是经典HelloWrold程序，Scala源代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简要说明：</p><ul><li>类名和文件名保持一致</li><li>args为参数，后面Array为类型，[]中的String为泛型</li><li>：后面为返回值 Unit表示返回值为空</li><li>= {} 存放函数体</li><li><code>;</code>句尾分号可有可无</li></ul><p>可以使用<code>scalac</code>和<code>scala</code>进行运行，也可以在IDEA中直接运行。</p><h3 id="与java混合">与Java混合</h3><p>前面我们说到，Scala代码中可以调用Java类库，所以我们也可以在Scala代码中直接插入Java代码，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-string">&quot;Hello Scala!&quot;</span>)<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Hello Java!&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以正确输出结果。</p><h3 id="原理分析">原理分析</h3><p>观察<code>scalac</code>命令得到的结果，发现得到了两个字节码文件，分别是<code>HelloWorld.class</code>和<code>HelloWorld$.class</code>。</p><img src="/2022/04/29/Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-Scala%E7%AE%80%E4%BB%8B/scalac%E7%BC%96%E8%AF%91%E5%90%8E%E5%BE%97%E5%88%B0%E4%B8%A4%E4%B8%AA%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6.png" class="" title="scalac编译后得到两个字节码文件"><blockquote><p>使用<code>jad</code>反编译命令（需要额外下载<code>.exe</code>，为了方便使用可以直接放入<code>$JAVA_HOME$/bin</code>目录下）</p></blockquote><p>通过反编译软件可以将这两个字节码文件反编译成Java的两个类，结果如下：</p><p><code>HelloWorld.class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span><br>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>    &#123;<br>        HelloWorld$.MODULE$.main(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>HelloWorld$.class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> scala.Predef$;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld$</span><br>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>    &#123;<br>        Predef$.MODULE$.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> HelloWorld$()<br>    &#123;<br>        MODULE$ = <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HelloWorld$ MODULE$;<br><br>    <span class="hljs-keyword">static</span> <br>    &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloWorld$</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察反编译后的代码，可以发现，我们利用scala运行的HelloWorld类实际上是一个入口类。在其中，我们调用了HelloWorld$这个类中的一个对象，来执行对应的方法。而这个对象采用了单例模式构造，整个系统中只有这一个对象。</p><p>scala源文件中的HelloWorld对象编译后成为一个类，对象本身编译后是生成的另一个类<code>HelloWorld$</code>的单例对象<code>HelloWorld$.MODULE$</code>，称之为单例对象。在<code>HelloWrold$</code>中有一个main的实例方法，<code>HelloWrold</code>类的静态方法通过单例对象来调用<code>HelloWorld$</code>中的main实例方法，完成方法的调用。</p><p>这种逻辑实际上是Scala为了做到完全的面向对象而采用的。在Java中存在static关键字，被static关键字修饰的属性通过类名直接调用。但是这并不符合面向对象中一切皆对象的逻辑，如果是一切皆对象，应该所有的情况都是通过对象来调用，但是这里还是存在通过类来调用。因此Scala中改进了这种方式，任何调用都是通过对象来完成的。但是这样的话就需要以某种方式来实现原来通过static实现的功能，于是引入了伴生对象。伴生对象通过单例模式实现，在整个系统中只有一个，即Scala中每个类只有一个伴生对象。static完成的静态功能通过单例对象的实例方法和属性来完成，做到了更加纯粹的面向对象。</p><p>我们可以通过一个等价的Java和Scala实现来更加深入的了解这一机制：</p><p>实现如下Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">school</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxxSchool&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, Integer age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&quot; &quot;</span> + Student.school);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">syh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;syh&quot;</span>, <span class="hljs-number">21</span>);<br>        syh.printInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中static实现的静态属性需要使用类名来调用。同样的功能通过Scala代码来实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name:<span class="hljs-type">String</span>, age:<span class="hljs-type">Int</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printInfo</span></span>() : <span class="hljs-type">Unit</span> = &#123;<br>    println(name + <span class="hljs-string">&quot; &quot;</span> + age + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-type">Student</span>.school)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 如果这样指定，Student部分会标红，表示无法找到</span><br><span class="hljs-comment">// 前面提到Scala中一切都需要使用对象来调用，这里的Student表示的是类Student的伴生对象，因此我们需要引入伴生对象</span><br><span class="hljs-comment">// 伴生对象的引入，需要名称一致，并且在同一个文件中</span><br><span class="hljs-comment">// 并且由于main函数也需要由对象来调用，因此main函数要写在object中</span><br><span class="hljs-comment">// 类中也可以写main函数，但是无法调用</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> school: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;xxxSchool&quot;</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> syh = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;syh&quot;</span>, <span class="hljs-number">21</span>)<br>    syh.printInfo()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将生成的两个字节码文件<code>Student.class</code>和<code>Student$.class</code>进行反编译得到代码，如下：</p><p><code>Student.class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> scala.Predef$;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>    &#123;<br>        Student$.MODULE$.main(args);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">school</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Student$.MODULE$.school();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span><br>    &#123;<br>        Predef$.MODULE$.println((<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">2</span>)).append(name).append(<span class="hljs-string">&quot; &quot;</span>).append(age).append(<span class="hljs-string">&quot; &quot;</span>).append(Student$.MODULE$.school()).toString());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Student$.class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student$</span><br>&#123;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">school</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> school;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>    &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">syh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;syh&quot;</span>, <span class="hljs-number">21</span>);<br>        syh.printInfo();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Student$()<br>    &#123;<br>        MODULE$ = <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Student$ MODULE$;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">school</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxxSchool&quot;</span>;<br><br>    <span class="hljs-keyword">static</span> <br>    &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student$</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里的Student类依然是一个入口类，其中有name和age的定义，用于<code>Student$</code>中单例对象的生成。利用单例对象的属性school来达到static的功能。</p><h3 id="与java-helloworld对比">与Java HelloWorld对比</h3><p>由于Java和Scala的源代码都是编译成字节码文件然后在JVM上运行，那么它们的命令之间是否可以相互调用呢？这里首先构建如下的测试代码：</p><p><code>HelloJava.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloJava</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello Java!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>HelloScala.scala</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloScala</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-string">&quot;Hello Scala!&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后分别通过<code>javac</code>和<code>scalac</code>来生成对应字节码文件，可以分别得到<code>HelloJava.class</code>、<code>HelloScala.class</code>和<code>HelloScala$.class</code></p><ul><li>通过scala调用javac生成的字节码文件</li></ul><p>可以直接调用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) PS C:\Users\Lenovo\Desktop\ScalaTest&gt; scala HelloJava<br>Hello Java!<br></code></pre></td></tr></table></figure><ul><li>通过java调用scalac生成的字节码文件</li></ul><p>不可以直接调用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) PS C:\Users\Lenovo\Desktop\ScalaTest&gt; java HelloScala<br>Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: scala/Predef$<br>        at HelloScala$.main(HelloScala.scala:3)<br>        at HelloScala.main(HelloScala.scala)<br>Caused by: java.lang.ClassNotFoundException: scala.Predef$<br>        at java.net.URLClassLoader.findClass(Unknown Source)<br>        at java.lang.ClassLoader.loadClass(Unknown Source)<br>        at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)<br>        at java.lang.ClassLoader.loadClass(Unknown Source)<br>        ... 2 more<br></code></pre></td></tr></table></figure><p>发现报错Class无法找到，原因是没有引入Scala的库，添加classpath既可以只能执行：</p><p>（下面的命令如果使用PowerShell无法执行？）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">C:\Users\Lenovo\Desktop\ScalaTest&gt;java -cp %SCALA_HOME%/lib/scala-library.jar; HelloScala<br>Hello Scala!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce中Reduce阶段的对象重用以及Map阶段的空行表现</title>
    <link href="/2022/04/26/MapReduce%E4%B8%ADReduce%E9%98%B6%E6%AE%B5%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%87%8D%E7%94%A8%E4%BB%A5%E5%8F%8AMap%E9%98%B6%E6%AE%B5%E7%9A%84%E7%A9%BA%E8%A1%8C%E8%A1%A8%E7%8E%B0/"/>
    <url>/2022/04/26/MapReduce%E4%B8%ADReduce%E9%98%B6%E6%AE%B5%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%87%8D%E7%94%A8%E4%BB%A5%E5%8F%8AMap%E9%98%B6%E6%AE%B5%E7%9A%84%E7%A9%BA%E8%A1%8C%E8%A1%A8%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="hadoop中迭代器的对象重用">Hadoop中迭代器的对象重用</h2><p>在书写MapReduce程序的时候，我们会自定义实现一个Reduce类，其中需要重写reduce函数，而reduce函数的格式如下（类型使用Text进行举例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;Text&gt; values, Reducer&lt;Text, Text, Text, Text&gt;.Context context)</span><br></code></pre></td></tr></table></figure><p>可以看到values的类型是一个迭代器，使用增强for可以进行迭代。但是在实际过程中，每次迭代其实是对当前的对象进行一次重新的赋值，也就是说在整个过程中，堆空间中只有一个对象的空间。举例来说，对于如下的代码，我们想实现的功能是将每个value都加入到list列表当中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Text&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (Text value : values) &#123;<br>list.add(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>假设values中的值为["1", "2","3"]，实际执行这个代码之后，会发现list中的值是["3", "3","3"]。这是因为每次add的实际上是同一个对象引用，而在迭代过程中每次会对这个对象重新赋值。最后一次迭代将对象赋值为3，而list中每个元素其实都是指向了同一个对象，因此list中的值全部为3。</p><p>为了解决这个问题，需要在每次迭代的时候重新new一个对象，然后将value的值赋值给这个对象，这样就可以保证每次迭代得到不同的对象引用。</p><h2 id="map阶段的空行表现">Map阶段的空行表现</h2><p>第二个问题是探究Map阶段的空行表现。</p><p>首先需要考虑<code>\n</code>和<code>\r</code>这两个字符：</p><ul><li><code>\n</code>：ASCII = 10，表示换行</li><li><code>\r</code>：ASCII = 13，表示回车，将光标移动到本行行首</li></ul><p>在不同的操作系统上，enter键的表现也有所不同：</p><ul><li>在Linux系统中，敲入enter键，在文件中会输入<code>\n</code>；</li><li>在Windows系统中，敲入enter键，在文件中会输入<code>\r\n</code>；</li><li>在Mac系统中，敲入enter键，在文件中会输入<code>\n</code></li></ul><p>并且不同的编辑软件对于行数的显示方式也有所不同，在Vim中，文件中有多少个<code>\n</code>，就认为文件有多少行。而在Windows的编辑器中，一般显示的行数会比实际的<code>\n</code>数目要更多。</p><p>在MapReduce程序中，默认输入的键值对类型是&lt;LongWritable,Text&gt;，表示文件偏移量以及一行的内容。默认按照<code>\n</code>，<code>\r</code>或者<code>\r\n</code>进行切分。</p><blockquote><p>可以在程序中指定自定义的行终止符，参数为<code>textinputformat.record.delimiter</code></p></blockquote><p>假如MapReduce读入一行空行，即只有终止符，那么这一行也会被读入进来，并且读入的是空字符串，内容为空，长度为0。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MapReduce</tag>
      
      <tag>details</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase学习笔记-高级(3)-HBase Bulk Loading</title>
    <link href="/2022/04/20/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7-3-HBase-Bulk-Loading/"/>
    <url>/2022/04/20/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7-3-HBase-Bulk-Loading/</url>
    
    <content type="html"><![CDATA[<blockquote><p>官方文档链接：<ahref="https://hbase.apache.org/book.html#arch.bulk.load">Apache HBase ™Reference Guide-Bulk Loading</a></p></blockquote><h2 id="bulk-load的简介">Bulk Load的简介</h2><p>HBase中提供了一些导入数据的方式，前面我们也提到了，包括使用HBaseShell中的put命令，使用HBase中提供的MapReduce程序，使用Java提供的操作HBase中Table的API等。这些方式都需要与HBase连接，然后再及进行操作，在涉及海量数据存储的情况下，这些方式会给HBase的存储，计算以及网络资源造成较大消耗，并不是一种高效的方式。</p><p>Bulk Load就是可以用来解决上面提到的问题。BulkLoad的方式是使用一个MapReduce任务来将数据以HBase的内部结构StroeFile的形式直接输出到运行的集群上，之后再将这些文件与HBase建立联系。相比于与HBase直接连接的操作，BulkLoad可以绕过与HBase的交互，包括预写日志、写入MemStore以及溢写flush等操作，因此使用的CPU以及网络资源更少，效率更高，适合海量数据的加载。</p><h2 id="bulk-load-步骤">Bulk Load 步骤</h2><h3 id="mapreduce-job完成数据准备">MapReduce Job完成数据准备</h3><p>Bulk Load首先需要利用MapReduce Job将数据加载到HDFS文件系统中。</p><p>依赖说明：</p><table><thead><tr class="header"><th>依赖</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>hbase-client</td><td>HBase客户端</td></tr><tr class="even"><td>hbase-mapreduce</td><td>HBase对MapReduce的支持</td></tr><tr class="odd"><td>hadoop-common</td><td>Hadoop通用包</td></tr><tr class="even"><td>hadoop-mapreduce-client-jobclient</td><td>Hadoop MapReduce任务客户端</td></tr><tr class="odd"><td>hadoop-mapreduce-client-core</td><td>MapReduce客户端核心库</td></tr><tr class="even"><td>hadoop-hdfs</td><td>HDFS相关操作</td></tr><tr class="odd"><td>hadoop-auth</td><td>Hadoop权限认证</td></tr><tr class="even"><td>commons-io</td><td>方便操作文件的Apache的工具类包</td></tr></tbody></table><p>由于该任务中只需要对数据进行读取并且输出，因此只需要Map阶段即可。</p><p><strong>Mapper程序编写</strong>：</p><p>在HBase中提供了两个类来专门对MapReduce支持：</p><ol type="1"><li><code>ImmutableBytesWritable</code>：对应Row Key</li><li><code>MapReduceExtendedCell</code>：对应key-value键值对</li></ol><p>在Mapper中，设置out_key为<code>ImmutableBytesWritable</code>，out_value为<code>MapReduceExtendedCell</code>，Mapper读取文件，之后经过操作逻辑之后转为输出键值对。需要使用KeyValue类来构建单元格，每个需要写入到表中的字段都需要构建出单元格。</p><p>（下面的程序假设已经从输入键值对中获取到了RowKey以及需要写入的字段，均为String形式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, ImmutableBytesWritable, MapReduceExtendedCell&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text value, Mapper&lt;LongWritable, Text, ImmutableBytesWritable, MapReduceExtendedCell&gt;.Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-comment">// 从in_key和in_value中获取到下面的内容，包括行键，列族名，列标识符，字段值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rowKeyString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00001&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">colFamilyString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;C1&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">colQualifier1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;col1&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">colQualifier2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;col2&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;value1&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;value2&quot;</span>;<br><br>        <span class="hljs-comment">// 转化成bytes数组备用</span><br>        <span class="hljs-type">byte</span>[] rowKeyBytes = Bytes.toBytes(rowKeyString);<br>        <span class="hljs-type">byte</span>[] colFamilyBytes = Bytes.toBytes(colFamilyString);<br>        <span class="hljs-type">byte</span>[] colQualifier1Bytes = Bytes.toBytes(colQualifier1);<br>        <span class="hljs-type">byte</span>[] colQualifier2Bytes = Bytes.toBytes(colQualifier2);<br>        <span class="hljs-type">byte</span>[] value1Bytes = Bytes.toBytes(value1);<br>        <span class="hljs-type">byte</span>[] value2Bytes = Bytes.toBytes(value2);<br><br>        <span class="hljs-comment">// 利用行键构建构建out_key</span><br>        <span class="hljs-type">ImmutableBytesWritable</span> <span class="hljs-variable">out_key_rowKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableBytesWritable</span>(rowKeyBytes);<br><br>        <span class="hljs-comment">// 利用KeyValue类构建单元格，每个需要写入到表中的字段都需要构建单元格</span><br>        <span class="hljs-type">KeyValue</span> <span class="hljs-variable">keyValue1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyValue</span>(rowKeyBytes, colFamilyBytes, colQualifier1Bytes, value1Bytes);<br>        <span class="hljs-type">KeyValue</span> <span class="hljs-variable">keyValue2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyValue</span>(rowKeyBytes, colFamilyBytes, colQualifier2Bytes, value2Bytes);<br><br>        <span class="hljs-comment">// 利用键值对构建out_value</span><br>        context.write(out_key_rowKey, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapReduceExtendedCell</span>(keyValue1));<br>        context.write(out_key_rowKey, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapReduceExtendedCell</span>(keyValue2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>驱动类编写</strong>：</p><p>与一般MapReduce程序驱动类不同之处在于需要获取利用<code>HFileOutputFormat2</code>来配置HFile输出</p><ol type="1"><li>加载配置文件</li><li>创建HBase连接</li><li>获取Table对象</li><li>构建MapReduce Job</li><li>MapReduce Job驱动类的固定配置</li><li>获取HBase Region的分布情况</li><li>配置HFile输出</li><li>提交MapReduce任务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDriver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, ClassNotFoundException &#123;<br>        <span class="hljs-comment">// 1. 加载配置文件</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> HBaseConfiguration.create();<br><br>        <span class="hljs-comment">// 2. 创建HBase连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionFactory.createConnection(conf);<br><br>        <span class="hljs-comment">// 3. 获取Table对象</span><br>        <span class="hljs-type">TableName</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> TableName.valueOf(<span class="hljs-string">&quot;MY_TABLE&quot;</span>);<br>        <span class="hljs-type">Table</span> <span class="hljs-variable">my_table</span> <span class="hljs-operator">=</span> connection.getTable(tableName);<br><br>        <span class="hljs-comment">// 4. 构建MapReduce Job</span><br>        <span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> Job.getInstance(conf);<br><br>        <span class="hljs-comment">// 5. MapReduce Job驱动类的固定配置</span><br>        job.setJarByClass(MyDriver.class);<br>        job.setMapperClass(MyMapper.class);<br>        job.setOutputKeyClass(ImmutableBytesWritable.class);<br>        job.setOutputValueClass(MapReduceExtendedCell.class);<br>        job.setMapOutputKeyClass(ImmutableBytesWritable.class);<br>        job.setMapOutputValueClass(MapReduceExtendedCell.class);<br><br>        FileInputFormat.setInputPaths(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;hdfs://hadoop102:8020/input&quot;</span>));<br>        FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;hdfs://hadoop102:8020/output&quot;</span>));<br><br>        <span class="hljs-comment">// 6. 获取HBase Region的分布情况</span><br>        <span class="hljs-type">RegionLocator</span> <span class="hljs-variable">regionLocator</span> <span class="hljs-operator">=</span> connection.getRegionLocator(tableName);<br><br>        <span class="hljs-comment">// 7. 配置HFile输出</span><br>        HFileOutputFormat2.configureIncrementalLoad(job, my_table, regionLocator);<br>        <br>        <span class="hljs-comment">// 8. 提交MapReduce任务</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> job.waitForCompletion(<span class="hljs-literal">true</span>);<br>        System.exit(result ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据加载到hbase">数据加载到HBase</h3><p>执行上面的MapReduce任务之后，就可以在集群中观察到上传的数据，之后需要将对应数据加载到HBase中，使用HBase中自带的工具即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hbase org.apache.hadoop.hbase.tool.LoadIncrementalHFiles /myData/output MY_NAMESPACE:MY_TABLE<br></code></pre></td></tr></table></figure><ul><li>后面的两个参数分别为数据在HDFS文件系统中的路径、需要加载到的表名（命名空间:表名）</li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>HBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase学习笔记-高级(2)-HBase工作机制</title>
    <link href="/2022/04/19/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7-2-HBase%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/04/19/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7-2-HBase%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="数据读取流程">数据读取流程</h2><p>HBase的核心模块是Region Server。RegionServer的主要构成部分是HLog和Region块，HLog中记录该Region的操作日志，Region中存储实际数据。一个Region对象由多个Store组成，每个Store对应当前分区中的一个列族，每个Store包含若干个StoreFile文件，StoreFile文件对应HDFS中的HFile文件。</p><p>读取数据需要知道这个数据存储在哪个Region上，之后找到对应的RegionServer。这些信息存储在meta表中，而meta表也是HBase中存储的一张表，同样被存放在某个Region中。因此首先需要获取meta表。找到meta表之后就可以查询到Region的位置，之后就可以到相应的服务器上查找数据。</p><p>整个读取流程如下：</p><ol type="1"><li>从Zookeeper中找到meta表所在的Region的位置，然后读取其中的数据。在meta表中存储了用户表的Region信息</li><li>之后，根据namespace、表名、行键找到对应Region信息</li><li>找到对应的Region Server，查找对应的Region</li><li>首先从MemStore中查询数据，再去BlockCache中查询数据，最后找到StoreFile</li></ol><blockquote><p>BlockCache是HBase实现的缓存机制，用于缓存从HDFS中读出的数据。HBase提供了两种不同的BlockCache实现来缓存从HDFS读取的数据：默认的堆上LruBlockCache和通常是堆外的BucketCache。默认情况下，所有用户表都启用块缓存，这意味着任何读取操作都将加载LRU缓存。</p><p>可以将MemStore理解为一级缓存，BlockCache理解为二级缓存。</p></blockquote><h2 id="数据写入流程">数据写入流程</h2><p>HBase的数据存储分为如下几个阶段：</p><ol type="1"><li>客户端拿到一个Row Key，需要知道这个Row Key存放在哪个Region中</li><li>根据Zookeeper获取到hbase:meta表，根据命名空间，表名，行键来查询对应的Region信息，查询到对应的Region服务器</li><li>数据先写入到内存中的MemStore结构里，在2.x版本之后增加了MemStore的Compaction操作</li><li>MemStore快写满了的时候（默认128M），或者内存中数据已经连续存放超过一定时间，会自动由后台程序将MemStore中的内容flush刷写到HDFS中的HFile中</li><li>当数据量较大的时候，会产生很多的StoreFile，这样对高效读取不利。HBase会将这些小的StoreFIle合并，一般3-10个文件合并成一个更大的StoreFile。</li></ol><h3id="memstore溢写以及storefile合并">MemStore溢写以及StoreFile合并</h3><p>当MemStore中写入的值变多，会触发溢写操作（flush）进行文件的溢写，成为一个StoreFile。</p><p>当溢写的文件过多的时候，会触发文件的合并操作（Compact），合并有两种方式（Major、Minor）。StoreFile的Compact操作需要对HBase的数据进行多次的重新读写，在这个过程中会产生大量的I/O。Compact利用提前的I/O操作来换取后续读性能的提高。</p><p><strong>flush触发条件</strong>：</p><ul><li>当MemStore中数据达到128M，触发Region级别溢写flush</li><li>当MemStore的存活时间超过一小时，触发RegionServer级别溢写flush</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.hregion.memstore.flush.size<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>134217728<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>hbase-default.xml<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.regionserver.optionalcacheflushinterval<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3600000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>hbase-default.xml<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>Region级别溢写：一个Store溢写，在同一个Region中的所有Store都需要溢写。</p><p>RegionServer级别溢写：Region服务器中保存的所有Store对应的MenStore都进行溢写。</p></blockquote><p><strong>Minor Compact</strong>：</p><ul><li>MinorCompact是小范围轻量级合并，用来对部分文件进行合并操作（默认是3-10个文件）</li><li>会清除过期数据（TTL），但是不做多版本数据的清理工作</li><li>MinorCompact的过程一般较快，I/O相对较低，并且可以设置闲时和忙时</li></ul><p>触发条件：</p><ul><li>在打开Region或者MemStore的时候会自动检测是否需要进行Compact（包括Minor、Major）</li><li>MinorCompact有一个最小合并数量，默认为3。在Store中的尚未处于Compact阶段的StoreFile数量大于等于3的时候需要做Compact</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.hstore.compaction.min<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">final</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">final</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>hbase-default.xml<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Major Compact</strong>：</p><ul><li>MajorCompact是全局范围重量级合并，用来对一个Region内部的所有StoreFile执行合并操作，最终合并出一个StoreFile文件</li><li>所有无效数据都会被处理</li></ul><p>触发条件：</p><ul><li>如果判断不需要进行Minor Compact，HBase会继续判断执行MajorCompact</li><li>如果在所有StoreFile中，时间戳最小的那个StoreFile的时间间隔大于MajorCompact的时间间隔（默认7天），则触发Major Compact</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.hregion.majorcompaction<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>604800000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>hbase-default.xml<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>7 day = 168 h = 604800 s = 604800000 ms</p></blockquote><h3 id="in-memory-compaction">In-Memory Compaction</h3><p>In-Memory Compaction在HBase2.x版本后新增的一个步骤。相比于默认的MenStore溢写区别在于实现了在内存中进行合并（Compact），核心思想是尽量延长内存中数据的生命周期，来减少总的IO开销。</p><p>在MemStore中，数据以段（Segment）为单位进行存储，MemStore中包含了多个Segment。</p><ul><li>数据写入时，首先写入到的是ActiveSegment中，也就是当前可以写入的Segment段</li><li>在2.x之前，如果MemStore中的数据量达到指定的阈值时，会直接将数据flush到磁盘中的一个StoreFile中</li><li>在In-Memory Compaction机制中，当ActiveSegment中数据满了之后，会将数据移动的pipeline中，一个pipeline中可以有多个Segment。pipeline中的多个Segment会合并成一个更大更紧凑的Segment</li></ul><p>pipeline中segment的合并策略：</p><p><strong>Basic</strong>：</p><ul><li>Basic Compact策略不清理多余的数据版本，直接合并</li><li>适用于大量写的情况</li></ul><p><strong>Eager</strong>：</p><ul><li>Eager Compact会过滤重复的数据，清理多余版本</li><li>主要针对数据大量过期淘汰的场景</li></ul><p><strong>Adaptive</strong>：</p><ul><li>Adaptive Compact根据数据的重复情况来决定是否使用Eager策略</li></ul><p>可以在<code>hbase-site.xml</code>中配置默认In-MemoryCompact的方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.hregion.compacting.memstore.type<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>&lt;none|basic|eager|adaptive&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以在创建表的时候指定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">create &quot;MY_TABLE&quot;, &#123;NAME =&gt; &quot;C1&quot;, IN_MEMORY_COMPACTION =&gt; &quot;BASIC&quot;&#125;<br></code></pre></td></tr></table></figure><h2 id="wal机制">WAL机制</h2><p>在分布式环境下，用户必须要考虑系统出错的情形。HBase采取WAL，即预写日志的方式来保证系统发生故障的时候能够恢复到正常状态。</p><p>在每个RegionServer都有一个HLog文件，这是一种预写文件，用来记录该RegionServer执行过的操作。用户更新数据必须先被记录在日志中才能被写入MemStore缓存。只有当缓存内容对应的日志已经成功写入磁盘之后，缓存内容才能被写入磁盘。</p><p>在日志写入HLog文件的过程中，执行的都是追加写。并且同一个RegionServer服务器的Region对象共用一个HLog，这样在记录日志的时候，只需要不断地把日志记录追加到单个日志文件中，而不需要同时打开、写入多个日志文件中，因此减少了磁盘寻址次数，提高对表的写操作性能。</p><p>而Zookeeper会实时监控每个RegionServer的状态，当某个Region服务器发生故障时，Zookeeper会通知Master，Master会首先去处理该故障服务器上遗留的HLog文件。由于同一个Region服务器的所有Region对象共用一个HLog，所以这个遗留的HLog文件会包含来自多个Region对象的日志记录。系统根据每条日志记录所属的Region对象对HLog数据进行拆分，并分别存放到相应的Region对象目录下，再将失效的Region重新分配到可用的Region服务器中，并在对应的Region服务器中进行日志回放，将日志记录中的数据写入到MemStore然后刷新到磁盘的StoreFile文件中，完成数据恢复。</p><h2 id="region管理">Region管理</h2><p>每个Region只能分配给一个RegionServer。在Master中记录了当前有哪些可用的RegionServer，以及当前Region的分配情况。当需要分配新的Region的时候，Master会选择一个可用的RegionServer进行分配。</p><p>当RegionServer上线时，会在Zookeeper的Server目录下建立代表自己的ZNode。Master通过订阅机制，使用Zookeeper来跟踪RegionServer的状态，当Zookeeper的Server目录下文件出现新增或者删除操作，Master可以得到来自Zookeeper的实时通知，这样一旦一个RegionServer上线，Master就可以马上得到对应消息。</p><p>当RegionServer下线时，它和Zookeeper的会话就会断开，Zookeeper会自动释放代表这台RegionServer的文件上的独占锁。Master也可以通过监听得到这个信息，即该RegionServer无法继续提供服务。此时Master会删除Zookeeper的Server目录下对应的ZNode，并将这台RegionServer上的Region分配给其他存活节点。（Region最终还是会对应到HDFS上的一个文件，而HDFS存在副本机制）</p><p>当一个Region中的数据逐渐变多，直到达到某一个阈值之后，会自动进行分裂。这个Region会等分成两个Region，并分配到不同的RegionServer中，原本的Region则会下线。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;-- Region最大文件大小为10G --&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.hregion.max.filesize<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10737418240<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">final</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">final</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>hbase-default.xml<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上过程即为自动分区。当Region达到一定大小会自动进行分区，分区大小的计算公式如下：<span class="math display">\[Min( R^2 \times \text{hbase.hregion.memstore.flush.size},\text{hbase.hregion.max.filesize})\]</span> 其中R为同一个表中，在同一个Region Server中Region的个数。</p><h2 id="master工作机制">Master工作机制</h2><p>Master在启动的时候：</p><ul><li>从Zookeeper上获取唯一一个代表ActiveMaster的锁，用来阻止其他备用节点成为Master</li><li>Master扫描Zookeeper上的Server父节点，获得当前可用的RegionServer列表，之后与每个RegionServer通信，获得当前已经分配的Region和Region Server的对应关系</li><li>扫描meta表，得到当前还未分配的Region，将他们放入待分配Region列表中</li></ul><p>Master下线：</p><p>由于Master只维护表和Region的元数据，并不参与表数据的IO过程，因此Master下线仅会导致所有元数据的修改操作无法进行（包括创建删除表、表结构修改、Region的负载均衡、处理Region上下线、进行Region合并等）。但是Region的自动分区操作还是可以完成的，表数据的读写还是可以正常完成的。（读写过程设计到Zookeeper、RegionServer），因此Master下线短时间内对整个HBase集群没有影响。</p><blockquote><p>Master中保存的都是冗余信息，上线之后可以从系统其他地方收集得到。</p></blockquote><h2 id="相关数据结构">相关数据结构</h2><h3 id="lsm树">LSM树</h3><p>传统的关系型数据库，一般都选择使用B+树来作为索引结构，而在大数据场景下，数据库的存储引擎选择的是LSM树，即日志结构合并树（LogStructured Merge Tree）。</p><p>使用LSM树的主要目标是快速建立索引，B+树在写入压力较大的时候，需要大量的磁盘随机I/O，严重影响创建索引的速度，不适合使用在写入操作非常频繁的场景中。而LSM树通过磁盘的顺序写，来实现较高的性能。</p><p>LSM树是一种存储策略，不同部分采用不同的数据结构。</p><p>LSM树的主要思想就是划分不同等级的结构。在插入记录的时候，先写日志，插入到内存当中。内存中的结构成为C0树，而当内存中的数据达到一定阈值，或者经过一段时间间隔，C0树合并到磁盘的C1树中，C1中的数据进一步合并到C2中，依次类推。</p><p>C0结构在内存中，可以使用B树、红黑树、跳表等结构（HBase中使用跳表），而磁盘中的结构使用B+树。</p><p>C0层保存了最近写入的数据，数据是有序的，并且允许随机更新与查询</p><p>C1层以及之后的数据都是在磁盘中，每一层的Key都是有序存储的。</p><p><strong>LSM数据写入操作</strong>：</p><ul><li>首先将操作写入WAL日志中，由于是顺序写，性能较高</li><li>之后将数据写入到内存中的C0结构中</li><li>当内存中的C0结构超过一定阈值，将内存中的C0和C1进行合并</li><li>合并后的新的C1顺序写入磁盘，替换之前的C1</li><li>C1层达到一定大小会继续和下层合并，合并后旧的文件都可以删除，只保留最新文件</li><li>在整个写入的过程中只使用到了内存结构，合并操作由后台线程异步完成，不会阻塞写入</li></ul><p><strong>LSM数据查询操作</strong>：</p><ul><li>首先查询内存中的C0层，如果没有查到，再不断逐层查询磁盘中的数据。</li><li>C0层是在内存中的数据结构，查询效率较高。由于数据分布在不同的层结构当中，所以一次查询可能需要跨多层进行查询，读取速度较慢</li><li>因此LSM树结构程序适合于大量写入，少量查询的场景</li></ul><h3 id="布隆过滤器">布隆过滤器</h3><p>在HBase中存储着海量数据，要判断某个RowKey或者某个列是否存在，可以使用布隆过滤器。</p><blockquote><p>判断一个元素是否在一个集合当中，可以使用哈希表来判断。在集合较小的情况下，哈希表是可行并且高效的，但是在数据量非常大的情况下，内存中无法存放这样一张哈希表，则无法适用。</p></blockquote><p>布隆过滤器可以判断一个值是否存在某个集合中，但是只能判断一定不存在和可能存在。即如果判断不存在，则一定不存在；如果判断存在，则是可能存在。</p><p>布隆过滤器主要维护一个bit数组，对于存入的每个值value，分别经过K个哈希函数得到K个值，然后对应bit数组对应位置上的值设置为1。</p><p>当利用value查询布隆过滤器时，也是利用这K个哈希函数，得到K个值，然后依次查询bit数组对应位置</p><ul><li>如果K个位置上均为1：则value可能存在</li><li>如果K个位置上存在一个不为1：则value一定不存在</li></ul><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://www.jianshu.com/p/3ecd112c009e">HBase中BlockCache的设计综述- 简书 (jianshu.com)</a></li><li><a href="http://c.biancheng.net/view/6533.html">HBase WAL机制(biancheng.net)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>HBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase学习笔记-高级(1)-HBase的架构与逻辑结构模型</title>
    <link href="/2022/04/18/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7-1-HBase%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/04/18/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7-1-HBase%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="系统架构">系统架构</h2><p>HBase集群是一种主从架构的设计，其中有三类角色：Client、MasterServer以及Region Server</p><p><strong>Client：</strong>客户端发出对HBase的操作请求，例如HBaseShell、编写的Java代码都属于客户端</p><p><strong>Master Server：</strong> Master Server是所有RegionServer的管理者，不负责管理用户数据表。</p><ul><li>监控Region Server</li><li>处理Region Server的故障转移</li><li>处理元数据的变更</li><li>处理Region的分配或者移除</li><li>在空闲时间进行数据的负载均衡</li><li>通过Zookeeper来发布自己的位置给客户端</li></ul><p><strong>Region Server：</strong> Region是用户数据表的实际管理者</p><ul><li>处理分配给它的Region</li><li>负责存储HBase的实际数据</li><li>刷新缓存到HDFS文件系统中</li><li>执行压缩</li><li>负责处理Region分片</li></ul><p>在RegionServer中包含了许多组件，包括：WAL、StoreFile（HFile）、Store、MemStore、Region等。这些也是在HBase中重要的逻辑结构模型。</p><h2 id="逻辑结构模型">逻辑结构模型</h2><p>HBase中用户数据存储在Region Server中，一个RegionServer存放的内容可以表示如下：</p><img src="/2022/04/18/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7-1-HBase%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B/HBase%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.png" class="" title="HBase逻辑结构模型"><ul><li><strong>Region</strong>：在HBase中，一张表会被划分成多个Region，并由RegionServer提供存储服务<ul><li>回应HBase的特点，原生支持分布式存储</li><li>每个Region保存一定行键范围的数据，Region中的数据有序，按照行键的字典序来进行排列</li></ul></li><li><strong>Store</strong>：每一个Region又会按照列族垂直划分成Store</li><li><strong>MemStore</strong>：为Store提供的缓存区域<ul><li>向HBase中写入数据时，都是先向MemStore中写入，提高读写速度</li><li>当MemStore存储将要满的时候，整个线程写入到HDFS的HFile中，写入之前会按照行键排序</li><li>每个列族有一个MemStore</li></ul></li><li><strong>StoreFile</strong>： Store的存储文件<ul><li>一个Store最终可能存储为多个StoreFile</li><li>物理存储为HFile（概念上的对应 HDFS &lt;-&gt; HFile ，HBase &lt;-&gt;StoreFile）</li><li>写入操作是连续写入的，写入的是按照行键排序的键值对数据，写入速度非常快</li></ul></li><li><strong>WAL</strong>： Write Ahead Log， 预写日志，用于故障恢复<ul><li>WAL是HBase中提供的一种高并发、持久化的日志保存与回放机制</li><li>在执行操作命令之前（例如put、delete、incr等），会将这个命令保存在WAL中</li><li>写入WAL之后，再去执行对应操作</li><li>一旦服务器崩溃，可以通过回放WAL来实现恢复崩溃之前的数据</li><li>物理上的存储是Hadoop的Sequence File</li></ul></li></ul><p>逻辑结构模型可以简单总结如下：</p><p>对于一张表，会按照行键横向划分成多个Region，每个Region按照列族纵向划分成多个Store。每个Store，最终的存储形式为StoreFile，物理存储为HDFS中的HFile。在执行操作之前，会将操作记录在WAL中，用于故障恢复。之后执行写入操作，数据写入HBase之前，首先需要写入对应的MenStore，当快要写满之后再持久化到文件中。写入文件之前需要对数据按照行键进行排序，之后再写入。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>HBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase学习笔记-入门(6)-HBase表结构设计</title>
    <link href="/2022/04/18/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-6-HBase%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/04/18/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-6-HBase%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="hbase表结构设计">HBase表结构设计</h2><h3 id="命名空间namespace">命名空间：NameSpace</h3><p>在一个项目中，需要使用HBase来保存多张表，不同的表可能有不同的业务关系，可以按照某种业务域来划分这些表。为了方便管理，不同的业务域以命名空间（NameSpace）来划分。</p><p>HBase初始存在两个命名空间，<code>defalut</code>和<code>hbase</code>。</p><ul><li>在<code>hbase</code>中存放了系统的内建表：meta和namespace</li><li><code>default</code>是默认的命名空间，在不指定的情况下，表将创建在该命名空间下</li></ul><p>命名空间相关语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建命名空间</span><br>create_namespace &quot;MY_NAMESPACE&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看命名空间列表</span><br>list_namespace<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看某张表的命名空间</span><br>describe_namespace &quot;MY_NAMESPACE&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在创建表的时候指定命名空间</span><br>create &quot;MY_NAMESPACE:MY_TABLE&quot;, &quot;C1&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除命名空间</span><br>drop_namespace &quot;MY_NAMESPACE&quot;<br></code></pre></td></tr></table></figure><ul><li>这里需要注意，如果命名空间中还有表的话，是无法删除的。删除之前需要保证该命名空间中已经没有表了，否则会报错</li></ul><h3 id="列族设计">列族设计</h3><p>在HBase中，列族的数量应该越少越好</p><ul><li>过多的列族会影响HBase的性能</li><li>列族按照stroe存储，当一个store存储的数据达到阈值之后，会进行flush。而这个flush操作会引起表中其他列族的flush操作，即表中所有的列族同时进行flush操作。这样会带来不必要的I/O开销，列族越多，对性能的影响越大</li><li>一般来说，我们只设置一个列族即可</li></ul><h3 id="版本设置">版本设置</h3><p>版本<code>VERIONS</code>属性，表示在HBase中，一个单元格会存放几份历史版本的数据，该值的设计需要考虑到具体的业务逻辑。HBase默认创建表的版本为1，即不保留历史版本的数据。</p><h3 id="数据压缩">数据压缩</h3><p>在HBase中可以是使用多种压缩编码，包括LZO、SNAPPY、GZIP等。根据压缩算法的不同特点进行选择</p><ul><li>GZIP：压缩率最高，是CPU密集型，对CPU的消耗算法比其他算法要多，压缩和解压速度也慢</li><li>LZO：压缩率居中，压缩和解压速度明显快于GZIP</li><li>Zippy / Snappy：压缩率最低，压缩和解压速度快于LZO</li></ul><p>压缩方式的设置是以列族为单位的，即每个列族可以设置一个压缩方式。具体修改属性为<code>COMPRESSION</code>，举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">alter &quot;MY_NAMESPACE:MY_TABLE&quot;, &#123;NAEM =&gt; &quot;C1&quot;, COMPRESSION =&gt; &quot;GZ&quot;&#125;<br></code></pre></td></tr></table></figure><h3 id="行键row-key设计原则">行键Row Key设计原则</h3><p>行键唯一标识了一个逻辑行的数据，在HBase中具有相当的重要性。因此在设计行键的时候也应当遵循一定的设计原则。</p><p>官方提供的行键设计原则：</p><ol type="1"><li><p>避免使用递增或者时序数据作为行键</p><p>由于在存储的过程中，数据会按照行键进行顺序存储，如果使用的是递增或者时序数据，会导致负载都在一台或某几台机器上，不利于负载均衡。</p></li><li><p>避免行键和列的长度过大</p><p>在HBase中，如果要访问一个单元格，需要有对应的行键、列族名、列标识符，如果这些名称的长度过大，则会占用较大的内存空间。因此行键和列的长度应该尽可能短，其中行键的最大长度支持64KB。</p></li><li><p>需要保证行键的唯一性</p><p>在设计行键的时候，必须保证它的唯一性。在HBase中数据的存储是键值对形式，如果向HBase中同一张表插入相同行键的数据，原先的数据会被覆盖。</p></li></ol><h3 id="避免数据热点">避免数据热点</h3><p>HBase原生支持分布式存储，并且它的应用场景也多是分布式的，因此避免数据热点是一个非常重要的方面。数据热点指的是大量的客户端直接访问集群中的一个或者某几个节点（进行读写操作），而其他节点一直处于空闲状态。大量的访问操作可能会导致某个服务器节点超出承受能力，导致整个RegionServer的性能下降，其他的Region也会受影响。</p><p>应对数据热点问题，可以从分区和行键设计两个方面着手。</p><h4 id="预分区">预分区</h4><p>HBase中存在自动分区的机制，当然我们也可以手动进行预分区。默认情况，一个HBase的表只有一个Region，由一个RegionServer进行管理。</p><ul><li>每个Region存在两个重要的属性：<code>start key</code>和<code>end key</code>。这两个属性表示这个Region维护的行键范围，在存储的时候，根据行键的不同存储到不同的Region中</li><li>如果只有一个Region，那么start key和endkey都为空，表示均可存储。当数据量越来越大的时候，HBase会进行Region分裂</li><li>我们也可以预先设置预分区，建议预分区的个数设置为节点的倍数，让Region均匀地分布在各个节点上</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指定预分区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 指定start key和end key</span><br>create &quot;MY_TABLE&quot;, &quot;C1&quot;, &#123;SPLITS =&gt; [&#x27;10&#x27;, &#x27;20&#x27;, &#x27;30&#x27;, &#x27;40&#x27;]&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 指定分区数量和分区策略</span><br>create &quot;MY_TABLE&quot;, &quot;C1&quot;， &#123;NUMREGIONS =&gt; 5, SPLITALGO =&gt; &#x27;HexStringSplit&#x27;&#125;<br></code></pre></td></tr></table></figure><p>第一种方式通过指定start key和endkey进行预分区，给定SPLITS列表表示指定划分界限，如示例中所示，切分4处，形成了5个分区。</p><p>第二种方式通过指定分区数量和分区策略来进行预分区，支持的分区策略有以下几种：</p><ul><li>HexStringSplit：适用于形式为十六进制的字符串的行键，预定义范围为<code>00000000</code>-&gt;<code>FFFFFFFF</code>。对于位数不够的行键，则使用0在填充高位。</li><li>DecimalStringSplit： 适用于形式为十进制的字符串的行键。</li><li>UniformSplit： 适用于形式为随机字节数组的行键。</li></ul><h4 id="行键设计">行键设计</h4><p>可以通过一些常见策略来设计行键，避免热点</p><ul><li><strong>反转策略</strong></li></ul><p>如果设计的行键在数据分布上不均匀，但是行键的尾部数据呈现出良好的随机性，则可以考虑将行键反转，或者直接将尾部的bytes提前到行键的开头（例如手机号码、时间戳等）</p><p>优点：使得RowKey随机分布，利于数据均匀分布在不同Region中，利于Get操作</p><p>缺点：不利于Scan操作，牺牲了Row Key的有序性，因为数据在原RowKey上的自然顺序已经被打乱</p><ul><li><strong>加盐策略</strong></li></ul><p>加盐的原理是在原Row Key的前面添加固定长度的随机数，即给RowKey分配一个随机的前缀</p><p>优点：随机数使得Row Key随机分布，利于负载均衡</p><p>缺点：由于添加的是随机数，因此基于RowKey进行查询的时候无法得知随机数是什么，最后只能进行全表扫描，效率低</p><ul><li><strong>哈希策略</strong></li></ul><p>对原Row Key进行哈希，得到哈希值完整或部分替换原RowKey的前缀部分。可以使用的哈希算法包括MD5、sha1、sha256、sha512等算法</p><p>优点：利于负载均衡</p><p>缺点：不利于Scan操作，因为打乱了原Row Key的自然顺序</p><blockquote><p>补充阅读：</p><p>HBase默认只支持对行键的索引，如果要针对其他的列进行查询，那么只能全表扫描，这样的效率是不高的，尤其在表存储数据量很大的情况下表现更加明显。</p><p>Apache Phoenix可以帮助解决这样的问题。（<ahref="https://phoenix.apache.org/">Overview | Apache Phoenix</a> ）</p><p>ApachePhoenix可以很好地和其他Hadoop组件整合在一起，包括Spark、Hive、MapReduce等，使得支持低延迟OLTP和业务操作分析。简单来说，它提供标准的SQL以及完备的ACID事务分析；通过利用HBase作为存储，通过SQL进行操作，如创建表、对数据增删改查等。</p></blockquote><h2 id="参考文章">参考文章</h2><ol type="1"><li><a href="https://hbase.apache.org/book.html">Apache HBase ™Reference Guide</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>HBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase学习笔记-入门(5)-HBase的Java API操作</title>
    <link href="/2022/04/17/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-5-HBase%E7%9A%84Java-API%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/04/17/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-5-HBase%E7%9A%84Java-API%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>使用Maven构建Java项目，需要引入<code>hbase-client</code>的依赖。</p><h2 id="连接构建">连接构建</h2><p>要完成对应的操作，首先需要建立本地Java程序与集群的连接，而构建连接需要对应的配置文件。</p><p>在分布式环境下，客户端访问HBase需要通过ZooKeeper的地址和端口来获取当前活跃的Master和所需的RegionServer地址。配置文件中至少要指定上面的内容。</p><p>首先将配置文件放在项目中的<code>resources</code>文件夹中，需要的配置文件有HBase的<code>hbase-site.xml</code>和Hadoop的<code>core-site.xml</code>。可以使用<code>HBaseConfiguration</code>的单例方法获取配置。这个方法会去读取我们刚才resource文件夹中的配置文件。如果文件夹中没有放置对应的配置文件也没有关系，可以获取之后使用set方法进行设置（就像下面的情况）。获取配置之后，创建连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Configuration configuration;<br><span class="hljs-keyword">private</span> Connection connection;<br><br><span class="hljs-meta">@Before</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 设置Zookeeper的地址和端口</span><br>    configuration = HBaseConfiguration.create();<br>    <span class="hljs-comment">// 设置和hbase-site.xml中相同</span><br>    configuration.set(<span class="hljs-string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="hljs-string">&quot;hadoop102, hadoop103, hadoop104&quot;</span>);<br>    configuration.set(<span class="hljs-string">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class="hljs-string">&quot;2181&quot;</span>);<br>    <span class="hljs-comment">// 获取连接</span><br>    connection = ConnectionFactory.createConnection(configuration);<br>&#125;<br><br><span class="hljs-meta">@After</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    connection.close();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意连接使用完毕之后需要关闭</li></ul><p>在Java中对于HBase的操作可以分成两大类：对数据表的管理操作和对表中数据的增删改查操作。前者的操作需要获取到<code>Admin</code>对象，后者的操作需要获取到<code>Table</code>对象</p><h2 id="数据表管理操作">数据表管理操作</h2><p>对于数据表的管理等操作需要先得到<code>Admin</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Configuration configuration;<br><span class="hljs-keyword">private</span> Connection connection;<br><span class="hljs-keyword">private</span> Admin admin;<br><br><span class="hljs-meta">@Before</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 设置Zookeeper的地址和端口</span><br>    configuration = HBaseConfiguration.create();<br>    <span class="hljs-comment">// 设置和hbase-site.xml中相同</span><br>    configuration.set(<span class="hljs-string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="hljs-string">&quot;hadoop102, hadoop103, hadoop104&quot;</span>);<br>    configuration.set(<span class="hljs-string">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class="hljs-string">&quot;2181&quot;</span>);<br>    <span class="hljs-comment">// 获取连接</span><br>    connection = ConnectionFactory.createConnection(configuration);<br>    <span class="hljs-comment">// 获取HBaseAdmin对象</span><br>    admin = connection.getAdmin();<br>&#125;<br><br><span class="hljs-meta">@After</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    admin.close();<br>    connection.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建表">创建表</h3><ol type="1"><li>调用tableExists判断表是否存在</li><li>创建表需要构建表描述器（TableDescriptor）、列族描述器（ColumnFamilyDescriptor）。这两个对象需要通过对应的描述器构建器使用build来创建</li><li>将列族描述器添加到表描述器中</li><li>使用admin.createTable创建表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createTable</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1. 构建表名</span><br>    <span class="hljs-type">TableName</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> TableName.valueOf(<span class="hljs-string">&quot;MY_TABLE&quot;</span>);<br><br>    <span class="hljs-comment">// 2.判断表是否存在</span><br>    <span class="hljs-keyword">if</span> (admin.tableExists(tableName)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;表已经存在!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 构建表描述构建器</span><br>    <span class="hljs-comment">// TableDescriptor: 表描述器，描述这个表的相关配置，如列族等</span><br>    <span class="hljs-comment">// TableDescriptorBuilder: 表描述构建器，用来构建表描述器</span><br>    <span class="hljs-type">TableDescriptorBuilder</span> <span class="hljs-variable">tableDescriptorBuilder</span> <span class="hljs-operator">=</span> TableDescriptorBuilder.newBuilder(tableName);<br><br>    <span class="hljs-comment">// 4. 构建列族描述构建器</span><br>    <span class="hljs-comment">// ColumnFamilyDescriptor: 列族描述器，描述列族相关信息，一个列族描述器对应一个列族</span><br>    <span class="hljs-comment">// ColumnFamilyDescriptorBuilder: 列族表述构造器，用来构建列族描述器</span><br>    <span class="hljs-type">ColumnFamilyDescriptorBuilder</span> <span class="hljs-variable">columnFamilyDescriptorBuilder</span> <span class="hljs-operator">=</span> ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(<span class="hljs-string">&quot;C1&quot;</span>));<br><br>    <span class="hljs-comment">// 5. 构建列族描述和表描述</span><br>    <span class="hljs-type">ColumnFamilyDescriptor</span> <span class="hljs-variable">columnFamilyDescriptor</span> <span class="hljs-operator">=</span> columnFamilyDescriptorBuilder.build();<br>    tableDescriptorBuilder.setColumnFamily(columnFamilyDescriptor);<br>    <span class="hljs-type">TableDescriptor</span> <span class="hljs-variable">tableDescriptor</span> <span class="hljs-operator">=</span> tableDescriptorBuilder.build();<br><br>    <span class="hljs-comment">// 6. 创建表</span><br>    admin.createTable(tableDescriptor);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于在HBase中存储的都是byte []，所以会经常使用到一个工具类Bytes（hbase包下的Bytes工具类），可以使用这个工具类将字符串、long、double等类型转化成byte[ ]数组，也可以将byte [ ]数组转化成指定类型</p></blockquote><h3 id="删除表">删除表</h3><p>直接调用API即可，注意也是需要先禁用，再删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteTable</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">TableName</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> TableName.valueOf(<span class="hljs-string">&quot;MY_TABLE&quot;</span>);<br>    <span class="hljs-comment">// 判断表是否存在，如果存在则删除，如果不存在则输出提示信息</span><br>    <span class="hljs-keyword">if</span> (admin.tableExists(tableName)) &#123;<br>        admin.disableTable(tableName);<br>        admin.deleteTable(tableName);<br>        System.out.println(<span class="hljs-string">&quot;表&quot;</span> + tableName.toString() + <span class="hljs-string">&quot;已经删除&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;表&quot;</span> + tableName.toString() + <span class="hljs-string">&quot;不存在&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="增删改查操作">增删改查操作</h2><p>对于表的增删改查需要先得到Table对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Configuration configuration;<br><span class="hljs-keyword">private</span> Connection connection;<br><br><span class="hljs-meta">@Before</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 设置Zookeeper的地址和端口</span><br>    configuration = HBaseConfiguration.create();<br>    <span class="hljs-comment">// 设置和hbase-site.xml中相同</span><br>    configuration.set(<span class="hljs-string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="hljs-string">&quot;hadoop102, hadoop103, hadoop104&quot;</span>);<br>    configuration.set(<span class="hljs-string">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class="hljs-string">&quot;2181&quot;</span>);<br>    <span class="hljs-comment">// 获取连接</span><br>    connection = ConnectionFactory.createConnection(configuration);<br>&#125;<br><br><span class="hljs-meta">@After</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    connection.close();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>HBase的connection对象是一个重量级的对象，编写代码的时候需要避免重复创建，并且它是线程安全的。</p><p>而Table对象施一公轻量级的，使用完之后需要close，它是非线程安全的。</p></blockquote><h3 id="插入数据">插入数据</h3><ol type="1"><li>使用HBase连接获取Table对象</li><li>构建RowKey，列族名和列名</li><li>构建put对象</li><li>添加对应列</li><li>使用Table对象执行put操作</li><li>关闭Table对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//1. 使用HBase连接获取Table对象</span><br>    <span class="hljs-type">TableName</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> TableName.valueOf(<span class="hljs-string">&quot;MY_TABLE&quot;</span>);<br>    <span class="hljs-type">Table</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> connection.getTable(tableName);<br><br>    <span class="hljs-comment">//2. 构建RowKey，列族名和列名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">rowKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00001&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">cfName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;C1&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">colName1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Name&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">colName2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Age&quot;</span>;<br><br>    <span class="hljs-comment">//3. 利用行键构建put对象</span><br>    <span class="hljs-type">Put</span> <span class="hljs-variable">put</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Put</span>(Bytes.toBytes(rowKey));<br><br>    <span class="hljs-comment">//4. 添加对应列</span><br>    put.addColumn(Bytes.toBytes(cfName), Bytes.toBytes(colName1), Bytes.toBytes(<span class="hljs-string">&quot;syh&quot;</span>));<br>    put.addColumn(Bytes.toBytes(cfName), Bytes.toBytes(colName2), Bytes.toBytes(<span class="hljs-string">&quot;21&quot;</span>));<br><br>    <span class="hljs-comment">//5. 使用Table对象执行put操作</span><br>    table.put(put);<br><br>    <span class="hljs-comment">//6. 关闭Table对象</span><br>    table.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过rowkey获取数据">通过rowkey获取数据</h3><ol type="1"><li>获取Table对象</li><li>使用rowKey构建get对象</li><li>执行get请求，得到Result对象（表示逻辑一行）</li><li>获取所有单元格</li><li>打印rowkey</li><li>迭代打印单元格列表</li><li>关闭表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1. 获取Table对象</span><br>    <span class="hljs-type">TableName</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> TableName.valueOf(<span class="hljs-string">&quot;MY_TABLE&quot;</span>);<br>    <span class="hljs-type">Table</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> connection.getTable(tableName);<br><br>    <span class="hljs-comment">// 2. 使用rowKey构建Get对象</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">rowKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00001&quot;</span>;<br>    <span class="hljs-type">Get</span> <span class="hljs-variable">get</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Get</span>(Bytes.toBytes(rowKey));<br><br>    <span class="hljs-comment">// 3. 执行get请求</span><br>    <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> table.get(get);<br><br>    <span class="hljs-comment">// 4. 获取所有单元格</span><br>    List&lt;Cell&gt; cells = result.listCells();<br><br>    <span class="hljs-comment">// 5. 打印rowKey</span><br>    <span class="hljs-type">byte</span>[] row = result.getRow();<br>    System.out.println(Bytes.toString(row));<br><br>    <span class="hljs-comment">// 6. 迭代打印单元格列表</span><br>    <span class="hljs-keyword">for</span> (Cell cell : cells) &#123;<br>        <span class="hljs-comment">// 将字符数组转化成字符串</span><br>        <span class="hljs-comment">// 获取列族的名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">colFamily</span> <span class="hljs-operator">=</span> Bytes.toString(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());<br>        <span class="hljs-comment">// 获取列的名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">colName</span> <span class="hljs-operator">=</span> Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());<br>        <span class="hljs-comment">// 获取值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());<br><br>        System.out.println(colFamily + <span class="hljs-string">&quot;:&quot;</span> + colName + <span class="hljs-string">&quot;-&gt;&quot;</span> + value);<br>    &#125;<br><br>    <span class="hljs-comment">// 7. 关闭表</span><br>    table.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意在循环内部，获取到的都是Array，需要使用offset和length来指定范围</p><h3 id="获取所有数据">获取所有数据</h3><ol type="1"><li>获取Table对象</li><li>构建scan请求对象</li><li>执行scan扫描请求，得到ResultScanner对象</li><li>循环ResultScanner对象，每次得到一个Result对象</li><li>对每个Result对象，即对每个逻辑行进行输出</li><li>手动关闭ResultScanner</li><li>关闭表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1. 获取Table对象</span><br>    <span class="hljs-type">TableName</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> TableName.valueOf(<span class="hljs-string">&quot;MY_TABLE&quot;</span>);<br>    <span class="hljs-type">Table</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> connection.getTable(tableName);<br><br>    <span class="hljs-comment">// 2. 构建scan请求对象</span><br>    <span class="hljs-type">Scan</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scan</span>();<br><br>    <span class="hljs-comment">// 3. 执行scan扫描请求，得到ResultScanner对象</span><br>    <span class="hljs-type">ResultScanner</span> <span class="hljs-variable">resultScanner</span> <span class="hljs-operator">=</span> table.getScanner(scan);<br><br>    <span class="hljs-comment">// 4. 循环ResultScanner对象，每次得到一个Result对象</span><br>    <span class="hljs-comment">// 5. 对每个Result对象，即对每个逻辑行进行输出</span><br>    <span class="hljs-keyword">for</span> (Result result : resultScanner) &#123;<br>        <span class="hljs-comment">// 对于每个result(逻辑行)内容的输出可以参考get的代码</span><br>        List&lt;Cell&gt; cells = result.listCells();<br>        <span class="hljs-type">byte</span>[] row = result.getRow();<br>        System.out.println(Bytes.toString(row));<br><br>        <span class="hljs-keyword">for</span> (Cell cell : cells) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">colFamily</span> <span class="hljs-operator">=</span> Bytes.toString(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">colName</span> <span class="hljs-operator">=</span> Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());<br><br>            System.out.println(colFamily + <span class="hljs-string">&quot;:&quot;</span> + colName + <span class="hljs-string">&quot;-&gt;&quot;</span> + value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 手动关闭ResultScanner</span><br>    resultScanner.close();<br><br>    <span class="hljs-comment">// 7. 关闭表</span><br>    table.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除数据">删除数据</h3><ol type="1"><li>获取Table对象</li><li>根据rowKey构建delete对象</li><li>执行delete请求</li><li>关闭表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1. 获取Table对象</span><br>    <span class="hljs-type">TableName</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> TableName.valueOf(<span class="hljs-string">&quot;MY_TABLE&quot;</span>);<br>    <span class="hljs-type">Table</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> connection.getTable(tableName);<br><br>    <span class="hljs-comment">// 2. 根据rowKey构建delete对象</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">rowKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00001&quot;</span>;<br>    <span class="hljs-type">Delete</span> <span class="hljs-variable">delete</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Delete</span>(Bytes.toBytes(rowKey));<br><br>    <span class="hljs-comment">// 3. 执行delete请求</span><br>    table.delete(delete);<br><br>    <span class="hljs-comment">// 4. 关闭表</span><br>    table.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="过滤器使用">过滤器使用</h3><p>过滤器的使用可以结合scan，在构建scan对象之后，利用setFilter进行设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scanWithFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">TableName</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> TableName.valueOf(<span class="hljs-string">&quot;MY_TABLE&quot;</span>);<br>    <span class="hljs-type">Table</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> connection.getTable(tableName);<br><br>    <span class="hljs-type">Scan</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scan</span>();<br><br>    <span class="hljs-comment">// 构建两个过滤器</span><br>    <span class="hljs-type">SingleColumnValueFilter</span> <span class="hljs-variable">startFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleColumnValueFilter</span>(<br>        Bytes.toBytes(<span class="hljs-string">&quot;C1&quot;</span>), Bytes.toBytes(<span class="hljs-string">&quot;Age&quot;</span>), CompareOperator.GREATER_OR_EQUAL, Bytes.toBytes(<span class="hljs-string">&quot;19&quot;</span>));<br>    <span class="hljs-type">SingleColumnValueFilter</span> <span class="hljs-variable">endFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleColumnValueFilter</span>(<br>        Bytes.toBytes(<span class="hljs-string">&quot;C1&quot;</span>), Bytes.toBytes(<span class="hljs-string">&quot;Age&quot;</span>), CompareOperator.LESS_OR_EQUAL, Bytes.toBytes(<span class="hljs-string">&quot;22&quot;</span>));<br>    <span class="hljs-comment">// 综合多个过滤器，得到过滤器列表</span><br>    <span class="hljs-type">FilterList</span> <span class="hljs-variable">filterList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterList</span>(FilterList.Operator.MUST_PASS_ALL, startFilter, endFilter);<br>    <span class="hljs-comment">// 在Scan对象中设置使用过滤器</span><br>    scan.setFilter(filterList);<br><br>    <span class="hljs-type">ResultScanner</span> <span class="hljs-variable">resultScanner</span> <span class="hljs-operator">=</span> table.getScanner(scan);<br><br>    <span class="hljs-keyword">for</span> (Result result : resultScanner) &#123;<br>        List&lt;Cell&gt; cells = result.listCells();<br>        <span class="hljs-type">byte</span>[] row = result.getRow();<br>        System.out.println(Bytes.toString(row));<br><br>        <span class="hljs-keyword">for</span> (Cell cell : cells) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">colFamily</span> <span class="hljs-operator">=</span> Bytes.toString(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">colName</span> <span class="hljs-operator">=</span> Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());<br><br>            System.out.println(colFamily + <span class="hljs-string">&quot;:&quot;</span> + colName + <span class="hljs-string">&quot;-&gt;&quot;</span> + value);<br>        &#125;<br>    &#125;<br><br>    resultScanner.close();<br>    table.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可能出现的错误">可能出现的错误</h2><ol type="1"><li><p>出现报错：<code>java.lang.NoSuchMethodError: org.apache.hadoop.security.HadoopKerberosName.setRuleMechanism(Ljava/lang/String;)V</code></p><p>缺少依赖：<code>hadoop-auth</code></p></li><li><p>没有在本地机器的hosts中配置hadoop102、hadoop103和hadoop104的地址映射</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>HBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase学习笔记-入门(4)-HBase的Shell操作</title>
    <link href="/2022/04/17/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-4-HBase%E7%9A%84Shell%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/04/17/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-4-HBase%E7%9A%84Shell%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="hbase-shell">HBase Shell</h2><p>HBase数据库默认的客户端程序是HBaseShell，这是一个命令行工具，类似于MySQL客户端启动后出现的命令行Shell。在启动HBase集群之后（同时配置了环境变量），在命令行中输入<code>hbase shell</code>即可进入。</p><p>HBaseShell是一个封装了Java客户端API的JRuby应用软件，其中提供的命令可以理解成为是Ruby函数的调用，每个命令都是一个Ruby脚本，后面跟着的参数为传入的参数，具体格式在后续进行说明。在下面链接中列出了在HBaseShell中可用的所有脚本：</p><p><ahref="https://github.com/apache/hbase/tree/master/hbase-shell/src/main/ruby/shell/commands">hbase/hbase-shell/src/main/ruby/shell/commandsat master · apache/hbase (github.com)</a></p><p>在 Shell中输入<code>help</code>可以获取可用命令列表，输入<code>help commandname</code>可获取特定命令的帮助，还可以输入各种命令查看集群、数据库和数据的各项详情。</p><ul><li>使用<code>status</code>命令查看当前集群各节点的状态</li><li>使用<code>version</code>命令查看当前 HBase 的版本号</li><li>使用命令<code>exit</code>或<code>quit</code>即可退出 HBaseShell</li><li>使用<code>whoami</code>命令显示当前用户</li></ul><p>HBaseShell提供的命令可以大致分为两类，一类是对数据表的管理命令，包括对表的创建，禁用，删除等操作；另一类是对表中数据的增删改查命令。</p><h2 id="数据表管理命令">数据表管理命令</h2><p>常用命令汇总：</p><table><thead><tr class="header"><th>命令</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>create</td><td>创建指定模式的新表</td></tr><tr class="even"><td>alter</td><td>修改表的结构，如添加新的列族等</td></tr><tr class="odd"><td>describe</td><td>展示表结构信息，包括列族的数量与属性等</td></tr><tr class="even"><td>list</td><td>列出HBase中已有的表</td></tr><tr class="odd"><td>exists</td><td>判断某个表是否存在</td></tr><tr class="even"><td>disable / enable</td><td>禁用 /解禁一个表。<strong>在删除和更改表之前，需要禁用这个表</strong></td></tr><tr class="odd"><td>disable_all</td><td>禁用所有的表，可以使用正则表达式匹配</td></tr><tr class="even"><td>is_disable</td><td>判断一个表是否被禁用</td></tr><tr class="odd"><td>drop</td><td>删除表</td></tr><tr class="even"><td>truncate</td><td>删除表中数据。truncate可以禁用表、删除表并自动重建表结构</td></tr></tbody></table><p>命令使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建表: 使用create命令，需要指明表名，列族名</span><br>create &quot;MY_TABLE&quot;, &quot;C1&quot;, &quot;C2&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改表: 使用alter命令，指定表名以及需要做什么样的修改</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改变列族C1的版本保存数目</span><br>alter &quot;MY_TABLE&quot;, &#123;NAME =&gt; &quot;C1&quot;, VERSION =&gt; 6&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">增加列族C3</span><br>alter &quot;MY_TABLE&quot;, &quot;C3&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除列族C3,下面两种方式都可以（HBase表中至少要包含一个列族，当表中只有一个列族的时候，无法将其删除）</span><br>alter &quot;MY_TABLE&quot;, &quot;delete&quot; =&gt; &quot;C3&quot;<br>alter &quot;MY_TABLE&quot;, &#123;NAME =&gt; &quot;C3&quot;, METHOD =&gt; &quot;delete&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除表: 首先需要禁用表，然后才能删除</span><br>disable &quot;MY_TABLE&quot;<br>drop &quot;MY_TABLE&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清空表中的数据，相当于禁用表，删除表，按照原结构重建表</span><br>truncate &quot;MY_TABLE&quot;<br></code></pre></td></tr></table></figure><blockquote><p>前面提到HBaseShell命令都是Ruby脚本，可以理解为对Ruby函数的调用，不同的函数传入参数的形式不同。传入引号包裹的字符串就是传入字符串；传入<code>&#123;&#125;</code>包裹的参数，表示传入一个类似Map的结构，其中Map的每一个键值对有<code>key =&gt; value</code>的格式，key一般是给定的参数，不使用引号标识；传入<code>[]</code>包裹的参数，表示传入一个类似数组的结构</p></blockquote><h2 id="增删改查命令">增删改查命令</h2><p>常用命令汇总：</p><table><thead><tr class="header"><th>命令</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>put</td><td>添加一个值到指定单元格中</td></tr><tr class="even"><td>get</td><td>通过表名、行键等参数获取行或者单元格的数据</td></tr><tr class="odd"><td>scan</td><td>遍历表并输出满足指定条件的行记录</td></tr><tr class="even"><td>count</td><td>计算表中的逻辑行数（会遍历所有的存储数据，谨慎使用）</td></tr><tr class="odd"><td>delete</td><td>删除表中列族或者列的数据</td></tr><tr class="even"><td>deleteall</td><td>删除逻辑行</td></tr></tbody></table><p>命令使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加数据: 使用put命令，但是每次只能保存一个列的值</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">put命令需要指定表名, 行键, 列族名:列标识符, 值, [时间戳]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">时间戳是可选项，如果没有显式指定，则系统自动插入当前时间戳</span><br>put &quot;MY_TABLE&quot;, &quot;000001&quot;, &quot;C1:Name&quot;, &quot;test&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新数据，同样使用put命令</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看数据: 使用get命令，可以获取行或者单元格的数据</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">表名，行键获取一行的数据</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">表名，行键，列族名:列标识符 获取单元格的数据</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中文的显示 &#123;FORMATTER =&gt; <span class="hljs-string">&#x27;toString&#x27;</span>&#125;</span><br>get &quot;MY_TABLE&quot;, &quot;000001&quot;<br>get &quot;MY_TABLE&quot;, &quot;000001&quot;, &quot;C1:Name&quot;, &#123;FORMATTER =&gt; &#x27;toString&#x27;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看全表，使用scan命令</span><br>scan &quot;MY_TABLE&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">限制查询数目</span><br>scan &quot;MY_TABLE&quot;, &#123;LIMIT =&gt; 3, FORMATTER =&gt; &#x27;toString&#x27;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定查询的列</span><br>scan &quot;MYTABLE&quot;, &#123;COLUMNS =&gt; [&#x27;C1:Name&#x27;,&#x27;C2:Address&#x27;]&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定查询的行键</span><br>scan &quot;MY_TABLE&quot;, &#123;ROWPREFIXFILTER =&gt; &#x27;000001&#x27;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除数据</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除某一个单元格的数据，使用delete</span><br>delete &quot;MY_TABLE&quot;, &quot;000001&quot;, &quot;C1:Name&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">delete无法跨列族操作，如果要删除一个逻辑行，需要使用deleteall命令</span><br>deleteall &quot;MY_TABLE&quot;, &quot;000001&quot;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，delete操作并不会马上删除数据，只会将对应的数据打上删除标记，在空闲合并数据的时候，数据才会被删除。同时delete删除的是最新版本的数据。</p></blockquote><h2 id="hbase过滤器">HBase过滤器</h2><p>在HBase中，get和scan操作可以使用过滤器来设置输出的范围，增加查询的条件，类似于SQL里面的where条件。在HBaseShell中使用<code>show_filter</code>命令可以查看当前HBase支持的过滤器类型。过滤器的实现使用的是Java，HBaseShell命令相当于封装了一层进行API的调用。</p><p>过滤器的语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scan &quot;表名&quot;, &#123;FILTER =&gt; &quot;过滤器(比较运算符, &#x27;比较器表达式&#x27;)&quot;&#125;<br></code></pre></td></tr></table></figure><ul><li>过滤器表示过滤的层次，如行键过滤器、列族过滤器等</li><li>比较运算符即表示判断逻辑，如等于，大于，小于等</li><li>比较器表达式表示进行比较的值，如匹配完整字节数组，匹配子字符串等</li></ul><p>过滤器可以在官方API中找到 <ahref="https://hbase.apache.org/devapidocs/index.html">org.apache.hadoop.hbase.filter(Apache HBase 3.0.0-alpha-3-SNAPSHOT API)</a>。所在包为<code>package org.apache.hadoop.hbase.filter</code></p><p>比较运算符：<code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>!=</code></p><p>比较器：</p><table><thead><tr class="header"><th>比较器</th><th>表达式语言缩写</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>BinaryComparator</td><td>binary:value</td><td>匹配完整字节数组</td></tr><tr class="even"><td>BinaryPrefixComparator</td><td>binaryprefix:value</td><td>匹配字节数组前缀</td></tr><tr class="odd"><td>BitComparator</td><td>bit:value</td><td>匹配比特位</td></tr><tr class="even"><td>NullComparator</td><td>null</td><td>匹配空值</td></tr><tr class="odd"><td>RegexStringComparator</td><td>regexstring:正则表达式</td><td>匹配正则表达式</td></tr><tr class="even"><td>SubstringComparator</td><td>substring:value</td><td>匹配子字符串</td></tr></tbody></table><p>并且如果需要使用多个过滤器共同来实现查询，可以使用<code>AND</code>或者<code>OR</code>来组合多个过滤器来完成查询</p><blockquote><p>但是需要注意的是，在HBaseShell中默认都是字符串比较，如果比较数值类型，可能会出现不准确的情况。</p></blockquote><p>下面介绍一些常用的过滤器以及对应的使用方法。</p><h3 id="行键过滤器">行键过滤器</h3><p>行键过滤器，RowFilter，可以实现对行键字符串的比较和过滤。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果行键是1234的子字符串，则匹配</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;RowFilter(=, &#x27;substring:1234&#x27;)&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果行键大于hahaha(字符串顺序)，则匹配</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;RowFilter(&gt;, &#x27;binary:hahaha&#x27;)&quot;&#125;<br></code></pre></td></tr></table></figure><p>其他行键过滤器描述：</p><table><thead><tr class="header"><th>行键过滤器</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>PrefixFilter</td><td>行键前缀比较器</td></tr><tr class="even"><td>KeyOnlyFilter</td><td>只显示单元格的键（列族名：列标识符），不显示值</td></tr><tr class="odd"><td>FirstKeyOnlyFilter</td><td>对于每一行，只显示第一个单元格</td></tr><tr class="even"><td>InclusiveStopFilter</td><td>指定终止条件行</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">PrefixFilter</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面两种方式等价, PrefixFilter无需结合运算符和比较器</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;PrefixFilter(&#x27;0001&#x27;)&quot;&#125;<br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;RowFilter(=, &#x27;binaryprefix:0001&#x27;)&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">KeyOnlyFilter</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;KeyOnlyFilter()&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">FirstKeyOnlyFilter</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;FirstKeyOnlyFilter()&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">InclusiveStopFilter</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面两种方式等价</span><br>scan &quot;MY_TABLE&quot;, &#123;STARTROW =&gt; &#x27;0001&#x27;, FILTER =&gt; &quot;InclusiveStopFilter(&#x27;binary:0002&#x27;)&quot;&#125;<br>scan &quot;MY_TABLE&quot;, &#123;STARTROW =&gt; &#x27;0001&#x27;, ENDROW =&gt; &#x27;0003&#x27;&#125;<br></code></pre></td></tr></table></figure><h3 id="列族与列过滤器">列族与列过滤器</h3><p>列族过滤器，FamilyFilter，根据列族字符串进行比较和过滤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配所有列族为C1的单元格</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;FamilyFilter(=, &#x27;binary:C1&#x27;)&quot;&#125;<br></code></pre></td></tr></table></figure><p>其他列过滤器描述：</p><table><thead><tr class="header"><th>列过滤器</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>QualifierFilter</td><td>列标识符过滤器，根据列标识符进行过滤</td></tr><tr class="even"><td>ColumnPrefixFilter</td><td>对列标识符前缀进行过滤</td></tr><tr class="odd"><td>MultipleColumnPrefixFilter</td><td>可以指定多个前缀对列标识符进行过滤</td></tr><tr class="even"><td>ColumnRangeFilter</td><td>过滤列标识符名称的范围，指定区间，同时可以指定区间开闭</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">QualifierFilter</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;QualifierFilter(=, &#x27;binary:Math&#x27;)&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ColumnPrefixFilter</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ColumnPrefixFilter无需结合运算符和比较器</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;ColumnPrefixFilter(&#x27;Ma&#x27;)&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">MultipleColumnPrefixFilter</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;MultipleColumnPrefixFilter(&#x27;Ma&#x27;, &#x27;Ag&#x27;)&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ColumnRangeFilter</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面命令指定为左开右闭</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;ColumnRangeFilter(&#x27;Big&#x27;, ture, &#x27;Math&#x27;, false)&quot;&#125;<br></code></pre></td></tr></table></figure><h3 id="值过滤器">值过滤器</h3><p>值过滤器按照单元格的值进行匹配和过滤。</p><table><thead><tr class="header"><th>值过滤器</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>ValueFilter</td><td>值过滤器，根据单元格中的值找到符合条件的键值对</td></tr><tr class="even"><td>SingleColumnValueFilter</td><td>指定对应列族和列，按照定位到的值进行比较</td></tr><tr class="odd"><td>SingleColumnValueExcludeFilter</td><td>排除匹配成功的值，与上一个过滤器的扫描结果相反</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ValueFilter,匹配所有值为haha的单元格</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;ValueFilter(=, &#x27;binary:haha&#x27;)&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">SingleColumnValueFilter,指定列族，列标识符，比较运算符，比较器</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">匹配所有C1:Name项值为haha的单元格</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;SingleColumnValueFilter(&#x27;C1&#x27;, &#x27;Name&#x27;, =, &#x27;binary:haha&#x27;)&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">SingleColumnValueExcludeFilter</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">SingleColumnValueFilter的反向匹配</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;SingleColumnValueExcludeFilter(&#x27;C1&#x27;, &#x27;Name&#x27;, =, &#x27;binary:haha&#x27;)&quot;&#125;<br></code></pre></td></tr></table></figure><h3 id="其他过滤器">其他过滤器</h3><table><thead><tr class="header"><th>过滤器</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>ColumnCountGetFilter</td><td>限制每个逻辑行中返回键值对的个数</td></tr><tr class="even"><td>TimestampsFilter</td><td>根据时间戳进行过滤，可以同时设置多个时间戳</td></tr><tr class="odd"><td>InclusiveStopFilter</td><td>设置停止行，扫描到对应行就停止扫描</td></tr><tr class="even"><td>PageFilter</td><td>对显示结果按行进行分页显示</td></tr><tr class="odd"><td>ColumnPaginationFilter</td><td>对一个逻辑行内的所有列进行分页，返回[offset,offset+limit]范围内的列</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ColumnCountGetFilter</span> <br>get &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;ColumnCountGetFilter(3)&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">TimestampsFilter</span><br>scan &quot;MY_TABLE&quot;, &#123;FILTER =&gt; &quot;TimestampsFilter(1, 3)&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">InclusiveStopFilter</span><br>scan &quot;MY_TABLE&quot;, &#123;STARTROW =&gt; &#x27;0001&#x27;, ENDROW =&gt; &#x27;0005&#x27;, FILTER =&gt; &quot;InclusiveStopFilter(&#x27;0003&#x27;)&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">PageFilter</span><br>scan &quot;MY_TABLE&quot;, &#123;STARTROW =&gt; &#x27;0001&#x27;, ENDROW =&gt; &#x27;0005&#x27;, FILTER =&gt; &quot;PageFilter(3)&quot;&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ColumnPaginationFilter</span><br>scan &quot;MY_TABLE&quot;, &#123;STARTROW =&gt; &#x27;0001&#x27;, ENDROW =&gt; &#x27;0005&#x27;, FILTER =&gt; &quot;ColumnPaginationFilter(2, 1)&quot;&#125;<br></code></pre></td></tr></table></figure><h2 id="其他操作">其他操作</h2><h3 id="数据上传与导出">数据上传与导出</h3><p>我们可以通过一个txt文件来完成数据的上传，在这个txt文件中每一行都是一条能够在HBaseShell中执行的命令。我们可以在HBaseShell之外，在Linux命令行中执行下面的命令，将txt文件中的命令一次全部执行。这一过程类似于MySQL中对<code>.sql</code>文件的<code>source</code>操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hbase shell [txt文件在Linux文件系统中的位置]<br></code></pre></td></tr></table></figure><p>还可以使用提供的MapReduce程序进行数据上传，在HBase中提供了一个用于Import的MapReduce作业，专门用来将数据文件导入到HBase中，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hbase org.apache.hadoop.hbase.mapreduce.Import 表名 HDFS数据文件路径<br></code></pre></td></tr></table></figure><p>对应还存在一个数据导出的MapReduce程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hbase org.apache.hadoop.hbase.mapreduce.Export 表名 HDFS输出路径<br></code></pre></td></tr></table></figure><h3 id="大量数据的计数统计">大量数据的计数统计</h3><p>当HBase中数据量大的时候，可以使用HBase中提供的MapReduce程序来进行计数统计，语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">HBASE_HOME/bin/hbase org.apache.hadoop.hbase.mapreduce.RowCounter <span class="hljs-string">&quot;表名&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="incr">incr</h3><p>incr可以实现对某个单元格的值进行原子性计数，语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">incr &quot;表名&quot;, &quot;rowkey&quot;, &quot;列族:列标识符&quot;, [累加值，默认为1]<br></code></pre></td></tr></table></figure><p>如果某一列需要实现计数功能，必须使用incr来创建对应的列，使用put创建的列是不能实现累加功能的。</p><p>对于incr创建的列，需要使用get_counter来访问，格式与get命令类似。</p><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="http://c.biancheng.net/view/6522.html">HBase过滤器入门教程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>HBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase学习笔记-入门(3)-HBase数据模型</title>
    <link href="/2022/04/17/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-3-HBase%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/04/17/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-3-HBase%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="hbase数据模型">HBase数据模型</h2><p>HBase中不支持关系型模型，而是根据用户的需求提供更加灵活和可扩展的表设计。在HBase中，同样存在表、行、列、单元格等概念，不同的是，HBase中有列族的概念。一个列族包括一列或者多列，并且HBase中的每个列都必须属于一个列族。</p><p>可以将HBase的数据模型理解成一个多个维度的Map结构。一张HBase表中存在若干行，并且一张表拥有多个列族，一个列族中存在多个列。根据行键我们可以唯一地定位到一行，在一行中，根据列族+列标识符又可以唯一定位到一列，即得到一个单元格。（可以将行键理解为一级key，列族+列标识符理解成二级key）</p><h3 id="表table">表（Table）</h3><p>HBase中的数据以表的形式存储，同一张表中的数据通常是相关的。一张表拥有多个列族，并且一张表由多个行组成。</p><h3 id="行row">行（Row）</h3><p>HBase中的一行由行键RowKey完全标识，一行内可以拥有多个列族，一个列族拥有多个列。通过列族+列标识符可以定位到行内的某一个值的内容。</p><p>行在存储的时候，会按照行键字典顺序进行排序。</p><h3 id="列族column-family">列族（Column Family）</h3><p>HBase中的列族是一些列的集合。一个列族拥有的列不需要事先定义，列族支持动态扩展，用户可以很轻松地添加一个列，无须预定义列的数量以及类型（也无法定义类型）。所有的列均以字符串的形式存储，在用户使用的时候按照需要自行进行数据类型转换</p><h3 id="列标识符column-qualifier">列标识符（Column Qualifier）</h3><p>列族中的数据通过列标识符来进行定位，列标识符没有特定的数据类型，按照byte[ ]来进行存储。</p><p>拥有了列族和列标识符之后，就可以按照<code>Column Family Name:Column Qualifier</code>格式来定位某一列，例如<code>C1:USER</code>。</p><h3 id="单元格cell">单元格（Cell）</h3><p>通过行键、列族、列标识符，我们可以定位到一个单元格，单元格中的内容以二进制存储，其中保存同一份数据的多个版本。每个版本记录了一个值和一个时间戳，用来标识版本的先后，最新的数据排列在最前面。</p><h3 id="时间戳timestamp">时间戳（Timestamp）</h3><p>在默认情况下，每一个单元格插入数据时都会用时间戳来进行版本标识。读取单元格数据时，如果时间戳没有被指定，则默认返回最新的数据；写入新的单元格数据时，如果没有设置时间戳，默认使用当前时间。每一个列族的单元数据的版本数量都被HBase 单独维护，默认情况下 HBase 保留 3 个版本数据。</p><h3 id="命名空间namespace">命名空间（NameSpace）</h3><p>命名空间，类似于关系型数据库中的DataBase概念。每个命名空间下有多个表，HBase有两个自带的命名空间，分别是hbase和default。其中hbase下存放的是HBase内置的表，包括meta和namespace等；而default是用户默认使用的命名空间。</p><hr /><p>对比来说，HBase表与关系型数据库中的表结构看起来没有太大差异，只是HBase中多了列族的概念，但是实际上差别还是挺大的。</p><p>在关系型数据库中，表的结构需要预先定义，包括列名，数据类型，值域等。如果需要添加新的列，需要修改表结构，而这对已经存在的数据会造成很大影响，并且关系型数据库中对每个列都预留了存储空间，如果新增一个列的话，会导致关系型数据库中产生很多<code>Null</code>值，消耗大量的存储空间。同时关系型数据库按照行来存储。</p><p>而在HBase中，<code>Null</code>在物理上不占用存储空间。并且如果要添加新列的话，只需要在列族中动态添加即可。另一方面，HBase面向列存储，在实际的物理存储中，列族是分开存储的。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>HBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase学习笔记-入门(2)-HBase集群搭建</title>
    <link href="/2022/04/16/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/04/16/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="前置条件">前置条件</h2><p>搭建HBase集群之间，首先需要完成Hadoop集群的搭建，并且需要先安装和搭建好Zookeeper。安装详情可以参考对应文章，搭建的集群同样为<code>hadoop102</code>，<code>hadoop103</code>，<code>hadoop104</code>。</p><p>这里需要注意Hadoop、Zookeeper以及HBase的版本适配问题，可以参考官方文档：<ahref="https://hbase.apache.org/book.html#basic.prerequisites">ApacheHBase ™ Reference Guide</a></p><p>此处选择的版本如下：</p><table><thead><tr class="header"><th>软件</th><th>版本</th></tr></thead><tbody><tr class="odd"><td>Hadoop</td><td>3.1.3</td></tr><tr class="even"><td>Zookeeper</td><td>3.7.0</td></tr><tr class="odd"><td>HBase</td><td>2.4.11</td></tr></tbody></table><h2 id="集群搭建">集群搭建</h2><p>首先需要上传解压HBase安装包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -zxvf hbase-2.4.11-bin.tar.gz -C /opt/moudle<br></code></pre></td></tr></table></figure><p>之后需要修改HBase中的配置文件，路径为<code>$HBase/conf</code></p><p>首先需要修改<code>hbase-env.sh</code>文件，这其中配置了HBase运行时变量，如Java路径，RegionServer相关参数等。这里我们需要在其中配置Java环境，并且设置使用我们自己的Zookeeper：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> JAVA_HOME=/opt/module/jdk1.8.0_212/<br><span class="hljs-built_in">export</span> HBASE_MANAGES_ZK=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><ul><li><p>第一行设置Java环境</p></li><li><p>第二行设置使用我们自己的Zookeeper</p><blockquote><p>如果该项设置为true，则表示使用Zookeeper作为HBase的一部分来管理启动，即Zookeeper随着HBase的启动而启动，随其关闭而关闭；</p><p>如果设置为false，则表示Zookeeper作为独立的集群来运行，与HBase脱离关系。</p></blockquote></li></ul><p>之后需要配置<code>hbase-site.xml</code>文件，其中可以添加HBase的相关配置，如分布式的模式，Zookeeper的配置等，配置如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-comment">&lt;!-- HBase数据在HDFS中的存放的路径 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.rootdir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://hadoop102:8020/hbase<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Hbase的运行模式。false是单机模式，true是分布式模式。若为false,Hbase和Zookeeper会运行在同一个JVM里面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.cluster.distributed<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- ZooKeeper的地址 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop102,hadoop103,hadoop104<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- ZooKeeper快照的存储位置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/opt/module/zookeeper-3.7.0/zkData<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>phoenix.schema.isNamespaceMappingEnabled<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中的NameNode节点，Zookeeper的地址，Zookeeper数据的存储位置需要按照实际进行配置。</p><p>（注意，NameNode节点和HMaster节点并没有绝对的一致关系，并不是说HMaster节点一定在NameNode节点上，具体在哪一个节点上运行HMaster与Zookeeper有关）</p><p>由于我们搭建的是完全分布式，所以需要在<code>regionservers</code>中写入需要配置为RegionServer的节点：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">hadoop102<br>hadoop103<br>hadoop104<br></code></pre></td></tr></table></figure><p>之后，添加相关的环境变量（和之前一样，我们选择放在<code>/etc/profile.d/my_env.sh</code>中）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#HBASE_HOME</span><br><span class="hljs-built_in">export</span> HBASE_HOME=/opt/module/hbase-2.4.11<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HBASE_HOME</span>/bin<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HBASE_HOME</span>/sbin<br></code></pre></td></tr></table></figure><p>在一台机器上完成对应操作之后，将文件进行分发，最终三台机器上拥有了对应的文件夹。之后就可以启动集群了。</p><h2 id="集群启动">集群启动</h2><p>在启动HBase之前，需要先启动Hadoop和Zookeeper。</p><p>命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动HBase</span><br><span class="hljs-variable">$HBASE_HOME</span>/bin/start-hbase.sh<br><span class="hljs-comment"># 关闭HBase</span><br><span class="hljs-variable">$HBASE_HOME</span>/bin/stop-hbase.sh<br></code></pre></td></tr></table></figure><p>由于配置了环境变量，可以直接使用。</p><p>启动集群之后，可以使用hbaseshell进行测试。输入<code>hbase shell</code>进入命令行操作模式，输入status查看目前状态，出现以下内容则表示hbase已经安装配置成功了：</p><img src="/2022/04/16/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-HBase%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/hbase-shell-status.png" class="" title="hbase-shell-status"><p>同时可以通过网页端可视化查看HBase，访问NameNode的16010端口（http://hadoop102:16010）</p><p>通过jps查看目前运行的Java进程，可以在Master节点上查看到HMaster进程，Slave节点上查看到HRegionServer进程。如果使用的是HBase内置的Zookeeper，则节点上还能够查看到HQuorumPeer进程；如果使用的是用户的Zookeeper，则查看到的是QuorumPeerMain进程。</p><blockquote><p>HQuorumPeer表示hbase管理的zookeeper</p><p>QuorumPeerMain表示zookeeper独立的进程</p></blockquote><h2 id="高可用配置">高可用配置</h2><p>HBase的高可用配置其实就是HMaster的高可用。在高可用情况下，如果HMaster进程由于某种原因不在了，会在备用节点中重新选举出新的Master</p><p>配置HMaster的高可用步骤如下：</p><ol type="1"><li>在<code>$HBASE_HOME/conf</code>中创建<code>backup-masters</code>文件</li><li>在文件中写入作为备用Master节点的主机名称，例如hadoop103、hadoop104</li><li>将修改后的文件进行分发</li><li>重启HBase</li><li>之后通过WebUI进行检查，可以查看到Backup Master中出现备用节点</li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>HBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase学习笔记-入门(1)-HBase基本介绍</title>
    <link href="/2022/04/16/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-HBase%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/04/16/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-HBase%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="hbase介绍">HBase介绍</h2><p>HBase是一个开源的、分布式的、版本化的非关系型数据库（NoSQL），底层利用HDFS提供分布式数据存储。HBase可以对数据进行随机存取和检索，可以存储结构化和半结构化的数据，例如一些网站内容，日志信息等等可以存放在HBase中。</p><ul><li>HBase是BigTable的开源Java版本，底层建立在HDFS之上，提供高可靠，高性能、列存储、可伸缩、实时读写等功能，属于NoSQL</li><li>在HBase中仅能够通过主键和主键的range来进行数据检索，并且仅支持单行事务</li><li>主要用来存储结构化和半结构化的数据</li><li>HBase仅提供简单的数据查询功能，不支持join等复杂操作，不支持复杂事务，相比传统的关系型数据库来说，HBase缺少很多特性，例如不支持带类型的列，不支持二级索引以及高级查询语言等</li><li>HBase中支持的数据类型为：byte[ ]</li></ul><p>HBase应用场景举例：对象存储、时序数据、推荐画像、时空数据、CubeDBOLAP、消息 / 订单、爬虫数据存储、海量数据备份、短网址...</p><p>HBase的特点：</p><ul><li><p>数据量大：一个表可以有上十亿行，上百万列，并且可以在横向和纵向两个维度插入数据，具有很大的弹性。而HBase采用LSM树作为内部数据存储结构，这种结构会周期性地将较小文件合并成大文件，以减少对磁盘的访问</p></li><li><p>面向列的存储：HBase内部使用面向列（族）的存储和权限控制，列（族）独立检索。其中的每个列是单独存储的。</p><blockquote><p>行存储的情况：一张表的数据存放在一起，进行数据的插入和更新会相对容易，但是查询操作需要读取所有（大部分）的数据</p><p>列存储的情况：一张表按照列分开存储，查询操作仅需要读取相关列即可，可以大幅降低系统的I/O吞吐量</p></blockquote></li><li><p>稀疏存储：对于为空的列，并不会占用存储空间。因此，表可以设计得非常稀疏，在很大程度上节省了存储开销</p></li><li><p>强扩展性：HBase底层为HDFS，支持分布式存储。HBase同样具有横向扩展性，通过增加集群中的服务器数量来提升集群的容量和性能</p><blockquote><p>HBase表根据Region大小进行分区，分别存放在集群中不同节点上。当添加新的节点时，集群会进行重新调整，在新的节点上启动HBase服务器，动态地实现扩展。</p><p>HBase的扩展是热扩展，可以在不停止现有服务的情况下，动态增减节点。</p></blockquote></li><li><p>高可靠性：HBase运行在HDFS之上，HDFS的多副本存储机制可以让HBase实现出现故障时的自动恢复，同时HBase内部也提供WAL和Replication机制。当集群中的单个节点出现故障的时候，协调服务组件Zookeeper会通知集群的主节点，将故障节点的HLog中的日志信息分发到各个从节点中进行数据恢复</p><blockquote><p>WAL（Write-Ahead-Log）预写日志：在HBase服务器处理数据插入和删除的过程中用来记录操作内容的日志。在执行操作之前先写入日志，保证数据写入的时候不会因集群异常而导致写入数据的丢失。</p><p>Replication机制：基于日志操作做数据同步。</p></blockquote></li></ul><h2 id="hbase对比">HBase对比</h2><h3 id="hbase-vs-rdbms">HBase vs RDBMS</h3><table><thead><tr class="header"><th>HBase</th><th>RDBMS</th></tr></thead><tbody><tr class="odd"><td>数据以表的形式存在</td><td>数据以表的形式存在</td></tr><tr class="even"><td>支持HDFS文件系统</td><td>支持多种文件系统（FAT，NTFS，EXT...）</td></tr><tr class="odd"><td>使用行键进行访问</td><td>使用主键进行访问</td></tr><tr class="even"><td>原生支持分布式存储和计算引擎</td><td>可以通过外部中间件支持分库分表，但是底层还是单机引擎</td></tr><tr class="odd"><td>具有行、列、列族、单元格等概念</td><td>具有行、列、单元格等概念</td></tr><tr class="even"><td></td><td></td></tr><tr class="odd"><td>支持横向扩展</td><td>支持向上的纵向扩展</td></tr><tr class="even"><td>使用API、MapReduce、Spark、Flink等来访问数据</td><td>使用SQL进行查询</td></tr><tr class="odd"><td>面向列族的存储，每个列族都是一个连续的单元</td><td>面向行的存储</td></tr><tr class="even"><td>不支持事务（支持单行数据的事务操作），不支持ACID特性</td><td>支持事务，并且保证事务的ACID特性</td></tr><tr class="odd"><td>适合结构化数据和非结构化数据</td><td>适合结构化数据</td></tr><tr class="even"><td>一般是分布式的</td><td>一般是中心化的</td></tr><tr class="odd"><td>不支持join等复杂操作</td><td>支持join等复杂操作</td></tr></tbody></table><h3 id="hbase-vs-hdfs">HBase vs HDFS</h3><p>HDFS是一个非常适合存储大型文件的分布式文件系统，但是不是一个通用的文件系统，无法在文件中快速查询某个数据。</p><p>HBase构建在HDFS之上，并为大型表提供快速查找（和更新）的操作。HBase内部将大量数据放在HDFS中名为<code>StoreFiles</code>的索引中，以便进行高速查找。HBase比较适合做快速查询等需求。</p><h3 id="hbase-vs-hive">HBase vs Hive</h3><p>Hive是一种数据仓库工具，它的本质相当于将HDFS中已经存储的文件在MySQL中做一个映射，以便使用HQL去管理查询。Hive通常用于数据分析和清洗，因为延迟较高，所以适用于离线的数据分析和清洗。Hive也是基于HDFS和MapReduce的，Hive存储的数据依旧在DataNode上，编写的HQL语句最终转换成MapReduce代码进行执行。</p><p>HBase是一种面向列存储的非关系型数据库，用于存储结构化和非结构化数据，不适合做关联查询等操作。HBase基于HDFS，数据持久化存储的体现形式是HFile，存放在DataNode中，被RegionServer以region等形式进行管理。同时延迟较低，适合接入在线业务使用。</p><p>总结来说，Hive和HBase是两种基于Hadoop的不同技术，Hive是一种类SQL的引擎，运行MapReduce任务；HBase是一种基于HDFS的键值对NoSQL数据库。两种技术可以同时使用，Hive用来进行统计查询，HBase用来进行实时数据查询，数据可以从Hive写入到HBase，或者从HBase写入Hive。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>HBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL表格形式转化例题</title>
    <link href="/2022/03/10/SQL%E8%A1%A8%E6%A0%BC%E5%BD%A2%E5%BC%8F%E8%BD%AC%E5%8C%96%E4%BE%8B%E9%A2%98/"/>
    <url>/2022/03/10/SQL%E8%A1%A8%E6%A0%BC%E5%BD%A2%E5%BC%8F%E8%BD%AC%E5%8C%96%E4%BE%8B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="列转行">列转行</h2><h3 id="eg.1179.重新格式化部门表">eg.1179.重新格式化部门表</h3><blockquote><p>部门表 Department： | Column Name | Type | | ----------- | ---- | |id | int | | revenue | int | | month | varchar |</p><p>(id, month)是表的联合主键。这个表格有关于每个部门每月收入的信息。月份（month）可以取下列值["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]。</p><p>编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id列和一些对应 每个月 的收入（revenue）列。</p><p>查询结果格式如下面的示例所示：</p><p>Department 表：</p><table><thead><tr class="header"><th>id</th><th>revenue</th><th>month</th></tr></thead><tbody><tr class="odd"><td>1</td><td>8000</td><td>Jan</td></tr><tr class="even"><td>2</td><td>9000</td><td>Jan</td></tr><tr class="odd"><td>3</td><td>10000</td><td>Feb</td></tr><tr class="even"><td>1</td><td>7000</td><td>Feb</td></tr><tr class="odd"><td>1</td><td>6000</td><td>Mar</td></tr></tbody></table><p>查询得到的结果表： | id | Jan_Revenue | Feb_Revenue | Mar_Revenue |... | Dec_Revenue | | ---- | ----------- | ----------- | ----------- |---- | ----------- | | 1 | 8000 | 7000 | 6000 | ... | null | | 2 | 9000| null | null | ... | null | | 3 | null | 10000 | null | ... | null|</p><p>注意，结果表有 13 列 (1个部门 id 列 + 12个月份的收入列)。</p></blockquote><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>    id, <br>    max(if(month=&#x27;Jan&#x27;, revenue, NULL)) as Jan_Revenue,<br>    max(if(month=&#x27;Feb&#x27;, revenue, NULL)) as Feb_Revenue,<br>    max(if(month=&#x27;Mar&#x27;, revenue, NULL)) as Mar_Revenue,<br>    max(if(month=&#x27;Apr&#x27;, revenue, NULL)) as Apr_Revenue,<br>    max(if(month=&#x27;May&#x27;, revenue, NULL)) as May_Revenue,<br>    max(if(month=&#x27;Jun&#x27;, revenue, NULL)) as Jun_Revenue,<br>    max(if(month=&#x27;Jul&#x27;, revenue, NULL)) as Jul_Revenue,<br>    max(if(month=&#x27;Aug&#x27;, revenue, NULL)) as Aug_Revenue,<br>    max(if(month=&#x27;Sep&#x27;, revenue, NULL)) as Sep_Revenue,<br>    max(if(month=&#x27;Oct&#x27;, revenue, NULL)) as Oct_Revenue,<br>    max(if(month=&#x27;Nov&#x27;, revenue, NULL)) as Nov_Revenue,<br>    max(if(month=&#x27;Dec&#x27;, revenue, NULL)) as Dec_Revenue<br>from Department<br>group by id<br>order by id<br></code></pre></td></tr></table></figure><ul><li>group by之后使用if过滤</li></ul><h2 id="行转列">行转列</h2><h3id="eg.1795.每个产品在不同商店的价格">eg.1795.每个产品在不同商店的价格</h3><blockquote><p>表：Products | Column Name | Type | | ----------- | ---- | |product_id | int | | store1 | int | | store2 | int | | store3 | int|</p><p>这张表的主键是product_id（产品Id）。每行存储了这一产品在不同商店store1,store2, store3的价格。如果这一产品在商店里没有出售，则值将为null。</p><p>请你重构 Products表，查询每个产品在不同商店的价格，使得输出的格式变为(product_id, store,price) 。如果这一产品在商店里没有出售，则不输出这一行。输出结果表中的顺序不作要求 。</p><p>查询输出格式请参考下面示例。</p><p>示例 1：</p><p>输入： Products table: | product_id | store1 | store2 | store3 | |---------- | ------ | ------ | ------ | | 0 | 95 | 100 | 105 | | 1 | 70| null | 80 |</p><p>输出： | product_id | store | price | | ---------- | ----- | ----- || 0 | store1 | 95 | | 0 | store2 | 100 | | 0 | store3 | 105 | | 1 |store1 | 70 | | 1 | store3 | 80 |</p><p>解释：</p><p>产品0在store1，store2,store3的价格分别为95,100,105。</p><p>产品1在store1，store3的价格分别为70,80。在store2无法买到。</p></blockquote><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>    product_id, <br>    &#x27;store1&#x27; as store,<br>    max(store1) as price<br>from Products<br>where store1 is not NULL<br>group by product_id<br>union all<br>select <br>    product_id, <br>    &#x27;store2&#x27; as store,<br>    max(store2) as price<br>from Products<br>where store2 is not NULL<br>group by product_id<br>union all<br>select <br>    product_id, <br>    &#x27;store3&#x27; as store,<br>    max(store3) as price<br>from Products<br>where store3 is not NULL<br>group by product_id<br></code></pre></td></tr></table></figure><ul><li>利用union all拼接不同情况</li><li>利用where过滤不同情况</li></ul><h2 id="数列构建">数列构建</h2><h3 id="eg.1613.找到遗失的id">eg.1613.找到遗失的ID</h3><blockquote><p>表: Customers | Column Name | Type | | ----------- | ---- | |customer_id | int | | customer_name | varchar |</p><p>customer_id 是该表主键.该表第一行包含了顾客的名字和id.</p><p>写一个 SQL 语句, 找到所有遗失的顾客id. 遗失的顾客id是指那些不在Customers 表中, 值却处于 1 和表中最大 customer_id 之间的id.</p><p>注意: 最大的 customer_id 值不会超过 100.返回结果按 ids 升序排列</p><p>查询结果格式如下例所示.</p><p>Customers 表: | customer_id | customer_name | | ----------- |------------- | | 1 | Alice | | 4 | Bob | | 5 | Charlie |</p><p>Result 表:</p><table><thead><tr class="header"><th>ids</th></tr></thead><tbody><tr class="odd"><td>2</td></tr><tr class="even"><td>3</td></tr></tbody></table><p>表中最大的customer_id是5, 所以在范围[1,5]内, ID2和3从表中遗失.</p></blockquote><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">with recursive temp(n) as (<br>    select 1<br>    union all<br>    select n+1<br>    from temp<br>    where n &lt;(<br>        select max(customer_id)<br>        from Customers<br>    )<br>) # 利用with递归查询构造id范围<br><br>select t.n as ids<br>from temp as t<br>where t.n not in (<br>    select customer_id<br>    from Customers<br>)<br></code></pre></td></tr></table></figure><h3id="eg.1767.寻找没有被执行的任务对">eg.1767.寻找没有被执行的任务对</h3><blockquote><p>表：Tasks | Column Name | Type | | ----------- | ---- | | task_id |int | | subtasks_count | int |</p><p>task_id 是这个表的主键。task_id表示的为主任务的id,每一个task_id被分为了多个子任务(subtasks)，subtasks_count表示为子任务的个数（n），它的值表示了子任务的索引从1到n。本表保证2&lt;=subtasks_count&lt;= 20。</p><p>表： Executed | Column Name | Type | | ----------- | ---- | | task_id| int | | subtask_id | int |</p><p>(task_id, subtask_id)是这个表的主键。每一行表示标记为task_id的主任务与标记为subtask_id的子任务被成功执行。本表保证，对于每一个task_id，subtask_id&lt;=subtasks_count。请试写一个SQL查询语句报告没有被执行的（主任务，子任务）对，即没有被执行的（task_id,subtask_id）。</p><p>以 任何顺序 返回即可。</p><p>查询结果格式如下。</p><p>示例 1：</p><p>输入：</p><p>Tasks 表:</p><table><thead><tr class="header"><th>task_id</th><th>subtasks_count</th></tr></thead><tbody><tr class="odd"><td>1</td><td>3</td></tr><tr class="even"><td>2</td><td>2</td></tr><tr class="odd"><td>3</td><td>4</td></tr></tbody></table><p>Executed 表: | task_id | subtask_id | | ------- | ---------- | | 1 |2 | | 3 | 1 | | 3 | 2 | | 3 | 3 | | 3 | 4 |</p><p>输出： | task_id | subtask_id | | ------- | ---------- | | 1 | 1 | |1 | 3 | | 2 | 1 | | 2 | 2 |</p><p>解释：</p><p>Task 1 被分成了 3 subtasks (1, 2, 3)。只有 subtask 2 被成功执行,所以我们返回 (1, 1) 和 (1, 3) 这两个主任务子任务对。</p><p>Task 2 被分成了 2 subtasks (1, 2)。没有一个subtask被成功执行,因此我们返回(2, 1)和(2, 2)。</p><p>Task 3 被分成了 4 subtasks (1, 2, 3,4)。所有的subtask都被成功执行，因此对于Task 3,我们不返回任何值。</p></blockquote><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">with recursive temp(task_id, subtask_id) as(<br>    select task_id, subtasks_count as subtask_id<br>    from Tasks<br>    union all<br>    select task_id, subtask_id-1<br>    from temp<br>    where subtask_id &gt; 1<br>) # 主要注意递归查询的书写<br><br>select t.task_id as task_id, t.subtask_id as subtask_id<br>from temp as t<br>left join Executed as e<br>on t.task_id = e.task_id and t.subtask_id = e.subtask_id<br>where e.subtask_id is NULL<br>order by task_id, subtask_id<br></code></pre></td></tr></table></figure><h2 id="字符串构建">字符串构建</h2><h3 id="eg.1384.按年度列出销售总额">eg.1384.按年度列出销售总额</h3><blockquote><p>Product 表： | Column Name | Type | | ----------- | ---- | |product_id | int | | product_name | varchar |</p><p>product_id 是这张表的主键。product_name 是产品的名称。</p><p>Sales 表： | Column Name | Type | | ----------- | ---- | | product_id| int | | period_start | date | | period_end | date | |average_daily_sales | int |</p><p>product_id 是这张表的主键。period_start 和 period_end是该产品销售期的起始日期和结束日期，且这两个日期包含在销售期内。average_daily_sales列存储销售期内该产品的日平均销售额。</p><p>编写一段 SQL 查询每个产品每年的总销售额，并包含 product_id,product_name 以及 report_year 等信息。</p><p>销售年份的日期介于 2018 年到 2020 年之间。你返回的结果需要按product_id 和 report_year 排序。</p><p>查询结果格式如下例所示：</p><p>Product table: | product_id | product_name | | ---------- |------------ | | 1 | LC Phone | | 2 | LC T-Shirt | | 3 | LC Keychain|</p><p>Sales table: | product_id | period_start | period_end |average_daily_sales | | ---------- | ------------ | ---------- |------------------- | | 1 | 2019-01-25 | 2019-02-28 | 100 | | 2 |2018-12-01 | 2020-01-01 | 10 | | 3 | 2019-12-01 | 2020-01-31 | 1 |</p><p>Result table: | product_id | product_name | report_year |total_amount | | ---------- | ------------ | ----------- | ------------| | 1 | LC Phone | 2019 | 3500 | | 2 | LC T-Shirt | 2018 | 310 | | 2 |LC T-Shirt | 2019 | 3650 | | 2 | LC T-Shirt | 2020 | 10 | | 3 | LCKeychain | 2019 | 31 | | 3 | LC Keychain | 2020 | 31 |</p></blockquote><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mysql">with years as (<br>    select<br>        &#x27;2018&#x27; as year,<br>        &#x27;2018-01-01&#x27; as year_start,<br>        &#x27;2018-12-31&#x27; as year_end<br>    union<br>    select<br>        &#x27;2019&#x27; as year,<br>        &#x27;2019-01-01&#x27; as year_start,<br>        &#x27;2019-12-31&#x27; as year_end<br>    union<br>    select<br>        &#x27;2020&#x27; as year,<br>        &#x27;2020-01-01&#x27; as year_start,<br>        &#x27;2020-12-31&#x27; as year_end<br>) # 列出时间范围框架表<br><br>select <br>    temp.product_id as product_id,<br>    p.product_name as product_name,<br>    temp.year as report_year,<br>    (datediff(temp.end,temp.start) + 1) * temp.avg_sales as total_amount<br>from (<br>    select #列出每个产品在每一年的销售时间<br>        s.product_id as product_id, y.year as year, average_daily_sales as avg_sales,<br>        if(s.period_start&gt;y.year_start, s.period_start, y.year_start) as start,<br>        if(s.period_end&lt;y.year_end, s.period_end, y.year_end) as end<br>    from Sales as s<br>    left join years as y<br>    on not(s.period_end &lt; y.year_start or s.period_start &gt; year_end)<br>) as temp<br>join Product as p<br>on temp.product_id = p.product_id<br>order by product_id, report_year<br></code></pre></td></tr></table></figure><p>eg.1635.Hopper公司查询</p><blockquote><p>表: Drivers | Column Name | Type | | ----------- | ---- | | driver_id| int | | join_date | date |</p><p>driver_id是该表的主键。该表的每一行均包含驾驶员的ID以及他们加入Hopper公司的日期。</p><p>表: Rides | Column Name | Type | | ----------- | ---- | | ride_id |int | | user_id | int | | requested_at | date |</p><p>ride_id是该表的主键。该表的每一行均包含行程ID(ride_id)，用户ID(user_id)以及该行程的日期(requested_at)。该表中可能有一些不被接受的乘车请求。</p><p>表: AcceptedRides | Column Name | Type | | ----------- | ---- | |ride_id | int | | driver_id | int | | ride_distance | int | |ride_duration | int |</p><p>ride_id是该表的主键。该表的每一行都包含已接受的行程信息。表中的行程信息都在“Rides”表中存在。</p><p>编写SQL查询以报告2020年每个月的以下统计信息：</p><p>截至某月底，当前在Hopper公司工作的驾驶员数量（active_drivers）。该月接受的乘车次数（accepted_rides）。返回按month升序排列的结果表，其中month是月份的数字（一月是1，二月是2，依此类推）。</p><p>查询结果格式如下例所示。</p><p>表 Drivers: | driver_id | join_date | | --------- | --------- | | 10| 2019-12-10 | | 8 | 2020-1-13 | | 5 | 2020-2-16 | | 7 | 2020-3-8 | | 4| 2020-5-17 | | 1 | 2020-10-24 | | 6 | 2021-1-5 |</p><p>表 Rides: | ride_id | user_id | requested_at | | ------- | ------- |------------ | | 6 | 75 | 2019-12-9 | | 1 | 54 | 2020-2-9 | | 10 | 63 |2020-3-4 | | 19 | 39 | 2020-4-6 | | 3 | 41 | 2020-6-3 | | 13 | 52 |2020-6-22 | | 7 | 69 | 2020-7-16 | | 17 | 70 | 2020-8-25 | | 20 | 81 |2020-11-2 | | 5 | 57 | 2020-11-9 | | 2 | 42 | 2020-12-9 | | 11 | 68 |2021-1-11 | | 15 | 32 | 2021-1-17 | | 12 | 11 | 2021-1-19 | | 14 | 18 |2021-1-27 |</p><p>表 AcceptedRides: | ride_id | driver_id | ride_distance |ride_duration | | ------- | --------- | ------------- | ------------- || 10 | 10 | 63 | 38 | | 13 | 10 | 73 | 96 | | 7 | 8 | 100 | 28 | | 17 |7 | 119 | 68 | | 20 | 1 | 121 | 92 | | 5 | 7 | 42 | 101 | | 2 | 4 | 6 |38 | | 11 | 8 | 37 | 43 | | 15 | 8 | 108 | 82 | | 12 | 8 | 38 | 34 | |14 | 1 | 90 | 74 |</p><p>结果表: | month | active_drivers | accepted_rides | | ----- |-------------- | -------------- | | 1 | 2 | 0 | | 2 | 3 | 0 | | 3 | 4 |1 | | 4 | 4 | 0 | | 5 | 5 | 0 | | 6 | 5 | 1 | | 7 | 5 | 1 | | 8 | 5 | 1| | 9 | 5 | 0 | | 10 | 6 | 0 | | 11 | 6 | 2 | | 12 | 6 | 1 |</p><p>截至1月底-&gt;两个活跃的驾驶员（10,8），没有被接受的行程。</p><p>截至2月底-&gt;三个活跃的驾驶员（10,8,5），没有被接受的行程。</p><p>截至3月底-&gt;四个活跃的驾驶员（10,8,5,7），一个被接受的行程（10）。</p><p>截至4月底-&gt;四个活跃的驾驶员（10,8,5,7），没有被接受的行程。</p><p>截至5月底-&gt;五个活跃的驾驶员（10,8,5,7,4），没有被接受的行程。</p><p>截至6月底-&gt;五个活跃的驾驶员（10,8,5,7,4），一个被接受的行程（13）。</p><p>截至7月底-&gt;五个活跃的驾驶员（10,8,5,7,4），一个被接受的行程（7）。</p><p>截至8月底-&gt;五个活跃的驾驶员（10,8,5,7,4），一位接受的行程（17）。</p><p>截至9月底-&gt;五个活跃的驾驶员（10,8,5,7,4），没有被接受的行程。</p><p>截至10月底-&gt;六个活跃的驾驶员（10,8,5,7,4,1），没有被接受的行程。</p><p>截至11月底-&gt;六个活跃的驾驶员（10,8,5,7,4,1），两个被接受的行程（20,5）。</p><p>截至12月底-&gt;六个活跃的驾驶员（10,8,5,7,4,1），一个被接受的行程（2）。</p></blockquote><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs mysql">with temp as (<br>    select &#x27;2020-1-31&#x27; as end_date<br>    union all<br>    select &#x27;2020-2-29&#x27; as end_date<br>    union all<br>    select &#x27;2020-3-31&#x27; as end_date<br>    union all<br>    select &#x27;2020-4-30&#x27; as end_date<br>    union all    <br>    select &#x27;2020-5-31&#x27; as end_date<br>    union all<br>    select &#x27;2020-6-30&#x27; as end_date<br>    union all<br>    select &#x27;2020-7-31&#x27; as end_date<br>    union all <br>    select &#x27;2020-8-31&#x27; as end_date<br>    union all <br>    select &#x27;2020-9-30&#x27; as end_date<br>    union all <br>    select &#x27;2020-10-31&#x27; as end_date<br>    union all <br>    select &#x27;2020-11-30&#x27; as end_date<br>    union all <br>    select &#x27;2020-12-31&#x27; as end_date  <br>) # 构建每个月份的最终截止日期<br><br><br>select <br>    month(t1.end_date) as month,<br>    any_value(t1.active_drivers) as active_drivers,<br>    sum(if(t2.ride_date is NULL, 0, 1)) as accepted_rides<br>from(<br>    select # 查询每个月的活跃司机数<br>        t.end_date as end_date, <br>        count(if(d.join_date &lt;= t.end_date, 1, NULL)) as active_drivers<br>    from temp as t <br>    join Drivers as d<br>    group by t.end_date<br>) as t1<br>left join(<br>    select # 查询接受的行程的具体时间<br>    date_format(r.requested_at,&#x27;%Y-%m&#x27;) as ride_date<br>    from AcceptedRides as a<br>    left join Rides as r<br>    on a.ride_id = r.ride_id<br>) as t2<br>on date_format(t1.end_date, &#x27;%Y-%m&#x27;) = t2.ride_date<br>group by t1.end_date<br>order by month<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>LeetCode</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL表格形式转化问题技巧汇总</title>
    <link href="/2022/03/10/SQL%E8%A1%A8%E6%A0%BC%E5%BD%A2%E5%BC%8F%E8%BD%AC%E5%8C%96%E9%97%AE%E9%A2%98%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"/>
    <url>/2022/03/10/SQL%E8%A1%A8%E6%A0%BC%E5%BD%A2%E5%BC%8F%E8%BD%AC%E5%8C%96%E9%97%AE%E9%A2%98%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="表格转化">表格转化</h2><p>表格转化大体上可以分分为两类，一种是原始表格的转化问题，另一种是设计序列构建新表格的问题。而在原始表格转化问题中，又可以分成行转列和列转行；在设计序列构建新表格的问题中，又可以分成数列构建和字符串构建。</p><h2 id="原始表格转化">原始表格转化</h2><h3 id="行转列">1. 行转列</h3><p>第一种情况：原表格有基准id</p><blockquote><p><strong>group by + sum / max / min + case / if / where</strong></p></blockquote><p>eg.1777.每家商店的产品价格（简单）</p><blockquote><p>表：Products</p><table><thead><tr class="header"><th>Column Name</th><th>Type</th></tr></thead><tbody><tr class="odd"><td>product_id</td><td>int</td></tr><tr class="even"><td>store</td><td>enum</td></tr><tr class="odd"><td>price</td><td>int</td></tr></tbody></table><p>(product_id,store) 是这个表的主键。store字段是枚举类型，它的取值为以下三种 ('store1', 'store2', 'store3')。price 是该商品在这家商店中的价格。写出一个 SQL查询语句，查找每种产品在各个商店中的价格。可以以 任何顺序 输出结果。</p><p>查询结果格式如下例所示：</p><p>Products 表：</p><table><thead><tr class="header"><th>product_id</th><th>store</th><th>price</th></tr></thead><tbody><tr class="odd"><td>0</td><td>store1</td><td>95</td></tr><tr class="even"><td>0</td><td>store3</td><td>105</td></tr><tr class="odd"><td>0</td><td>store2</td><td>100</td></tr><tr class="even"><td>1</td><td>store1</td><td>70</td></tr><tr class="odd"><td>1</td><td>store3</td><td>80</td></tr></tbody></table><p>Result 表：</p><table><thead><tr class="header"><th>product_id</th><th>store1</th><th>store2</th><th>store3</th></tr></thead><tbody><tr class="odd"><td>0</td><td>95</td><td>100</td><td>105</td></tr><tr class="even"><td>1</td><td>70</td><td>null</td><td>80</td></tr></tbody></table><p>产品 0 的价格在商店 1 为 95 ，商店 2 为 100 ，商店 3 为 105 。产品 1的价格在商店 1 为 70 ，商店 3 的产品 1 价格为 80 ，但在商店 2中没有销售。</p></blockquote><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>    product_id, <br>    max(if(store=&#x27;store1&#x27;, price, NULL)) as store1,<br>    max(if(store=&#x27;store2&#x27;, price, NULL)) as store2,<br>    max(if(store=&#x27;store3&#x27;, price, NULL)) as store3<br>from Products<br>group by product_id<br></code></pre></td></tr></table></figure><ul><li>首先group by进行分组，然后通过if过滤分别计算不同指标</li></ul><p>第二种情况：原表格没有基准id，需要我们自己构造</p><blockquote><p><strong>row_number() + group by + sum / max / min + case / if /where</strong></p></blockquote><p>eg.618.学生地理信息报告</p><blockquote><p>一所美国大学有来自亚洲、欧洲和美洲的学生，他们的地理信息存放在如下student 表中。</p><table><thead><tr class="header"><th>name</th><th>continent</th></tr></thead><tbody><tr class="odd"><td>Jack</td><td>America</td></tr><tr class="even"><td>Pascal</td><td>Europe</td></tr><tr class="odd"><td>Xi</td><td>Asia</td></tr><tr class="even"><td>Jane</td><td>America</td></tr></tbody></table><p>写一个查询语句实现对大洲（continent）列的 透视表操作，使得每个学生按照姓名的字母顺序依次排列在对应的大洲下面。输出的标题应依次为美洲（America）、亚洲（Asia）和欧洲（Europe）。</p><p>对于样例输入，它的对应输出是：</p><table><thead><tr class="header"><th>America</th><th>Asia</th><th>Europe</th></tr></thead><tbody><tr class="odd"><td>Jack</td><td>Xi</td><td>Pascal</td></tr><tr class="even"><td>Jane</td><td></td><td></td></tr></tbody></table></blockquote><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>    max(if(continent=&#x27;America&#x27;, name, NULL)) as America,<br>    max(if(continent=&#x27;Asia&#x27;, name, NULL)) as Asia,<br>    max(if(continent=&#x27;Europe&#x27;, name, NULL)) as Europe<br>from(<br>    select # 按照每个州划分，每个州按照name进行排序<br>        name, <br>        continent,<br>        row_number() over(partition by continent order by name) as rk<br>    from student<br>) as temp<br>group by rk<br></code></pre></td></tr></table></figure><ul><li>首先构造基准id，在这里是rk</li><li>之后与情况一类似</li></ul><p><strong>总结</strong></p><ul><li>观察题中是否有基准id,若题中无基准id，需要先使用row_number()进行构造</li><li>使用的聚合函数sum/max/min是根据列中的数据格式决定的</li></ul><h3 id="列转行">2. 列转行</h3><p>列转行通用技巧是使用<strong>union all</strong></p><p>eg.1435.制作会话柱状图</p><blockquote><p>表：Sessions | Column Name | Type | | ----------- | ---- | |session_id | int | | duration | int |</p><p>session_id 是该表主键，duration 是用户访问应用的时间, 以秒为单位</p><p>你想知道用户在你的 app上的访问时长情况。因此决定统计访问时长区间分别为 "[0-5&gt;","[5-10&gt;", "[10-15&gt;" 和 "15 or more"（单位：分钟）的会话数量，并以此绘制柱状图。写一个SQL查询来报告（访问时长区间，会话总数）。结果可用任何顺序呈现。</p><p>下方为查询的输出格式：</p><p>Sessions 表： | session_id | duration | | ---------- | -------- | | 1| 30 | | 2 | 199 | | 3 | 299 | | 4 | 580 | | 5 | 1000 |</p><p>Result 表： | bin | total | | ---- | ----- | | [0-5&gt; | 3 | |[5-10&gt; | 1 | | [10-15&gt; | 0 | | 15 or more | 1 |</p><p>对于 session_id 1，2 和 3 ，它们的访问时间大于等于 0 分钟且小于 5分钟。</p><p>对于 session_id 4，它的访问时间大于等于 5 分钟且小于 10 分钟.</p><p>没有会话的访问时间大于等于 10 分钟且小于 15 分钟。</p><p>对于 session_id 5, 它的访问时间大于等于 15 分钟。</p></blockquote><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>    &#x27;[0-5&gt;&#x27; as bin,<br>    sum(if(duration &gt;=0 and duration &lt;300, 1, 0)) as total<br>from Sessions<br>union all<br>select<br>    &#x27;[5-10&gt;&#x27; as bin,<br>    sum(if(duration &gt;=300 and duration &lt;600, 1, 0)) as total<br>from Sessions<br>union all<br>select<br>    &#x27;[10-15&gt;&#x27; as bin,<br>    sum(if(duration &gt;=600 and duration &lt;900, 1, 0)) as total<br>from Sessions<br>union all<br>select<br>    &#x27;15 or more&#x27; as bin,<br>    sum(if(duration &gt;=900, 1, 0)) as total<br>from Sessions<br></code></pre></td></tr></table></figure><ul><li>利用union all完成不同情况下行的拼接</li></ul><h2 id="设计序列构建新表格">设计序列构建新表格</h2><h3 id="数列构建">1. 数列构建</h3><p>result中出现了一个无中生有的列，且列中的数据为一个逐渐递增的数列，考虑使用with的递归方法构建</p><blockquote><p><strong>with recursive + left join</strong></p></blockquote><p>eg.1336.每次访问的交易次数</p><blockquote><p>表: Visits | Column Name | Type | | ----------- | ---- | | user_id |int | | visit_date | date |</p><p>(user_id, visit_date) 是该表的主键，该表的每行表示 user_id 在visit_date 访问了银行</p><p>表: Transactions | Column Name | Type | | ----------- | ---- | |user_id | int | | transaction_date | date | | amount | int |</p><p>该表没有主键，所以可能有重复行。该表的每一行表示 user_id 在transaction_date 完成了一笔 amount 数额的交易，可以保证用户 (user) 在transaction_date 访问了银行 (也就是说 Visits 表包含 (user_id,transaction_date)行)，银行想要得到银行客户在一次访问时的交易次数和相应的在一次访问时该交易次数的客户数量的图表。</p><p>写一条 SQL查询多少客户访问了银行但没有进行任何交易，多少客户访问了银行进行了一次交易等等</p><p>结果包含两列：</p><p>transactions_count： 客户在一次访问中的交易次数</p><p>visits_count： 在 transactions_count交易次数下相应的一次访问时的客户数量transactions_count 的值从 0到所有用户一次访问中的max(transactions_count) 按 transactions_count排序</p><p>下面是查询结果格式的例子：</p><p>Visits 表: | user_id | visit_date | | ------- | ---------- | | 1 |2020-01-01 | | 2 | 2020-01-02 | | 12 | 2020-01-01 | | 19 | 2020-01-03 || 1 | 2020-01-02 | | 2 | 2020-01-03 | | 1 | 2020-01-04 | | 7 |2020-01-11 | | 9 | 2020-01-25 | | 8 | 2020-01-28 |</p><p>Transactions 表: | user_id | transaction_date | amount | | ------- |---------------- | ------ | | 1 | 2020-01-02 | 120 | | 2 | 2020-01-03 |22 | | 7 | 2020-01-11 | 232 | | 1 | 2020-01-04 | 7 | | 9 | 2020-01-25 |33 | | 9 | 2020-01-25 | 66 | | 8 | 2020-01-28 | 1 | | 9 | 2020-01-25 |99 |</p><p>结果表: | transactions_count | visits_count | | ------------------ |------------ | | 0 | 4 | | 1 | 5 | | 2 | 0 | | 3 | 1 |</p><ul><li>对于 transactions_count = 0, visits 中 (1, "2020-01-01"), (2,"2020-01-02"), (12, "2020-01-01") 和 (19, "2020-01-03")没有进行交易，所以 visits_count = 4 。</li><li>对于 transactions_count = 1, visits 中 (2, "2020-01-03"), (7,"2020-01-11"), (8, "2020-01-28"), (1, "2020-01-02") 和 (1, "2020-01-04")进行了一次交易，所以 visits_count = 5 。</li><li>对于 transactions_count = 2, 没有客户访问银行进行了两次交易，所以visits_count = 0 。</li><li>对于 transactions_count = 3, visits 中 (9, "2020-01-25")进行了三次交易，所以 visits_count = 1 。</li><li>对于 transactions_count &gt;= 4,没有客户访问银行进行了超过3次交易，所以我们停止在 transactions_count = 3。</li></ul></blockquote><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">with recursive temp(transactions_count) as<br>(<br>    select 0<br>    union all<br>    select transactions_count+1 <br>    from temp<br>    where transactions_count&lt;(<br>        select max(num) as max_num<br>        from(<br>            select<br>                count(*) over(partition by transaction_date, user_id) as num<br>            from transactions<br>        ) as temp<br>    )<br>) # 利用with recursive构造出结果表中的第一列<br># 后续使用temp表进行left连接<br>select t.transactions_count, count(t1.id) as visits_count<br>from temp as t<br>left join (<br>    select v.user_id as id, v.visit_date, count(t.amount) as times<br>    from Visits as v<br>    left join Transactions as t<br>    on v.user_id = t.user_id and v.visit_date = t.transaction_date<br>    group by v.user_id, v.visit_date<br>) as t1<br>on t.transactions_count = t1.times<br>group by t.transactions_count<br></code></pre></td></tr></table></figure><h3 id="字符串构建">2. 字符串构建</h3><p>result中出现了一个无中生有的列，且列中的数据为未曾出现过的字符串，考虑使用<strong>unionall</strong>方法直接构造</p><p>eg.1127.用户购买平台</p><blockquote><p>支出表: Spending | Column Name | Type | | ----------- | ---- | |user_id | int | | spend_date | date | | platform | enum | | amount | int|</p><p>这张表记录了用户在一个在线购物网站的支出历史，该在线购物平台同时拥有桌面端（'desktop'）和手机端（'mobile'）的应用程序。</p><p>这张表的主键是 (user_id, spend_date, platform)。平台列 platform是一种 ENUM ，类型为（'desktop', 'mobile'）。</p><p>写一段 SQL 来查找每天 仅 使用手机端用户、仅使用桌面端用户和 同时使用桌面端和手机端的用户人数和总支出金额。</p><p>查询结果格式如下例所示：</p><p>Spending table: | user_id | spend_date | platform | amount | |------- | ---------- | -------- | ------ | | 1 | 2019-07-01 | mobile |100 | | 1 | 2019-07-01 | desktop | 100 | | 2 | 2019-07-01 | mobile | 100| | 2 | 2019-07-02 | mobile | 100 | | 3 | 2019-07-01 | desktop | 100 | |3 | 2019-07-02 | desktop | 100 |</p><p>Result table: | spend_date | platform | total_amount | total_users || ---------- | -------- | ------------ | ----------- | | 2019-07-01 |desktop | 100 | 1 | | 2019-07-01 | mobile | 100 | 1 | | 2019-07-01 |both | 200 | 1 | | 2019-07-02 | desktop | 100 | 1 | | 2019-07-02 |mobile | 100 | 1 | | 2019-07-02 | both | 0 | 0 |</p><p>在 2019-07-01, 用户1 同时 使用桌面端和手机端购买, 用户2 仅使用了手机端购买，而用户3 仅 使用了桌面端购买。</p><p>在 2019-07-02, 用户2 仅 使用了手机端购买, 用户3 仅使用了桌面端购买，且没有用户 同时 使用桌面端和手机端购买。</p></blockquote><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>    temp2.spend_date,<br>    temp1.platform,<br>    sum(if(temp1.platform = temp2.platform, amount, 0)) as total_amount,<br>    count(if(temp1.platform = temp2.platform, 1, null)) as total_users<br>from (<br>    select &#x27;mobile&#x27; as platform<br>    union<br>    select &#x27;desktop&#x27; as platform<br>    union<br>    select &#x27;both&#x27; as platform<br>) as temp1 # 字符串构建<br>join (<br>    select<br>        user_id, spend_date,<br>        any_value(if(count(platform) = 2, &#x27;both&#x27;, platform)) as platform,<br>        sum(amount) as amount<br>    from Spending<br>    group by user_id, spend_date<br>) as temp2<br>group by temp2.spend_date, temp1.platform<br></code></pre></td></tr></table></figure><h2 id="with的递归查询">with的递归查询</h2><p>with recursive语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">with recursive temp(n) as<br>(<br>    select 0 #初始条件<br>    union all<br>    select n+1 # 每次递归的操作<br>    from temp # 调用递归<br>    where n&lt;7 # 递归停止条件<br>)<br></code></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://leetcode-cn.com/problems/students-report-by-geography/solution/zong-jie-ge-lei-biao-ge-ge-shi-hua-wen-t-tl4e/">pipideveloper-总结各类表格格式化问题-leetcode</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>LeetCode</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-Yarn(2)-Yarn命令行操作与参数配置</title>
    <link href="/2022/02/23/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Yarn-2-Yarn%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/02/23/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Yarn-2-Yarn%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="yarn常用命令">Yarn常用命令</h2><h3 id="任务查看">1.任务查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 列出所有的Application<br>yarn application -list<br><br>// 根据Application状态进行过滤<br>yarn application -list -appStates 状态<br><br>// 根据application_id来kill掉Appliation<br>yarn application -kill application_id<br></code></pre></td></tr></table></figure><ul><li>任务的所有状态有：ALL、NEW、NEW_SAVING、SUBMITTED、ACCEPTED、RUNNING、FINISHED、FAILED、KILLED</li></ul><h3 id="日志查看">2.日志查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 查询Application日志<br>yarn logs -applicationId application_id<br><br>// 查询Container日志<br>yarn logs -applicationId application_id -containerId container_id<br></code></pre></td></tr></table></figure><ul><li>application_id可以通过任务查看得到，container_id可以通过容器查看得到</li></ul><h3 id="运行任务查看">3.运行任务查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 列出所有Application尝试的列表<br>yarn applicationattempt -list application_id<br><br>// 打印ApplicationAttempt状态<br>yarn applicationattempt -status application_id<br></code></pre></td></tr></table></figure><h3 id="容器查看">4.容器查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 列出某个application的所有container<br>yarn container -list application_id<br><br>// 打印Container的状态<br>yarn container -status container_id<br></code></pre></td></tr></table></figure><ul><li>注意只有任务在运行的过程中才能看到Container的状态，因为任务运行完成之后Container会释放</li></ul><h3 id="节点状态查看">5.节点状态查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 列出所有节点<br>yarn node -list -all<br></code></pre></td></tr></table></figure><h3 id="队列查看">6.队列查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 打印队列信息<br>yarn queue -status QueueName<br></code></pre></td></tr></table></figure><ul><li>QueueName即在调度器中的队列名称</li></ul><h3 id="队列配置更新">7.队列配置更新</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 更新队列配置<br>yarn rmadmin -refreshQueues<br></code></pre></td></tr></table></figure><ul><li><p>只有队列配置信息更新之后可以刷新</p></li><li><p>如果更改了Yarn配置的话则无法使用这个命令刷新，需要重启Yarn</p></li></ul><h2 id="yarn重要参数配置">Yarn重要参数配置</h2><p>1）ResourceManager相关</p><ul><li><code>yarn.resourcemanager.scheduler.class</code>：配置调度器，默认为容量调度器</li><li><code>yarn.resourcemanager.client.thread-count</code>：ResourceManager用来处理调度器请求的线程数量，默认为50</li></ul><p>2）NodeManager相关</p><ul><li><p><code>yarn.nodemanager.resource.detect-hardware-capabilities</code>：是否让yarn自动检测硬件进行配置，默认为false</p></li><li><p><code>yarn.nodemanager.resource.count-logical-processors-as-cores</code>：是否将虚拟核数当作CPU核数，默认为false</p></li><li><p><code>yarn.nodemanager.resource.pcores-vcores-multiplier</code>：虚拟核数与物理核数的比例</p></li><li><p><code>yarn.nodemanager.resource.memory-mb</code>：NodeManager使用内存，默认为8G</p></li><li><p><code>yarn.nodemanager.resource.system-reserved-memory-mb</code>：NodeManager为系统保留多少内存</p><blockquote><p>上面两个参数只需要配置一个即可</p></blockquote></li><li><p><code>yarn.nodemanager.resource.cpu-vcores</code>：NodeManager使用CPU核数，默认为8个</p></li><li><p><code>yarn.nodemanager.pmem-check-enabled</code>：是否开启物理内存检查限制container，默认打开</p></li><li><p><code>yarn.nodemanager.vmem-check-enabled</code>：是否开启虚拟内存检查限制container，默认打开</p></li><li><p><code>yarn.nodemanager.vmem-pmem-ratio</code>：虚拟内存与物理内存比例，默认为2:1</p></li></ul><p>3）Container相关</p><ul><li><code>yarn.scheduler.minimum-allocation-mb</code>：容器最小内存，默认1G</li><li><code>yarn.scheduler.maximun-allocation-mb</code>：容器最大内存，默认8G</li><li><code>yarn.scheduler.minimum-allocation-vcores</code>：容器最小CPU核数，默认1个</li><li><code>yarn.scheduler.maximum-allocation-vcores</code>：容器最大CPU核数，默认4个</li></ul><p>以上配置信息可以在<code>yarn-site.xml</code>中进行配置。</p><h2 id="调度器配置">调度器配置</h2><p>容量调度器和公平调度器默认情况下都只有一个default队列，不能满足生产要求。可以在配置文件中配置多队列。</p><p>配置多队列可以防止单个任务将所有资源全部耗尽；并且可以实现任务的降级使用，在特殊时期保证重要的任务队列资源充足</p><ol type="1"><li><p>容量调度器配置：相关配置在<code>$HADOOP_HOME/etc/hadoop/capacity-scheduler.xml</code>中，可以配置多队列、配置每个队列的最低和最大使用资源、队列使用权限、队列优先级、任务超时设置等</p></li><li><p>公平调度器配置：公平调度器的配置默认在ApacheHadoop中没有，需要自己创建配置文件，然后在<code>yarn-site.xml</code>文件中指定相关的配置信息，同样可以配置队列相关的信息</p></li></ol><blockquote><p>通过-D来表示运行时改变参数值，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-D mapreduce.job.queuename=xxx<br></code></pre></td></tr></table></figure><p>附加：Yarn的Tool接口，动态参数传递的同时，允许-D来添加运行参数值</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>Yarn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-Yarn(1)-Yarn概述与工作机制</title>
    <link href="/2022/02/23/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Yarn-1-Yarn%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/02/23/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Yarn-1-Yarn%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="yarn概述">Yarn概述</h2><p>Yarn是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而MapReduce等运算程序就相当于运行在操作系统上的应用程序。</p><h3 id="基础架构">1. 基础架构</h3><p>Yarn的主要组件有：ResouceManager、NodeManager、ApplicationMaster和Container等组件构成。</p><ul><li>ResouceManager：Yarn的老大，负责整个系统的资源管理和分配<ol type="1"><li>处理客户端请求</li><li>监控其余的NodeManager</li><li>启动或监控ApplicationMaster</li><li>资源的分配和调度</li></ol></li><li>NodeManager：Yarn的小弟，管理Yarn集群中每个节点上的资源和任务<ol type="1"><li>管理单个节点上的资源</li><li>处理来自ResourceManager的命令</li><li>处理来自ApplicationMaster的命令</li></ol></li><li>ApplicationMaster：管理在Yarn内运行的应用程序实例（客户端提交的单个任务）<ol type="1"><li>为应用程序申请资源并分配给内部的任务</li><li>任务的监控与容错</li><li>一个任务的各个部分可能会在不同的NodeManager上运行</li></ol></li><li>Container：Yarn中的资源抽象<ol type="1"><li>封装了某个节点上的多维度资源，如内存、CPU、磁盘，网络等</li></ol></li></ul><h3 id="工作机制">2. 工作机制</h3><p>回顾前面的阶段，Job提交阶段中，完成了对输入文件的切片，得到了切片规划文件、集群配置文件以及jar包，然后向Yarn提交任务。</p><blockquote><p>需要运行任务，运行资源的时候，都需要向老大ResouceManager进行申请</p></blockquote><ol type="1"><li>MapReduce程序提交到客户端所在的节点</li><li>YarnRunner向ResourceManager申请一个Application，这个Application用于管理这个MapReduce程序，对应一个作业id</li><li>ResourceManager返回该应用程序的资源路径</li><li>YarnRunner接收到返回结果，让MapRedeuce提交运行所需要的资源<ul><li>运行所需要的资源包括<code>Job.split</code>切片规划文件，<code>Job.xml</code>集群配置信息以及<code>xxx.jar</code>程序对应的jar包</li></ul></li><li>程序资源提交完毕之后，申请运行MRAppMaster</li><li>ResourceManager会将用户的请求初始化成为一个Task</li><li>ResourceManager管理的所有Task会形成队列，以调度算法决定执行哪一个Task</li><li>之后其中一个NodeManger领取到这个Task任务</li><li>这个NodeManger创建容器Container，并产生MRAppmaster，管理任务的执行</li><li>Container从HDFS上拷贝资源到本地</li><li>MapReduce程序中需要运行MapTask，则MRAppmaster向ResouceManager申请对应的运行资源</li><li>ResouceManager进行任务分配，则对应的NodeManger会领取任务并创建容器</li><li>MRAppmaster向对应的NodeManger发送启动脚本，并等待所有的MapTask运行完成</li><li>运行完成之后，MRAppmaster再向ResouceManager申请资源运行ReduceTask</li><li>ReduceTask向MapTask获取相应分区的数据</li><li>程序运行完成之后，MRAppmaster向ResouceManager申请注销自己</li></ol><h3 id="作业提交流程">3. 作业提交流程</h3><p>1）<strong>作业提交</strong></p><ol type="1"><li>Client调用job.waitForCompletion方法，向整个集群提交MapReduce作业</li><li>Client向ResourceManager申请一个作业id</li><li>ResourceManager返回job资源的提交路径和作业id</li><li>Client提交jar包、切片信息和配置文件到指定的资源提交路径（提交到HDFS当中）</li><li>Client资源提交完毕，向ResouceManager申请运行MRAppMaster</li></ol><p>2）<strong>作业初始化</strong></p><ol type="1"><li>ResourceManager收到申请之后，将该job添加到容量调度器当中</li><li>某个空闲的NodeManager领取该job</li><li>该NodeManager创建Container，并产生MRAppMaster</li><li>从HDFS上下载Client提交的资源到本地</li></ol><p>3）<strong>任务分配</strong></p><ol type="1"><li>MRAppMaster向ResourceManager申请运行多个MapTask的任务资源</li><li>ResourceManager将运行MapTask任务分配给另外的NodeManager，对应的NodeManager领取任务并创建容器</li></ol><p>4）<strong>任务运行</strong></p><ol type="1"><li>MRAppMaster向接收到任务的NodeManager发送程序启动脚本，启动对应的任务</li><li>MRAppMaster等待所有MapTask运行完毕之后，向ResourceManager申请资源运行ReduceTask</li><li>ReduceTask从MapTask获取相应分区的数据</li><li>程序运行完毕之后，MRAppMaster向ResourceManager申请注销自己</li></ol><p>5）<strong>进度和任务状态更新</strong></p><ol type="1"><li><p>Yarn中的任务将其进度和状态返回给应用管理器，客户端每秒向应用管理器请求进度更新，展示给用户</p><blockquote><p>请求时间可以通过<code>mapreduce.client.progressmonitor.pollinterval</code>进行设置</p></blockquote></li></ol><p>6）<strong>作业完成</strong></p><ol type="1"><li><p>除了向应用管理器请求作业进度外，客户端每5秒都会通过调用waitForCompletion()来检查作业是否完成。作业完成之后，应用管理器和Container会清理工作状态。作业的信息会被历史服务器存储下来，以备后续的用户核查</p><blockquote><p>检查时间间隔可以通过<code>mapreduce.client.completion.pollinterval</code>进行设置</p></blockquote></li></ol><blockquote><p>在其中会涉及到HDFS读写文件，MapReduce工作流程和Yarn工作流程，对应三张流程图。</p></blockquote><h2 id="yarn调度器和调度算法">Yarn调度器和调度算法</h2><p>在Yarn调度任务的过程中存在调度器和调度算法的概念。目前，在Hadoop作业调度器主要有三种：FIFO调度器、容量调度器和公平调度器。</p><ul><li>在Apache Hadoop3.1.3默认的资源调度器是容量调度器</li><li>CDH框架默认是公平调度器</li></ul><p>在Hadoop中的<code>yarn-default.xml</code>文件中可以查看具体配置，字段为<code>yarn.resourcemanager.scheduler.class</code></p><h3 id="先进先出调度器fifo">1.先进先出调度器（FIFO）</h3><p>FIFO调度器：指的是单队列的，根据提交作业的先后顺序进行服务。在FIFO调度器中可以存在同时执行的任务，分配资源的原则是，<strong>将资源分配给最先来的任务，后续的任务在有资源空余的情况下才能够执行。</strong></p><ul><li><p>优点：简单易懂</p></li><li><p>缺点：不支持多队列，在生产环境下很少使用</p></li></ul><h3 id="容量调度器capacity-scheduler">2.容量调度器（CapacityScheduler）</h3><p>容量调度器是Yahoo开发的多用户调度器，它的特点如下：</p><ul><li><strong>支持多队列</strong>：可以配置多个队列，一个队列可以配置一定的资源量，同时在队列内部可以采用相应的调度策略（默认在队列内部使用FIFO调度算法）</li><li><strong>具有容量保证</strong>：对于每个队列，可以设置资源的最低保证和资源的使用上限（最少有多少资源，最多能使用多少资源）</li><li><strong>灵活性</strong>：如果一个队列有资源剩余的时候，可以暂时共享给那些需要资源的队列，但是当这个队列有新的程序提交的时候，外借的资源会进行归还（本队列对自己的资源有最高的使用优先权）</li><li><strong>多租户</strong>：可以支持多用户的集群共享以及多应用程序的共同运行（即在一个队列中可以根据用户进行划分；并且为了防止同一个用户的作业独占队列中的资源，可以对同一用户提交的作业所占的最大资源量进行限制）</li></ul><p>容量调度器的资源分配机制：</p><img src="/2022/02/23/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Yarn-1-Yarn%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/%E5%AE%B9%E9%87%8F%E8%B0%83%E5%BA%A6%E5%99%A8.png" class="" title="容量调度器"><p>容量调度器从root开始进行资源的分配：</p><ol type="1"><li><p><strong>队列资源分配</strong>：在初始设置的时候，可以为每个队列设置资源的占有比例。从root开始，使用深度优先算法，优先选择<strong>队列资源使用率</strong>最低的的队列分配资源。</p><blockquote><p>队列资源使用率：已经使用的资源量 / 队列的最小资源容量</p><p>（其中队列的最小资源容量由管理员配置）</p></blockquote></li><li><p><strong>作业资源分配</strong>：在一个队列中会存在多个任务，默认按照提交作业的优先级和提交时间顺序进行资源分配</p></li><li><p><strong>容器资源分配</strong>：在一个作业中涉及到多个Container，这些Container可能是多样化的，涉及不同的优先级、节点、资源量和数量。该如何为容器分配资源呢？按照容器的优先级进行分配，先为优先级高的Container分配资源。对于同一优先级，按照数据本地性原则进行分配，优先选择满足本地的Container，再依次满足其余的Container</p><blockquote><p>数据本地原则：</p><ol type="1"><li>任务和数据在同一节点</li><li>任务和数据在同一机架</li><li>任务和数据不在同一节点也不在同一机架</li></ol></blockquote></li></ol><h3 id="公平调度器fair-scheduler">3.公平调度器（Fair Scheduler）</h3><p>公平调度器是Fackbook开发的多用户调度器，它和容量调度器存在相同点和不同点：</p><p><strong>与容量调度器的相同点</strong>：</p><ol type="1"><li><strong>支持多队列</strong>：支持多队列多作业</li><li><strong>具有容量保证</strong>：每个队列同样具有资源的最低保证和资源的使用上限</li><li><strong>灵活性</strong>：资源能够共享，同时本队列对自己的资源具有最高使用优先权</li><li><strong>多租户</strong>：多用户集群共享，多应用程序共同运行，同时对同一用户提交的作业所占的最大资源量进行限制</li></ol><p><strong>与容量调度器的不同点</strong>：</p><ol type="1"><li>核心调度策略不同<ul><li>容量调度器：优先选择资源使用率低的队列</li><li>公平调度器：优先选择对资源缺额比例大的</li></ul></li><li>每个队列可以单独设置资源分配方式<ul><li>容量调度器：FIFO、DRF</li><li>公平调度器：FIFO、FAIR、DRF</li></ul></li></ol><blockquote><p>公平分配器如其名，为了实现公平。但是何为公平？这里的公平是通过权重来体现的，而我们默认的公平就对应了权重全为1。</p></blockquote><p>公平调度器的资源分配机制：</p><p>在每个队列中设置的资源分配方式</p><ul><li><p>FIFO策略：公平调度器每个队列资源分配采用FIFO的话，则此时公平调度器相当于上面讲过的容量调度器</p></li><li><p>FAIR策略：FAIR策略是一种最大最小公平算法，它的思想是最大化系统中每个用户收到的最小分配资源。</p><blockquote><p>假设每个用户都有足够的请求，即资源无法空余，则这种策略会给每个用户一份均等资源。而广义上的最大最小公平算法包括权重的概念，用户可以获得与它的权重成正比的一份资源，也即我们前面所说的公平的定义。</p><p>当然如果分配给用户的资源有溢出，则空闲部分可以再分给其余任务。</p></blockquote></li><li><p>DRF策略：DRF基于最大最小公平算法改进而来，不同的是最大最小算法只支持某一种单一资源的分配，而DRF支持多种资源的分配，并且最大化每个任务的主资源的最小分配资源</p><blockquote><p>DRF首先会计算任务是CPU密集型资源还是内存密集型资源，具体来说就是利用任务需要的资源除以系统的总资源得到两个比例，哪个比例大则这个任务的主资源就是对应的资源。</p><p>之后，每次迭代都要选择一个任务进行资源分配，选择方法是选择当前主资源占总资源占比最小的那个任务</p></blockquote></li></ul><p>FAIR分配举例：</p><img src="/2022/02/23/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Yarn-1-Yarn%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/FAIR%E5%88%86%E9%85%8D.png" class="" title="FAIR分配"><ul><li>溢出资源会分配给需要资源的任务</li><li>不加权的情况是加权的特殊情况，即所有权重都相同</li></ul><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://www.itdaan.com/blog/2016/06/05/975b7220a309.html#/">Yarn公平调度器之DRF算法- 开发者知识库 (itdaan.com)</a></li><li><ahref="https://blog.csdn.net/zc19921215/article/details/102961730#/">Yarn的CapacityScheduler与DRF了解_淡定一生2333的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>Yarn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-MapReduce(7)-数据压缩</title>
    <link href="/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-7-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"/>
    <url>/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-7-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="hadoop压缩概述">Hadoop压缩概述</h2><p>压缩的优缺点：</p><ul><li>优点：减少磁盘IO、降低磁盘的存储空间</li><li>缺点：增加CPU开销</li></ul><p>压缩原则：</p><ul><li><p>运算密集型的Job，少用压缩</p></li><li><p>IO密集型的Job，多用压缩</p></li></ul><h2 id="mapreduce支持的压缩编码">MapReduce支持的压缩编码</h2><p>压缩算法的对比介绍</p><table><thead><tr class="header"><th>压缩格式</th><th>Hadoop自带</th><th>算法</th><th>文件扩展名</th><th>是否可切片</th><th>程序是否需要修改</th></tr></thead><tbody><tr class="odd"><td>DEFLATE</td><td>√</td><td>DEFALTE</td><td>.deflate</td><td>×</td><td>不需要</td></tr><tr class="even"><td>Gzip</td><td>√</td><td>DEFALTE</td><td>.gz</td><td>×</td><td>不需要</td></tr><tr class="odd"><td>bzip2</td><td>√</td><td>bzip2</td><td>.bz2</td><td>√</td><td>不需要</td></tr><tr class="even"><td>LZ0</td><td>×，需要安装</td><td>LZ0</td><td>.lzo</td><td>√</td><td>需要建立索引，还需指定输入格式</td></tr><tr class="odd"><td>Snappy</td><td>√</td><td>Snappy</td><td>.snappy</td><td>×</td><td>不需要</td></tr></tbody></table><ul><li>Gzip压缩<ul><li>优点：压缩率较高</li><li>缺点：不支持Split；压缩/解压速度一般</li></ul></li><li>Bzip2压缩<ul><li>优点：压缩率高，支持Split</li><li>缺点：压缩/解压速度慢</li></ul></li><li>Lzo压缩<ul><li>优点：压缩/解压速度比较快，支持Split</li><li>缺点：压缩率一般；想要支持切片需要额外建立索引</li></ul></li><li>Snappy压缩<ul><li>优点：压缩/解压速度块</li><li>缺点：不支持Split，压缩率一般</li></ul></li></ul><h2 id="压缩位置选择">压缩位置选择</h2><p>压缩可以在MapReduce的任意阶段启用</p><ul><li>输入端采用压缩：无需显示指定使用的编解码格式，Hadoop自动检查文件的扩展名</li><li>Mapper输出采用压缩：为了减少MapTask和ReduceTask之间的网络IO，重点考虑压缩和解压块LZO、Snappy</li><li>Reducer输出采用压缩：如果数据永久保存，则考虑压缩率高的Bzip2和Gzip；如果要输入下一个MapReduce，则要考虑数据量和是否支持切片</li></ul><blockquote><p>需要使用压缩的话，可以在驱动类中进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 开启 map 端输出压缩</span><br>conf.setBoolean(<span class="hljs-string">&quot;mapreduce.map.output.compress&quot;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置 map 端输出压缩方式</span><br>conf.setClass(<span class="hljs-string">&quot;mapreduce.map.output.compress.codec&quot;</span>, <br>BZip2Codec.class,CompressionCodec.class);<br><span class="hljs-comment">// 设置 reduce 端输出压缩开启</span><br>FileOutputFormat.setCompressOutput(job, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置压缩的方式</span><br> FileOutputFormat.setOutputCompressorClass(job, BZip2Codec.class); <br><span class="hljs-comment">// FileOutputFormat.setOutputCompressorClass(job, GzipCodec.class); </span><br><span class="hljs-comment">// FileOutputFormat.setOutputCompressorClass(job, DefaultCodec.class);</span><br><br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-MapReduce(6)-Join应用</title>
    <link href="/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-6-Join%E5%BA%94%E7%94%A8/"/>
    <url>/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-6-Join%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="背景描述">背景描述</h2><p>现在我们有两个文件，称为文件A和文件B，文件B更大，文件A更小。希望完成两个文件的Join操作，即使用文件A中的某个字段来替换B中的字段，Join依据为id相同。</p><p>这个任务的重点在于如何完成Join操作，我们可以选择在Reduce阶段完成，也可以在Map阶段完成。</p><h2 id="reduce-join">Reduce Join</h2><p>在这种情况下，Map阶段的工作就是将两个文件都读入，处理成键值对的形式。连接字段作为key，其余内容作为值。并且我们需要打上标签，来表示后面的内容是来自哪一张表的。</p><p>而在Reduce阶段，我们可以根据键值对中的标签来区分不同文件，之后再进行合并即可。</p><blockquote><p>这里不知道如何完成的操作应该是如何判断键值对的内容来自哪一张表，可以通过以下过程来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取对应文件名称 context为上下文对象</span><br><span class="hljs-type">InputSplit</span> <span class="hljs-variable">split</span> <span class="hljs-operator">=</span> context.getInputSplit();<br><span class="hljs-type">FileSplit</span> <span class="hljs-variable">fileSplit</span> <span class="hljs-operator">=</span> (FileSplit) split;<br>filename = fileSplit.getPath().getName();<br><br></code></pre></td></tr></table></figure><p>由于不同文件会产生不同的数据分片，也就会分配给不同的Mapper，所以每个Mapper只需要执行上面的过程一次即可，可以选择将其放在Mapper的setup函数当中（重写setup函数）</p></blockquote><p>这种方案，合并的操作是在Reduce阶段完成的，Reduce阶段的处理压力太大，而Map阶段的运算负载很低，资源利用率不高，在Reduce阶段容易产生数据倾斜。</p><h2 id="map-join">Map Join</h2><p>Mapjoin适用于一张表十分小，一张表很大的场景。具体思想就是在Map端缓存多张表，提前处理业务逻辑。增加Map端的业务，来减少Reduce端数据的压力，尽可能减少数据倾斜。</p><p>使用<strong>DistributedCache</strong>，具体流程如下：</p><ol type="1"><li><p>在Mapper的setup阶段，将文件读取到缓存集合当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过缓存文件得到小表数据 pd.txt</span><br>URI[] cacheFiles = context.getCacheFiles();<br><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(cacheFiles[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//获取文件系统对象,并开流</span><br><span class="hljs-type">FileSystem</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> FileSystem.get(context.getConfiguration());<br><span class="hljs-type">FSDataInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> fs.open(path);<br><span class="hljs-comment">//通过包装流转换为 reader,方便按行读取</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br></code></pre></td></tr></table></figure></li><li><p>在Driver驱动类中加载缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//缓存普通文件到 Task 运行节点。</span><br>job.addCacheFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(<span class="hljs-string">&quot;file:///e:/cache/pd.txt&quot;</span>));<br><span class="hljs-comment">//如果是集群运行,需要设置 HDFS 路径</span><br>job.addCacheFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(<span class="hljs-string">&quot;hdfs://hadoop102:8020/cache/pd.txt&quot;</span>));<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-MapReduce(5)-MapTask和ReduceTask</title>
    <link href="/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-5-MapTask%E5%92%8CReduceTask/"/>
    <url>/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-5-MapTask%E5%92%8CReduceTask/</url>
    
    <content type="html"><![CDATA[<h2 id="maptask">MapTask</h2><ol type="1"><li><p><strong>Read阶段</strong>：MapTask通过InputFormat获得RecordReader，从输入中解析出一个个键值对</p></li><li><p><strong>Map阶段</strong>：将得到的键值对交给用户编写的map函数进行处理，并产生一系列新的键值对</p></li><li><p><strong>Collect阶段</strong>：将生成的键值对进行分区（调用Partitioner），并写入一个环形缓冲区内</p></li><li><p><strong>Spill阶段</strong>：溢写阶段。溢写阶段会生成临时文件，在数据写入本地磁盘之前，先对数据进行一次本地排序，并在必要的时候对数据进行合并、压缩等操作</p><ul><li>使用快排：先按照分区编号进行排序，然后按照key进行排序。这样经过排序之后，数据以分区为单位聚集在一起，并且同一分区所有的数据对key有序</li><li>按照分区编号由小到大将数据写入临时文件中（任务工作目录下的<code>output/spillN.out</code>）。如果用户设置了Combiner，则在写入文件之前还会对每个分区的数据进行一次合并操作</li><li>分区数据的元信息也会写入内存中，每个分区的元信息中包括了分区在临时文件中的偏移量，压缩前数据大小和压缩后数据大小。如果当前内存的索引超过1MB，也会将内存索引写入文件<code>output/spillN.out.index</code>中</li></ul></li><li><p><strong>Merge阶段</strong>：当所有数据处理完成之后，MapTask对所有的临时文件进行一次合并，以确保最终只会生成一个数据文件。</p><ul><li>所有的临时文件合并成一个大文件<code>output/file.out</code>，同时生成相应的索引文件<code>output/file.out.index</code></li><li>在进行文件合并的过程中，MapTask以分区为单位进行合并，对于某个分区来说，会采用多轮递归合并的方式。（每轮合并<code>mapreduce.task.io.sort.factor</code>默认10个文件）</li></ul><blockquote><p>让每个MapTask最终只生成一个数据文件，可以避免同时打开大量文件和同时读取大量小文件产生的随机读取带来的开销</p></blockquote></li></ol><h2 id="reducetask">ReduceTask</h2><ol type="1"><li><strong>Copy阶段</strong>：ReduceTask从各个MapTask上远程拷贝对应数据。并且针对某一片数据，如果其大小超过一定阈值，则写在磁盘上，否则直接放在内存当中</li><li><strong>Sort阶段</strong>：在远程拷贝数据的同时，ReduceTsk启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上的文件过多。</li><li><strong>Reduce阶段</strong>：用户自定义的reduce函数进行结果计算</li></ol><p>对于ReduceTask的启动个数：</p><ol type="1"><li>ReduceTask =0，表示没有Reduce阶段，输出文件个数和Map个数一致，这时候也没有Shuffle阶段</li><li>ReduceTask默认值为1</li><li>如果数据分布不均匀，在Reduce阶段很有可能产生数据倾斜</li><li>ReduceTask数量并不是任意设置的，还要考虑业务逻辑需求</li><li>如果分区数量不是1但是ReduceTask数量是1，则不执行分区过程。因为在MapTask的源码中，执行分区的前提是先判断ReduceNum的个数是否大于1，不大于1的话则不会执行分区过程。</li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-MapReduce(4)-自定义分区和排序</title>
    <link href="/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E5%92%8C%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E5%92%8C%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="partition分区">Partition分区</h2><p>自定义分区类需要继承Partitioner，重写其中的getPartiton方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPartitioner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Partitioner</span>&lt;Text, FLowBean&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPartition</span><span class="hljs-params">(Text text, FLowBean fLowBean, <span class="hljs-type">int</span> numPartitions)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> text.toString();<br><br>        <span class="hljs-type">int</span> partition;<br>        <span class="hljs-comment">// 分区逻辑</span><br>        <span class="hljs-keyword">if</span> (phone.startsWith(<span class="hljs-string">&quot;136&quot;</span>)) &#123;<br>            partition = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phone.startsWith(<span class="hljs-string">&quot;137&quot;</span>)) &#123;<br>            partition = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phone.startsWith(<span class="hljs-string">&quot;138&quot;</span>)) &#123;<br>            partition = <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phone.startsWith(<span class="hljs-string">&quot;139&quot;</span>)) &#123;<br>            partition = <span class="hljs-number">3</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            partition = <span class="hljs-number">4</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> partition;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在驱动类中进行相应的设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置自定义的partitioner，以及设置对应的分区数目</span><br>job.setPartitionerClass(myPartitioner.class);<br>job.setNumReduceTasks(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ol type="1"><li><p>可以自由指定ReduceTask的数量，但是最好和getPartition的结果数保持一致</p><blockquote><ul><li>如果ReduceTask的数量 &gt;getPartition的结果数，则会多产生几个空的输出文件part-r-000xx；</li><li>如果ReduceTask的数量 &lt;getPartition的结果数，则会有一部分数据无处安放，会报错；</li><li>如果ReduceTask的数量 =1，那么不管MapTask输出多少个分区文件，最终结果都交给一个ReduceTask，最终也就只会产生一个结果文件part-r-00000；</li><li><strong>在ReduceTask数量为1的时候，MapTask中根本不走我们自定义的Partitioner，而是走自己创建的一个内部类</strong></li></ul></blockquote></li><li><p>返回的分区号必须从0开始，逐一累加</p></li></ol><h2 id="writablecomparable排序">WritableComparable排序</h2><p>将自定义类作为key的时候，应该实现WritableComparable接口，使得它能够进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlowBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WritableComparable</span>&lt;FlowBean&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(FlowBean bean)</span> &#123;<br>        <span class="hljs-type">int</span> result;<br>        <span class="hljs-comment">// 按照总流量大小，倒序排列</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sumFlow &gt; bean.getSumFlow()) &#123;<br>            result = -<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sumFlow &lt; bean.getSumFlow()) &#123;<br>            result = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            result = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-MapReduce(3)-MapReduce流程</title>
    <link href="/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-3-MapReduce%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-3-MapReduce%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="流程初印象">流程初印象</h2><img src="/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-3-MapReduce%E6%B5%81%E7%A8%8B/%E5%88%9D%E5%8D%B0%E8%B1%A1.png" class="" title="初印象"><p>上面是MapReduce的工作流程图的大致版本，主要可以分为以下几个部分。我首先用通俗的话语描述每个流程需要完成的事情，然后再分别介绍每个环节的具体步骤和细节。</p><ol type="1"><li><p>MapReduce的输入一般来说是一个或者多个文件，在代码中通过指定路径获取。</p></li><li><p>有了文件之后，需要决定这些文件要分配给多少个Mapper，需要如何分配给这些Mapper，即采用什么样的切片机制。这个过程由InputFormat来完成。</p></li><li><p>每个Mapper得到自己对应的那部分文件，之后以某种形式形成键值对输入，经过Mapper的逻辑之后形成键值对输出。</p><blockquote><p>某种形式指可以是&lt;偏移量，一行&gt;或者&lt;偏移量，多行&gt;等，允许用户指定</p></blockquote></li><li><p>每个Mapper的键值对输出，最终都需要持久化成为一个文件，但是并不是一下子形成的，在形成过程中，会涉及到排序，溢写，分区等操作，还有可能Combiner合并操作。最终每个Mapper对应得到一个输出文件。</p></li><li><p>Mapper的任务完成之后启动Reducer，启动Reducer的个数可以由用户指定。Reducer根据分区从不同的Mapper取来对应的数据，然后将其归并成输入文件。以键值对的形式输入，经过Reducer的逻辑之后形成键值对输出。</p></li><li><p>来自Reducer的键值对输出需要持久化为文件，并且每个Reducer最终对应生成一个文件。而键值对应该如何输出成为文件，这个过程由OutputFormat来控制。</p></li></ol><h2 id="inputformat数据输入">InputFormat数据输入</h2><p>这一部分完成的操作是采用<strong>切片机制</strong>决定如何将文件分配给不同的Mapper。并且在这一部分，会讲到Job任务提交的过程。</p><h3 id="数据切片">1. 数据切片</h3><p>在MapReduce中，使用数据切片来对输入的数据进行划分，从而决定一个MapReduce任务需要开启多少个Mapper，称为MapTask并行度。</p><blockquote><p>这里可能会涉及到的概念辨析：</p><ul><li><p>数据块：数据块是HDFS在物理上将数据以块状进行划分存储，<strong>数据块是HDFS的存储数据单位</strong></p></li><li><p>数据切片：数据切片是在逻辑上对输入进行划分，并不会在磁盘上对它进行切分存储。<strong>数据切片是MapReduce程序计算输入数据的单位</strong>，一个切片会对应启动一个MapTask</p></li></ul></blockquote><p>对于一个MapReduce任务来说，它的MapTask并行度在客户端提交任务的时候携带的切片文件信息来决定，切片文件信息中描述了该如何对输入文件进行切片。</p><h3 id="job提交流程">2. Job提交流程</h3><p>Job的提交流程如下：</p><ol type="1"><li>确认当前Job的状态</li><li>处理新旧API之间的兼容性（setUseNewAPI）</li><li>connect（连接本地或者连接集群）</li><li>将Job提交到系统<ol type="1"><li>检查输入和输出路径</li><li>创建提交信息的路径，设置必要的集群信息</li><li>拷贝jar包到集群中</li><li><strong>计算Job的数据切片，生成切片规划文件</strong></li><li>向路径中写入配置文件</li><li>提交Job，返回提交状态</li></ol></li></ol><blockquote><p>在计算数据切片的过程中，会根据配置信息来获取一个InputFormat的子类用于计算数据切片，默认是<strong>FileInputFormat</strong>。</p></blockquote><h3 id="inputformat">3. InputFormat</h3><p>在MapReduce中，InputFormat是一个抽象类，描述了如何来进行数据切片。里面提供了两个抽象方法<code>getSplits</code>和<code>createRecordReader</code>，其他具体完成数据切片的类都是这个抽象类的子类。</p><blockquote><p>这里说的InputFormat类来自于<code>package org.apache.hadoop.mapreduce</code>。而在Hadoop源码中，还存在一个InputFormat接口，这个接口内容与inputFormat类基本一致，但是它来自于<code>package org.apache.hadoop.mapred</code></p><p>这两个包分别是新旧版本的API。<code>package org.apache.hadoop.mapreduce</code>表示更新的版本，值得注意。</p></blockquote><p>在IDEA中通过<code>ctrl+H</code>查看InputFromat的实现类，如下图所示：</p><img src="/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-3-MapReduce%E6%B5%81%E7%A8%8B/InputFormat.png" class="" title="InputFormat"><h4 id="fileinputformat">3.1 FileInputFormat</h4><p>FileInputFormat直接继承了抽象类InputFormat。在FileInputFormat中，实现了InputFormat的抽象方法getSplits，但是没有实现createRecordReader。<strong>FileInputFormat仍然是个抽象类</strong>。</p><p>FileInputFormat切片机制：</p><ol type="1"><li>简单地按照文件的内容长度进行切分</li><li>切片大小默认等于数据块Block大小</li><li>切片的时候不考虑数据集整体，而是逐个针对每个文件进行单独切片</li></ol><p>FileInputFormat切片流程：</p><ol type="1"><li><p>找到输入的路径，遍历其中的每个文件</p></li><li><p>对于遍历的每个文件：</p><ol type="1"><li><p>获取文件大小</p></li><li><p>计算切片大小</p></li><li><p>形成切片（<strong>每次切片的时候，都需要判断切完剩下的部分是否大于块的1.1倍，如果大于就可以再分，否则剩余的就作为一个块</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (((<span class="hljs-type">double</span>) bytesRemaining)/splitSize &gt; SPLIT_SLOP) <span class="hljs-comment">//SPLIT_SLOP=1.1</span><br></code></pre></td></tr></table></figure></li><li><p>将切片信息写入一个切片规划文件当中</p></li><li><p>InputSplit只记录了切片的元数据信息，比如起始位置、长度以及所在的节点列表等。</p></li></ol></li><li><p>提交切片规划文件到Yarn上，Yarn上的MrAppMaster就可以根据切片规划文件计算开启MapTask个数</p></li></ol><p>FileInputFormat中计算切片大小的公式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.max(minSize, Math.min(maxSize, blockSize));<br>mapreduce.input.fileinputformat.split.minsize=<span class="hljs-number">1</span>; <span class="hljs-comment">//默认值为1</span><br>mapreduce.input.fileinputformat.split.maxsize= Long.MAXValue; <span class="hljs-comment">//默认值Long.MAXValue</span><br></code></pre></td></tr></table></figure><p>因此在默认情况下，切片大小 = blocksize。</p><p>于是，根据这个计算公式我们可以对切片大小进行调整。</p><ul><li>maxsize：参数如果调得比blockSize小，则会让切片变小，而且就等于配置的这个参数的值</li><li>minsize：参数调的比blockSize大，则可以让切片变得比blockSize还大</li></ul><blockquote><p>可以使用的信息：获取切片信息的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取切片的文件名称</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> inputSplit.getPath().getName();<br><span class="hljs-comment">// 根据文件类型获取切片信息</span><br><span class="hljs-type">FileSplit</span> <span class="hljs-variable">inputSplit</span> <span class="hljs-operator">=</span> (FileSplit) context.getInputSplit();<br></code></pre></td></tr></table></figure></blockquote><p>注意在切片的过程中，会判断文件是否是可以切分的。如果不可以切分，则一个文件还是一个文件。（如部分压缩文件的情况）</p><h4 id="textinputformat">3.2 TextInputFormat</h4><p>TextInputFormat是FileInputFormat的直接子类，实现了其中没有实现的createRecordReader方法。在createRecordReader中它返回了一个LineRecordReader，按行读取每条记录形成键值对。键是存储该行在整个文件中的起始字节偏移量，LongWritable类型。值是这行的内容，不包括任何行终止符（换行符和回车符），Text类型。</p><h4 id="combinetextinputformat">3.3 CombineTextInputFormat</h4><p>CombineTextInputFormat是FileInputFormat的直接子类，适用于小文件过多的场景。默认的TextInputFormat切片机制按照文件进行切片，不管文件多小，至少会形成一个单独的切片。这样如果有大量的小文件的话，就会产生大量的MapTask，处理效率低下。</p><p>CombineTextInputFormat用于小文件过多的场景，它可以将多个小文件从逻辑上规划到一个切片中，这样，多个小文件就可以交给一个 MapTask 处理。</p><p>在CombineTextInputFormat中可以使用setMaxInputSplitSize值进行设置。下面是CombineTextInputFormat进行切片的机制：</p><p>首先进行虚拟存储过程：</p><p>将输入目录下所有文件大小，依次和设置的 setMaxInputSplitSize值比较，如果不大于设置的最大值，逻辑上划分一个块。如果输入文件大于设置的最大值且大于两倍，那么以最大值切割一块；当剩余数据大小超过设置的最大值且不大于最大值 2倍，此时 将文件均分成 2 个虚拟存储块（防止出现太小切片）。</p><blockquote><p>例如 setMaxInputSplitSize 值为 4M，输入文件大小为8.02M，则先逻辑上分成一个 4M。剩余的大小为 4.02M，如果按照 4M逻辑划分，就会出现 0.02M 的小的虚拟存储 文件，所以将剩余的 4.02M文件切分成（2.01M 和 2.01M）两个文件。</p></blockquote><p>切片过程：</p><ol type="1"><li>判断虚拟存储的文件大小是否大于setMaxInputSplitSize的值，如果大于则单独形成一个切片</li><li>如果不大于则和下一个虚拟存储文件进行合并，共同形成一个切片</li><li>继续判断下一个切片</li></ol><h4 id="设置使用的inputformat">3.4 设置使用的InputFormat</h4><p>在Driver类中进行配置</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果不设置 InputFormat，它默认用的是 TextInputFormat.class</span><br>job.setInputFormatClass(CombineTextInputFormat.class);<br><span class="hljs-comment">//虚拟存储切片最大值设置 4m</span><br>CombineTextInputFormat.setMaxInputSplitSize(job, <span class="hljs-number">4194304</span>);<br></code></pre></td></tr></table></figure></blockquote><h2 id="map和reduce流程">Map和Reduce流程</h2><p>在前面的流程当中，以及完成了切片信息的获取，Yarn根据切片信息决定启动Mapper的个数，以及每个Mapper对应的数据。</p><h3 id="recordreader">1. RecordReader</h3><p>现在每个Mapper有了自己对应的数据，但是我们知道Mapper的输入是键值对形式的，所以需要有一个中间流程将数据转化成键值对的形式，这就是RecordReader做的事情。</p><p>在前面的TextInputFormat中我们也提到了它实现的<code>createRecordReader</code>中返回了<code>LineRecordReader</code>。这就是RecordReader的一种，它将数据文件组织成<code>&lt;偏移量, 每行内容&gt;</code>的键值对形式。</p><h3 id="mapreduce流程">2. MapReduce流程</h3><img src="/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-3-MapReduce%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B1.png" class="" title="流程1"><img src="/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-3-MapReduce%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B2.png" class="" title="流程2"><p>上面是MapReduce的全流程，我们可以看到，在第6步是Mapper里面的逻辑，是用户自定义实现的输入键值对，输出键值对逻辑。在第14步之后的Reducer，则是对应用户自定义实现的输入键值对组，输出键值对的逻辑。</p><p>在Mapper和Reducer之间，还有很多流程，这些流程统称为Shuffle过程。</p><h2 id="shuffle机制">Shuffle机制</h2><h3 id="shuffle过程">1. shuffle过程</h3><p>在前面的图中我们可以看到，在Mapper和Reducer之间还存在很多步骤，并不是一下到达的，这个过程我们称为Shffle过程。</p><ol type="1"><li>MapTask收集map方法输出的键值对，放在内存缓冲区中</li><li>内存缓冲区无法一次性存放所有的输出，于是会存在不断的溢写，可能会溢出多个文件</li><li>在溢写的过程中，需要将内存中的文件持久化到本地，在此之前会对文件内部的数据按照分区进行快排，快排的依据是key值。排序完成之后，形成本地文件</li><li>在过程中会可能会出现多个溢写文件，这些文件各自内部按照分区有序，但是最终需要形成一个分区有序的大文件，所以再对所有的溢写文件进行归并排序</li><li>在上面的合并过程中，可以出现Combiner过程（可选）</li><li>启动ReduceTask。ReduceTask按照自己的分区号，去各个MapTask机器上取得对应的分区数据</li><li>它从每个MapTask上远程拷贝相应的数据文件，如果文件大小超过一定阈值，则溢写磁盘上，否则存储在内存中。如果磁盘上文件数目达到一定阈值，则进行一次归并排序以生成一个更大文件；如果内存中文件大小或者数目超过一定阈值，则进行一次合并后将数据溢写到磁盘上</li><li>Reducer需要得到一个统一的输入文件，所以当所有数据拷贝完毕之后，需要再对这些不同文件进行归并排序</li><li>合成大文件之后，Shuffle的过程就结束了，后面进入ReduceTask的逻辑运算过程。</li></ol><blockquote><p><strong>注意事项</strong>：</p><ol type="1"><li><p>Shuffle中的缓冲区大小会影响到MapReduce程序的执行效率，原则上来说，缓冲区越大，磁盘IO的次数越少，执行的速度也就越快</p></li><li><p>缓冲区的大小可以通过参数调整：mapreduce.task.io.sort.mb，默认为100M</p></li><li><p>Shuffle过程在Map阶段结束之后，Reduce阶段开启之前。如果整个任务根本没有Reduce阶段，那么也就没有Shffle阶段，直接在Map阶段键值对输出那里就退出了。</p></li></ol></blockquote><h3 id="partition分区">2. Partition分区</h3><p>在Reduce阶段，每个Reducer得到的是相同分区的数据。默认情况下进行的Partitioner分区如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashPartitioner</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Partitioner</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPartition</span><span class="hljs-params">(K key, V value, <span class="hljs-type">int</span> numReduceTasks)</span> &#123;<br>        <span class="hljs-keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分区和Reducer的个数之间存在紧密联系，默认的分区逻辑如上所示，按照hashcode的值对Reducer的个数取余，得到不同的分区。</p><blockquote><p>前面说到Mapper的个数和数据切片有关，但是这里Reducer的个数则可以由程序员直接指定，默认只开启一个Reducer。</p><p>实际情况中，指定多少个Reducer应该需要通过进行测试来确定。</p></blockquote><p>如果要自定义实现分区逻辑的化，需要自定义类继承Partioner，并且重写其中的getPartition方法，具体可以查看后续笔记。</p><h3 id="writablecomparable排序">3. WritableComparable排序</h3><p>在Shuffle过程中，存在多处排序操作，排序是MapReduce框架中最重要的操作之一。在Mapper溢写过程中，存在快排操作；多个溢写文件的合并，使用的是归并排序；在Reducer获取输入文件的时候，会进行归并排序。</p><p>MapTask和ReduceTask均会对数据<strong>按照key</strong>进行排序，该操作属于Hadoop的默认行为，任何应用程序中的数据均会被排序，而不管逻辑上是否需要。因此在指定键值对的时候（Mapper的输出键值对和Reducer的输入键值对，当然这两者是相同的），key能够排序是必要的。</p><p>默认排序按照字典顺序进行排序，如果使用的是自定义类作为key值的化，那么需要实现WritableComparable接口，重写其中的compareTo方法，具体可以查看后续笔记。</p><h3 id="combiner合并">4. Combiner合并</h3><p>Combiner是MapReduce程序中，Mapper和Reducer之外的一种组件，它出现的背景是为了减轻Reducer的负担，所以提前在Mapper阶段进行合并操作。它的意义就是对每一个MapTask的输出进行局部汇总，以减少网络传输量。</p><p>Combiner和Reducer做的事情在逻辑上是一致的，<strong>而Combiner组件的父类正是Reducer</strong>。它和Reducer之间的区别在于运行的位置不同，Combiner是在每一个MapTask所在的节点运行的，而Reducer是接收全局的所有Mapper的输出结果。</p><p>我们可以自定义实现Combiner的逻辑，需要自定义Combiner继承Reducer，重写Reducer方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCombiner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, IntWritable, Text, IntWritable&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        ...<span class="hljs-comment">//合并逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在驱动Driver中进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">job.setCombinerClass(MyCombiner.class)<br></code></pre></td></tr></table></figure><p>而我们前面也说了，Combiner和Reducer完成的事情基本是相同的，所以在可以使用Combiner的情况下，也可以这样指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">job.setCombinerClass(MyReducer.class)<br></code></pre></td></tr></table></figure><p><strong>不过需要注意的是，并不是所有情况下都能使用Combiner的</strong>，是否能够使用Combiner，需要根据业务逻辑来进行判断。</p><h2 id="outputformat数据输出">OutputFormat数据输出</h2><p>在Reducer得到键值对输出之后，需要最终输出得到结果。从键值对输出到结果，则是OutputFormat完成的事情。OutputFormat是MapReduce输出的基类，所有MapReduce的输出类都继承了OutputFormat类。</p><p>下面是MapReduce中自带的一些输出类，默认使用的是TextOutputFormat。</p><img src="/2022/02/22/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-3-MapReduce%E6%B5%81%E7%A8%8B/OutputFormat.png" class="" title="OutputFormat"><p>当然我们也可以自定义一个OutputFormat类，我们自定义的MyOutputFormat可以继承上面的类，并且实现里面的getRecordWriter方法。在getRecordWriter中需要返回一个RecordWriter，里面重写对应的write和close方法，来完成我们的输出逻辑。当然最后还是需要在驱动类中完成绑定。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-MapReduce(2)-MapReduce序列化</title>
    <link href="/2022/02/20/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-2-MapReduce%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/02/20/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-2-MapReduce%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="hadoop序列化">Hadoop序列化</h2><h3 id="序列化的概念">1. 序列化的概念</h3><p>序列化：序列化就是将内存中的对象转化成字节序列（或者其他数据传输协议）以便于持久化到磁盘和网络传输。</p><p>反序列化：反序列化就是将收到的字节序列（或者其他数据传输协议）或者是磁盘的持久化数据，转换成内存中的对象。</p><h3 id="hadoop序列化背景">2. hadoop序列化背景</h3><p>在MapReduce的过程中，Mapper和Reducer之间存在数据交换，他们很有可能是不在一台节点上的，所以需要利用网络传输的手段来传输数据。因此数据需要序列化。在之前的示例中，我们使用的是hadoopwritable类型的数据，那是Hadoop提供的可以序列化的基本类型。但是如果我们在键值对中想要使用我们自定义的类型，那么不作任何准备是不行的，因此需要完成序列化。</p><p>我们使用的是Hadoop的序列化，即让我们自定义的类实现序列化接口Writable。</p><p>这里并不使用java的序列化，因为Java的序列化是一个重量级的序列化框架（Serializable）。一个对象被序列化之后，会附带很多额外的信息，包括各种校验信息，Header，继承体系等等，不便于在网络中高效传输，所以Hadoop自己开发了一套序列化机制（Writable）。</p><p>Hadoop的序列化特点：</p><ul><li>紧凑：高效使用存储空间</li><li>快速：读写数据的额外开销小</li><li>互操作：支持多语言的交互</li></ul><h2id="自定义类实现序列化接口writable">自定义类实现序列化接口（Writable）</h2><p>程序背景：我们希望统计用户的上行流量、下行流量以及流量总和，因此我们定义一个自定义类FlowBean来完成对应信息的记录，并完成序列化。</p><h3 id="自定义类">1.自定义类</h3><p>这里我们仅实现一个自定义类记录流量，FlowBean。</p><p>具体实现序列化的步骤如下：</p><ol type="1"><li>必须<strong>实现Writable接口</strong></li><li>反序列化的时候，需要反射调用空参构造函数，所以必须有<strong>空参构造</strong></li><li><strong>重写序列化方法write</strong></li><li><strong>重写反序列化方法readFields</strong></li><li>这里注意反序列化的顺序和序列化的顺序要完全一致</li><li>如果想要将结果显示在文件中，需要<strong>重写toString()方法</strong></li><li>如果想要将自定义的对象放在key中传输，还需要实现WritableComparable接口。因为MapReduce框架中的Shuffle过程要求对key能够排序</li></ol><p>因此，我们的自定义类实现如下（省略了setter和getter方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FLowBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Writable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> upFlow;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> downFlow;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> sumFlow;<br><br>    <span class="hljs-comment">// 空参构造</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FLowBean</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>        <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(DataOutput dataOutput)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        dataOutput.writeLong(upFlow);<br>        dataOutput.writeLong(downFlow);<br>        dataOutput.writeLong(sumFlow);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFields</span><span class="hljs-params">(DataInput dataInput)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">this</span>.upFlow = dataInput.readLong();<br>        <span class="hljs-built_in">this</span>.downFlow = dataInput.readLong();<br>        <span class="hljs-built_in">this</span>.sumFlow = dataInput.readLong();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> upFlow + <span class="hljs-string">&quot;\t&quot;</span> + downFlow + <span class="hljs-string">&quot;\t&quot;</span> + sumFlow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后续的Mapper和Reducer同样需要自定义实现来完成对应的逻辑。</p><h3 id="mapper">2.Mapper</h3><p>Mapper的输入输出：<code>&lt;LongWritable, Text&gt;</code>-&gt;<code>&lt;Text, FlowBean&gt;</code></p><p>Mapper的逻辑：将读入的每一行进行转化，转化成对应电话号码和流量描述的键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlowMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, FLowBean&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">FLowBean</span> <span class="hljs-variable">outV</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FLowBean</span>();<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text value, Mapper&lt;LongWritable, Text, Text, FLowBean&gt;.Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> value.toString();<br>        String[] infos = line.split(<span class="hljs-string">&quot;\t&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> infos[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">String</span> <span class="hljs-variable">upFlow</span> <span class="hljs-operator">=</span> infos[infos.length - <span class="hljs-number">3</span>];<br>        <span class="hljs-type">String</span> <span class="hljs-variable">downFlow</span> <span class="hljs-operator">=</span> infos[infos.length - <span class="hljs-number">2</span>];<br><br>        outK.set(phone);<br>        outV.setUpFlow(Long.parseLong(upFlow));<br>        outV.setDownFlow(Long.parseLong(downFlow));<br>        outV.setSumFlow();<br><br>        context.write(outK, outV);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="reducer">3.Reducer</h3><p>Reducer的输入输出：<code>&lt;Text, FlowBean&gt;</code>-&gt;<code>&lt;Text, FlowBean&gt;</code></p><p>Reducer的逻辑：将电话号码相同的流量描述对象进行统计求和，每次reduce输出一个电话号码和一个流量描述总和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FLowReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, FLowBean, Text, FLowBean&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">FLowBean</span> <span class="hljs-variable">outV</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FLowBean</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;FLowBean&gt; values, Reducer&lt;Text, FLowBean, Text, FLowBean&gt;.Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sumUpFlow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sumDownFlow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (FLowBean value : values) &#123;<br>            sumUpFlow += value.getUpFlow();<br>            sumDownFlow += value.getDownFlow();<br>        &#125;<br><br>        outV.setUpFlow(sumUpFlow);<br>        outV.setDownFlow(sumDownFlow);<br>        outV.setSumFlow();<br><br>        context.write(key, outV);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="driver">4.Driver</h3><p>Driver仍然是固定的流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlowDriver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, ClassNotFoundException &#123;<br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>        <span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> Job.getInstance(conf);<br><br>        job.setJarByClass(FlowDriver.class);<br><br>        job.setMapperClass(FlowMapper.class);<br>        job.setReducerClass(FLowReducer.class);<br><br>        job.setMapOutputKeyClass(Text.class);<br>        job.setMapOutputValueClass(FLowBean.class);<br><br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(FLowBean.class);<br><br>        FileInputFormat.setInputPaths(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;D:/input/inputflow&quot;</span>));<br>        FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;D:/output/output&quot;</span>));<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> job.waitForCompletion(<span class="hljs-literal">true</span>);<br><br>        System.exit(result ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-MapReduce(1)-MapReduce概述</title>
    <link href="/2022/02/20/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-1-MapReduce%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/02/20/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MapReduce-1-MapReduce%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="mapreduce概述">MapReduce概述</h2><p>MapReduce是一个<strong>分布式运算程序</strong>的编程框架，在这个框架下，我们很容易就能编写出基于Hadoop的应用。它的核心功能是将<strong>用户编写的业务逻辑代码</strong>和自带的默认组件整合成一个完整的分布式运算程序，并发地运行在一个Hadoop集群上。我们只需要基于这个框架进行业务逻辑的编写即可。</p><ul><li>优点：<ul><li>易于编程：用户只需要简单地实现一些接口，就可以完成一个分布式程序</li><li>良好的扩展性：计算资源可以通过简单地增加机器来进行扩展</li><li>高容错性：如果有节点挂了，上面的计算任务可以自动转移到另外的节点上运行，这个过程由Hadoop内部自动进行完成</li><li>适合PB以上海量数据的离线处理</li></ul></li><li>缺点：<ul><li>不擅长进行实时计算</li><li>不擅长流式计算：MapReduce的输入数据集是静态的</li><li>不擅长DAG（有向无环图）的计算：即前一个程序的输出是后一个程序的输入。MapReduce可以完成这样的工作，但是由于每个MapReduce作业的输入结果都会写入到磁盘，完成这种情形会造成大量的磁盘IO，导致性能非常低下</li></ul></li></ul><blockquote><p>Spark Streaming和Flink擅长流式计算。</p><p>Spark擅长DAG的计算。</p></blockquote><h2 id="mapreduce核心思想">MapReduce核心思想</h2><p>一个MapReduce运算程序一般分为两个阶段，<strong>Map阶段</strong>和<strong>Reduce阶段</strong>。</p><ul><li>在Map阶段中，会有多个Mapper并发实例。它们完全并行运行，互不相干</li><li>每个Mapper都是以键值对的形式读入数据，以键值对的形式输出数据，并且这里键值对的形式是可以修改和定义的</li><li>在Reduce阶段中，同样有多个Reducer并发实例。它们完全并行运行，互不相干。<strong>一个Reducer对应后续的一个结果文件的输出</strong></li><li>Reducer的输入和输出同样是键值对的形式，并且Reducer的输入来自于前面的Mapper的输出</li><li>MapReduce 编程模型只能包含一个 Map 阶段和一个 Reduce阶段，如果用户的业 务逻辑非常复杂，那就只能多个 MapReduce程序，串行运行</li></ul><h2 id="mapreduce运行进程">MapReduce运行进程</h2><p>一个完整的MapReduce程序在分布式运行的时候有三类实例进程：</p><ol type="1"><li><strong>MrAppMaster</strong>：负责整个程序的过程调度以及状态协调</li><li><strong>MapTask</strong>：负责Map阶段的整个数据处理流程</li><li><strong>ReduceTask</strong>：负责Reduce阶段的整个数据处理流程</li></ol><h2 id="wordcount示例的实现">WordCount示例的实现</h2><h3 id="描述">1. 描述</h3><p>WordCount是官方提供的示例程序之一，也算是MapReduce编程的HelloWorld程序。它的输入是文件，输出是文件中每个单词（以空格分隔）出现的次数，并且会按照字典序升序进行排列。</p><p>首先这里先提供MapReduce常用的数据序列化类型。在指定键值对的类型的时候，需要用到的是HadoopWritable类型。（如果是自定义类型的话，后续会讲到需要实现Writable接口）</p><table><thead><tr class="header"><th>Java类型</th><th>Hadoop Writable类型</th><th>Java类型</th><th>Hadoop Writable类型</th></tr></thead><tbody><tr class="odd"><td>Boolean</td><td>BooleanWritable</td><td>Double</td><td>DoubleWritable</td></tr><tr class="even"><td>Byte</td><td>ByteWritable</td><td>String</td><td>Text</td></tr><tr class="odd"><td>Int</td><td>IntWritable</td><td>Map</td><td>MapWritable</td></tr><tr class="even"><td>Float</td><td>FloatWritable</td><td>Array</td><td>ArrayWritable</td></tr><tr class="odd"><td>Long</td><td>LongWritable</td><td>Null</td><td>NullWritable</td></tr></tbody></table><blockquote><p>这里需要注意<strong>String</strong>对应的是<strong>Text</strong>，其余类型只需要添加Writable后缀即可。</p></blockquote><p>书写MapReduce程序需要遵循它的编程规范。需要用户编写的程序主要分成三个部分Mapper、Reducer和Driver。</p><p><strong>Mapper阶段</strong>：</p><ol type="1"><li>用户自定义Mapper要继承父类Mapper</li><li>在泛型中指定输入和输出对应的KV对的类型</li><li>重写父类中的方法（可重写的方法包括setup、map、cleanup）</li><li>主要的业务逻辑写在map方法中</li><li><strong>map方法会对每个键值对执行一次</strong></li></ol><p><strong>Reducer阶段</strong>：</p><ol type="1"><li>用户自定义的Reducer要继承父类Reducer</li><li>在泛型中指定输入和输出对应的KV对的类型，其中输入的键值对类型应该和Mapper的输出键值对类型相同</li><li>重写父类中的方法（可重写的方法包括setup、reduce、cleanup）</li><li>主要的业务逻辑写在reduce方法中</li><li><strong>reduce方法会对键值相同的键值对组执行一次</strong>。即一次得到的是一个key值以及对应的多个value值</li></ol><p><strong>Driver阶段</strong>：</p><ol type="1"><li>Driver相当于YARN集群的客户端，用于提交我们整个程序到YARN集群，提交的是封装了MapReduce程序相关运行参数的job对象。</li><li>相当于整个MapReduce程序的入口</li><li>在这里我们会进行整个程序的关联</li><li>这里的代码基本类似，完成的是一些模板式的工作</li></ol><h3 id="代码实现">2. 代码实现</h3><p>在书写代码之前应该要准备相关的环境，使用Maven管理依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-hdfs<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>以下代码的实现尤其需要注意导包的正确与否，需要导入正确的包才能正确地运行。</p></blockquote><h4 id="wordcountmapper">WordCountMapper</h4><p>首先实现Mapper，命名为WordCountMapper。我们自己写的类需要继承Mapper类。</p><p>这里，由于我们没有修改输入的形式，所以采用的是默认的方式，即按行读取文件。传入的是键值对<code>&lt;long, String&gt;</code>的形式，前者表示当前的文件指针的偏移值，后者表示这一行的内容。于是在Mapper中指定，应该使用hadoopwritable类型，为<code>&lt;LongWritable, Text&gt;</code>。</p><p>在Map阶段，我们会将每个词都分出来，并且每分出一个词，就为它计数为1，这样，Reduce阶段就只需要将每个词的的计数进行对应相加，就可以得到这个词出现的总次数。因此Map阶段的输出键值对应该是这样的形式<code>&lt;Text, IntWritable&gt;</code>，前者表示词word的内容，后者表示出现了一次（1）。</p><p>之后我们需要重写父类中的map方法，具体完成的逻辑就是将每一行取出来，然后对这一行的内容进行一个拆分，得到一个个对应的word，每个word都以键值对的形式写入。<strong>写入利用函数中传入的context对象，这是贯穿过程始终的上下文对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordCountMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">IntWritable</span> <span class="hljs-variable">outV</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text value, Mapper&lt;LongWritable, Text, Text, IntWritable&gt;.Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-comment">// 这里的key就是偏移量，value就是一行的内容</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> value.toString();<br>        String[] words = line.split(<span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            outK.set(word);<br>            <span class="hljs-comment">// 写入输出键值对</span><br>            context.write(outK, outV);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="wordcountreducer">WordCountReducer</h4><p>之后实现Reducer。这里命名为WordCountReducer，同样需要继承对应的Reducer。</p><p>指定键值对泛型中的类型，输入键值对的类型同Map阶段输出的类型一致，所以是<code>&lt;Text, IntWritable&gt;</code>。Reduce阶段完成对word出现次数的统计，输出每个词出现的次数，所以输出的键值对类型也是<code>&lt;Text, IntWritable&gt;</code>。</p><p>确定了键值对的类型之后，就是实现父类中的reduce方法。这个reduce方法会对每个key值相同的所有键值对组执行一次。这里，传入的键值对组就表示这个key在各个地方出现的次数，我们只需要完成累加即可传出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordCountReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, IntWritable, Text, IntWritable&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">IntWritable</span> <span class="hljs-variable">outV</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;IntWritable&gt; values, Reducer&lt;Text, IntWritable, Text, IntWritable&gt;.Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-comment">// key对应一个key,values对应在所有得到的键值对中key对应的所有values</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (IntWritable value : values) &#123;<br>            sum += value.get();<br>        &#125;<br>        outV.set(sum);<br>        <span class="hljs-comment">// key表示word内容，无需改写</span><br>        context.write(key, outV);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="wordcountdriver">WordCountDriver</h4><p>之后需要完成Driver的书写。Driver中完成的任务是流程化，模板化的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordCountDriver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, ClassNotFoundException &#123;<br>        <span class="hljs-comment">// 固定套路</span><br>        <span class="hljs-comment">// 1. 获取job</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>        <span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> Job.getInstance(conf);<br><br>        <span class="hljs-comment">// 2. 设置jar包路径</span><br>        <span class="hljs-comment">// 通过反射机制可以获取全类名，后续也是同样的原理</span><br>        job.setJarByClass(WordCountDriver.class);<br><br>        <span class="hljs-comment">// 3. 关联mapper和reducer</span><br>        job.setMapperClass(WordCountMapper.class);<br>        job.setReducerClass(WordCountReducer.class);<br><br>        <span class="hljs-comment">// 4. 设置map输出的kv类型</span><br>        job.setMapOutputKeyClass(Text.class);<br>        job.setMapOutputValueClass(IntWritable.class);<br><br>        <span class="hljs-comment">// 5. 设置最终输出的kv类型</span><br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(IntWritable.class);<br><br>        <span class="hljs-comment">// 6. 设置输出路径和输出路径</span><br><span class="hljs-comment">//        FileInputFormat.setInputPaths(job, new Path(&quot;D:/input/inputword&quot;));</span><br><span class="hljs-comment">//        FileOutputFormat.setOutputPath(job, new Path(&quot;D:/output/output1&quot;));</span><br>        <span class="hljs-comment">// 动态获取输入和输出路径</span><br>        FileInputFormat.setInputPaths(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">0</span>]));<br>        FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">1</span>]));<br><br>        <span class="hljs-comment">// 7. 提交job(job成功完成返回ture)</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> job.waitForCompletion(<span class="hljs-literal">true</span>);<br><br>        System.exit(result ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="本地测试">3. 本地测试</h3><p>在本地运行需要在本地也存在Hadoop环境才可以运行。准备好对应的环境之后，运行WordCountDriver类即可。</p><h3 id="提交到集群测试">4. 提交到集群测试</h3><p>提交到集群上运行首先需要将程序打成jar包然后上传到服务器端。</p><p>之后在服务器端运行即可；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop jar wc.jar com.syh.mapreduce.wordcount.WordCountDriver /input /output<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-HDFS(4)-HDFS读写流程和工作机制</title>
    <link href="/2022/02/18/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HDFS-4-HDFS%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/02/18/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HDFS-4-HDFS%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="hdfs的写机制">HDFS的写机制</h2><ol type="1"><li><p>客户端向NameNode请求上传文件，NameNode检查该上传请求的权限以及目录结构，然后返回是否可以上传</p></li><li><p>如果可以上传，那么客户端会请求第一个数据分块Block应该上传到哪几个DataNode节点上</p></li><li><p>NameNode返回对应的DataNode节点</p></li><li><p>客户端向对应的DataNode节点上传数据</p><blockquote><p>用户成功写入了一个数据块就认为成功，不关心后续副本的复制问题。每次创建副本的时候，当前Datanode只对下一个Datanode负责</p><p>客户端上传Block，以Packet为单位，每一个Packet会携带一个chunk。chunk是Hadoop中最小的单位。</p><p>Packet是Client端向Dataode，或者DataNode的PipLine之间传输数据的基本单位，默认<code>64kB</code>.</p><p>Chunk是最小的Hadoop中最小的单位，是Client向DataNode或DataNode的PipLne之间进行数据校验的基本单位，默认<code>512Byte</code>，因为用作校验(自己校验自己)，故每个chunk需要带有<code>4Byte</code>的校验位。所以实际每个chunk写入packet的大小为516Byte，真实数据与校验值数据的比值为128:1。</p></blockquote></li><li><p>当一个Block传输完成之后，客户端再次请求NameNode进行第二个Block的传输。</p></li></ol><blockquote><p>机架感知策略：如果客户端在DataNode上写入，则第一份写入自己所在的DataNode，如果不是，则随机选择一个DataNode。之后第二份选择写入与第一份不同机架的一个DataNode，第三份选择与第二份相同机架不同节点的一个DataNode。</p></blockquote><h2 id="hdfs的读机制">HDFS的读机制</h2><ol type="1"><li>客户端向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址</li><li>挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据</li><li>DataNode 开始传输数据给客户端（从磁盘里面读取数据输入流，以 Packet为单位 来做校验）。</li><li>客户端以 Packet 为单位接收，先在本地缓存，然后写入目标文件</li></ol><h2id="namenode和secondarynamenode工作机制">NameNode和SecondaryNameNode工作机制</h2><h3 id="简要描述">1. 简要描述</h3><ul><li>fsimage文件：由Namenode存储的，文件系统中的元数据信息。该文件在Namenode启动时被加载到内存当中，并且一直保持只读状态。</li><li>Namnode启动过程中，只接受读请求，不接受写请求（安全模式）</li><li>需要修改元数据的时候，不能直接修改fsimage文件。需要将修改事务写到一系列新的edits文件当中。edits文件会定时合并，成为新的fsimage文件</li><li>fsimage和edits文件都存储在主节点的本地文件系统当中</li><li>如果存储文件过多或者数据分块过多，会造成fsimage文件过大，这也是为什么HDFS不适合存储海量小文件。并且在使用是，需要合理设置HDFS的文件分块大小</li><li>SecondaryNamenode可以帮助Namenode完成合并任务，降低Namenode的压力。SecondaryNamenode负责将fsimage和edits文件合并形成新的fsimage文件。该过程周期性自动进行</li><li>合并的时候会通知Namenode，让其暂停使用当前的edits文件，将新纪录写到新的edits文件当中</li></ul><h3 id="具体流程">2. 具体流程</h3><ol type="1"><li>第一阶段：NameNode启动<ol type="1"><li>第一次启动NameNode格式化之后，创建Fsiamge文件和Edits文件；如果不是第一次创建，就将文件加载到内存中</li><li>客户端对元数据进行增删改的请求</li><li>NameNode记录操作日志，更新滚动日志</li><li>NameNode在内存中对元数据进行增删改</li></ol></li><li>第二阶段：SecondaryNameNode启动<ol type="1"><li>Secondary NameNode 询问 NameNode 是否需要 CheckPoint。直接带回NameNode 是否检查结果。</li><li>Secondary NameNode 请求执行 CheckPoint。</li><li>NameNode 滚动正在写的 Edits 日志。</li><li>将滚动前的编辑日志和镜像文件拷贝到 Secondary NameNode。</li><li>Secondary NameNode 加载编辑日志和镜像文件到内存，并合并。</li><li>生成新的镜像文件 fsimage.chkpoint。</li><li>拷贝 fsimage.chkpoint 到 NameNode。</li><li>NameNode 将 fsimage.chkpoint 重新命名成 fsimage。</li></ol></li></ol><blockquote><p>Fsimage和Edits</p><ul><li>Fsimage文件：是HDFS文件系统元数据的一个永久性的检查点，其中包含HDFS文件系统的所有目录和文件inode的序列化信息</li><li>Edits文件：存放操作日志</li></ul><p>合并Edits的时候，只会合并编号高于当前最大Fsimage编号的那些Edits文件</p></blockquote><p><strong>注意</strong>：fsimage中并没有记录块所对应的DataNode信息，这些信息是在集群启动的时候由DataNode向NameNode汇报的。</p><h3 id="文件查看">3. 文件查看</h3><p>可以通过命令查看Fsimage文件</p><ol type="1"><li><p>ovi查看Fsimage文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdfs oiv -p 文件类型 -i 镜像文件 -o 转换后文件输出路径<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdfs oiv -p XML -i fsimage_0000000000000000025 -o ~/fsimage.xml<br></code></pre></td></tr></table></figure></li><li><p>oev查看edits文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdfs oev -p 文件类型 -i 编辑日志 -o 转换后文件输出路径<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdfs oev -p XML -i edits_0000000000000000012-0000000000000000013 -o ~/edits.xml<br></code></pre></td></tr></table></figure></li></ol><h3 id="checkpoint时间设置">4.CheckPoint时间设置</h3><blockquote><p>在hdfs-default.xml中的配置</p></blockquote><ol type="1"><li><p>定时执行：默认SecondaryNameNode每隔一小时执行一次</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.checkpoint.period<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3600s<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>当操作次数达到一百万的时候执行一次，每一分钟检查一次操作次数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.checkpoint.txns<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1000000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>操作动作次数<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.checkpoint.check.period<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>60s<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span> 1 分钟检查一次操作次数<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="datanode工作机制">DataNode工作机制</h2><h3 id="工作机制">1. 工作机制</h3><ol type="1"><li>一个数据块在 DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳。</li><li>DataNode 启动后向 NameNode 注册，通过后，周期性（6 小时）的向NameNode 上 报所有的块信息。</li><li>心跳是每 3 秒一次，心跳返回结果带有 NameNode 给该 DataNode的命令如复制块 数据到另一台机器，或删除某个数据块。如果超过 10分钟没有收到某个 DataNode 的心跳， 则认为该节点不可用。</li><li>集群运行中可以安全加入和退出一些机器</li></ol><blockquote><p>DataNode向NameNode上报信息的设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.blockreport.intervalMsec<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>21600000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.directoryscan.interval<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>21600s<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="数据完整性">2. 数据完整性</h3><p>DataNode节点检查数据完整性，使用crc校验算法。</p><p>DataNode在读取Block的时候会计算校验和，如果计算得到的校验和与Block在创建的时候得到的校验和不一致，说明Block已经损坏，数据不可用。则让Client去读取其他DataNode上的Block。</p><p>并且在DataNode内部，也会在文件创建之后周期性验证它的校验和。</p><h3 id="掉线时限参数设置">3.掉线时限参数设置</h3><p>DataNode进程死亡或者网络故障，会导致DataNode无法与NameNode进行通信。如果经过连续一段时间之后，NameNode仍然没有收到该DataNode的心跳信息，那么就认为这个DataNode已经挂掉了，不能使用。这段时间称作超时时长。HDFS默认的超时时长为10分钟+30秒。</p><p>实际的超时时长计算公式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">TimeOut = <span class="hljs-number">2</span> * dfs.namenode.heartbeat.recheck-interval + <span class="hljs-number">10</span> * dfs.heartbeat.interval<br></code></pre></td></tr></table></figure><p>对应在<code>hdfs-site.xml</code>中的配置信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.heartbeat.recheck-interval<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>300000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.heartbeat.interval<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>前者单位为毫秒、后者单位为秒</li></ul><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://www.cnblogs.com/we9999/p/12404121.html#/">Hadoop之HDFS的block、packet、chunk- 浮世间 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>HDFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-HDFS(3)-HDFS的API操作</title>
    <link href="/2022/02/18/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HDFS-3-HDFS%E7%9A%84API%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/02/18/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HDFS-3-HDFS%E7%9A%84API%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="客户端环境配置">客户端环境配置</h2><p>首先需要在本地安装和配置Hadoop。</p><p>下载一份hadoop在本地解压，然后配置HADOOP_HOME。idea运行时会读这个环境变量然后找到他里面的bin文件，所以本地的hadoop只需要有bin目录即可。</p><blockquote><p>并且里面缺少了winutils.exe和hadoop.dll，需要额外下载</p><p><ahref="https://github.com/steveloughran/winutils">steveloughran/winutils:Windows binaries for Hadoop versions (built from the git commit ID usedfor the ASF relase) (github.com)</a></p></blockquote><p>之后创建Maven工程，并导入相应的依赖坐标（其中hadoop-client的版本需要和服务器上对应）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.syh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-hdfs<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="api操作">API操作</h2><p>创建HdfsClient类完成对应的API操作测试</p><p>首先是集群的连接和断开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HdfsClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> FileSystem fs;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> URISyntaxException, IOException, InterruptedException &#123;<br>        <span class="hljs-comment">// 连接集群的NN地址</span><br>        <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(<span class="hljs-string">&quot;hdfs://hadoop102:8020&quot;</span>);<br>        <span class="hljs-comment">// 创建一个配置文件</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>        <span class="hljs-comment">// 用户指定</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;syh&quot;</span>;<br>        <span class="hljs-comment">// 获取客户端对象</span><br>        fs = FileSystem.get(uri, configuration, user);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 关闭资源</span><br>        fs.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件夹创建">1. 文件夹创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">fs.mkdirs(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;/xiyou/huaguoshan&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="文件上传和下载">2. 文件上传和下载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">fs.copyFromLocalFile(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;d:/sunwukong.txt&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;/xiyou/huaguoshan/&quot;</span>));<br>fs.copyToLocalFile(<span class="hljs-literal">false</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;/xiyou/huaguoshan/sunwukong.txt&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;d:/zhubajie.txt&quot;</span>), <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><ul><li>copyFromLocalFile可以指定对源文件是否删除，是否允许覆盖</li><li>copyToLocalFile可以指定对源文件是否删除，是否开启校验<ul><li>最后一个参数指定为false，则开启校验，下载来的文件会有<code>.crc</code>文件</li></ul></li></ul><h3 id="文件更名和移动">3. 文件更名和移动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更名、移动、文件更名、文件夹更名</span><br>fs.rename(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;/xiyou&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;/xiyou-temp&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="文件删除">4. 文件删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除路径、是否递归</span><br>fs.delete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;/xiyou-temp/temphaha&quot;</span>), <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h3 id="文件详情查看">5. 文件详情查看</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"> RemoteIterator&lt;LocatedFileStatus&gt; files = fs.listFiles(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;/&quot;</span>), <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">while</span> (files.hasNext()) &#123;<br>    <span class="hljs-type">LocatedFileStatus</span> <span class="hljs-variable">fileStatus</span> <span class="hljs-operator">=</span> files.next();<br><br>    System.out.println(fileStatus.getPath());<br>    System.out.println(fileStatus.getPermission());<br>    System.out.println(fileStatus.getOwner());<br>    System.out.println(fileStatus.getGroup());<br>    System.out.println(fileStatus.getLen());<br>    System.out.println(fileStatus.getModificationTime());<br>    System.out.println(fileStatus.getReplication());<br>    System.out.println(fileStatus.getBlockSize());<br>    System.out.println(fileStatus.getPath().getName());<br><br>    <span class="hljs-comment">// 获取块信息</span><br>    BlockLocation[] blockLocations = fileStatus.getBlockLocations();<br>    System.out.println(Arrays.toString(blockLocations));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断文件或者文件夹">6. 判断文件或者文件夹</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">FileStatus[] fileStatuses = fs.listStatus(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;/xiyou-temp&quot;</span>));<br><br><span class="hljs-keyword">for</span> (FileStatus fileStatus : fileStatuses) &#123;<br>    <span class="hljs-keyword">if</span> (fileStatus.isFile()) &#123;<br>        System.out.println(<span class="hljs-string">&quot;文件 + &quot;</span> + fileStatus.getPath().getName());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;目录 + &quot;</span> + fileStatus.getPath().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>HDFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-HDFS(2)-HDFS的Shell操作</title>
    <link href="/2022/02/18/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HDFS-2-HDFS%E7%9A%84Shell%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/02/18/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HDFS-2-HDFS%E7%9A%84Shell%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="shell操作命令">Shell操作命令</h2><p>基本语法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop fs 具体命令 <br>或者<br>hdfs dfs 具体命令<br></code></pre></td></tr></table></figure><p>两者完全相同，具体命令前面会有短横线，参数也会有短横线。</p><p>帮助文档查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop fs -help 命令<br></code></pre></td></tr></table></figure><p>HDFS的Shell操作和Linux的Shell操作基本相同。</p><h3 id="文件上传">1. 文件上传</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop fs -moveFromLocal<br>hadoop fs -copyFromLocal<br>hadoop fs -put<br>hadoop fs -appendToFile<br></code></pre></td></tr></table></figure><ul><li>move会将本地文件删除</li><li>put等同于copyFromLocal</li></ul><h3 id="文件下载">2. 文件下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop fs -copyToLocal<br>hadoop fs -get<br></code></pre></td></tr></table></figure><ul><li>get等同于copyToLocal</li></ul><h3 id="hdfs直接操作">3. HDFS直接操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop fs -ls<br>hadoop fs -cat<br>hadoop fs -chgrp<br>hadoop fs -chmod<br>hadoop fs -chown<br>hadoop fs -mkdir<br>hadoop fs -cp<br>hadoop fs -mv<br>hadoop fs -tail<br>hadoop fs -rm<br>hadoop fs -du<br>hadoop fs -setrop # 设置HDFS文件的副本数量<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>HDFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-HDFS(1)-HDFS概述</title>
    <link href="/2022/02/18/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HDFS-1-HDFS%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/02/18/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HDFS-1-HDFS%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="hdfs概述">HDFS概述</h2><ol type="1"><li>HDFS是一种分布式文件系统，用于存储文件</li><li>它适合一次写入，多次读取的场景</li><li>优点：高容错性、适合处理大数据、廉价服务器</li><li>缺点：不适合低延时数据访问、不能高效对大量小文件进行存储、不支持并发写入和文件随机修改，仅允许数据追加</li><li>组成架构：使用主从式的分布式架构<ul><li>NameNode</li><li>DataNode</li><li>Secondary NameNode</li><li>Client</li></ul></li><li><strong>文件块大小</strong>：分块存储，文件块的大小通过<code>dfs.blocksize</code>来指定，在Hadoop2.x和3.x中，默认是128M，在1.x中默认是64M<ul><li>文件块设置的大小与磁盘传输的速率有关，如果传输速率更快，达到200M上下的话，可以将块大小设置成256M</li><li>HDFS块设置的太小的话，会增加寻址的时间</li><li>HDFS块设置的太大的话，不能充分利用分布式系统并行计算的能力，效率降低</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
      <tag>HDFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-入门(5)-集群启动</title>
    <link href="/2022/02/18/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-5-%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8/"/>
    <url>/2022/02/18/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-5-%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="集群配置">集群配置</h2><p>在配置集群之前，我们首先需要明确集群部署的规划，这里有几点需要注意的地方：</p><ul><li>NameNode和SecondaryNameNode不要安装在同一台服务器上</li><li>ResoureManager也很消耗内存，不要和NameNode、SecondaryNameNode配置在同一台服务器上</li></ul><p>于是在我们现有的三台机器hadoop102、hadoop103、hadoop104的基础上，进行如下的部署规划：</p><table><thead><tr class="header"><th>节点</th><th>HDFS</th><th>Yarn</th></tr></thead><tbody><tr class="odd"><td>hadoop102</td><td>NameNode、DataNode</td><td>NodeManager</td></tr><tr class="even"><td>hadoop103</td><td>DataNode</td><td>ResourceManager、NodeManager</td></tr><tr class="odd"><td>hadoop104</td><td>SecondaryNameNode、DataNode</td><td>NodeManager</td></tr></tbody></table><p>hadoop在服务器端的配置文件分为两大部分，一部分是默认的配置文件，另一部分是用户自定义的配置文件。自定义的配置文件中配置的内容的优先级要高于默认配置文件的内容。</p><p>配置文件一共有四个，分别是<code>core-site.xml</code>、<code>hdfs-site.xml</code>、<code>yarn-site.xml</code>、<code>mapred-site.xml</code>，其中自定义配置文件可以在路径<code>$HADOOP_HOME/etc/hadoop</code>路径中找到。</p><p>之后，对自定义配置文件做如下配置。</p><ul><li><p>核心配置文件（core-site.xml）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 指定 NameNode 的地址 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://hadoop102:8020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 指定 hadoop 数据的存储目录 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/opt/module/hadoop-3.1.3/data<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 配置 HDFS 网页登录使用的静态用户为 syh --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.http.staticuser.user<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>syh<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>HDFS配置文件（hdfs-site.xml）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-comment">&lt;!-- nn web 端访问地址--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop102:9870<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 2nn web 端访问地址--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop104:9868<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Yarn配置文件（yarn-site.xml）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 指定 MR 走 shuffle --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 指定 ResourceManager 的地址--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop103<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 环境变量的继承 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.env-whitelist<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAP<br>RED_HOME<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li><li><p>MapReduce配置文件（mapred-site.xml）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 指定 MapReduce 程序运行在 Yarn 上 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>之后将配置好的集群文件分发到其他两台服务器上（三台服务器中都需要配置相同内容）。</p><h2 id="集群启动">集群启动</h2><h3 id="命令行启动">1. 命令行启动</h3><p>启动集群之前，需要配置workers文件，路径为<code>$HADOOP_HOME/etc/hadoop/workers</code>，其中增加所有的节点名称，即</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">hadoop102<br>hadoop103<br>hadoop104<br></code></pre></td></tr></table></figure><ul><li>文件内容中不允许有空格，空行等，因为每一行都会被解析成hostname的名称，需要完全匹配</li><li>workers文件同样需要进行分发，在三台服务器上都需要进行配置</li></ul><p>之后就可以进行集群的启动。</p><ol type="1"><li><p>如果是第一次启动集群，那么需要在NameNode（hadoop102）上进行节点的格式化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd $HADOOP_HOME<br>hdfs namenode -format<br></code></pre></td></tr></table></figure></li><li><p>启动HDFS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd $HADOOP_HOME<br>sbin/start-dfs.sh<br></code></pre></td></tr></table></figure></li><li><p>启动Yarn（在ResourceManager（hadoop103）上启动）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd $HADOOP_HOME<br>sbin/start-yarn.sh<br></code></pre></td></tr></table></figure></li></ol><p>这样就完成了集群的启动，可以使用jps命令查看启动情况，也可以在浏览器中查看对应的数据信息：</p><ol type="1"><li>web端查看HDFS的NameNode<code>http://hadoop102:9870</code></li><li>web端查看Yarn的ResourceManager<code>http://hadoop103:8088</code></li></ol><h3 id="历史服务器和日志聚集的配置">2. 历史服务器和日志聚集的配置</h3><p>为了查看程序的历史运行情况，需要进行历史服务器的配置。</p><p>历史服务器的配置在<code>mapred-site.xml</code>配置文件中进行，在该文件中添加如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 历史服务器端地址 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop102:10020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 历史服务器 web 端地址 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop102:19888<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同样需要将配置文件对其他两台服务器进行分发。</p><p>之后再配置了历史服务器的服务器上进行启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mapred --daemon start historyserver<br></code></pre></td></tr></table></figure><blockquote><p>启动失败的话检查一下代码，是不是history写错了（history中的r和o总喜欢换位置的人路过）</p></blockquote><p>同样可以利用jps命令进行查看是否启动正确。</p><p>配置完了历史服务器之后，还需要对日志聚集服务进行配置。在hadoop运行的过程中，每台服务器上都会产生运行的日志。日志聚集的概念就是将所有服务器的日志聚集上传到HDFS系统上。</p><p>开启日志聚集功能，需要重新启动NodeManager、ResourceManager和HistoryServer。</p><p>开启日志聚集功能首先需要配置<code>yarn-site.xml</code>文件，在该配置文件中添加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开启日志聚集功能 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 设置日志聚集服务器地址 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.log.server.url<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>http://hadoop102:19888/jobhistory/logs<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 设置日志保留时间为 7 天 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>604800<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将配置文件分发给其他两台服务器。之后对NodeManager、ResourceManager和HistoryServer进行关闭再启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd $HADOOP_HOME<br>sbin/stop-yarn.sh<br>mapred --daemon stop historyserver<br><br>start-yarn.sh<br>mapred --daemon start historyserver<br></code></pre></td></tr></table></figure><p>之后可以通过web端访问历史服务器<code>http://hadoop102:19888</code>并查看运行日志。</p><h3 id="集群启动和停止">3. 集群启动和停止</h3><ul><li>可以通过命令行方式对集群启动和停止</li></ul><p>各个模块分开启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">start-dfs.sh/stop-dfs.sh<br>start-yarn.sh/stop-yarn.sh<br></code></pre></td></tr></table></figure><p>各个服务组件逐一启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdfs --daemon start/stop namenode/datanode/secondarynamenode<br>yarn --daemon start/stop resourcemanager/nodemanager<br></code></pre></td></tr></table></figure><ul><li>也可以通过编写脚本来启动</li></ul><p>将脚本写在之前配置过的<code>~/bin</code>目录下，因为这个目录已经加入到环境变量中了</p><p>hadoop集群启动和停止脚本：myhadoop.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -lt 1 ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No Args Input...&quot;</span><br>    <span class="hljs-built_in">exit</span> ;<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br><span class="hljs-string">&quot;start&quot;</span>)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; =================== 启动 hadoop 集群 ===================&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 启动 hdfs ---------------&quot;</span><br>    ssh hadoop102 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/sbin/start-dfs.sh&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 启动 yarn ---------------&quot;</span><br>    ssh hadoop103 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/sbin/start-yarn.sh&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 启动 historyserver ---------------&quot;</span><br>    ssh hadoop102 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon start historyserver&quot;</span><br>;;<br><span class="hljs-string">&quot;stop&quot;</span>)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; =================== 关闭 hadoop 集群 ===================&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 关闭 historyserver ---------------&quot;</span><br>    ssh hadoop102 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon stop historyserver&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 关闭 yarn ---------------&quot;</span><br>    ssh hadoop103 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/sbin/stop-yarn.sh&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 关闭 hdfs ---------------&quot;</span><br>    ssh hadoop102 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/sbin/stop-dfs.sh&quot;</span><br>;;<br>*)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Input Args Error...&quot;</span><br>;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><p>查看所有节点jps脚本：jpsall</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> hadoop102 hadoop103 hadoop104<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> =============== <span class="hljs-variable">$host</span> ===============<br>    ssh <span class="hljs-variable">$host</span> jps <br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>当然要给脚本执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x myhadoop.sh<br>chmod +x jpsall<br></code></pre></td></tr></table></figure><p>将更新的<code>~/bin</code>目录进行分发，使得在每个服务器上都能使用</p><h2 id="常用端口号和配置文件说明">常用端口号和配置文件说明</h2><p>常用端口号：</p><table><thead><tr class="header"><th style="text-align: left;">端口名称</th><th>Hadoop2.x</th><th>Hadoop3.x</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">NameNode内部通信端口</td><td>8020 / 9000</td><td>8020 / 9000 / 9820</td></tr><tr class="even"><td style="text-align: left;">NameNode HTTP访问端口</td><td>50070</td><td>9870</td></tr><tr class="odd"><td style="text-align: left;">MapReduce查看任务端口</td><td>8088</td><td>8088</td></tr><tr class="even"><td style="text-align: left;">历史服务器通信端口</td><td>19888</td><td>19888</td></tr></tbody></table><p>需要的配置文件</p><ul><li>3.x：core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml、workers</li><li>2.x：core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml、slaves</li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-入门(4)-SSH免密登录</title>
    <link href="/2022/02/17/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-4-SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
    <url>/2022/02/17/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-4-SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="公钥和私钥原理">公钥和私钥原理</h2><p>这里ssh使用的是rsa的加密。</p><p><strong>非对称加密</strong>非对称加密算法中，有两个密钥：公钥和私钥。它们是一对，如果用公钥进行加密，只有用对应的私钥才能解密；如果用私钥进行加密，只有用对应的公钥才能解密。非对称加密算法实现机密信息的交换过程为：甲方生成一对密钥并将其中一个作为公钥向其他方公开；得到该公钥的乙方使用该密钥对机密信息进行加密后发送给甲方；甲方再用自己的另一个专用密钥对加密后的信息进行解密。</p><p>简要来说：</p><ol type="1"><li>A服务器生成了公钥和私钥</li><li>它将公钥分发给B服务器，这样，A服务器就可以通过ssh来访问B</li><li>A向B发送的数据使用私钥来进行加密</li><li>B服务器接收到数据之后，就会在授权Key中找到A的公钥，解密数据</li><li>B返回给A的数据使用A的公钥进行加密</li><li>A接收到返回数据之后，使用私钥进行解密</li></ol><h2 id="配置免密登录">配置免密登录</h2><p>配置免密登录很简单，首先需要生成公钥和私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>之后将公钥拷贝到需要免密登录的目标机器上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-copy-id hadoop102<br>ssh-copy-id hadoop103<br>ssh-copy-id hadoop104<br></code></pre></td></tr></table></figure><p>其中，自己到自己的ssh也需要配置。</p><blockquote><p>在这一步中，我们会完成如下的免密配置：</p><p>在hadoop102上，使用syh用户配置对其他服务器的免密登录；</p><p>在hadoop103上，使用syh用户配置对其他服务器的免密登录；</p><p>在hadoop104上，使用syh用户配置对其他服务器的免密登录；</p><p>在hadoop102上，使用root用户配置对其他服务器的免密登录。</p></blockquote><h2 id="参考文章">参考文章</h2><ol type="1"><li>https://www.zhihu.com/question/25912483/answer/2287241608</li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-入门(3)-编写xsync分发脚本</title>
    <link href="/2022/02/17/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-3-%E7%BC%96%E5%86%99xsync%E5%88%86%E5%8F%91%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/02/17/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-3-%E7%BC%96%E5%86%99xsync%E5%88%86%E5%8F%91%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="脚本编写">脚本编写</h2><p>目前我们使用的是syh用户。</p><p>我们希望编写一个分发脚本，它能够循环复制文件到所有节点的相同目录之下。并且我们希望脚本在任何路径都能够使用。</p><p>首先，我们将脚本放在syh用户的bin目录下，完整路径为<code>/home/syh/bin</code>，在bin目录中，我们创建xsync文件并写入以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment">#1. 判断参数个数</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -lt 1 ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> Not Enough Arguement!<br>    <span class="hljs-built_in">exit</span>;<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment">#2. 遍历集群所有机器</span><br><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> hadoop102 hadoop103 hadoop104<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> ==================== <span class="hljs-variable">$host</span> ====================<br>    <span class="hljs-comment">#3. 遍历所有目录，挨个发送</span><br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-variable">$@</span><br>    <span class="hljs-keyword">do</span><br>        <span class="hljs-comment">#4. 判断文件是否存在</span><br>        <span class="hljs-keyword">if</span> [ -e <span class="hljs-variable">$file</span> ]<br>            <span class="hljs-keyword">then</span><br>            <span class="hljs-comment">#5. 获取父目录</span><br>            pdir=$(<span class="hljs-built_in">cd</span> -P $(<span class="hljs-built_in">dirname</span> <span class="hljs-variable">$file</span>); <span class="hljs-built_in">pwd</span>)<br>            <span class="hljs-comment">#6. 获取当前文件的名称</span><br>            fname=$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$file</span>)<br>            ssh <span class="hljs-variable">$host</span> <span class="hljs-string">&quot;mkdir -p <span class="hljs-variable">$pdir</span>&quot;</span><br>            rsync -av <span class="hljs-variable">$pdir</span>/<span class="hljs-variable">$fname</span> <span class="hljs-variable">$host</span>:<span class="hljs-variable">$pdir</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">echo</span> <span class="hljs-variable">$file</span> does not exists!<br>        <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>之后为这个文件添加执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x xsync<br></code></pre></td></tr></table></figure><p>之后我们要配置环境变量，仍然使用我们之前创建的my_env.sh文件，在其中增加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/profile.d/my_env.sh<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#HOME_BIN</span><br><span class="hljs-built_in">export</span> MYBIN_HOME=/home/syh<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$MYBIN_HOME</span>/bin<br></code></pre></td></tr></table></figure><p>之后刷新环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><p>之后将脚本复制到<code>/bin</code>目录下，以便全局调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /home/syh/bin/xsync /bin/<br></code></pre></td></tr></table></figure><p>这样，如果是使用sudo使用xsync命令的话，则需要使用如下方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ./bin/sxync ...<br></code></pre></td></tr></table></figure><h2 id="文件分发">文件分发</h2><p>之后我们可以使用刚才编写的xsync脚本来进行文件分发</p><p>举例来说，我们将刚才的java文件夹发送出去，在hadoop102下执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">xsync /ept/module/jdk1.8.0_212<br></code></pre></td></tr></table></figure><p>类似地，我们需要完成<code>/home/syh/bin</code>目录和<code>/opt/module/hadoop-3.1.3</code>目录的分发</p><h2 id="命令使用">命令使用</h2><p>在Linux服务器上进行文件传输会涉及到两个命令</p><h3 id="scp安全拷贝">1.scp安全拷贝</h3><p>它的基本语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r $user@$host:$pdir/$fname $user@$host:$pdir/$fname<br></code></pre></td></tr></table></figure><p>其中，前者为被拷贝的文件目录，后者是目标文件目录。scp可以完成任意两台服务器之间的文件拷贝，只要用户名密码匹配即可。如果是在本机上的文件目录，则可以不用添加user和host，直接用路径即可。</p><p>scp每次都会完成文件的全部复制操作。</p><h3 id="rsync远程同步">2.rsync远程同步</h3><p>rsync完成的是同步操作，同步即指的是会复制修改不同的文件，而不会全部复制，因此在执行的时候会比scp快一些。它主要用于备份和镜像，具有速度快、避免复制相同内容和支持符号链接的优点。</p><p>基本语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -av $user@$host:$pdir/$fname $user@$host:$pdir/$fname<br></code></pre></td></tr></table></figure><p>它与scp命令有类似的特点，区别在于一个是复制，一个是同步。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-入门(2)-安装JDK环境和Hadoop</title>
    <link href="/2022/02/17/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-%E5%AE%89%E8%A3%85JDK%E7%8E%AF%E5%A2%83%E5%92%8CHadoop/"/>
    <url>/2022/02/17/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-2-%E5%AE%89%E8%A3%85JDK%E7%8E%AF%E5%A2%83%E5%92%8CHadoop/</url>
    
    <content type="html"><![CDATA[<h2 id="安装">安装</h2><p>下面的操作都是在hadoop102节点上完成的。</p><p>这里使用了两个压缩包<code>hadoop-3.1.3.tar.gz</code>和<code>jdk-8u212-linux-x64.tar.gz</code></p><p>解压安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /opt/software/<br>tar -zxvf jdk-8u212-linux-x64.tar.gz -C /opt/module/<br>tar -zxvf hadoop-3.1.3.tar.gz -C /opt/module/<br></code></pre></td></tr></table></figure><p>之后完成配置文件的修改即可，可以分别使用如下命令进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -version<br>hadoop version<br></code></pre></td></tr></table></figure><h2 id="配置文件">配置文件</h2><p>可以在<code>/etc/profile</code>中进行配置，但是这里可以使用另一种方法。在这个配置文件中有一段脚本，可以将<code>/etc/profile.d/</code>目录下的所有<code>.sh</code>文件全局生效来配置环境变量。即我们可以在这个目录下维护自己添加的所有环境变量，便于管理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim my_env.sh<br></code></pre></td></tr></table></figure><p>在其中完成java和Hadoop的配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#JAVA_HOME</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/opt/module/jdk1.8.0_212<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br><br><span class="hljs-comment">#HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_HOME=/opt/module/hadoop-3.1.3<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HADOOP_HOME</span>/bin<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HADOOP_HOME</span>/sbin<br></code></pre></td></tr></table></figure><p>之后刷新环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记-入门(1)-IP和主机名称的配置</title>
    <link href="/2022/02/17/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-IP%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%A7%B0%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/02/17/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8-1-IP%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%A7%B0%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="前情回顾">前情回顾</h2><p>在此之前，完成了VMware的基本安装来模拟不同服务器，安装系统使用了centos-7.5，安装了最小版本。接下来的操作是完成一台模板虚拟机的配置，并将这台模板虚拟机进行克隆得到后续的其他节点。</p><h2 id="配置操作">配置操作</h2><h3 id="修改虚拟机ip">1.修改虚拟机IP</h3><p>通过修改文件来修改虚拟机的静态IP（如果没有软件需要使用yum先安装一下）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><p>将其中的以下字段进行修改（第一个字段是修改，后续是添加）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">BOOTPROTO=static<br><br>IPADDR=192.168.10.100<br>GATEWAY=192.168.10.2<br>DNS1=192.168.10.2<br></code></pre></td></tr></table></figure><p>分别配置静态地址、网关和DNS。</p><h3 id="修改vmware和windows网络设置">2.修改VMware和Windows网络设置</h3><p>在VMware中，点击编辑-&gt;虚拟网络编辑器-&gt;VMnet8，修改网络配置。</p><p>修改子网IP为192.168.10.0。</p><p>选择NAT模式，修改NAT设置中的网关IP为192.168.10.2。</p><p>查看Windows系统适配器中VMware Network AdapterVMnet8的IP地址。打开”网络和Internet“设置，修改适配器选项，选择VMnet8的属性，修改其中的IPV4设置，其中默认网关设置为192.168.10.2，首选DNS服务器设置为192.168.10.2，备用DNS服务器设置为8.8.8.8。</p><p>上面的网络配置都是对应的。</p><h3 id="修改主机名和主机映射文件">3.修改主机名和主机映射文件</h3><p>修改主机名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/hostname<br>hadoop 100<br></code></pre></td></tr></table></figure><p>配置主机名称映射hosts文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/hosts<br></code></pre></td></tr></table></figure><p>添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.10.100 hadoop100<br>192.168.10.101 hadoop101<br>192.168.10.102 hadoop102<br>192.168.10.103 hadoop103<br>192.168.10.104 hadoop104<br>192.168.10.105 hadoop105<br>192.168.10.106 hadoop106<br>192.168.10.107 hadoop107<br>192.168.10.108 hadoop108<br></code></pre></td></tr></table></figure><p>重启虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">reboot<br></code></pre></td></tr></table></figure><h3 id="后续的软件准备">4.后续的软件准备</h3><p>安装epel-release：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y epel-release<br></code></pre></td></tr></table></figure><blockquote><p>Extra Packages for Enterprise Linux是为“红帽系”的操作系统提供额外的软件包， 适用于 RHEL、CentOS 和Scientific Linux。相当于是一个软件仓库，大多数 rpm 包在官方 repository中是找不到的）</p></blockquote><p>安装net-tool：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y net-tools<br></code></pre></td></tr></table></figure><p>安装vim：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y vim<br></code></pre></td></tr></table></figure><p>关闭防火墙，关闭防火墙开机自启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop firewalld<br>systemctl disable firewalld.service<br></code></pre></td></tr></table></figure><p>创建syh用户并修改密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd syh<br>passwd syh<br></code></pre></td></tr></table></figure><p>配置syh用户具有root权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sudoers<br></code></pre></td></tr></table></figure><p>修改文件，在%wheel这行下面添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Allows people in group wheel to run all commands</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">wheel  ALL=(ALL)       ALL</span><br>syh     ALL=(ALL)       NOPASSWD:ALL<br></code></pre></td></tr></table></figure><p>在/opt目录下创建文件夹module和software文件夹，并修改所属主和组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /opt/module<br>mkdir /opt/software<br><br>chown syh:syh /opt/module<br>chown syh:syh /opt/software<br></code></pre></td></tr></table></figure><h2 id="虚拟机克隆">虚拟机克隆</h2><p>从hadoop100中克隆出三台虚拟机，分别为hadoop102，hadoop103，hadoop104。</p><p>克隆完成之后需要依次将这些虚拟机的IP和hostname进行修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sysconfig/network-scripts/ifcfg-ens33<br>vim /etc/hostname<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>Hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux环境变量错误导致找不到命令</title>
    <link href="/2022/02/17/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E6%89%BE%E4%B8%8D%E5%88%B0%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/02/17/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E6%89%BE%E4%B8%8D%E5%88%B0%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述与解决">问题描述与解决</h2><p>在某些情况下，自己配置环境变量导致出现了错误，例如变量符号<code>$</code>打错了之类的，这样会导致很多命令无法使用，例如<code>ls</code>，<code>vim</code>之类的，这导致没有办法通过正常方式修改原先错误的配置文件。</p><p>解决方案如下：</p><ol type="1"><li><p>首先在命令行中输入如下命令，使得暂时可以使用命令行执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=/usr/bin:/usr/sbin:/bin:/sbin <br></code></pre></td></tr></table></figure></li><li><p>打开相应的配置文件，使用系统自带的<code>vi</code></p></li><li><p>刷新环境变量<code>source</code></p></li><li><p>重启服务器<code>reboot</code></p></li></ol><h2 id="参考文章">参考文章</h2><p><ahref="https://blog.csdn.net/weixin_45335305/article/details/106920244#/">CentOS中错误配置环境变量导致命令不可用_林浩吧的博客-CSDN博客_centos环境变量配置错误</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript完成对json数据的排序</title>
    <link href="/2022/02/13/JavaScript%E5%AE%8C%E6%88%90%E5%AF%B9json%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/02/13/JavaScript%E5%AE%8C%E6%88%90%E5%AF%B9json%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="排序实现">排序实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//json排序所需函数(filed表示需要用来排序的key,rev表示是否升序,primer表示value的类型)</span><br><span class="hljs-title function_">sortBy</span>(<span class="hljs-params">filed, rev, primer</span>)&#123;<br>    rev = (rev) ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>        a = a[filed];<br>        b = b[filed];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> (primer) != <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>            a = <span class="hljs-title function_">primer</span>(a);<br>            b = <span class="hljs-title function_">primer</span>(b);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a &lt; b) &#123; <span class="hljs-keyword">return</span> rev * -<span class="hljs-number">1</span>; &#125;<br>        <span class="hljs-keyword">if</span> (a &gt; b) &#123; <span class="hljs-keyword">return</span> rev * <span class="hljs-number">1</span>; &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>后续调用：（<code>this.Data</code>为json列表，id为排序根据字段，parseInt为对应的value类型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">Data</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sortBy</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-built_in">parseInt</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>功能模块</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue动态绑定class属性</title>
    <link href="/2022/02/13/Vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Aclass%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/02/13/Vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Aclass%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="方法尝试">方法尝试</h2><p>使用方法参考了其他文章，这里将本人使用过的方式对应列举出来。</p><p>方式一：直接在标签中指定true or false，或者布尔变量：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;content-box&#x27;:true,&#x27;content-box-not-collapsed&#x27;:!$store.state.collapse&#125;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://www.cnblogs.com/sweeeper/p/11506726.html#/">vue动态绑定class的几种方式- sweeeper - 博客园 (cnblogs.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>奇怪の小坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios异步获取数据，其他函数进行调用</title>
    <link href="/2022/02/13/axios%E5%BC%82%E6%AD%A5%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8/"/>
    <url>/2022/02/13/axios%E5%BC%82%E6%AD%A5%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="解决方案">解决方案</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-title function_">getNowId</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-comment">//获取新数据(同步获取)</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get_cv_data</span>(value);<br>    ...<br>&#125;，<br><br><span class="hljs-comment">//利用axios获取所有声优信息</span><br><span class="hljs-keyword">async</span> <span class="hljs-title function_">get_all_cv_data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">data</span>:res&#125; = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;xxxx&#x27;</span>);<br><br>    <span class="hljs-keyword">var</span> res_cv = res[<span class="hljs-string">&#x27;cv&#x27;</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> res_cv)&#123;<br>        <span class="hljs-keyword">var</span> url = res_cv[index][<span class="hljs-string">&#x27;image&#x27;</span>];<br>        res_cv[index][<span class="hljs-string">&#x27;image&#x27;</span>] = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../../../img&#x27;</span>+url);<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cvData</span> = res_cv;<br>&#125;,<br></code></pre></td></tr></table></figure><p>在调用<code>get_all_cv_data</code>的函数当中，如果需要等到数据获取完成之后再执行后续的代码，则也需要使用<code>async</code>和<code>await</code>来进行修饰</p><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://blog.csdn.net/weixin_45538554/article/details/118300451#/">vueaxios异步改同步请求(获得数据后再执行下面的代码)_Java-张无忌的博客-CSDN博客_axios同步请求数据</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>奇怪の小坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中使用require加载图片遇到的问题</title>
    <link href="/2022/02/13/Vue%E4%B8%AD%E4%BD%BF%E7%94%A8require%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/13/Vue%E4%B8%AD%E4%BD%BF%E7%94%A8require%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="require的使用">require的使用</h2><p>在vue中使用require：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//path为路径变量</span><br>img = <span class="hljs-built_in">require</span>(path)  无法引入<br>img = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./&#x27;</span>+path)  可以引入 <br></code></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://blog.csdn.net/fhjdzkp/article/details/105271862#/">(26条消息)vue动态加载图片问题，报错Cannot find module"."_风华绝代的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>奇怪の小坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用elementUI过程中遇到的问题记录</title>
    <link href="/2022/02/13/%E4%BD%BF%E7%94%A8elementUI%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/02/13/%E4%BD%BF%E7%94%A8elementUI%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="问题记录">问题记录</h2><p>目前已经记录的问题简要描述如下：</p><ol type="1"><li><p>table组件切换时会有不同程度的长度变化</p></li><li><p>带输入建议的input中，输入建议显示空白</p></li><li><p>input输入建议的模糊查询</p></li><li><p>table的定位跳转</p></li><li><p>侧边栏子菜单展开后会多出1px</p></li><li><p>弹出对话框的抖动问题</p></li></ol><h2 id="解决方案">解决方案</h2><h3 id="table组件长度变化">1.table组件长度变化</h3><p>如果将elementUItable作为动态组件在页面中显示，第一次显示是正常的，而后续来回切换之后再显示，table会出现不同程度的长度变化，据官方所说这好像是内部的一个小bug。</p><p>一种解决方案是在每次切换回表格的时候对数据进行重新加载，在activate生命周期的时候执行下面的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">multipleTable</span>.<span class="hljs-title function_">doLayout</span>();<br>     <span class="hljs-comment">// el-table加ref=&quot;multipleTable&quot;</span><br> &#125;);<br></code></pre></td></tr></table></figure><h3id="带输入建议的input组件显示空白">2.带输入建议的input组件显示空白</h3><p>elementUI中提供有带输入建议的input组件使用如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-autocomplete</span></span><br><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inline-input&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;show&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;searchName&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">:fetch-suggestions</span>=<span class="hljs-string">&quot;querySearch&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;名称搜索&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">:trigger-on-focus</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">:model-append-to-body</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">@<span class="hljs-attr">select</span>=<span class="hljs-string">&quot;handleSelect&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-autocomplete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中实现返回输入建议的是绑定在<code>:fetch-suggestions</code>里的方法，下面的问题3中会提供一种模糊查询的方式。目前遇到的问题是返回建议是空白的，原因在于显示的数据中，输入建议必须是在<code>value</code>字段当中。</p><h3 id="返回模糊查询的输入建议">3.返回模糊查询的输入建议</h3><p>input组件通过绑定在<code>:fetch-suggestions</code>里的方法实现输入建议。通常在输入建议当中，我们会返回模糊查询之后的结果，通过以下方式来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//用来实现模糊查找的两个函数</span><br><span class="hljs-title function_">querySearch</span>(<span class="hljs-params">queryString, cb</span>) &#123;<br>    <span class="hljs-keyword">var</span> searchData = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>;<span class="hljs-comment">//需要查询的全部数据</span><br>    <span class="hljs-keyword">var</span> results = queryString ? searchData.<span class="hljs-title function_">filter</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createFilter</span>(queryString)) : searchData;<br>    <span class="hljs-comment">// 调用 callback 返回建议列表的数据</span><br>    <span class="hljs-title function_">cb</span>(results);<br>&#125;,<br>    <br><span class="hljs-title function_">createFilter</span>(<span class="hljs-params">queryString</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">searchData</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> (searchData.<span class="hljs-property">label</span>.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">indexOf</span>(queryString.<span class="hljs-title function_">toLowerCase</span>()) &gt; -<span class="hljs-number">1</span>);<br>    &#125;;<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="table的定位跳转">4.table的定位跳转</h3><p>目前需要完成的任务是，在输入框中输入了数据，然后表格需要将对应数据行显示当前的第一列。这个功能可以通过获取所需数据行在全部数据中的index，然后通过index进行定位跳转来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//element-ui跳转到指定行</span><br><span class="hljs-title function_">tableScrollMove</span>(<span class="hljs-params">refName,index=<span class="hljs-number">0</span></span>)&#123;<br>    <span class="hljs-keyword">if</span>(!refName || !<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>[refName]) <span class="hljs-keyword">return</span><span class="hljs-comment">//不存在表格的ref vm 则返回</span><br>    <span class="hljs-keyword">let</span> vmEl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>[refName].<span class="hljs-property">$el</span><br>    <span class="hljs-keyword">if</span>(!vmEl) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">//计算滚动条的位置</span><br>    <span class="hljs-keyword">const</span> targetTop = vmEl.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.el-table__body tr&#x27;</span>)[index].<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">top</span>;<br>    <span class="hljs-keyword">const</span> containerTop = vmEl.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.el-table__body&#x27;</span>).<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">top</span>;<br>    <span class="hljs-keyword">const</span> scrollParent = vmEl.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.el-table__body-wrapper&#x27;</span>);<br>    scrollParent.<span class="hljs-property">scrollTop</span> = targetTop - containerTop;<br>&#125;,<br></code></pre></td></tr></table></figure><p>其中refName表示table表格的ref值，index表示当前需要展示的数据对应的index。</p><p>目前遇到的实现情况是，在输入框中输入了对应数据的名称（声优或者动漫的名称），通过监听目前输入框中数据的变化，动态查找到该数据在全部数据中的index，然后调用上面的定位方式。</p><h3 id="侧边栏子菜单展开后会多出1px">5.侧边栏子菜单展开后会多出1px</h3><p>elementUI中提供侧边栏功能，侧边栏展开后子菜单可能会出现宽度多出1px的问题，解决方案如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">//对<span class="hljs-selector-tag">table</span>设置以下样式<br><span class="hljs-selector-class">.el-menu</span>&#123;<br>    <span class="hljs-attribute">border-right-width</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="弹出对话框的抖动问题">6.弹出对话框的抖动问题</h3><p>弹出对话框的时候会导致页面抖动，这是因为出现滑块的原因，解决方案如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style scope&gt;<br>/* 防止打开对话框时页面的抖动 */<br>body&#123;<br>  padding-right: 0px !important;<br>  overflow: hidden;<br>&#125;<br>&lt;/style&gt;<br>如果按照上述的设置不会起到作用，因为&quot;&lt;style scope&gt;&quot;中将css样式设定为局部的。所以需要将&quot;scope&quot;去掉。<br></code></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://segmentfault.com/q/1010000020355390#/">element-ui的table，切换路由后高度变小- SegmentFault 思否</a></li><li><ahref="https://blog.csdn.net/wyhstars/article/details/81672195#/">element-ui带输入建议的input框踩坑(输入建议空白以及会闪出上一次的输入建议问题)_wyhstars的博客-CSDN博客_elementinput</a></li><li><ahref="https://www.cnblogs.com/yuwenjing0727/p/14741875.html#/">element-ui表格定位到某一行- yuwenjing - 博客园 (cnblogs.com)</a></li><li><ahref="https://blog.csdn.net/YingDaoMonkey/article/details/81809865#/">elementUI导航栏展开后子菜单宽度多出1px问题_YingDaoMonkey的博客-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>奇怪の小坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elementUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用elementUI完成文件上传</title>
    <link href="/2022/02/12/%E5%88%A9%E7%94%A8elementUI%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <url>/2022/02/12/%E5%88%A9%E7%94%A8elementUI%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="整体描述">整体描述</h2><p>利用elementUI中提供的upload组件可以完成文件上传功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>        &lt;el-upload<br>              ref=&quot;upload&quot;<br>              :action=&quot;$store.state.backend_url+&#x27;post/reference&#x27;&quot;<br>              :headers=&quot;myHeaders&quot;<br>              :file-list=&quot;fileList&quot;<br>              :on-success=&quot;handleSuccess&quot;<br>              :on-error=&quot;handleError&quot;<br>              :auto-upload=&quot;false&quot;&gt;<br>        &lt;/el-upload&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      myHeaders: &#123;<br>        Authorization: &#x27;Bearer &#x27; + this.$cookies.get(&#x27;token&#x27;)<br>      &#125;,<br>      fileList: [],<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>其中action表示后端接收的地址，header可以携带自定义的请求header。</p><p><code>on-sucess</code>和<code>on-error</code>可以分别绑定上传事件和上传失败事件。</p><p>在后端如果使用Flask进行接收的话，可以利用request中的file进行接收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">data = request.files.get(<span class="hljs-string">&#x27;file&#x27;</span>)<br>data.save(<span class="hljs-string">&#x27;reference/&#x27;</span> + data.filename)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>功能模块</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>elementUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>登录模块的实现</title>
    <link href="/2022/02/12/%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/02/12/%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="登录模块的实现步骤">登录模块的实现步骤</h2><p>首先描述登录模块的设计步骤和思想：</p><ol type="1"><li><p>首先在前台提供输入表单，表单可以使用elementUI中提供的表单元素（有前端规则验证）</p></li><li><p>获取到前端输入之后，向后端发送请求，这里需要通过BasicAuth的验证，在axios参数中需要携带auth</p></li><li><p>向后端发送请求通过之后，可以得到返回的token，这里的token需要持久化记录，所以可以选择利用Cookies进行记录，此后需要用到的地方也可以直接从Cookies中取出</p></li><li><p>登录之后，由前端发出的其余请求都需要携带token，并且进行TokenAuth的验证。这里可以通过利用axios的拦截器来进行完成，在请求前完成对请求头的token添加</p></li><li><p>之后需要完成路由鉴权，如果当前路由需要token才能访问，而Cookies中没有token，那么就跳转到登录页面</p></li><li><p>登录退出的话，只需要进行Cookies的清除即可</p></li></ol><p>以上是登录模块的设计思想，下面的细节说明是基于nuxt-cli工程的，其余工程也可以有类似的实现方式。</p><h2 id="nuxt中cookies的应用">Nuxt中Cookies的应用</h2><p>前端的Cookies可以简单的理解为一个携带信息的字符串，它保存在客户端，通过代码可以从中解析出对应的信息。因此，Cookies在Nuxt中就可以作为一个全局变量的提取器（个人理解）。在获得信息的时候将其存入Cookies中，当需要的时候再将它从Cookies中解析出来使用。</p><p>Nuxt要使用Cookies，需要引入插件：cookie-universal-nuxt 。</p><p>首先进行安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm intall cookie-universal-nuxt --save<br></code></pre></td></tr></table></figure><p>然后在nuxt配置文件<code>nuxt.config.js</code>中引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">modules</span>: [<br>    <span class="hljs-string">&#x27;cookie-universal-nuxt&#x27;</span>,<br>],<br></code></pre></td></tr></table></figure><p>之后就可以使用了，下面是一些常见的操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//设置cookies</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$cookies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;token&#x27;</span>, token)<br><br><span class="hljs-comment">//获取cookies</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;token&#x27;</span>)<br><br><span class="hljs-comment">//清除cookies</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$cookies</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;token&#x27;</span>)<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$cookies</span>.<span class="hljs-title function_">removeAll</span>()<br></code></pre></td></tr></table></figure><p>于是，可以在登录axios的response中完成相应的cookies存储工作，以便后续的使用。</p><h2 id="nuxt中axios拦截器的使用">Nuxt中axios拦截器的使用</h2><p>axios拦截器可以在项目中任何一个axios请求的不同阶段发生之前进行事先定义的操作。我们需要在nuxt项目中定义axios拦截器，在axios发送请求之前给它加上token。</p><p>首先需要修改配置文件<code>nuxt.config.js</code>，进行模块和插件的添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-string">&#x27;@/plugins/axios&#x27;</span>,<br>],<br><span class="hljs-attr">modules</span>: [<br>    <span class="hljs-string">&#x27;@nuxtjs/axios&#x27;</span>,<br>],<br><br></code></pre></td></tr></table></figure><p>然后创建插件文件<code>plugins/axios.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//添加插件文件 plugins/axios.js</span><br><span class="hljs-keyword">let</span> isClient = process.<span class="hljs-property">env</span>.<span class="hljs-property">VUE_ENV</span> === <span class="hljs-string">&#x27;client&#x27;</span> <span class="hljs-comment">//区分端</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (&#123;redirect, $axios, app&#125;) =&gt; &#123;<br>  $axios.<span class="hljs-title function_">onRequest</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">//match api</span><br>      <span class="hljs-keyword">let</span> token = app.<span class="hljs-property">$cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;token&#x27;</span>);<br>      <span class="hljs-comment">//add token</span><br>      <span class="hljs-keyword">if</span> (token) config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">&#x27;Bearer &#x27;</span> + token;<br>      <span class="hljs-comment">//其他的请求前业务逻辑 比如：api map</span><br>      <span class="hljs-title function_">resolve</span>(config);<br>    &#125;)<br>  &#125;);<br><br>  $axios.<span class="hljs-title function_">onResponse</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">//返回数据逻辑处理 比如：error_code错误处理</span><br>      <span class="hljs-title function_">resolve</span>(res);<br>    &#125;)<br>  &#125;);<br><br>  $axios.<span class="hljs-title function_">onError</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Making request to &#x27;</span> + config.<span class="hljs-property">url</span>);<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;出现了未知的异常，请重新登录&#x27;</span>);<br>  &#125;)<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="nuxt路由鉴权">Nuxt路由鉴权</h2><p>Nuxt中的路由鉴权可以通过中间件来完成，中间件允许定义一个自定义函数运行在一个页面或者一组页面渲染之前。这里只说明自定义函数中应该完成的逻辑，中间件的引入和使用就不再说明。于是在这个自定义函数中，我们可以对当前路由进行判断，如果不满足要求，就跳转到登录页面。</p><p>以下为<code>middleware/auth.js</code>中的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-keyword">let</span> now_route = context.<span class="hljs-property">route</span>.<span class="hljs-property">fullPath</span>;<br>  <span class="hljs-comment">//检查当前路由是否在/data下</span><br>  <span class="hljs-keyword">if</span> (now_route.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;/data&quot;</span>) === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//检查是否有token,如果没有token，则跳转到登录页面</span><br>    <span class="hljs-keyword">let</span> token = context.<span class="hljs-property">$cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;token&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!token) &#123;<br>      context.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//检查是否是admin页面</span><br>  <span class="hljs-keyword">if</span> (now_route.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;/data/admin&quot;</span>) === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//检查是否有权限</span><br>    <span class="hljs-keyword">let</span> auth = context.<span class="hljs-property">$cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;auth&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (auth !== <span class="hljs-number">0</span>) &#123;<br>      context.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//检查是否是editor页面</span><br>  <span class="hljs-keyword">if</span> (now_route.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;/editor&quot;</span>) === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//检查是否有权限</span><br>    <span class="hljs-keyword">let</span> auth = context.<span class="hljs-property">$cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;auth&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (auth !== <span class="hljs-number">0</span> &amp;&amp; auth !== <span class="hljs-number">1</span>) &#123;<br>      context.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://blog.csdn.net/AK852369/article/details/115792191#/">Nuxt引用cookie-universal-nuxt在服务端请求cookie_明知山-CSDN博客_cookie-universal-nuxt</a></li><li><a href="https://www.jianshu.com/p/2479eaca2bf7#/">nuxt服务端进行请求时带上token - 简书 (jianshu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>功能模块</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Nuxt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷新nuxt中的组件</title>
    <link href="/2022/02/12/%E5%88%B7%E6%96%B0nuxt%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/02/12/%E5%88%B7%E6%96%B0nuxt%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>在经过一些操作之后，在组件中调用如下刷新操作，但是网页中并没有显示出效果。必须要手动点击刷新按钮之后才能看到效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$nuxt</span>.<span class="hljs-title function_">refresh</span>()<br></code></pre></td></tr></table></figure><h2 id="问题解决">问题解决</h2><p>可以用一种绑定key到组件上的方法进行解决。当key更改的时候，组件也会刷新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">refreshKey</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">//用于刷新</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">handleCommand</span>(<span class="hljs-params">command</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$cookies</span>.<span class="hljs-title function_">removeAll</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">refreshKey</span> += <span class="hljs-number">1</span>; <span class="hljs-comment">//在页面跳转之前使用</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>&#125;);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>奇怪の小坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nuxt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python实现Markdown的读取和转换</title>
    <link href="/2022/02/12/Python%E5%AE%9E%E7%8E%B0Markdown%E7%9A%84%E8%AF%BB%E5%8F%96%E5%92%8C%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/02/12/Python%E5%AE%9E%E7%8E%B0Markdown%E7%9A%84%E8%AF%BB%E5%8F%96%E5%92%8C%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="markdown转html">markdown转html</h2><p>先安装所需的包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install markdown<br>pip install codecs<br></code></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取md文件，并转化成md格式的字符串</span><br>input_md = codecs.<span class="hljs-built_in">open</span>(md_path, mode=<span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>md_str = input_md.read()<br><span class="hljs-comment"># 将md格式的字符串转化成html格式的字符串</span><br>html_str = markdown.markdown(md_str)<br></code></pre></td></tr></table></figure><h2 id="html转markdown">html转markdown</h2><p>先安装所需的包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install html2text<br></code></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> html2text<br><br>text_maker = html2text.HTML2Text()<br><br><span class="hljs-comment"># html_str是html格式的字符串</span><br>md_str = text_maker.handle(html_str)<br></code></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><ol type="1"><li><p><ahref="https://www.jianshu.com/p/0eff6cba1b7f#/">Python下将Markdown转为HTML- 简书 (jianshu.com)</a></p></li><li><p>[<ahref="https://www.cnblogs.com/ttkl/p/10767536.html#/">python]html格式转md格式- 行走的DT - 博客园 (cnblogs.com)</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask通过nginx反向代理时获取客户端真实IP</title>
    <link href="/2022/02/12/Flask%E9%80%9A%E8%BF%87nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%97%B6%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9C%9F%E5%AE%9EIP/"/>
    <url>/2022/02/12/Flask%E9%80%9A%E8%BF%87nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%97%B6%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9C%9F%E5%AE%9EIP/</url>
    
    <content type="html"><![CDATA[<h2 id="问题解决">问题解决</h2><p>正常情况下，通过如下方式即可获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ip = request.remote_addr<br></code></pre></td></tr></table></figure><p>如果使用了nginx进行代理的话，需要首先在nginx的配置文件中进行相应的修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">server &#123;<br>    location / &#123;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在Flask代码中通过如下方式获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> request<br><br>real_ip = request.headers[<span class="hljs-string">&#x27;X-Forwarded-For&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://lpwmm.blog.csdn.net/article/details/109474476?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=1#/">Flask使用nginx反向代理后获取客户端真实IP地址_Dexter'sLaboratory-CSDN博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask静态文件的组织方式</title>
    <link href="/2022/02/12/Flask%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/02/12/Flask%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="默认组织方式">默认组织方式</h2><p>Flask默认的目录结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">- app.py<br>- static<br>- js<br>    - css<br>    - img<br>- templates<br>- index.html<br></code></pre></td></tr></table></figure><p>静态文件就放在static文件夹下，可以通过网址直接访问。网址类似于<code>http://localhost/static/xxxx</code>。</p><h2 id="自定义组织方式">自定义组织方式</h2><p>在app实例化的时候对这些组织方式进行相应的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可对实例、配置模板文件路径、静态文路径进行配置</span><br>app = Flask(__name__,static_folder=<span class="hljs-string">&#x27;xxx&#x27;</span>,static_url_path=<span class="hljs-string">&#x27;xxx&#x27;</span>,template_folder=<span class="hljs-string">&#x27;xxx&#x27;</span>)<br> <br>static_folder = <span class="hljs-string">&#x27;static&#x27;</span><br> <br>static_url_path = <span class="hljs-literal">None</span>, <br> <br>template_folder = <span class="hljs-string">&#x27;templates&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>static_folder表示静态文件存放的目录，默认是当前项目中的static目录</li><li>static_url_path表示远程访问静态文件的时候的前缀，默认不写则与static_folder同名<ul><li>如果该项设置为<code>''</code>，而其他保持默认情况，则url中访问<code>/img/test.png</code>，实际访问的是<code>/static/img/test.png</code>文件</li></ul></li><li>template表示模板目录，默认是当前项目中的templates 目录</li></ul><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://blog.csdn.net/JSYhq/article/details/88619573#/">Flask—静态资源配置_HuQi-CSDN博客_flask静态资源</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask向前端返回文件流</title>
    <link href="/2022/02/12/Flask%E5%90%91%E5%89%8D%E7%AB%AF%E8%BF%94%E5%9B%9E%E6%96%87%E4%BB%B6%E6%B5%81/"/>
    <url>/2022/02/12/Flask%E5%90%91%E5%89%8D%E7%AB%AF%E8%BF%94%E5%9B%9E%E6%96%87%E4%BB%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="返回文件流">返回文件流</h2><p>通过调用函数make_response和send_from_directory</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> make_response, send_from_directory<br><br>response = make_response(send_from_directory(path, file_name, as_attachment=<span class="hljs-literal">True</span>))<br><span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>其中，path为文件所在的文件夹路径，file_name为文件的名称（包括了后缀）</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask通过url传递参数</title>
    <link href="/2022/02/12/Flask%E9%80%9A%E8%BF%87url%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/"/>
    <url>/2022/02/12/Flask%E9%80%9A%E8%BF%87url%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="使用举例">使用举例</h2><p>通过在链接中使用箭头符号即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/data/&lt;path&gt;&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getImgFromPath</span>(<span class="hljs-params">path</span>):<br>    <span class="hljs-built_in">print</span>(path)<br></code></pre></td></tr></table></figure><p>这样指定之后，前端可以通过访问<code>/data/xxx</code>链接进入该函数，后端的path会对应获取到path。</p><p>如果xxx中含有斜杠<code>/</code>，即为路径的形式，则默认情况下会出现无法获取的情况，这时候需要使用path进行修饰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/data/&lt;path:data_path&gt;&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getImgFromPath</span>(<span class="hljs-params">data_path</span>):<br>    <span class="hljs-built_in">print</span>(data_path)<br></code></pre></td></tr></table></figure><p>默认情况下，xxx会有一些限制，可以通过不同的修饰来扩大xxx的范围：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">string: 默认的数据类型，需注意不能带有<span class="hljs-string">&#x27;/&#x27;</span>，否则会报404error<br><span class="hljs-built_in">int</span>: 整型数据<br><span class="hljs-built_in">float</span>: 浮点型<br>path： 和string类似，但是可以传递斜杠/<br>uuid： uuid类型的字符串<br><span class="hljs-built_in">any</span>：可以指定多种路径<br></code></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://blog.csdn.net/liuzonghao88/article/details/89376851#/">Flask通过URL传递参数，参数中含有'/'斜杠问题_liuzh的博客-CSDN博客_url参数带斜杠</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask获取各类参数</title>
    <link href="/2022/02/12/Flask%E8%8E%B7%E5%8F%96%E5%90%84%E7%B1%BB%E5%8F%82%E6%95%B0/"/>
    <url>/2022/02/12/Flask%E8%8E%B7%E5%8F%96%E5%90%84%E7%B1%BB%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="flask获取get参数">Flask获取get参数</h2><p>通过request.args.get()方式进行获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以username举例</span><br>username = request.args.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="flask获取post参数">Flask获取post参数</h2><p>post获取参数分为多种情况，下面列举我在实际过程中使用过的获取方式。</p><h3 id="原始参数">1. 原始参数</h3><p>原始参数指的是以json格式传送的参数，在axios中一般以如下方式传递：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$axios</span>.<span class="hljs-title function_">post</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">backend_url</span> + <span class="hljs-string">&#x27;post/changePwd&#x27;</span>, &#123;<br>    <span class="hljs-attr">username</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span>,<br>    <span class="hljs-attr">password</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">password</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>此类参数的接收，使用json进行解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">data = request.get_data()<br>json_data = json.loads(data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>user_name = json_data.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>pwd = json_data.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="使用表单传递的数据">2.使用表单传递的数据</h3><p>使用表单传递的数据，可能有文件，也可能有参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 文件传递</span><br>file_data = request.files.get(<span class="hljs-string">&#x27;file&#x27;</span>)<br><span class="hljs-comment"># 表单参数传递</span><br>path = request.form.get(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-comment"># 文件获取之后可能的操作(文件下载)</span><br>file_data.save(path + file_data.filename)<br></code></pre></td></tr></table></figure><p>还有其他的方法等遇到了再继续补充...</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask实现密码登录以及token验证</title>
    <link href="/2022/02/12/Flask%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E4%BB%A5%E5%8F%8Atoken%E9%AA%8C%E8%AF%81/"/>
    <url>/2022/02/12/Flask%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E4%BB%A5%E5%8F%8Atoken%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<p>下面主要完成的是通过Flask实现密码登录，用户成功登录之后，后端返回一个token。此后用户通过token即可访问其他需要验证的网站。</p><h2 id="flask实现密码登录">Flask实现密码登录</h2><p>首先安装所需的模块：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install flask_httpauth<br>pip install itsdangerous<br></code></pre></td></tr></table></figure><p>之后创建一个工具对象<code>utils/MyToken.py</code>，用于生成token以及验证token（通过捕获不同的错误来确定token的状态：正确、错误、过期等）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itsdangerous <span class="hljs-keyword">import</span> TimedJSONWebSignatureSerializer <span class="hljs-keyword">as</span> Serializer<br><span class="hljs-keyword">from</span> itsdangerous <span class="hljs-keyword">import</span> BadSignature, SignatureExpired<br><br>SECRET_KEY = <span class="hljs-string">&#x27;xxxxxxx&#x27;</span>  <span class="hljs-comment"># 这里可以设置密钥 </span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Token</span>:<br><br>    <span class="hljs-comment"># 生成token，有效时间为60min,3600s</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_auth_token</span>(<span class="hljs-params">user_id, expiration=<span class="hljs-number">3600</span></span>):<br>        s = Serializer(SECRET_KEY, expires_in=expiration)<br>        <span class="hljs-keyword">return</span> s.dumps(&#123;<span class="hljs-string">&#x27;user_id&#x27;</span>: user_id&#125;).decode()<br><br>    <span class="hljs-comment"># 解析token</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_auth_token</span>(<span class="hljs-params">token</span>):<br>        s = Serializer(SECRET_KEY)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># token正确</span><br>            data = s.loads(token)<br>            <span class="hljs-keyword">return</span> data<br>        <span class="hljs-keyword">except</span> SignatureExpired:<br>            <span class="hljs-comment"># token过期</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;token已经过期&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">except</span> BadSignature:<br>            <span class="hljs-comment"># token错误</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;token错误&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>之后在Flask前端进行相应的验证配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify, g, request, abort, make_response, send_from_directory<br><span class="hljs-keyword">from</span> flask_cors <span class="hljs-keyword">import</span> CORS<br><span class="hljs-keyword">from</span> flask_httpauth <span class="hljs-keyword">import</span> HTTPBasicAuth<br><span class="hljs-keyword">from</span> utils.MyToken <span class="hljs-keyword">import</span> Token<br><br>auth_user = HTTPBasicAuth()  <span class="hljs-comment"># 用户名和密码验证</span><br><br><span class="hljs-comment"># 用户名和密码验证</span><br><span class="hljs-meta">@auth_user.verify_password</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_password</span>(<span class="hljs-params">username, password</span>):<br>    <span class="hljs-comment"># 验证用户id与密码是否匹配</span><br>    label, auth = db.hasUser(username, password)<br>    <span class="hljs-comment"># 如果用户id与密码对应不上，返回False</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> label:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    g.user_id = username<br>    g.user_auth = auth<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>用户名和密码验证主要是使用HTTPBasicAuth，在postman的测试中，指定路径为<code>Authorization -&gt; Basic Auth</code>。通过verify_password函数来指定验证方式。其中hasUser函数是自己写的函数，可以通过连接数据库，并通过给定的username和password来判定用户id和密码是否匹配，如果匹配，则返回True，否则返回False。</p><p>然后在需要用户密码验证的链接之前增加修饰：<code>@auth_user.login_required</code></p><p>如下，完成登录链接的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 登录验证</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-meta">@auth_user.login_required</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    user = g.user_id<br>    token = Token.generate_auth_token(g.user_id)<br>    <span class="hljs-keyword">return</span> jsonify(&#123;<span class="hljs-string">&#x27;token&#x27;</span>: token&#125;)<br></code></pre></td></tr></table></figure><p>如果用户访问该链接，会首先进行auth_use的验证，只有当验证返回True的时候才会进入login函数。login函数中返回token给前端。</p><h2 id="flask实现token验证">Flask实现token验证</h2><p>token验证的实现与前面类似，同样是通过实现验证函数来完成。token验证主要是使用HTTPTokenAuth，在postman的测试中，指定路径为<code>Authorization -&gt; Bearer Token</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask_httpauth <span class="hljs-keyword">import</span> HTTPTokenAuth<br><br>auth_token = HTTPTokenAuth()  <span class="hljs-comment"># token验证</span><br><br><span class="hljs-comment"># token验证</span><br><span class="hljs-meta">@auth_token.verify_token</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_token</span>(<span class="hljs-params">token</span>):<br>    token = re.sub(<span class="hljs-string">r&#x27;^&quot;|&quot;$&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, token)<br>    label = Token.verify_auth_token(token)<br>    <span class="hljs-keyword">return</span> label<br></code></pre></td></tr></table></figure><p>然后在需要token验证的链接之前增加修饰：<code>@auth_token.login_required</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取数据</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/data&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-meta">@auth_token.login_required</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">allData</span>():<br>    data = db.getData()<br>    <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><h2 id="与前端axios的对接">与前端axios的对接</h2><p>前端axios完成用户密码的传递（通过<code>auth</code>指定），这里的密码使用md5加密是为了进行演示，实际情况下一般不会使用md5进行密码的加密：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> toParams = &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">param</span>.<span class="hljs-property">username</span>.<span class="hljs-title function_">toString</span>(),<br>    <span class="hljs-attr">password</span>: <span class="hljs-title function_">md5</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">param</span>.<span class="hljs-property">password</span>).<span class="hljs-title function_">toUpperCase</span>(),<br>&#125;<br><br><span class="hljs-comment">//向后端发送登录请求</span><br><span class="hljs-variable language_">this</span>.$axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">backend_url</span> + <span class="hljs-string">&#x27;login&#x27;</span>,<br>    <span class="hljs-attr">auth</span>: toParams,<br>&#125;)<br></code></pre></td></tr></table></figure><p>前端axios完成token的传递（一般是通过axios的拦截器完成）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">$axios.<span class="hljs-title function_">onRequest</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//match api</span><br>    <span class="hljs-keyword">let</span> token = app.<span class="hljs-property">$cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;token&#x27;</span>);<br>    <span class="hljs-comment">//add token</span><br>    <span class="hljs-keyword">if</span> (token) config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">&#x27;Bearer &#x27;</span> + token;<br>    <span class="hljs-comment">//其他的请求前业务逻辑 比如：api map</span><br>    <span class="hljs-title function_">resolve</span>(config);<br>  &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure><p>这里涉及到cookies和axios拦截器的使用，内容可以查看相关文章。</p><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://www.cnblogs.com/-wenli/p/14016905.html#/">Flask实现token认证- -零 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flask</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mavon-editor的使用</title>
    <link href="/2022/02/11/mavon-editor%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/02/11/mavon-editor%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="mavon-editor的基本使用">mavon-editor的基本使用</h2><p>mavon-editor是一款基于Vue的Markdown编辑器，可以在前端展示Markdown的编辑界面并完成相关的编辑操作。接下来介绍该组件的基本使用方式，包括组件引入以及组件使用。当然在使用之前，需要进行安装，安装指令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install mavon-editor --save<br></code></pre></td></tr></table></figure><h3 id="组件引入">1. 组件引入</h3><h4 id="在vue-cli工程中引入">1.1 在vue-cli工程中引入</h4><p>在<code>main.js</code>文件中进行全局注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//全局注册</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> mavonEditor <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mavon-editor&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;mavon-editor/dist/css/index.css&#x27;</span><br><br><span class="hljs-comment">//使用组件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(mavonEditor);<br></code></pre></td></tr></table></figure><h4 id="在nuxt-cli工程中引入">1.2 在nuxt-cli工程中引入</h4><p>首先在plugins文件夹中创建js文件<code>vueMarkdown.js</code>，里面填入以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> mavonEditor <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mavon-editor&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;mavon-editor/dist/css/index.css&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(mavonEditor);<br></code></pre></td></tr></table></figure><p>之后在nuxt的配置文件<code>nuxt.config.js</code>中引入插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-string">&#x27;@/plugins/vueMarkdown&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure><h3 id="组件使用">2. 组件使用</h3><p>引入完成之后，就可以以组件的形式使用，使用标签<code>&lt;mavon-editor&gt;&lt;/mavon-editor&gt;</code>即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">mavon-editor</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;md&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入文档内容...&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:boxShadow</span>=<span class="hljs-string">&quot;true&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;z-index:1;border: 1px solid #d9d9d9;min-height:550px&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;content&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:toolbars</span>=<span class="hljs-string">&quot;toolbars&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      @<span class="hljs-attr">save</span>=<span class="hljs-string">&quot;saveMd&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      @<span class="hljs-attr">imgAdd</span>=<span class="hljs-string">&quot;handleImgAdd&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      @<span class="hljs-attr">imgDel</span>=<span class="hljs-string">&quot;handleImgDel&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mavon-editor</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;target&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">toolbars</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">bold</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 粗体</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">italic</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 斜体</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">header</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 标题</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">underline</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 下划线</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">strikethrough</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 中划线</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">mark</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 标记</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">superscript</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 上角标</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">subscript</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 下角标</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">quote</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 引用</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">ol</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 有序列表</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">ul</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 无序列表</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">link</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 链接</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">imagelink</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 图片链接</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">code</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// code</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">table</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 表格</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">fullscreen</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 全屏编辑</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">readmodel</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 沉浸式阅读</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">htmlcode</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 展示html源码</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">help</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 帮助</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">/* 1.3.5 */</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">undo</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 上一步</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">redo</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 下一步</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">trash</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 清空</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">save</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 保存（触发events中的save事件）</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">/* 1.4.2 */</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">navigation</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 导航目录</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">/* 2.1.8 */</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">alignleft</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 左对齐</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">aligncenter</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 居中</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">alignright</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 右对齐</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">/* 2.2.1 */</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">subfield</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 单双栏模式</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">preview</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 预览</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>引入之后，我们就能够在页面中看到如下效果：</p><img src="/2022/02/11/mavon-editor%E7%9A%84%E4%BD%BF%E7%94%A8/mavon-editor%E7%95%8C%E9%9D%A2.png" class="" title="mavon-editor界面"><p>其中，常用参数的含义如下：</p><ul><li>placehodler：文档内容为空的时候在输入框中显示的内容</li><li>boxShadow：是否展示阴影效果</li><li>v-model=“content”：表示文档内容，文档内容与data中的数据content是动态双向绑定的</li><li>toolbars：表示工具栏中需要显示的内容</li></ul><p>经常用到的几个监听的事件：save事件，imgAdd事件和imgDel事件。save事件在点击保存按钮或者按下<code>ctrl+s</code>之后触发，imgAdd事件在点击图片上传之后触发，imgDel事件在点击图片按钮中的删除按钮后触发（手动删除文档内容中的引入图片代码不会触发）</p><blockquote><p>通过引入mavon-editor可以完成前端修改网页内容后动态保存，具体思路如下：</p><p>首先网页的展示设置成动态的，一个网页的内容对应后端的一个md文件。网页展示之前向后端请求内容，后端读取对应的md文件内容，将其转化成html格式的字符串，然后将html字符串和md字符串传送给前端，其中html字符串通过<code>v-html</code>指令绑定，将内容展现出来，md字符串绑定到content中，可以展示在编辑器中。</p><p>在前端修改网页，只需要修改编辑器中的文档内容，通过动态绑定机制可以获取到当前的文档内容。之后监听保存事件，将当前文档内容传送给后端，后端保存到对应路径即可。</p></blockquote><h2 id="图片上传和删除">图片上传和删除</h2><p>图片的上传和删除分别监听imgAdd和imgDel事件。</p><h3 id="图片上传">1. 图片上传</h3><p>默认的图片上传事件会将本地图片放入文档内容中，但是在前后端分离的情况下，图片不会上传到服务器中。</p><p>于是需要监听imgAdd事件，将本地添加的图片上传到后端服务器当中。发起axios请求向后端上传图片，后端将图片保存在指定的目录下，然后返回图片访问的url，然后前端的mavon-editor通过调用img2url来完成代码的替换。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//图片上传功能</span><br>    <span class="hljs-title function_">handleImgAdd</span>(<span class="hljs-params">pos, $file</span>) &#123;<br>      <span class="hljs-comment">//将图片上传到服务器上</span><br>      <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();<br>      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>, $file);<br>      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;path&#x27;</span>, <span class="hljs-string">&#x27;img/&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">target</span>);<br>      <span class="hljs-comment">//向后端传送表单数据，同时指定保存路径(img/xxx)</span><br>      <span class="hljs-comment">//上传的文件名即为文件在本地的名称</span><br>      <span class="hljs-variable language_">this</span>.$axios(&#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>        <span class="hljs-attr">url</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">backend_url</span> + <span class="hljs-string">&#x27;post/addImg&#x27;</span>,<br>        <span class="hljs-attr">data</span>: formData<br>      &#125;)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> img_url = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">backend_url</span> + response.<span class="hljs-property">data</span>.<span class="hljs-property">url</span>;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">md</span>.$img2Url(pos, img_url);<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">$notify</span>.<span class="hljs-title function_">success</span>(&#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;图片上传成功，此后不应手动修改已上传图片的名称&#x27;</span>,<br>            <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>,<br>          &#125;)<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">$notify</span>.<span class="hljs-title function_">error</span>(&#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;图片上传失败&#x27;</span>,<br>            <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>,<br>          &#125;)<br>        &#125;)<br>    &#125;,<br></code></pre></td></tr></table></figure><p>其中上传的链接需要根据实际内容进行修改。</p><blockquote><p>这里有一个问题，就是嵌入在md中的访问图片的方式是通过img标签，src属性来完成的，这种方式没有办法带上header，也就没有办法完成权限的验证。一种解决方法是这里可以让后端将图片保存到静态资源当中，即可以通过url直接访问得到（如flask的static），这样就可以通过img中的src得到图片。</p></blockquote><h3 id="图片删除">2. 图片删除</h3><p>图片删除监听imgDel事件，其中参数pos中可以获得图片的链接，通过<code>pos[0]</code>即可。获取到图片的链接后（具体来说获取到图片的名称即可），就可以向后端发送请求，后端再根据图片的路径进行删除。具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//图片删除功能</span><br>    <span class="hljs-title function_">handleImgDel</span>(<span class="hljs-params">pos</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pos[<span class="hljs-number">0</span>]);<br>      <span class="hljs-comment">//请求后端删除对应的文件</span><br>      <span class="hljs-comment">//通过名称来找到对应的文件，如果名称被修改，会造成无法删除的错误</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$axios</span>.<span class="hljs-title function_">post</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">backend_url</span> + <span class="hljs-string">&#x27;post/deleteImg&#x27;</span>, &#123;<br>        <span class="hljs-attr">img_url</span>: pos[<span class="hljs-number">0</span>]<br>      &#125;)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">$notify</span>.<span class="hljs-title function_">success</span>(&#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;删除成功&#x27;</span>,<br>            <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>,<br>          &#125;)<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">$notify</span>.<span class="hljs-title function_">error</span>(&#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;后台删除失败，请查看是否更改了图片名称&#x27;</span>,<br>            <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>,<br>          &#125;)<br>        &#125;)<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="nuxt与markdown相关的工具插件">Nuxt与Markdown相关的工具插件</h2><p>mavon-editor还具有Markdown回显的功能，这里没有用到所以就没有进行说明。</p><p>在资料收集的过程中，还发现了在nuxt中一些与Markdown相关的插件，这里做一个记录：</p><ul><li>markdownit：<ahref="https://blog.csdn.net/a1368783069/article/details/120089500#/">nuxt.js显示markdown文档_面向未来的历史-CSDN博客</a></li><li><span class="citation"data-cites="nuxt/content">@nuxt/content</span>：<ahref="https://content.nuxtjs.org/">Introduction - Nuxt Content(nuxtjs.org)</a></li></ul><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://blog.csdn.net/qq_44706619/article/details/119573048#/">vue使用mavon-editor保存md到数据库，页面回显，二次编辑__小郑有点困了的博客-CSDN博客</a></li><li><ahref="https://www.cnblogs.com/qdhxhz/p/14865995.html#/">Nuxt引入mavon-editor插件实现markdown功能- 雨点的名字 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/78ea4f94a3d0#/">mavon-editor使用教程 - 简书 (jianshu.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>功能模块</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Nuxt</tag>
      
      <tag>mavon-editor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios实现文件下载</title>
    <link href="/2022/02/11/axios%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    <url>/2022/02/11/axios%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="axios完成文件下载">axios完成文件下载</h2><p>常见的下载方式有两种，第一种是通过直接访问服务器的文件地址进行自动下载；第二种是服务器返回blob文件流，然后前端再对文件流进行处理和下载。（一般小文件适用于第一种下载方案，不占用过多服务器资源，而对于体积庞大的文件，常常使用文件流的方式进行传输）</p><p>下面是通过axios完成文件下载的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-title function_">fileDownload</span>(<span class="hljs-params">path, name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始下载&quot;</span> + path);<br>    axios.<span class="hljs-title function_">get</span>(path, &#123;<br>        <span class="hljs-attr">responseType</span>: <span class="hljs-string">&quot;arraybuffer&quot;</span><br>    &#125;)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([response.<span class="hljs-property">data</span>]);<br>        <span class="hljs-keyword">const</span> blobUrl = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);<br>        <span class="hljs-keyword">const</span> tmpLink = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        tmpLink.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>;<br>        tmpLink.<span class="hljs-property">href</span> = blobUrl;<br>        tmpLink.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;download&#x27;</span>, name);<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(tmpLink);<br>        tmpLink.<span class="hljs-title function_">click</span>();<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(tmpLink);<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(blobUrl);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这种方式实现的下载功能有一个缺点，就是用户无法感知下载的进度，只有在下载成功之后才会显示成功，而不会显示下载的过程。这点对于用户体验是很不友好的，于是考虑增加文件下载进度显示功能。</p><h2 id="实现文件下载进度显示功能">实现文件下载进度显示功能</h2><p>具体实现过程如下，以下过程实现是在Nuxt工程中，其他工程可以进行参考。</p><p>首先创建<code>store/download.js</code>文件，通过Vuex模块来保存有关下载的全局变量，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">state</span> = (<span class="hljs-params"></span>) =&gt; (&#123;<br>  <span class="hljs-attr">progressList</span>: [],<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>,<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mutations = &#123;<br>  <span class="hljs-comment">// 新增下载进度对象</span><br>  <span class="hljs-title function_">setProgress</span>(<span class="hljs-params">state, progressObj</span>) &#123;<br>    <span class="hljs-comment">// 如果进度列表存在</span><br>    <span class="hljs-keyword">if</span> (state.<span class="hljs-property">progressList</span>.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">if</span> (state.<span class="hljs-property">progressList</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">path</span> === progressObj.<span class="hljs-property">path</span>)) &#123;<br>        <span class="hljs-comment">// 改变当前进度对象的progress</span><br>        state.<span class="hljs-property">progressList</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">path</span> === progressObj.<span class="hljs-property">path</span>).<span class="hljs-property">progress</span> = progressObj.<span class="hljs-property">progress</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 当前进度列表为空，没有下载任务，直接将该进度对象添加到进度数组内</span><br>      state.<span class="hljs-property">progressList</span>.<span class="hljs-title function_">push</span>(progressObj);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 删除下载进度对象</span><br>  <span class="hljs-title function_">delProgress</span>(<span class="hljs-params">state, props</span>) &#123;<br>    <span class="hljs-comment">// 删除进度列表中的进度对象</span><br>    state.<span class="hljs-property">progressList</span>.<span class="hljs-title function_">splice</span>(state.<span class="hljs-property">progressList</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">path</span> === props), <span class="hljs-number">1</span>)<br>  &#125;,<br>  <span class="hljs-comment">//生成器</span><br>  <span class="hljs-title function_">idGenerator</span>(<span class="hljs-params">state</span>) &#123;<br>    state.<span class="hljs-property">id</span>++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中progressList中存放当前正在下载的进度对象，通过id进行表示。id为一个全局的变量，通过生成器方法保证递增不重复。在每次使用id之前，都需要调用一次idGenerator方法（这点应该有更好的解决方案，目的就是为了保证每个进度对象对应的id是不重复的）。同时方法中提供新增和删除进度对象的方法。</p><p>之后，创建全局组件，用于展示进度。创建<code>components/DownloadNotice.vue</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br><br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;mapState&#125; from &#x27;vuex&#x27;<br><br>export default &#123;<br>  // 用于提示下载进度<br>  name: &#x27;DownloadNotice&#x27;,<br>  computed: &#123;<br>    ...mapState(&#x27;download&#x27;, [&#x27;progressList&#x27;]) // 转化成计算属性<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      notify: &#123;&#125; // 用来维护下载文件进度弹框对象<br>    &#125;<br>  &#125;,<br>  watch: &#123; // 监听进度列表的变化<br>    progressList: &#123;<br>      handler(n) &#123;<br>        let data = JSON.parse(JSON.stringify(n));<br>        data.forEach(item =&gt; &#123;<br>          const domList = [...document.getElementsByClassName(item.path)];<br>          // 如果页面已经有该进度对象的弹框，则更新它的进度progress<br>          // 这里className和path的类型不同但是值相同，如果使用===会出现多个消息框<br>          if (domList.find(i =&gt; i.className == item.path)) &#123;<br>            domList.find(i =&gt; i.className == item.path).innerHTML = item.progress + &#x27;%&#x27;;<br>          &#125; else &#123;<br>            // 此处容错处理，如果后端传输文件流报错，删除当前进度对象<br>            if (item.progress == null) &#123;<br>              this.$store.commit(&#x27;download/delProgress&#x27;, item.path);<br>              return;<br>            &#125;// 如果页面中没有该进度对象所对应的弹框，页面新建弹框，并在notify中加入该弹框对象，属性名为该进度对象的path(上文可知path是唯一的)，属性值为$notify(element ui中的通知组件)弹框对象<br>            this.notify[item.path] = this.$notify.success(&#123;<br>              title: &#x27;&#x27;,<br>              dangerouslyUseHTMLString: true,<br>              message: `&lt;p style=&quot;width: 100px;&quot;&gt;正在下载&lt;span class=&quot;$&#123;item.path&#125;&quot; style=&quot;float: right&quot;&gt;$&#123;item.progress&#125;%&lt;/span&gt;&lt;/p&gt;`, // 显示下载百分比，类名为进度对象的path(便于后面更新进度百分比)<br>              showClose: false,<br>              duration: 0<br>            &#125;);<br>          &#125;<br>          //console.log(item.progress + &#x27;%&#x27;, &#x27;--------------------------&gt;&#x27;);<br><br>          if (item.progress === 100) &#123; // 如果下载进度到了100%，关闭该弹框，并删除notify中维护的弹框对象<br>            //异步函数，等待1s之后将其close<br>            setTimeout(() =&gt; &#123;<br>              this.notify[item.path].close()<br>            &#125;, 1000);<br><br>            // delete this.notify[item.path] 上面的close()事件是异步的，这里直接删除会报错，利用setTimeout，将该操作加入异步队列<br>            setTimeout(() =&gt; &#123;<br>              delete this.notify[item.path]<br>            &#125;, 1000)<br><br>            // 删除caseInformation中state的progressList中的进度对象<br>            this.$store.commit(&#x27;download/delProgress&#x27;, item.path)<br>          &#125;<br>        &#125;)<br>      &#125;,<br>      deep: true<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>组件中会监听全局的进度对象的变化，然后做出相应的显示变化。</p><p>之后在下载相关的方法中进行相应的修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fileDownload</span>(<span class="hljs-params">name, com_name</span>) &#123;<br>  <span class="hljs-keyword">let</span> downProgress = &#123;&#125;;<br>  <span class="hljs-keyword">let</span> that = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">//调用Vuex中的模拟生成器获取id</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;download/idGenerator&#x27;</span>);<br>  <span class="hljs-keyword">let</span> id = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">download</span>.<span class="hljs-property">id</span>;<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始下载&quot;</span> + name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$axios</span>.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">backend_url</span> + <span class="hljs-string">&#x27;data/download/&#x27;</span> + com_name + name, &#123;<br>    <span class="hljs-attr">responseType</span>: <span class="hljs-string">&quot;arraybuffer&quot;</span>,<br>    <span class="hljs-title function_">onDownloadProgress</span>(<span class="hljs-params">progress</span>) &#123;<br>      <span class="hljs-comment">// progress对象中的loaded表示已经下载的数量，total表示总数量，这里计算出百分比</span><br>      downProgress = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">100</span> * progress.<span class="hljs-property">loaded</span> / progress.<span class="hljs-property">total</span>);<br>      <span class="hljs-comment">// 将此次下载的文件名和下载进度组成对象再用vuex状态管理</span><br>      that.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;download/setProgress&#x27;</span>, &#123;<span class="hljs-attr">path</span>: id, <span class="hljs-string">&#x27;progress&#x27;</span>: downProgress&#125;);<br>    &#125;<br>  &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([response.<span class="hljs-property">data</span>]);<br>      <span class="hljs-keyword">const</span> blobUrl = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);<br>      <span class="hljs-keyword">const</span> tmpLink = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>      tmpLink.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>;<br>      tmpLink.<span class="hljs-property">href</span> = blobUrl;<br>      tmpLink.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;download&#x27;</span>, name);<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(tmpLink);<br>      tmpLink.<span class="hljs-title function_">click</span>();<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(tmpLink);<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(blobUrl);<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>      that.<span class="hljs-property">$notify</span>.<span class="hljs-title function_">error</span>(&#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;下载失败&#x27;</span>,<br>        <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>,<br>      &#125;)<br>    &#125;)<br>&#125;,<br></code></pre></td></tr></table></figure><p>同时需要在页面中用mixins混入downloadNotice组件（与上面的下载方法在同一个.vue文件当中）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">DownloadNotice</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./DownloadNotice&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">mixins</span>: [<span class="hljs-title class_">DownloadNotice</span>],<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在页面中触发下载操作的时候，就能够出现相应的下载进度提示效果。</p><h2 id="参考文章">参考文章</h2><ol type="1"><li><ahref="https://blog.csdn.net/w1099690237/article/details/120418909#/">vue项目实现文件下载进度条_coder__wang的博客-CSDN博客_vue文件下载进度条</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>功能模块</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>axios</tag>
      
      <tag>Nuxt</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
