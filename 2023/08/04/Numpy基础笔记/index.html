

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/myfavicon.png">
  <link rel="icon" href="/img/myfavicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="EverNorif">
  <meta name="keywords" content="">
  
    <meta name="description" content="Numpy是Python中科学计算的基础，它提供了一个极为强大的类，n维数组。本篇主要是Numpy的基础学习笔记，主要包括Numpy的核心概念和基础操作。在核心概念方面，介绍了shape、axis、vectorization、broadcasting等；在基础操作方面，介绍了数组的创建、计算、索引、变换等操作。">
<meta property="og:type" content="article">
<meta property="og:title" content="Numpy基础笔记">
<meta property="og:url" content="https://evernorif.github.io/2023/08/04/Numpy%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="EverNorif">
<meta property="og:description" content="Numpy是Python中科学计算的基础，它提供了一个极为强大的类，n维数组。本篇主要是Numpy的基础学习笔记，主要包括Numpy的核心概念和基础操作。在核心概念方面，介绍了shape、axis、vectorization、broadcasting等；在基础操作方面，介绍了数组的创建、计算、索引、变换等操作。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-04T14:40:32.000Z">
<meta property="article:modified_time" content="2023-08-04T14:55:09.230Z">
<meta property="article:author" content="EverNorif">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Numpy">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Numpy基础笔记 - EverNorif</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"evernorif.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/bilibiliTV.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"gtag":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>EverNorif</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tools/" target="_self">
                <i class="iconfont icon-briefcase"></i>
                <span>工具</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-bilibili"></i>
                <span>番剧</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/bangumis/" target="_self">
                    <i class="iconfont icon-bilibili-fill"></i>
                    <span>追番</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/cinemas/" target="_self">
                    <i class="iconfont icon-youtube-fill"></i>
                    <span>追剧</span>
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Numpy基础笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-04 22:40" pubdate>
          2023年8月4日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          42 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Numpy基础笔记</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    <!-- compatible with older versions-->
                    本文最后更新于：2023-08-04T22:55:09+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="简介">简介</h1>
<p><a
target="_blank" rel="noopener" href="https://numpy.org/doc/stable/index.html">Numpy</a>是一个功能强大的Python第三方pacakge，它为我们提供了一个非常强大的数据结构，n维数组，即<code>numpy.ndarray</code>。它是几乎所有Python数据科学工具包的基础。</p>
<p>Numpy底层使用C语言编写，因此相比与原生Python，它具有非常快的速度。同时，Numpy使用向量化Vectorization技术来减少代码中显式出现循环的次数，使得代码具有更好的可读性，更适合用于描述复杂的数学方程。可以说，Numpy就是Python
Data science中多维数组的事实标准。</p>
<p>numpy的安装非常简单，直接使用pip或者conda进行即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install numpy<br>conda install numpy<br></code></pre></td></tr></table></figure>
<p>在代码中进行引入的时候，通常会将numpy引入为<code>np</code>，后续我们也都遵循这个约定。同时后面在进行描述的时候，可能会涉及到数组、矩阵等表述，在大多数语境下，这两者指的是同一个东西，都是<code>ndarray</code>对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果只是为了学习相关编程语言，那么可以使用一个在线Code网站<a
target="_blank" rel="noopener" href="https://replit.com/">replit</a>，它允许我们直接通过浏览器来实时运行代码。</p>
</blockquote>
<h1 id="核心概念">核心概念</h1>
<p>n维数组<code>np.ndarray</code>是Numpy中的核心和基础，学习Numpy最重要的就是学习这个类以及相关方法的使用。不过在此之前，有必要先了解Numpy中的几个核心概念，包括shape、axis、vectorization和broadcasting，理解这些概念有利于更好地把握numpy的运行机制。</p>
<h2 id="shape">Shape</h2>
<p>对于n维数组来说，它的形状shape是非常重要的一个属性，我们可以通过<code>.shape</code>来查看数组的形状，也可以使用<code>.reshape()</code>方法来改变数组的形状。在使用ndarray的过程中，shape是一个非常基本的，也是我们应该非常关注的一个属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">table = np.arange(<span class="hljs-number">24</span>).reshape((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-comment"># table.shape</span><br>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment"># table输出如下:</span><br>array([[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],<br>        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],<br>        [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]],<br><br>       [[<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],<br>        [<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],<br>        [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>]]])<br></code></pre></td></tr></table></figure>
<p>对于二维数组来说，shape可以告诉我们这个数组有几行几列，但是对于更高维度的情况，就比较难直观地理解shape的含义。我们可以从数组嵌套的角度来理解shape，计算shape的过程就是一个逐层去除嵌套的过程。例如上面的table是一个三维的数组，它的shape为<code>(2, 3, 4)</code>。结合它的输出，第一个2表示去掉第一层<code>[]</code>，我们可以得到两个元素；第二个3表示对于上面的每个元素，再次解除嵌套去掉<code>[]</code>，可以得到三个元素；以此类推。</p>
<p>而<code>reshape</code>方法则是上面这个过程的逆过程。对于一个需要进行reshape的矩阵，我们首先可以将其进行flatten，即拍平成一个一维矩阵，之后按照shape进行逐层的分配，最终得到期望的形状。</p>
<h2 id="axis">Axis</h2>
<p>与shape紧密相关的概念是axis轴，或者可以理解为维度。对于一个矩阵来说，我们希望知道它的shape，同时也希望了解哪些数据位于哪些轴上。在numpy的数组中，轴从0开始进行索引，依次递增。从最外层<code>[]</code>开始是axis=0轴，逐步进入内部轴的索引也依次增加。例如对于二维数组来说，垂直轴为0轴，水平轴为1轴。</p>
<p>axis与shape也有对应关系。如果一个数组维度为<code>n</code>，那么它的axis最高就是<code>n-1</code>，同时它的shape也就是一个含有<code>n</code>个数字的tuple。实际上我们可以将shape理解为在描述每个axis上具有多少个元素。例如上面例子中的三维数组table，shape为<code>(2, 3, 4)</code>，则代表在axis=0上有2个元素，在axis=1上有3个元素，在axis=2上有4个元素。这里的元素指的不是最小单位数字，而是可能由多个数字构成的，具有类似结构的组合。</p>
<p>在Numpy中，有许多方法会根据是否指定axis来改变对应的行为。以<code>.max()</code>方法为例，有如下测试结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">table = np.arange(<span class="hljs-number">24</span>).reshape((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-comment"># shape: (2, 3, 4)</span><br><span class="hljs-comment"># axis:  (0, 1, 2)</span><br><span class="hljs-comment"># table output: </span><br>array([[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],<br>        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],<br>        [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]],<br><br>       [[<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],<br>        [<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],<br>        [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>]]])<br><br><span class="hljs-comment"># table.max() </span><br><span class="hljs-number">23</span><br><br><span class="hljs-comment"># table.max(axis=0)</span><br><span class="hljs-comment"># shape: (3, 4)</span><br>array([[<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],<br>       [<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],<br>       [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>]])<br><br><span class="hljs-comment"># table.max(axis=1)</span><br><span class="hljs-comment"># shape: (2, 4)</span><br>array([[ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],<br>       [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>]])<br><br><span class="hljs-comment"># table.max(axis=2)</span><br><span class="hljs-comment"># shape: (2, 3)</span><br>array([[ <span class="hljs-number">3</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>],<br>       [<span class="hljs-number">15</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>]])<br></code></pre></td></tr></table></figure>
<p>可以看到，如果没有指定axis，那么numpy默认将所有的最小单元纳入考虑，相当于将整个数组拍平之后进行函数计算。而如果指定了axis，那么在计算过程中会沿着对应轴走，每次传入在该轴对应维度下的一个元素。<strong>对于聚合函数来说，沿着哪个轴走，最终得到的array
shape就会消除掉哪一个维度</strong>（轴对应的维度），这点也可以在最终结果的shape中发现。此时可以将单个数字看作特殊的零维矩阵。</p>
<p>事实上，Numpy
的许多函数都是这样运行的：如果没有指定轴，那么它们会对整个数据集执行操作。否则，它们以轴方式执行操作。</p>
<h2 id="vectorization">Vectorization</h2>
<p>Vectorization，又称矢量化，它指的是<strong>对数组中的每个元素以相同的方式执行相同的操作</strong>。该操作与for循环执行得到的结果相同，但是在代码中不需要出现for关键字，以此提高可读性。矢量化计算是Numpy能够做到干净，可读性的关键。虽然向量化并不会提高甚至有可能降低执行性能，但是相比于它带来的巨大可读性，这些性能损耗是可以接受的。</p>
<p>Numpy自身提供的方法大都能够进行矢量化，但是有些时候我们会使用到其他Package的方法，如果也想矢量化，那么需要使用
<a
target="_blank" rel="noopener" href="https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html">np.vectorize()</a>
方法来获得该方法的矢量化版本。例如我们需要使用阶乘函数，即<code>math.factorial</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> factorial<br><br>a = np.arange(<span class="hljs-number">10</span>).reshape((<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>))<br>factorial(a)<br></code></pre></td></tr></table></figure>
<p>直接使用会报错：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">TypeError: only <span class="hljs-built_in">integer</span> scalar arrays can be converted to a scalar index<br></code></pre></td></tr></table></figure>
<p>此时需要先创建阶乘函数的向量化版本，之后才能正常使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> factorial<br><br>factorial_vectorization = np.vectorize(factorial)<br>a = np.arange(<span class="hljs-number">10</span>).reshape((<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>))<br>factorial_vectorization(a)<br></code></pre></td></tr></table></figure>
<h2 id="broadcasting">Broadcasting</h2>
<p>Broadcasting，也称为广播，它是扩展两个不同形状的数组并弄清楚如何在它们之间执行矢量化计算的过程。</p>
<p>通常两个数组之间能够进行计算，是因为它们的维度能够相互匹配。例如对于数组加法，如果要进行数组之间的加法，这两个数组必须具有相同的shape。但是在numpy中，有时候两个数组的shape并不相同，但是它们仍然能够完成计算，这就是Broadcasting在发挥作用。</p>
<p>Broadcasting有一个核心规则：<strong>如果数组的维度匹配或者其中一个数组的大小为
1，则数组可以相互广播</strong>。如果数组沿轴的大小匹配，则将逐个元素对元素进行操作，类似于内置
Python 函数 zip() 的工作方式。如果其中一个数组在轴上的大小为
1，则该值将沿该轴进行广播，即重复多次，以匹配另一个数组中沿该轴的元素数量。</p>
<p>以下面的例子来进行说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">3</span>).reshape((<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))<br><span class="hljs-comment"># a output:</span><br>array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]])<br><br>b = np.arange(<span class="hljs-number">3</span>).reshape((<span class="hljs-number">3</span>,<span class="hljs-number">1</span>))<br><span class="hljs-comment"># b output:</span><br>array([[<span class="hljs-number">0</span>],<br>       [<span class="hljs-number">1</span>],<br>       [<span class="hljs-number">2</span>]])<br><br>c = a + b<br><span class="hljs-comment"># c.shape: (3, 3)</span><br><span class="hljs-comment"># c = a+b: output</span><br>array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>       [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>       [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])<br><span class="hljs-comment"># progress:</span><br><span class="hljs-comment"># broadcasting of a</span><br>[<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>]<br><br><span class="hljs-comment"># broadcasting of b</span><br>[<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<br>]<br></code></pre></td></tr></table></figure>
<p>在上面的例子中，数组a的shape为<code>(1, 3)</code>，数组b的shape为<code>(3, 1)</code>，这两个数组进行加法运算，需要维度的匹配。经过观察可以发现，a和b可以进行广播，并且最终匹配的shape是<code>(3, 3)</code>。而广播实际上就是一个沿着某一个轴重复的过程。例如这里的数组a需要广播到<code>(3, 3)</code>，因此它需要沿着axis=0轴进行元素重复；数组b需要广播到<code>(3, 3)</code>，它需要沿着axis=1轴进行元素重复。两个数组都广播到相同shape之后，就可以按照位置对应进行加法计算了。</p>
<p>不过需要注意只有在某个轴上大小为1时才能进行Broadcasting，否则会报错：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ValueError: operands could not be broadcast together with shapes ...<br></code></pre></td></tr></table></figure>
<h1 id="基础操作">基础操作</h1>
<h2 id="ndarray创建">ndarray创建</h2>
<h3 id="np.array">np.array</h3>
<p>在之前的操作中我们使用<code>np.arange</code>来创建过数组，得到的是一个从0到指定值的递增序列。同样我们可以通过<code>np.array()</code>来从python序列类型中创建ndarray，注意其中提供的list嵌套形状就是最终矩阵的shape，而元素类型会由numpy自动推断，当然也可以通过<code>dtype</code>属性进行手动指定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<br>    [<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>],<br>    [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>])<br><br>a.ndim  <span class="hljs-comment"># 2</span><br><br>a.shape  <span class="hljs-comment"># (2, 4)</span><br><br>a.size  <span class="hljs-comment"># 8</span><br><br>a.dtype  <span class="hljs-comment"># dtype(&#x27;int64&#x27;)</span><br><br>a.dtype.name  <span class="hljs-comment"># &#x27;int64&#x27;</span><br></code></pre></td></tr></table></figure>
<p>ndarray的常用属性如下：</p>
<ul>
<li><code>ndim</code>：数组的维度，也是shape
tuple的元素个数，也是轴的个数</li>
<li><code>shape</code>：数组的形状</li>
<li><code>size</code>：数组所有元素的个数，是shape
tuple中所有值的乘积</li>
<li><code>dtype</code>：数组中元素的类型</li>
</ul>
<p>在ndarray中，所有的元素都需要具有相同的类型，常用的类型有下面这些，完成的支持类型列表可以参考<a
target="_blank" rel="noopener" href="https://numpy.org/devdocs/user/basics.types.html">Data Types|Numpy
Documentation</a>。</p>
<table>
<thead>
<tr class="header">
<th>C type</th>
<th>numpy type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bool</td>
<td>np.bool_</td>
</tr>
<tr class="even">
<td>int</td>
<td>np.intc</td>
</tr>
<tr class="odd">
<td>long</td>
<td>np.int_</td>
</tr>
<tr class="even">
<td>float</td>
<td>np.single</td>
</tr>
<tr class="odd">
<td>double</td>
<td>np.double</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在Numpy中使用字符串多少有点奇怪，但是Numpy确实也能够支持。不过因为这种用法确实非常少见，这里不进行更加细致的描述</p>
</blockquote>
<h3 id="other-method">other method</h3>
<p>下面列出了一些其他常用的特殊数组创建方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># zeros: 全零矩阵</span><br>np.zeros((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>))<br>array([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],<br>       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])<br><br><span class="hljs-comment"># ones: 全一矩阵</span><br>np.ones((<span class="hljs-number">3</span>, <span class="hljs-number">2</span>))<br>array([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>       [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>       [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])<br><span class="hljs-comment"># arange: 通过range构造序列再生成矩阵</span><br><span class="hljs-comment"># 生成的矩阵都是1维的，可以通过reshape进行变换</span><br>np.arange(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment"># reshape最后一个值为-1表示自动计算</span><br>np.arange(<span class="hljs-number">10</span>).reshape((<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># empyt: 随机矩阵</span><br>np.empty((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><br><span class="hljs-comment"># linspace: 在范围内均匀生成指定元素个数</span><br><span class="hljs-comment"># 解决在arrage中无法通过step精确控制矩阵元素个数的问题</span><br>np.linspace(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">7</span>)<br><br><span class="hljs-comment"># random: 返回[0, 1)之间的随机值</span><br><span class="hljs-comment"># 生成一维矩阵</span><br>np.random.random(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># randn: 按照标准正态分布随机</span><br><span class="hljs-comment"># 生成一维矩阵</span><br>np.random.randn(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>
<h2 id="数学计算">数学计算</h2>
<p>由于Numpy支持向量化，因此利用Numpy来进行数学计算变得非常直观：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>])<br>b = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># 以下方法均返回一个新的对象，而非在原对象上修改</span><br><br><span class="hljs-comment"># 矩阵加法</span><br>a + b<br><span class="hljs-comment"># 矩阵减法</span><br>a - b<br><span class="hljs-comment"># 矩阵点乘（对应位置相乘）</span><br>a * b<br><span class="hljs-comment"># 矩阵乘法: @ 或者.dot()</span><br>a.reshape((<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)) @ b.reshape((<span class="hljs-number">1</span>, <span class="hljs-number">4</span>))<br>a.reshape((<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)).dot(b.reshape((<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)))<br><span class="hljs-comment"># 逐元素操作</span><br>a ** <span class="hljs-number">2</span><br><span class="hljs-comment"># 矩阵转置: 转置后的矩阵shape是原来的逆序</span><br>a.T<br>a.transpose()<br></code></pre></td></tr></table></figure>
<p>Numpy中还提供了许多通用的方法，这些方法同样支持向量化，允许直接接受一个ndarray作为输入，然后对其中的元素依次进行对应操作。更多方法可以参考官方文档<a
target="_blank" rel="noopener" href="https://numpy.org/doc/stable/user/quickstart.html#functions-and-methods-overview">Functions
and Methods Overview|Numpy Documentation</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>])<br><br>np.exp(a)  <span class="hljs-comment"># e的乘方</span><br>np.sqrt(a)  <span class="hljs-comment"># 开根号</span><br>np.ceil(a)  <span class="hljs-comment"># 向上取整</span><br>np.floor(a)  <span class="hljs-comment"># 向下取整</span><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure>
<p>Numpy中还有许多聚合函数，例如<code>.sum()</code>,
<code>.max()</code>, <code>.mean()</code>和
<code>.std()</code>等等，这些聚合函数基本都有两种运行模式，在不指定axis的情况下考虑整个矩阵，在指定axis的情况下沿着对应axis进行聚合计算。</p>
<h2 id="index与mark">Index与Mark</h2>
<h3 id="基础索引">基础索引</h3>
<p>在ndarray中进行取值，方法与python原生的list类似，利用<code>[]</code>完成，并且支持通过单个索引位置或者切片进行取值。不过ndarray更加灵活，它在任意一个维度上都支持索引或者切片操作。并且利用索引进行取值之后，我们也可以通过直接赋值来修改矩阵中对应的value。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">120</span>).reshape((<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>))<br>a[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>a[:,<span class="hljs-number">3</span>, <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<p>在Numpy中还提供了<code>...</code>表达式，它可以用来简化连续的多个<code>:</code>，例如有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># assume x has 5 axes</span><br><br>x[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ...] <span class="hljs-keyword">is</span> equivalent to x[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, :, :, :]<br><br>x[..., <span class="hljs-number">3</span>] <span class="hljs-keyword">is</span> equivalent to x[:, :, :, :, <span class="hljs-number">3</span>] <br><br>x[<span class="hljs-number">4</span>, ..., <span class="hljs-number">5</span>, :] <span class="hljs-keyword">is</span> equivalent to x[<span class="hljs-number">4</span>, :, :, <span class="hljs-number">5</span>, :]<br></code></pre></td></tr></table></figure>
<p>Numpy中提供一个<code>np.nonzero()</code>方法来查找数组中不为零的元素的下标，利用这个方法可以进行快速的过滤和查找。对于一个n维的数组，该方法会返回n个一维数组。这些一维数组具有相同的长度，利用类似zip的方法可以获取到每个不为零元素的下标。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>).reshape((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>np.nonzero(a)<br><br><span class="hljs-comment"># np.nonzero(a) output:</span><br>(array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]), array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]), array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]))<br></code></pre></td></tr></table></figure>
<h3 id="mark矩阵">Mark矩阵</h3>
<p>此外，ndarray还允许我们通过<strong>Mark矩阵</strong>来进行取值。Mark矩阵是一个和原矩阵具有相同shape的矩阵，元素类型为布尔类型。利用Mark矩阵取值的过程就是判断Mark矩阵对应位置上是否为True，为True就加入最终的结果。利用Mark矩阵进行取值，最终得到的结果是一个一维矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可以通过条件表达式来得到一个由布尔值构成的矩阵</span><br>a = np.arange(<span class="hljs-number">20</span>).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">5</span>))<br><br>mark = a % <span class="hljs-number">3</span> == <span class="hljs-number">0</span><br><span class="hljs-comment"># mark output:</span><br>array([[ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>],<br>       [<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>],<br>       [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>],<br>       [ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>]])<br><br>a[mark]<br><span class="hljs-comment"># a[mark] output:</span><br>array([ <span class="hljs-number">0</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>])<br></code></pre></td></tr></table></figure>
<p>我们可以通过条件表达式来得到一个由布尔值构成的矩阵，多个条件可以使用<code>&amp;</code>和<code>|</code>来进行多条件连接，注意不能使用<code>and</code>和<code>or</code>，原因是这些内置的操作符没有实现向量化。</p>
<h3 id="index矩阵">Index矩阵</h3>
<p>更进一步，Numpy允许使用<strong>index矩阵</strong>来进行索引，区别于Mark矩阵中的值都是布尔值，这个index矩阵由下标索引组成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>)**<span class="hljs-number">2</span><br><br>index = np.array([<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>],<br>    [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>],<br>])<br><br><span class="hljs-comment"># index矩阵</span><br>a[index]<br>array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">9</span>],<br>       [ <span class="hljs-number">4</span>, <span class="hljs-number">16</span>]])<br></code></pre></td></tr></table></figure>
<p>index矩阵完成的操作非常容易理解，实际上就是讲index中各个位置上的元素替换为被查询矩阵对应下标的元素，被查询的维度是矩阵的第一维度。以上面的举例来看，<code>a[index]</code>的计算实际上就是下面的过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># index</span><br>array([[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>],<br>       [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>]])<br><span class="hljs-comment"># a[index]</span><br>array([[a[<span class="hljs-number">1</span>], a[<span class="hljs-number">3</span>]],<br>       [a[<span class="hljs-number">2</span>], a[<span class="hljs-number">4</span>]]])<br><span class="hljs-comment"># 即为</span><br>array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">9</span>],<br>       [ <span class="hljs-number">4</span>, <span class="hljs-number">16</span>]])<br></code></pre></td></tr></table></figure>
<p>我们还可以在矩阵的不同维度上使用index矩阵，不过要求多个index矩阵之间的shape相同。在不同维度上应用index矩阵与上面的单个index矩阵具有相同的原理，不同维度上index矩阵的值结合起来就是最终定位对应元素的依据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment"># a output</span><br>array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],<br>       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],<br>       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])<br><br><span class="hljs-comment"># two index matrix</span><br>i = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],  <span class="hljs-comment"># indices for the first dim of `a`</span><br>              [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]])<br>j = np.array([[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>],  <span class="hljs-comment"># indices for the second dim</span><br>              [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])<br><br><span class="hljs-comment"># a[i, j]</span><br><span class="hljs-comment"># array([[a[0, 2], a[1, 1]],</span><br><span class="hljs-comment">#        [a[1, 3], a[2, 3]]])</span><br>a[i, j]<br>array([[ <span class="hljs-number">2</span>,  <span class="hljs-number">5</span>],<br>       [ <span class="hljs-number">7</span>, <span class="hljs-number">11</span>]])<br><br><span class="hljs-comment"># a[i, 2] support vectorization</span><br><span class="hljs-comment"># array([[a[0, 2], a[1, 2]],</span><br><span class="hljs-comment">#        [a[1, 2], a[2, 2]]])</span><br>a[i, <span class="hljs-number">2</span>]<br>array([[ <span class="hljs-number">2</span>,  <span class="hljs-number">6</span>],<br>       [ <span class="hljs-number">6</span>, <span class="hljs-number">10</span>]])<br><br><span class="hljs-comment"># a[:, j] support silce</span><br>a[:, j]<br>array([[[ <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>], [ <span class="hljs-number">3</span>,  <span class="hljs-number">3</span>]],<br><br>       [[ <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>],<br>        [ <span class="hljs-number">7</span>,  <span class="hljs-number">7</span>]],<br><br>       [[<span class="hljs-number">10</span>,  <span class="hljs-number">9</span>],<br>        [<span class="hljs-number">11</span>, <span class="hljs-number">11</span>]]])<br></code></pre></td></tr></table></figure>
<h2 id="shape变换">Shape变换</h2>
<h3 id="reshape">reshape</h3>
<p>我们可以利用Numpy中提供的方法来操作单个矩阵的shape。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">60</span>).reshape((<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># 矩阵展平，返回一维矩阵</span><br>a.flatten()  <span class="hljs-comment"># 返回一个新矩阵</span><br>a.ravel()  <span class="hljs-comment"># 返回原矩阵的一个视图view</span><br><br><span class="hljs-comment"># 修改矩阵的shape</span><br>a.reshape((<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))  <span class="hljs-comment"># 返回新矩阵</span><br>a.resize((<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))  <span class="hljs-comment"># 直接修改原矩阵</span><br></code></pre></td></tr></table></figure>
<h3 id="新增维度">新增维度</h3>
<p>有时候我们可能需要为矩阵新增一个维度，表现在shape上就是在某个轴上多出一个1，此时我们可以使用numpy中提供的关键字<code>np.newaxis</code>。实际上这个关键字就是None的别名，不过具有更好的可读性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>)<br>a[np.newaxis, :].shape  <span class="hljs-comment"># (1, 6)</span><br><br>np.newaxis <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure>
<p>或者可以使用numpy提供的<code>expand_dims</code>方法，通过axis指定需要在哪个轴上新增维度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>)  <span class="hljs-comment"># a shape: (6,)</span><br><br>b = np.expand_dims(a, axis=<span class="hljs-number">0</span>)<br>b.shape  <span class="hljs-comment"># (1, 6)</span><br></code></pre></td></tr></table></figure>
<h3 id="矩阵堆叠">矩阵堆叠</h3>
<p>numpy中还提供多个矩阵拼接的方法，或者称为矩阵堆叠。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>    [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>])<br>b = np.array([<br>    [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>    [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br>])<br><br><span class="hljs-comment"># vstack</span><br>np.vstack((a, b))<br>array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>],<br>       [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>       [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])<br><br><span class="hljs-comment"># hstack</span><br>np.hstack((a, b))<br>array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])<br></code></pre></td></tr></table></figure>
<p>对于二维矩阵来说，<code>vstack</code>表示垂直(vertical)堆叠；<code>hstack</code>表示水平(horizontal)堆叠。对于维度更高的矩阵来说，<code>vstack</code>表示沿axis=0堆叠；<code>hstack</code>表示沿axis=1堆叠。<strong>沿着哪个轴进行堆叠，对应维度的shape会增加</strong>，其他维度的shape不发生改变。因此在堆叠的时候，其他维度的shape需要相同才能够堆叠。</p>
<p>除了<code>vstack</code>和<code>hstack</code>之外，numpy中还有一个更加灵活的方法<code>concatenate</code>，它允许接受axis参数指定沿着哪个轴进行堆叠。如果提供axis为None，则直接拍平再进行操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">np.concatenate((a, b), axis=<span class="hljs-number">0</span>)<br>np.concatenate((a, b), axis=<span class="hljs-number">1</span>)<br>np.concatenate((a, b), axis=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure>
<h3 id="矩阵分割">矩阵分割</h3>
<p>除了矩阵堆叠，还可以进行矩阵分割split，有类似的方法<code>hsplit</code>、<code>vsplit</code>和<code>array_split</code>。<code>hsplit</code>表示水平切割，或者说沿axis=1切割；<code>vsplit</code>表示垂直切割，或者说沿axis=0切割；<code>array_split</code>允许接受axis参数，指定沿着哪个轴进行切割；如果提供axis为Node，则直接拍平再进行操作。以上方法都接收一个目标切割数<code>indices_or_sections</code>，注意该目标数需要与对应的维度shape具有整除关系，这样才能正常切割。不过<code>array_split</code>并不受这个限制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># hsplit</span><br>np.hsplit(a, <span class="hljs-number">5</span>)<br>[array([[ <span class="hljs-number">0</span>],<br>        [ <span class="hljs-number">5</span>],<br>        [<span class="hljs-number">10</span>]]),<br> array([[ <span class="hljs-number">1</span>],<br>        [ <span class="hljs-number">6</span>],<br>        [<span class="hljs-number">11</span>]]),<br> array([[ <span class="hljs-number">2</span>],<br>        [ <span class="hljs-number">7</span>],<br>        [<span class="hljs-number">12</span>]]),<br> array([[ <span class="hljs-number">3</span>],<br>        [ <span class="hljs-number">8</span>],<br>        [<span class="hljs-number">13</span>]]),<br> array([[ <span class="hljs-number">4</span>],<br>        [ <span class="hljs-number">9</span>],<br>        [<span class="hljs-number">14</span>]])]<br><br><span class="hljs-comment"># vsplit</span><br>np.vsplit(a, <span class="hljs-number">3</span>)<br>[array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]),<br> array([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]]),<br> array([[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]])]<br><br><span class="hljs-comment"># array_split</span><br><span class="hljs-comment"># 下面两个表达式分别对应上面的两个方法</span><br>np.array_split(a, <span class="hljs-number">5</span>, axis=<span class="hljs-number">1</span>)<br>np.array_split(a, <span class="hljs-number">3</span>, axis=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># array_split indices_or_sections 不受整除限制</span><br><br>np.array_split(a, <span class="hljs-number">2</span>, axis=<span class="hljs-number">0</span>)<br>[array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],<br>        [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]]),<br> array([[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]])]<br></code></pre></td></tr></table></figure>
<h2 id="视图view与复制copy">视图View与复制Copy</h2>
<p>在使用numpy的过程中，通常会涉及到矩阵的复制等操作。对于ndarray来说，主要分为三种情况，分别是直接赋值<code>=</code>，使用视图<code>view()</code>以及使用复制<code>copy()</code>。</p>
<p>如果直接通过等号进行赋值，实际上并没有产生复制，新旧矩阵完全是相同的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br>b = a<br><span class="hljs-built_in">print</span>(b <span class="hljs-keyword">is</span> a)  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure>
<p>ndarray提供视图<code>.view()</code>方法，通过view方法产生的矩阵是原矩阵的一个视图，它们共享相同的底层数据。可以修改视图矩阵的shape而不影响原矩阵，但是修改视图的数据，原矩阵的数据也会受到影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br>b = a.view()<br><span class="hljs-built_in">print</span>(b <span class="hljs-keyword">is</span> a)  <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(b.base <span class="hljs-keyword">is</span> a)  <span class="hljs-comment"># True</span><br><br>b = b.reshape((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))  <span class="hljs-comment"># b shape变成(2, 2)</span><br><span class="hljs-built_in">print</span>(a.shape)  <span class="hljs-comment"># a shape 保持不变</span><br><br>b[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] = <span class="hljs-number">10</span> <span class="hljs-comment"># 修改b中的元素</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">0</span>])  <span class="hljs-comment"># ouptut 10，a中的元素也相应改变</span><br></code></pre></td></tr></table></figure>
<p>ndarray同样提供复制方法<code>.copy()</code>。通过copy方法产生的矩阵是完完全全的复制，属于deep
copy，新旧矩阵之间不会有任何的相互影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">b = a.copy()<br></code></pre></td></tr></table></figure>
<h2 id="数据保存和读取">数据保存和读取</h2>
<p>numpy中也提供数据的读取和保存方法，可以将一个ndarray对象保存在文件当中，并在需要的时候可以从文件中进行读取。对应的存储文件有两种，后缀名分别是<code>.npy</code>和<code>.npz</code>。单个ndarray的保存对应npy文件，同时存储多个ndarray对应使用npz文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>)<br>b = np.arange(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># npy file</span><br>np.save(<span class="hljs-string">&quot;test-save-a&quot;</span>, a)<br>c = np.load(<span class="hljs-string">&quot;test-save-a.npy&quot;</span>)<br><br><span class="hljs-comment"># npz file</span><br>np.savez(<span class="hljs-string">&quot;test-save-a&quot;</span>, a, b)<br>d = np.load(<span class="hljs-string">&quot;test-save-a.npz&quot;</span>)<br>d[<span class="hljs-string">&#x27;arr_0&#x27;</span>] <span class="hljs-comment"># means a</span><br>d[<span class="hljs-string">&#x27;arr_1&#x27;</span>] <span class="hljs-comment"># means b</span><br></code></pre></td></tr></table></figure>
<h1 id="参考文章">参考文章</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://realpython.com/numpy-tutorial/">Numpy
Tutorial|RealPython</a></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/doc/stable/user/index.html">Numpy User
Guide|Numpy Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/doc/stable/reference/index.html">Numpy
API Reference|Numpy Documentation</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%90%8E%E7%AB%AF/" class="category-chain-item">后端</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%90%8E%E7%AB%AF/Python/" class="category-chain-item">Python</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Python/" class="print-no-link">#Python</a>
      
        <a href="/tags/Numpy/" class="print-no-link">#Numpy</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Numpy基础笔记</div>
      <div>https://evernorif.github.io/2023/08/04/Numpy基础笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>EverNorif</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月4日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/05/Conda%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/" title="Conda相关操作记录">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Conda相关操作记录</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/02/Mac-Terminal%E7%BE%8E%E5%8C%96%E5%8F%8A%E9%85%8D%E7%BD%AE/" title="Mac Terminal美化及配置">
                        <span class="hidden-mobile">Mac Terminal美化及配置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <i class="iconfont icon-love"></i> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/xiaomai.model.json"},"display":{"position":"left","width":150,"height":300,"vOffset":-90},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
